"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_stagewise_toolbar-react_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@stagewise/toolbar-react/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@stagewise/toolbar-react/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StagewiseToolbar: () => (/* binding */ StagewiseToolbar)\n/* harmony export */ });\n/* harmony import */ var _stagewise_toolbar__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stagewise/toolbar */ \"(app-pages-browser)/./node_modules/@stagewise/toolbar/dist/index.es.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\nfunction StagewiseToolbar({\n  config,\n  enabled = \"development\" === \"development\"\n}) {\n  const isLoaded = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (isLoaded.current || !enabled) return;\n    isLoaded.current = true;\n    (0,_stagewise_toolbar__WEBPACK_IMPORTED_MODULE_0__.initToolbar)(config);\n  }, [config, enabled]);\n  return null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhZ2V3aXNlL3Rvb2xiYXItcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBaUQ7QUFDUDtBQUMxQztBQUNBO0FBQ0EsWUFBWSxhQUFvQjtBQUNoQyxDQUFDO0FBQ0QsbUJBQW1CLDZDQUFNO0FBQ3pCLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0EsSUFBSSwrREFBVztBQUNmLEdBQUc7QUFDSDtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXVyZW56aHVudXNzb3YvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdGFnZXdpc2UvdG9vbGJhci1yZWFjdC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluaXRUb29sYmFyIH0gZnJvbSBcIkBzdGFnZXdpc2UvdG9vbGJhclwiO1xuaW1wb3J0IHsgdXNlUmVmLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIFN0YWdld2lzZVRvb2xiYXIoe1xuICBjb25maWcsXG4gIGVuYWJsZWQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiXG59KSB7XG4gIGNvbnN0IGlzTG9hZGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNMb2FkZWQuY3VycmVudCB8fCAhZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlzTG9hZGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIGluaXRUb29sYmFyKGNvbmZpZyk7XG4gIH0sIFtjb25maWcsIGVuYWJsZWRdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5leHBvcnQge1xuICBTdGFnZXdpc2VUb29sYmFyXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@stagewise/toolbar-react/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@stagewise/toolbar/dist/index.es.js":
/*!**********************************************************!*\
  !*** ./node_modules/@stagewise/toolbar/dist/index.es.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initToolbar: () => (/* binding */ initToolbar)\n/* harmony export */ });\nvar define_MAIN_MODULES_default = { \"index-DsC5zpes.js\": `import { jsx, jsxs } from \"react/jsx-runtime\";\nimport { createContext, useMemo, useContext, useState, useRef, useCallback, useEffect, createRef } from \"react\";\nconst ConfigContext = createContext({\n  config: void 0\n});\nfunction ConfigProvider({\n  children,\n  config\n}) {\n  const value = useMemo(() => ({\n    config\n  }), [config]);\n  return /* @__PURE__ */ jsx(ConfigContext.Provider, { value, children });\n}\nfunction useConfig() {\n  return useContext(ConfigContext);\n}\nvar __create$1 = Object.create, __defProp$2 = Object.defineProperty, __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor, __getOwnPropNames$1 = Object.getOwnPropertyNames, __getProtoOf$1 = Object.getPrototypeOf, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __commonJS$1 = (cb, mod) => function() {\n  return mod || (0, cb[__getOwnPropNames$1(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, __copyProps$1 = (to, from, except, desc) => {\n  if (from && typeof from == \"object\" || typeof from == \"function\") for (var keys = __getOwnPropNames$1(from), i = 0, n = keys.length, key; i < n; i++)\n    key = keys[i], !__hasOwnProp$1.call(to, key) && key !== except && __defProp$2(to, key, {\n      get: ((k) => from[k]).bind(null, key),\n      enumerable: !(desc = __getOwnPropDesc$1(from, key)) || desc.enumerable\n    });\n  return to;\n}, __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(__defProp$2(target, \"default\", {\n  value: mod,\n  enumerable: !0\n}), mod)), require_typeof$1 = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\"(exports, module) {\n  function _typeof$2(o) {\n    \"@babel/helpers - typeof\";\n    return module.exports = _typeof$2 = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o$1) {\n      return typeof o$1;\n    } : function(o$1) {\n      return o$1 && typeof Symbol == \"function\" && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, module.exports.__esModule = !0, module.exports.default = module.exports, _typeof$2(o);\n  }\n  module.exports = _typeof$2, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_toPrimitive$1 = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\"(exports, module) {\n  var _typeof$1 = require_typeof$1().default;\n  function toPrimitive$1(t, r2) {\n    if (_typeof$1(t) != \"object\" || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (e !== void 0) {\n      var i = e.call(t, r2 || \"default\");\n      if (_typeof$1(i) != \"object\") return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (r2 === \"string\" ? String : Number)(t);\n  }\n  module.exports = toPrimitive$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_toPropertyKey$1 = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\"(exports, module) {\n  var _typeof = require_typeof$1().default, toPrimitive = require_toPrimitive$1();\n  function toPropertyKey$1(t) {\n    var i = toPrimitive(t, \"string\");\n    return _typeof(i) == \"symbol\" ? i : i + \"\";\n  }\n  module.exports = toPropertyKey$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_defineProperty$1 = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\"(exports, module) {\n  var toPropertyKey = require_toPropertyKey$1();\n  function _defineProperty(e, r2, t) {\n    return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {\n      value: t,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[r2] = t, e;\n  }\n  module.exports = _defineProperty, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_objectSpread2$1 = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\"(exports, module) {\n  var defineProperty = require_defineProperty$1();\n  function ownKeys(e, r2) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r2 && (o = o.filter(function(r$1) {\n        return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r2 = 1; r2 < arguments.length; r2++) {\n      var t = arguments[r2] != null ? arguments[r2] : {};\n      r2 % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n        defineProperty(e, r$1, t[r$1]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n        Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n      });\n    }\n    return e;\n  }\n  module.exports = _objectSpread2, module.exports.__esModule = !0, module.exports.default = module.exports;\n} });\nfunction observable(subscribe) {\n  const self = {\n    subscribe(observer) {\n      let teardownRef = null, isDone = !1, unsubscribed = !1, teardownImmediately = !1;\n      function unsubscribe() {\n        if (teardownRef === null) {\n          teardownImmediately = !0;\n          return;\n        }\n        unsubscribed || (unsubscribed = !0, typeof teardownRef == \"function\" ? teardownRef() : teardownRef && teardownRef.unsubscribe());\n      }\n      return teardownRef = subscribe({\n        next(value) {\n          var _observer$next;\n          isDone || (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n        },\n        error(err) {\n          var _observer$error;\n          isDone || (isDone = !0, (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err), unsubscribe());\n        },\n        complete() {\n          var _observer$complete;\n          isDone || (isDone = !0, (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer), unsubscribe());\n        }\n      }), teardownImmediately && unsubscribe(), { unsubscribe };\n    },\n    pipe(...operations) {\n      return operations.reduce(pipeReducer, self);\n    }\n  };\n  return self;\n}\nfunction pipeReducer(prev, fn) {\n  return fn(prev);\n}\nfunction observableToPromise(observable$1) {\n  const ac = new AbortController();\n  return new Promise((resolve, reject) => {\n    let isDone = !1;\n    function onDone() {\n      isDone || (isDone = !0, obs$.unsubscribe());\n    }\n    ac.signal.addEventListener(\"abort\", () => {\n      reject(ac.signal.reason);\n    });\n    const obs$ = observable$1.subscribe({\n      next(data) {\n        isDone = !0, resolve(data), onDone();\n      },\n      error(data) {\n        reject(data);\n      },\n      complete() {\n        ac.abort(), onDone();\n      }\n    });\n  });\n}\nfunction share(_opts) {\n  return (source) => {\n    let refCount = 0, subscription = null;\n    const observers = [];\n    function startIfNeeded() {\n      subscription || (subscription = source.subscribe({\n        next(value) {\n          for (const observer of observers) {\n            var _observer$next;\n            (_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n          }\n        },\n        error(error) {\n          for (const observer of observers) {\n            var _observer$error;\n            (_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, error);\n          }\n        },\n        complete() {\n          for (const observer of observers) {\n            var _observer$complete;\n            (_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n          }\n        }\n      }));\n    }\n    function resetIfNeeded() {\n      if (refCount === 0 && subscription) {\n        const _sub = subscription;\n        subscription = null, _sub.unsubscribe();\n      }\n    }\n    return observable((subscriber) => (refCount++, observers.push(subscriber), startIfNeeded(), { unsubscribe() {\n      refCount--, resetIfNeeded();\n      const index = observers.findIndex((v) => v === subscriber);\n      index > -1 && observers.splice(index, 1);\n    } }));\n  };\n}\nfunction behaviorSubject(initialValue) {\n  let value = initialValue;\n  const observerList = [], addObserver = (observer) => {\n    value !== void 0 && observer.next(value), observerList.push(observer);\n  }, removeObserver = (observer) => {\n    observerList.splice(observerList.indexOf(observer), 1);\n  }, obs = observable((observer) => (addObserver(observer), () => {\n    removeObserver(observer);\n  }));\n  return obs.next = (nextValue) => {\n    if (value !== nextValue) {\n      value = nextValue;\n      for (const observer of observerList) observer.next(nextValue);\n    }\n  }, obs.get = () => value, obs;\n}\nfunction createChain(opts) {\n  return observable((observer) => {\n    function execute(index = 0, op = opts.op) {\n      const next = opts.links[index];\n      if (!next) throw new Error(\"No more links to execute - did you forget to add an ending link?\");\n      return next({\n        op,\n        next(nextOp) {\n          return execute(index + 1, nextOp);\n        }\n      });\n    }\n    return execute().subscribe(observer);\n  });\n}\nfunction isObject(value) {\n  return !!value && !Array.isArray(value) && typeof value == \"object\";\n}\nconst run = (fn) => fn();\nfunction sleep(ms = 0) {\n  return new Promise((res) => setTimeout(res, ms));\n}\nvar __create = Object.create, __defProp$1 = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty, __commonJS = (cb, mod) => function() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n}, __copyProps = (to, from, except, desc) => {\n  if (from && typeof from == \"object\" || typeof from == \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++)\n    key = keys[i], !__hasOwnProp.call(to, key) && key !== except && __defProp$1(to, key, {\n      get: ((k) => from[k]).bind(null, key),\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  return to;\n}, __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(__defProp$1(target, \"default\", {\n  value: mod,\n  enumerable: !0\n}), mod));\nconst noop = () => {\n}, freezeIfAvailable = (obj) => {\n  Object.freeze && Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n  var _memo$cacheKey;\n  const cacheKey = path.join(\".\");\n  return (_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {\n    get(_obj, key) {\n      if (!(typeof key != \"string\" || key === \"then\"))\n        return createInnerProxy(callback, [...path, key], memo);\n    },\n    apply(_1, _2, args) {\n      const lastOfPath = path[path.length - 1];\n      let opts = {\n        args,\n        path\n      };\n      return lastOfPath === \"call\" ? opts = {\n        args: args.length >= 2 ? [args[1]] : [],\n        path: path.slice(0, -1)\n      } : lastOfPath === \"apply\" && (opts = {\n        args: args.length >= 2 ? args[1] : [],\n        path: path.slice(0, -1)\n      }), freezeIfAvailable(opts.args), freezeIfAvailable(opts.path), callback(opts);\n    }\n  })), memo[cacheKey];\n}\nconst createRecursiveProxy = (callback) => createInnerProxy(callback, [], /* @__PURE__ */ Object.create(null)), createFlatProxy = (callback) => new Proxy(noop, { get(_obj, name) {\n  if (name !== \"then\")\n    return callback(name);\n} });\nvar require_typeof = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\"(exports, module) {\n  function _typeof$2(o) {\n    \"@babel/helpers - typeof\";\n    return module.exports = _typeof$2 = typeof Symbol == \"function\" && typeof Symbol.iterator == \"symbol\" ? function(o$1) {\n      return typeof o$1;\n    } : function(o$1) {\n      return o$1 && typeof Symbol == \"function\" && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n    }, module.exports.__esModule = !0, module.exports.default = module.exports, _typeof$2(o);\n  }\n  module.exports = _typeof$2, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_toPrimitive = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\"(exports, module) {\n  var _typeof$1 = require_typeof().default;\n  function toPrimitive$1(t, r2) {\n    if (_typeof$1(t) != \"object\" || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (e !== void 0) {\n      var i = e.call(t, r2 || \"default\");\n      if (_typeof$1(i) != \"object\") return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (r2 === \"string\" ? String : Number)(t);\n  }\n  module.exports = toPrimitive$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_toPropertyKey = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\"(exports, module) {\n  var _typeof = require_typeof().default, toPrimitive = require_toPrimitive();\n  function toPropertyKey$1(t) {\n    var i = toPrimitive(t, \"string\");\n    return _typeof(i) == \"symbol\" ? i : i + \"\";\n  }\n  module.exports = toPropertyKey$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_defineProperty = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\"(exports, module) {\n  var toPropertyKey = require_toPropertyKey();\n  function _defineProperty(e, r2, t) {\n    return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {\n      value: t,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }) : e[r2] = t, e;\n  }\n  module.exports = _defineProperty, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_objectSpread2 = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\"(exports, module) {\n  var defineProperty = require_defineProperty();\n  function ownKeys(e, r2) {\n    var t = Object.keys(e);\n    if (Object.getOwnPropertySymbols) {\n      var o = Object.getOwnPropertySymbols(e);\n      r2 && (o = o.filter(function(r$1) {\n        return Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n      })), t.push.apply(t, o);\n    }\n    return t;\n  }\n  function _objectSpread2(e) {\n    for (var r2 = 1; r2 < arguments.length; r2++) {\n      var t = arguments[r2] != null ? arguments[r2] : {};\n      r2 % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n        defineProperty(e, r$1, t[r$1]);\n      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n        Object.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n      });\n    }\n    return e;\n  }\n  module.exports = _objectSpread2, module.exports.__esModule = !0, module.exports.default = module.exports;\n} });\n__toESM(require_objectSpread2());\n__toESM(require_defineProperty());\nvar import_objectSpread2$1$1 = __toESM(require_objectSpread2());\nfunction transformResultInner(response, transformer2) {\n  if (\"error\" in response) {\n    const error = transformer2.deserialize(response.error);\n    return {\n      ok: !1,\n      error: (0, import_objectSpread2$1$1.default)((0, import_objectSpread2$1$1.default)({}, response), {}, { error })\n    };\n  }\n  return {\n    ok: !0,\n    result: (0, import_objectSpread2$1$1.default)((0, import_objectSpread2$1$1.default)({}, response.result), (!response.result.type || response.result.type === \"data\") && {\n      type: \"data\",\n      data: transformer2.deserialize(response.result.data)\n    })\n  };\n}\nvar TransformResultError = class extends Error {\n  constructor() {\n    super(\"Unable to transform response from server\");\n  }\n};\nfunction transformResult(response, transformer2) {\n  let result;\n  try {\n    result = transformResultInner(response, transformer2);\n  } catch {\n    throw new TransformResultError();\n  }\n  if (!result.ok && (!isObject(result.error.error) || typeof result.error.error.code != \"number\")) throw new TransformResultError();\n  if (result.ok && !isObject(result.result)) throw new TransformResultError();\n  return result;\n}\n__toESM(require_objectSpread2());\nvar import_defineProperty$5 = __toESM$1(require_defineProperty$1()), import_objectSpread2$1 = __toESM$1(require_objectSpread2$1());\nfunction isTRPCClientError(cause) {\n  return cause instanceof TRPCClientError;\n}\nfunction isTRPCErrorResponse(obj) {\n  return isObject(obj) && isObject(obj.error) && typeof obj.error.code == \"number\" && typeof obj.error.message == \"string\";\n}\nfunction getMessageFromUnknownError(err, fallback) {\n  return typeof err == \"string\" ? err : isObject(err) && typeof err.message == \"string\" ? err.message : fallback;\n}\nvar TRPCClientError = class TRPCClientError2 extends Error {\n  constructor(message, opts) {\n    var _opts$result, _opts$result2;\n    const cause = opts == null ? void 0 : opts.cause;\n    super(message, { cause }), (0, import_defineProperty$5.default)(this, \"cause\", void 0), (0, import_defineProperty$5.default)(this, \"shape\", void 0), (0, import_defineProperty$5.default)(this, \"data\", void 0), (0, import_defineProperty$5.default)(this, \"meta\", void 0), this.meta = opts == null ? void 0 : opts.meta, this.cause = cause, this.shape = opts == null || (_opts$result = opts.result) === null || _opts$result === void 0 ? void 0 : _opts$result.error, this.data = opts == null || (_opts$result2 = opts.result) === null || _opts$result2 === void 0 ? void 0 : _opts$result2.error.data, this.name = \"TRPCClientError\", Object.setPrototypeOf(this, TRPCClientError2.prototype);\n  }\n  static from(_cause, opts = {}) {\n    const cause = _cause;\n    return isTRPCClientError(cause) ? (opts.meta && (cause.meta = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, cause.meta), opts.meta)), cause) : isTRPCErrorResponse(cause) ? new TRPCClientError2(cause.error.message, (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, opts), {}, { result: cause })) : new TRPCClientError2(getMessageFromUnknownError(cause, \"Unknown error\"), (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, opts), {}, { cause }));\n  }\n};\nfunction getTransformer(transformer2) {\n  const _transformer = transformer2;\n  return _transformer ? \"input\" in _transformer ? _transformer : {\n    input: _transformer,\n    output: _transformer\n  } : {\n    input: {\n      serialize: (data) => data,\n      deserialize: (data) => data\n    },\n    output: {\n      serialize: (data) => data,\n      deserialize: (data) => data\n    }\n  };\n}\n__toESM$1(require_objectSpread2$1());\n__toESM$1(require_objectSpread2$1());\n__toESM$1(require_objectSpread2$1());\n__toESM$1(require_objectSpread2$1());\nconst lazyDefaults = {\n  enabled: !1,\n  closeMs: 0\n}, keepAliveDefaults = {\n  enabled: !1,\n  pongTimeoutMs: 1e3,\n  intervalMs: 5e3\n}, exponentialBackoff = (attemptIndex) => attemptIndex === 0 ? 0 : Math.min(1e3 * 2 ** attemptIndex, 3e4), resultOf = (value, ...args) => typeof value == \"function\" ? value(...args) : value;\nvar import_defineProperty$3 = __toESM$1(require_defineProperty$1()), TRPCWebSocketClosedError = class TRPCWebSocketClosedError2 extends Error {\n  constructor(opts) {\n    super(opts.message, { cause: opts.cause }), this.name = \"TRPCWebSocketClosedError\", Object.setPrototypeOf(this, TRPCWebSocketClosedError2.prototype);\n  }\n}, ResettableTimeout = class {\n  constructor(onTimeout, timeoutMs) {\n    this.onTimeout = onTimeout, this.timeoutMs = timeoutMs, (0, import_defineProperty$3.default)(this, \"timeout\", void 0);\n  }\n  /**\n  * Resets the current timeout, restarting it with the same duration.\n  * Does nothing if no timeout is active.\n  */\n  reset() {\n    this.timeout && (clearTimeout(this.timeout), this.timeout = setTimeout(this.onTimeout, this.timeoutMs));\n  }\n  start() {\n    clearTimeout(this.timeout), this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n  }\n  stop() {\n    clearTimeout(this.timeout), this.timeout = void 0;\n  }\n};\nfunction withResolvers() {\n  let resolve, reject;\n  return {\n    promise: new Promise((res, rej) => {\n      resolve = res, reject = rej;\n    }),\n    resolve,\n    reject\n  };\n}\nasync function prepareUrl(urlOptions) {\n  const url = await resultOf(urlOptions.url);\n  if (!urlOptions.connectionParams) return url;\n  const connectionParams = \\`\\${url.includes(\"?\") ? \"&\" : \"?\"}connectionParams=1\\`;\n  return url + connectionParams;\n}\nasync function buildConnectionMessage(connectionParams) {\n  const message = {\n    method: \"connectionParams\",\n    data: await resultOf(connectionParams)\n  };\n  return JSON.stringify(message);\n}\nvar import_defineProperty$2 = __toESM$1(require_defineProperty$1()), RequestManager = class {\n  constructor() {\n    (0, import_defineProperty$2.default)(this, \"outgoingRequests\", new Array()), (0, import_defineProperty$2.default)(this, \"pendingRequests\", {});\n  }\n  /**\n  * Registers a new request by adding it to the outgoing queue and setting up\n  * callbacks for lifecycle events such as completion or error.\n  *\n  * @param message - The outgoing message to be sent.\n  * @param callbacks - Callback functions to observe the request's state.\n  * @returns A cleanup function to manually remove the request.\n  */\n  register(message, callbacks) {\n    const { promise: end, resolve } = withResolvers();\n    return this.outgoingRequests.push({\n      id: String(message.id),\n      message,\n      end,\n      callbacks: {\n        next: callbacks.next,\n        complete: () => {\n          callbacks.complete(), resolve();\n        },\n        error: (e) => {\n          callbacks.error(e), resolve();\n        }\n      }\n    }), () => {\n      this.delete(message.id), callbacks.complete(), resolve();\n    };\n  }\n  /**\n  * Deletes a request from both the outgoing and pending collections, if it exists.\n  */\n  delete(messageId) {\n    messageId !== null && (this.outgoingRequests = this.outgoingRequests.filter(({ id }) => id !== String(messageId)), delete this.pendingRequests[String(messageId)]);\n  }\n  /**\n  * Moves all outgoing requests to the pending state and clears the outgoing queue.\n  *\n  * The caller is expected to handle the actual sending of the requests\n  * (e.g., sending them over the network) after this method is called.\n  *\n  * @returns The list of requests that were transitioned to the pending state.\n  */\n  flush() {\n    const requests = this.outgoingRequests;\n    this.outgoingRequests = [];\n    for (const request of requests) this.pendingRequests[request.id] = request;\n    return requests;\n  }\n  /**\n  * Retrieves all currently pending requests, which are in flight awaiting responses\n  * or handling ongoing subscriptions.\n  */\n  getPendingRequests() {\n    return Object.values(this.pendingRequests);\n  }\n  /**\n  * Retrieves a specific pending request by its message ID.\n  */\n  getPendingRequest(messageId) {\n    return messageId === null ? null : this.pendingRequests[String(messageId)];\n  }\n  /**\n  * Retrieves all outgoing requests, which are waiting to be sent.\n  */\n  getOutgoingRequests() {\n    return this.outgoingRequests;\n  }\n  /**\n  * Retrieves all requests, both outgoing and pending, with their respective states.\n  *\n  * @returns An array of all requests with their state (\"outgoing\" or \"pending\").\n  */\n  getRequests() {\n    return [...this.getOutgoingRequests().map((request) => ({\n      state: \"outgoing\",\n      message: request.message,\n      end: request.end,\n      callbacks: request.callbacks\n    })), ...this.getPendingRequests().map((request) => ({\n      state: \"pending\",\n      message: request.message,\n      end: request.end,\n      callbacks: request.callbacks\n    }))];\n  }\n  /**\n  * Checks if there are any pending requests, including ongoing subscriptions.\n  */\n  hasPendingRequests() {\n    return this.getPendingRequests().length > 0;\n  }\n  /**\n  * Checks if there are any pending subscriptions\n  */\n  hasPendingSubscriptions() {\n    return this.getPendingRequests().some((request) => request.message.method === \"subscription\");\n  }\n  /**\n  * Checks if there are any outgoing requests waiting to be sent.\n  */\n  hasOutgoingRequests() {\n    return this.outgoingRequests.length > 0;\n  }\n}, import_defineProperty$1 = __toESM$1(require_defineProperty$1());\nfunction asyncWsOpen(ws) {\n  const { promise, resolve, reject } = withResolvers();\n  return ws.addEventListener(\"open\", () => {\n    ws.removeEventListener(\"error\", reject), resolve();\n  }), ws.addEventListener(\"error\", reject), promise;\n}\nfunction setupPingInterval(ws, { intervalMs, pongTimeoutMs }) {\n  let pingTimeout, pongTimeout;\n  function start() {\n    pingTimeout = setTimeout(() => {\n      ws.send(\"PING\"), pongTimeout = setTimeout(() => {\n        ws.close();\n      }, pongTimeoutMs);\n    }, intervalMs);\n  }\n  function reset() {\n    clearTimeout(pingTimeout), start();\n  }\n  function pong() {\n    clearTimeout(pongTimeout), reset();\n  }\n  ws.addEventListener(\"open\", start), ws.addEventListener(\"message\", ({ data }) => {\n    clearTimeout(pingTimeout), start(), data === \"PONG\" && pong();\n  }), ws.addEventListener(\"close\", () => {\n    clearTimeout(pingTimeout), clearTimeout(pongTimeout);\n  });\n}\nvar WsConnection = class WsConnection2 {\n  constructor(opts) {\n    var _opts$WebSocketPonyfi;\n    if ((0, import_defineProperty$1.default)(this, \"id\", ++WsConnection2.connectCount), (0, import_defineProperty$1.default)(this, \"WebSocketPonyfill\", void 0), (0, import_defineProperty$1.default)(this, \"urlOptions\", void 0), (0, import_defineProperty$1.default)(this, \"keepAliveOpts\", void 0), (0, import_defineProperty$1.default)(this, \"wsObservable\", behaviorSubject(null)), (0, import_defineProperty$1.default)(this, \"openPromise\", null), this.WebSocketPonyfill = (_opts$WebSocketPonyfi = opts.WebSocketPonyfill) !== null && _opts$WebSocketPonyfi !== void 0 ? _opts$WebSocketPonyfi : WebSocket, !this.WebSocketPonyfill) throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a \\`WebSocket\\`-ponyfill\");\n    this.urlOptions = opts.urlOptions, this.keepAliveOpts = opts.keepAlive;\n  }\n  get ws() {\n    return this.wsObservable.get();\n  }\n  set ws(ws) {\n    this.wsObservable.next(ws);\n  }\n  /**\n  * Checks if the WebSocket connection is open and ready to communicate.\n  */\n  isOpen() {\n    return !!this.ws && this.ws.readyState === this.WebSocketPonyfill.OPEN && !this.openPromise;\n  }\n  /**\n  * Checks if the WebSocket connection is closed or in the process of closing.\n  */\n  isClosed() {\n    return !!this.ws && (this.ws.readyState === this.WebSocketPonyfill.CLOSING || this.ws.readyState === this.WebSocketPonyfill.CLOSED);\n  }\n  async open() {\n    var _this = this;\n    if (_this.openPromise) return _this.openPromise;\n    _this.id = ++WsConnection2.connectCount;\n    const wsPromise = prepareUrl(_this.urlOptions).then((url) => new _this.WebSocketPonyfill(url));\n    _this.openPromise = wsPromise.then(async (ws) => {\n      _this.ws = ws, ws.addEventListener(\"message\", function({ data }) {\n        data === \"PING\" && this.send(\"PONG\");\n      }), _this.keepAliveOpts.enabled && setupPingInterval(ws, _this.keepAliveOpts), ws.addEventListener(\"close\", () => {\n        _this.ws === ws && (_this.ws = null);\n      }), await asyncWsOpen(ws), _this.urlOptions.connectionParams && ws.send(await buildConnectionMessage(_this.urlOptions.connectionParams));\n    });\n    try {\n      await _this.openPromise;\n    } finally {\n      _this.openPromise = null;\n    }\n  }\n  /**\n  * Closes the WebSocket connection gracefully.\n  * Waits for any ongoing open operation to complete before closing.\n  */\n  async close() {\n    var _this2 = this;\n    try {\n      await _this2.openPromise;\n    } finally {\n      var _this$ws;\n      (_this$ws = _this2.ws) === null || _this$ws === void 0 || _this$ws.close();\n    }\n  }\n};\n(0, import_defineProperty$1.default)(WsConnection, \"connectCount\", 0);\nfunction backwardCompatibility(connection) {\n  return connection.isOpen() ? {\n    id: connection.id,\n    state: \"open\",\n    ws: connection.ws\n  } : connection.isClosed() ? {\n    id: connection.id,\n    state: \"closed\",\n    ws: connection.ws\n  } : connection.ws ? {\n    id: connection.id,\n    state: \"connecting\",\n    ws: connection.ws\n  } : null;\n}\nvar import_defineProperty$4 = __toESM$1(require_defineProperty$1()), import_objectSpread2 = __toESM$1(require_objectSpread2$1()), WsClient = class {\n  constructor(opts) {\n    var _opts$retryDelayMs;\n    (0, import_defineProperty$4.default)(this, \"connectionState\", void 0), (0, import_defineProperty$4.default)(this, \"allowReconnect\", !1), (0, import_defineProperty$4.default)(this, \"requestManager\", new RequestManager()), (0, import_defineProperty$4.default)(this, \"activeConnection\", void 0), (0, import_defineProperty$4.default)(this, \"reconnectRetryDelay\", void 0), (0, import_defineProperty$4.default)(this, \"inactivityTimeout\", void 0), (0, import_defineProperty$4.default)(this, \"callbacks\", void 0), (0, import_defineProperty$4.default)(this, \"lazyMode\", void 0), (0, import_defineProperty$4.default)(this, \"reconnecting\", null), this.callbacks = {\n      onOpen: opts.onOpen,\n      onClose: opts.onClose,\n      onError: opts.onError\n    };\n    const lazyOptions = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, lazyDefaults), opts.lazy);\n    this.inactivityTimeout = new ResettableTimeout(() => {\n      if (this.requestManager.hasOutgoingRequests() || this.requestManager.hasPendingRequests()) {\n        this.inactivityTimeout.reset();\n        return;\n      }\n      this.close().catch(() => null);\n    }, lazyOptions.closeMs), this.activeConnection = new WsConnection({\n      WebSocketPonyfill: opts.WebSocket,\n      urlOptions: opts,\n      keepAlive: (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, keepAliveDefaults), opts.keepAlive)\n    }), this.activeConnection.wsObservable.subscribe({ next: (ws) => {\n      ws && this.setupWebSocketListeners(ws);\n    } }), this.reconnectRetryDelay = (_opts$retryDelayMs = opts.retryDelayMs) !== null && _opts$retryDelayMs !== void 0 ? _opts$retryDelayMs : exponentialBackoff, this.lazyMode = lazyOptions.enabled, this.connectionState = behaviorSubject({\n      type: \"state\",\n      state: lazyOptions.enabled ? \"idle\" : \"connecting\",\n      error: null\n    }), this.lazyMode || this.open().catch(() => null);\n  }\n  /**\n  * Opens the WebSocket connection. Handles reconnection attempts and updates\n  * the connection state accordingly.\n  */\n  async open() {\n    var _this = this;\n    _this.allowReconnect = !0, _this.connectionState.get().state !== \"connecting\" && _this.connectionState.next({\n      type: \"state\",\n      state: \"connecting\",\n      error: null\n    });\n    try {\n      await _this.activeConnection.open();\n    } catch (error) {\n      return _this.reconnect(new TRPCWebSocketClosedError({\n        message: \"Initialization error\",\n        cause: error\n      })), _this.reconnecting;\n    }\n  }\n  /**\n  * Closes the WebSocket connection and stops managing requests.\n  * Ensures all outgoing and pending requests are properly finalized.\n  */\n  async close() {\n    var _this2 = this;\n    _this2.allowReconnect = !1, _this2.inactivityTimeout.stop();\n    const requestsToAwait = [];\n    for (const request of _this2.requestManager.getRequests()) request.message.method === \"subscription\" ? request.callbacks.complete() : request.state === \"outgoing\" ? request.callbacks.error(TRPCClientError.from(new TRPCWebSocketClosedError({ message: \"Closed before connection was established\" }))) : requestsToAwait.push(request.end);\n    await Promise.all(requestsToAwait).catch(() => null), await _this2.activeConnection.close().catch(() => null), _this2.connectionState.next({\n      type: \"state\",\n      state: \"idle\",\n      error: null\n    });\n  }\n  /**\n  * Method to request the server.\n  * Handles data transformation, batching of requests, and subscription lifecycle.\n  *\n  * @param op - The operation details including id, type, path, input and signal\n  * @param transformer - Data transformer for serializing requests and deserializing responses\n  * @param lastEventId - Optional ID of the last received event for subscriptions\n  *\n  * @returns An observable that emits operation results and handles cleanup\n  */\n  request({ op: { id, type, path, input, signal }, transformer: transformer2, lastEventId }) {\n    return observable((observer) => {\n      const abort = this.batchSend({\n        id,\n        method: type,\n        params: {\n          input: transformer2.input.serialize(input),\n          path,\n          lastEventId\n        }\n      }, (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, observer), {}, { next(event) {\n        const transformed = transformResult(event, transformer2.output);\n        if (!transformed.ok) {\n          observer.error(TRPCClientError.from(transformed.error));\n          return;\n        }\n        observer.next({ result: transformed.result });\n      } }));\n      return () => {\n        abort(), type === \"subscription\" && this.activeConnection.isOpen() && this.send({\n          id,\n          method: \"subscription.stop\"\n        }), signal == null || signal.removeEventListener(\"abort\", abort);\n      };\n    });\n  }\n  get connection() {\n    return backwardCompatibility(this.activeConnection);\n  }\n  reconnect(closedError) {\n    var _this3 = this;\n    if (this.connectionState.next({\n      type: \"state\",\n      state: \"connecting\",\n      error: TRPCClientError.from(closedError)\n    }), this.reconnecting) return;\n    const tryReconnect = async (attemptIndex) => {\n      try {\n        await sleep(_this3.reconnectRetryDelay(attemptIndex)), _this3.allowReconnect && (await _this3.activeConnection.close(), await _this3.activeConnection.open(), _this3.requestManager.hasPendingRequests() && _this3.send(_this3.requestManager.getPendingRequests().map(({ message }) => message))), _this3.reconnecting = null;\n      } catch {\n        await tryReconnect(attemptIndex + 1);\n      }\n    };\n    this.reconnecting = tryReconnect(0);\n  }\n  setupWebSocketListeners(ws) {\n    var _this4 = this;\n    const handleCloseOrError = (cause) => {\n      const reqs = this.requestManager.getPendingRequests();\n      for (const { message, callbacks } of reqs)\n        message.method !== \"subscription\" && (callbacks.error(TRPCClientError.from(cause ?? new TRPCWebSocketClosedError({\n          message: \"WebSocket closed\",\n          cause\n        }))), this.requestManager.delete(message.id));\n    };\n    ws.addEventListener(\"open\", () => {\n      run(async () => {\n        var _this$callbacks$onOpe, _this$callbacks;\n        _this4.lazyMode && _this4.inactivityTimeout.start(), (_this$callbacks$onOpe = (_this$callbacks = _this4.callbacks).onOpen) === null || _this$callbacks$onOpe === void 0 || _this$callbacks$onOpe.call(_this$callbacks), _this4.connectionState.next({\n          type: \"state\",\n          state: \"pending\",\n          error: null\n        });\n      }).catch((error) => {\n        ws.close(3e3), handleCloseOrError(error);\n      });\n    }), ws.addEventListener(\"message\", ({ data }) => {\n      if (this.inactivityTimeout.reset(), typeof data != \"string\" || [\"PING\", \"PONG\"].includes(data)) return;\n      const incomingMessage = JSON.parse(data);\n      if (\"method\" in incomingMessage) {\n        this.handleIncomingRequest(incomingMessage);\n        return;\n      }\n      this.handleResponseMessage(incomingMessage);\n    }), ws.addEventListener(\"close\", (event) => {\n      var _this$callbacks$onClo, _this$callbacks2;\n      handleCloseOrError(event), (_this$callbacks$onClo = (_this$callbacks2 = this.callbacks).onClose) === null || _this$callbacks$onClo === void 0 || _this$callbacks$onClo.call(_this$callbacks2, event), (!this.lazyMode || this.requestManager.hasPendingSubscriptions()) && this.reconnect(new TRPCWebSocketClosedError({\n        message: \"WebSocket closed\",\n        cause: event\n      }));\n    }), ws.addEventListener(\"error\", (event) => {\n      var _this$callbacks$onErr, _this$callbacks3;\n      handleCloseOrError(event), (_this$callbacks$onErr = (_this$callbacks3 = this.callbacks).onError) === null || _this$callbacks$onErr === void 0 || _this$callbacks$onErr.call(_this$callbacks3, event), this.reconnect(new TRPCWebSocketClosedError({\n        message: \"WebSocket closed\",\n        cause: event\n      }));\n    });\n  }\n  handleResponseMessage(message) {\n    const request = this.requestManager.getPendingRequest(message.id);\n    if (!request) return;\n    request.callbacks.next(message);\n    let completed = !0;\n    \"result\" in message && request.message.method === \"subscription\" && (message.result.type === \"data\" && (request.message.params.lastEventId = message.result.id), message.result.type !== \"stopped\" && (completed = !1)), completed && (request.callbacks.complete(), this.requestManager.delete(message.id));\n  }\n  handleIncomingRequest(message) {\n    message.method === \"reconnect\" && this.reconnect(new TRPCWebSocketClosedError({ message: \"Server requested reconnect\" }));\n  }\n  /**\n  * Sends a message or batch of messages directly to the server.\n  */\n  send(messageOrMessages) {\n    if (!this.activeConnection.isOpen()) throw new Error(\"Active connection is not open\");\n    const messages = messageOrMessages instanceof Array ? messageOrMessages : [messageOrMessages];\n    this.activeConnection.ws.send(JSON.stringify(messages.length === 1 ? messages[0] : messages));\n  }\n  /**\n  * Groups requests for batch sending.\n  *\n  * @returns A function to abort the batched request.\n  */\n  batchSend(message, callbacks) {\n    var _this5 = this;\n    return this.inactivityTimeout.reset(), run(async () => {\n      _this5.activeConnection.isOpen() || await _this5.open(), await sleep(0), _this5.requestManager.hasOutgoingRequests() && _this5.send(_this5.requestManager.flush().map(({ message: message$1 }) => message$1));\n    }).catch((err) => {\n      this.requestManager.delete(message.id), callbacks.error(TRPCClientError.from(err));\n    }), this.requestManager.register(message, callbacks);\n  }\n};\nfunction createWSClient(opts) {\n  return new WsClient(opts);\n}\nfunction wsLink(opts) {\n  const { client } = opts, transformer2 = getTransformer(opts.transformer);\n  return () => ({ op }) => observable((observer) => {\n    const connStateSubscription = op.type === \"subscription\" ? client.connectionState.subscribe({ next(result) {\n      observer.next({\n        result,\n        context: op.context\n      });\n    } }) : null, requestSubscription = client.request({\n      op,\n      transformer: transformer2\n    }).subscribe(observer);\n    return () => {\n      requestSubscription.unsubscribe(), connStateSubscription == null || connStateSubscription.unsubscribe();\n    };\n  });\n}\nvar import_defineProperty = __toESM$1(require_defineProperty$1()), import_objectSpread2$4 = __toESM$1(require_objectSpread2$1()), TRPCUntypedClient = class {\n  constructor(opts) {\n    (0, import_defineProperty.default)(this, \"links\", void 0), (0, import_defineProperty.default)(this, \"runtime\", void 0), (0, import_defineProperty.default)(this, \"requestId\", void 0), this.requestId = 0, this.runtime = {}, this.links = opts.links.map((link) => link(this.runtime));\n  }\n  $request(opts) {\n    var _opts$context;\n    return createChain({\n      links: this.links,\n      op: (0, import_objectSpread2$4.default)((0, import_objectSpread2$4.default)({}, opts), {}, {\n        context: (_opts$context = opts.context) !== null && _opts$context !== void 0 ? _opts$context : {},\n        id: ++this.requestId\n      })\n    }).pipe(share());\n  }\n  async requestAsPromise(opts) {\n    var _this = this;\n    try {\n      const req$ = _this.$request(opts);\n      return (await observableToPromise(req$)).result.data;\n    } catch (err) {\n      throw TRPCClientError.from(err);\n    }\n  }\n  query(path, input, opts) {\n    return this.requestAsPromise({\n      type: \"query\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context,\n      signal: opts == null ? void 0 : opts.signal\n    });\n  }\n  mutation(path, input, opts) {\n    return this.requestAsPromise({\n      type: \"mutation\",\n      path,\n      input,\n      context: opts == null ? void 0 : opts.context,\n      signal: opts == null ? void 0 : opts.signal\n    });\n  }\n  subscription(path, input, opts) {\n    return this.$request({\n      type: \"subscription\",\n      path,\n      input,\n      context: opts.context,\n      signal: opts.signal\n    }).subscribe({\n      next(envelope) {\n        switch (envelope.result.type) {\n          case \"state\": {\n            var _opts$onConnectionSta;\n            (_opts$onConnectionSta = opts.onConnectionStateChange) === null || _opts$onConnectionSta === void 0 || _opts$onConnectionSta.call(opts, envelope.result);\n            break;\n          }\n          case \"started\": {\n            var _opts$onStarted;\n            (_opts$onStarted = opts.onStarted) === null || _opts$onStarted === void 0 || _opts$onStarted.call(opts, { context: envelope.context });\n            break;\n          }\n          case \"stopped\": {\n            var _opts$onStopped;\n            (_opts$onStopped = opts.onStopped) === null || _opts$onStopped === void 0 || _opts$onStopped.call(opts);\n            break;\n          }\n          case \"data\":\n          case void 0: {\n            var _opts$onData;\n            (_opts$onData = opts.onData) === null || _opts$onData === void 0 || _opts$onData.call(opts, envelope.result.data);\n            break;\n          }\n        }\n      },\n      error(err) {\n        var _opts$onError;\n        (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, err);\n      },\n      complete() {\n        var _opts$onComplete;\n        (_opts$onComplete = opts.onComplete) === null || _opts$onComplete === void 0 || _opts$onComplete.call(opts);\n      }\n    });\n  }\n};\nconst untypedClientSymbol = Symbol.for(\"trpc_untypedClient\"), clientCallTypeMap = {\n  query: \"query\",\n  mutate: \"mutation\",\n  subscribe: \"subscription\"\n}, clientCallTypeToProcedureType = (clientCallType) => clientCallTypeMap[clientCallType];\nfunction createTRPCClientProxy(client) {\n  const proxy = createRecursiveProxy(({ path, args }) => {\n    const pathCopy = [...path], procedureType = clientCallTypeToProcedureType(pathCopy.pop()), fullPath = pathCopy.join(\".\");\n    return client[procedureType](fullPath, ...args);\n  });\n  return createFlatProxy((key) => key === untypedClientSymbol ? client : proxy[key]);\n}\nfunction createTRPCClient(opts) {\n  const client = new TRPCUntypedClient(opts);\n  return createTRPCClientProxy(client);\n}\n__toESM$1(require_objectSpread2$1());\n__toESM$1(require_objectSpread2$1());\nvar require_asyncIterator = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\"(exports, module) {\n  function _asyncIterator$1(r2) {\n    var n, t, o, e = 2;\n    for (typeof Symbol < \"u\" && (t = Symbol.asyncIterator, o = Symbol.iterator); e--; ) {\n      if (t && (n = r2[t]) != null) return n.call(r2);\n      if (o && (n = r2[o]) != null) return new AsyncFromSyncIterator(n.call(r2));\n      t = \"@@asyncIterator\", o = \"@@iterator\";\n    }\n    throw new TypeError(\"Object is not async iterable\");\n  }\n  function AsyncFromSyncIterator(r2) {\n    function AsyncFromSyncIteratorContinuation(r$1) {\n      if (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + \" is not an object.\"));\n      var n = r$1.done;\n      return Promise.resolve(r$1.value).then(function(r$2) {\n        return {\n          value: r$2,\n          done: n\n        };\n      });\n    }\n    return AsyncFromSyncIterator = function(r$1) {\n      this.s = r$1, this.n = r$1.next;\n    }, AsyncFromSyncIterator.prototype = {\n      s: null,\n      n: null,\n      next: function() {\n        return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n      },\n      return: function(r$1) {\n        var n = this.s.return;\n        return n === void 0 ? Promise.resolve({\n          value: r$1,\n          done: !0\n        }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n      },\n      throw: function(r$1) {\n        var n = this.s.return;\n        return n === void 0 ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n      }\n    }, new AsyncFromSyncIterator(r2);\n  }\n  module.exports = _asyncIterator$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} });\n__toESM$1(require_asyncIterator());\n__toESM$1(require_objectSpread2$1());\nvar require_usingCtx = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\"(exports, module) {\n  function _usingCtx() {\n    var r2 = typeof SuppressedError == \"function\" ? SuppressedError : function(r$1, e$1) {\n      var n$1 = Error();\n      return n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n    }, e = {}, n = [];\n    function using(r$1, e$1) {\n      if (e$1 != null) {\n        if (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n        if (r$1) var o = e$1[Symbol.asyncDispose || Symbol.for(\"Symbol.asyncDispose\")];\n        if (o === void 0 && (o = e$1[Symbol.dispose || Symbol.for(\"Symbol.dispose\")], r$1)) var t = o;\n        if (typeof o != \"function\") throw new TypeError(\"Object is not disposable.\");\n        t && (o = function() {\n          try {\n            t.call(e$1);\n          } catch (r$2) {\n            return Promise.reject(r$2);\n          }\n        }), n.push({\n          v: e$1,\n          d: o,\n          a: r$1\n        });\n      } else r$1 && n.push({\n        d: e$1,\n        a: r$1\n      });\n      return e$1;\n    }\n    return {\n      e,\n      u: using.bind(null, !1),\n      a: using.bind(null, !0),\n      d: function() {\n        var o, t = this.e, s = 0;\n        function next() {\n          for (; o = n.pop(); ) try {\n            if (!o.a && s === 1) return s = 0, n.push(o), Promise.resolve().then(next);\n            if (o.d) {\n              var r$1 = o.d.call(o.v);\n              if (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n            } else s |= 1;\n          } catch (r$2) {\n            return err(r$2);\n          }\n          if (s === 1) return t !== e ? Promise.reject(t) : Promise.resolve();\n          if (t !== e) throw t;\n        }\n        function err(n$1) {\n          return t = t !== e ? new r2(n$1, t) : n$1, next();\n        }\n        return next();\n      }\n    };\n  }\n  module.exports = _usingCtx, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_OverloadYield = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\"(exports, module) {\n  function _OverloadYield(e, d) {\n    this.v = e, this.k = d;\n  }\n  module.exports = _OverloadYield, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_awaitAsyncGenerator = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\"(exports, module) {\n  var OverloadYield$1 = require_OverloadYield();\n  function _awaitAsyncGenerator$1(e) {\n    return new OverloadYield$1(e, 0);\n  }\n  module.exports = _awaitAsyncGenerator$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} }), require_wrapAsyncGenerator = __commonJS$1({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\"(exports, module) {\n  var OverloadYield = require_OverloadYield();\n  function _wrapAsyncGenerator$1(e) {\n    return function() {\n      return new AsyncGenerator(e.apply(this, arguments));\n    };\n  }\n  function AsyncGenerator(e) {\n    var r2, t;\n    function resume(r$1, t$1) {\n      try {\n        var n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield;\n        Promise.resolve(u ? o.v : o).then(function(t$2) {\n          if (u) {\n            var i = r$1 === \"return\" ? \"return\" : \"next\";\n            if (!o.k || t$2.done) return resume(i, t$2);\n            t$2 = e[i](t$2).value;\n          }\n          settle(n.done ? \"return\" : \"normal\", t$2);\n        }, function(e$1) {\n          resume(\"throw\", e$1);\n        });\n      } catch (e$1) {\n        settle(\"throw\", e$1);\n      }\n    }\n    function settle(e$1, n) {\n      switch (e$1) {\n        case \"return\":\n          r2.resolve({\n            value: n,\n            done: !0\n          });\n          break;\n        case \"throw\":\n          r2.reject(n);\n          break;\n        default:\n          r2.resolve({\n            value: n,\n            done: !1\n          });\n      }\n      (r2 = r2.next) ? resume(r2.key, r2.arg) : t = null;\n    }\n    this._invoke = function(e$1, n) {\n      return new Promise(function(o, u) {\n        var i = {\n          key: e$1,\n          arg: n,\n          resolve: o,\n          reject: u,\n          next: null\n        };\n        t ? t = t.next = i : (r2 = t = i, resume(e$1, n));\n      });\n    }, typeof e.return != \"function\" && (this.return = void 0);\n  }\n  AsyncGenerator.prototype[typeof Symbol == \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function() {\n    return this;\n  }, AsyncGenerator.prototype.next = function(e) {\n    return this._invoke(\"next\", e);\n  }, AsyncGenerator.prototype.throw = function(e) {\n    return this._invoke(\"throw\", e);\n  }, AsyncGenerator.prototype.return = function(e) {\n    return this._invoke(\"return\", e);\n  }, module.exports = _wrapAsyncGenerator$1, module.exports.__esModule = !0, module.exports.default = module.exports;\n} });\n__toESM$1(require_usingCtx());\n__toESM$1(require_awaitAsyncGenerator());\n__toESM$1(require_wrapAsyncGenerator());\n__toESM$1(require_objectSpread2$1());\nvar __defProp = Object.defineProperty, __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: !0 });\n}, external_exports = {};\n__export(external_exports, {\n  BRAND: () => BRAND,\n  DIRTY: () => DIRTY,\n  EMPTY_PATH: () => EMPTY_PATH,\n  INVALID: () => INVALID,\n  NEVER: () => NEVER,\n  OK: () => OK,\n  ParseStatus: () => ParseStatus,\n  Schema: () => ZodType,\n  ZodAny: () => ZodAny,\n  ZodArray: () => ZodArray,\n  ZodBigInt: () => ZodBigInt,\n  ZodBoolean: () => ZodBoolean,\n  ZodBranded: () => ZodBranded,\n  ZodCatch: () => ZodCatch,\n  ZodDate: () => ZodDate,\n  ZodDefault: () => ZodDefault,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodEffects: () => ZodEffects,\n  ZodEnum: () => ZodEnum,\n  ZodError: () => ZodError,\n  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,\n  ZodFunction: () => ZodFunction,\n  ZodIntersection: () => ZodIntersection,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodLazy: () => ZodLazy,\n  ZodLiteral: () => ZodLiteral,\n  ZodMap: () => ZodMap,\n  ZodNaN: () => ZodNaN,\n  ZodNativeEnum: () => ZodNativeEnum,\n  ZodNever: () => ZodNever,\n  ZodNull: () => ZodNull,\n  ZodNullable: () => ZodNullable,\n  ZodNumber: () => ZodNumber,\n  ZodObject: () => ZodObject,\n  ZodOptional: () => ZodOptional,\n  ZodParsedType: () => ZodParsedType,\n  ZodPipeline: () => ZodPipeline,\n  ZodPromise: () => ZodPromise,\n  ZodReadonly: () => ZodReadonly,\n  ZodRecord: () => ZodRecord,\n  ZodSchema: () => ZodType,\n  ZodSet: () => ZodSet,\n  ZodString: () => ZodString,\n  ZodSymbol: () => ZodSymbol,\n  ZodTransformer: () => ZodEffects,\n  ZodTuple: () => ZodTuple,\n  ZodType: () => ZodType,\n  ZodUndefined: () => ZodUndefined,\n  ZodUnion: () => ZodUnion,\n  ZodUnknown: () => ZodUnknown,\n  ZodVoid: () => ZodVoid,\n  addIssueToContext: () => addIssueToContext,\n  any: () => anyType,\n  array: () => arrayType,\n  bigint: () => bigIntType,\n  boolean: () => booleanType,\n  coerce: () => coerce,\n  custom: () => custom,\n  date: () => dateType,\n  datetimeRegex: () => datetimeRegex,\n  defaultErrorMap: () => en_default,\n  discriminatedUnion: () => discriminatedUnionType,\n  effect: () => effectsType,\n  enum: () => enumType,\n  function: () => functionType,\n  getErrorMap: () => getErrorMap,\n  getParsedType: () => getParsedType,\n  instanceof: () => instanceOfType,\n  intersection: () => intersectionType,\n  isAborted: () => isAborted,\n  isAsync: () => isAsync,\n  isDirty: () => isDirty,\n  isValid: () => isValid,\n  late: () => late,\n  lazy: () => lazyType,\n  literal: () => literalType,\n  makeIssue: () => makeIssue,\n  map: () => mapType,\n  nan: () => nanType,\n  nativeEnum: () => nativeEnumType,\n  never: () => neverType,\n  null: () => nullType,\n  nullable: () => nullableType,\n  number: () => numberType,\n  object: () => objectType,\n  objectUtil: () => objectUtil,\n  oboolean: () => oboolean,\n  onumber: () => onumber,\n  optional: () => optionalType,\n  ostring: () => ostring,\n  pipeline: () => pipelineType,\n  preprocess: () => preprocessType,\n  promise: () => promiseType,\n  quotelessJson: () => quotelessJson,\n  record: () => recordType,\n  set: () => setType,\n  setErrorMap: () => setErrorMap,\n  strictObject: () => strictObjectType,\n  string: () => stringType,\n  symbol: () => symbolType,\n  transformer: () => effectsType,\n  tuple: () => tupleType,\n  undefined: () => undefinedType,\n  union: () => unionType,\n  unknown: () => unknownType,\n  util: () => util,\n  void: () => voidType\n});\nvar util;\n(function(util2) {\n  util2.assertEqual = (_) => {\n  };\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever, util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items)\n      obj[item] = item;\n    return obj;\n  }, util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] != \"number\"), filtered = {};\n    for (const k of validKeys)\n      filtered[k] = obj[k];\n    return util2.objectValues(filtered);\n  }, util2.objectValues = (obj) => util2.objectKeys(obj).map(function(e) {\n    return obj[e];\n  }), util2.objectKeys = typeof Object.keys == \"function\" ? (obj) => Object.keys(obj) : (object) => {\n    const keys = [];\n    for (const key in object)\n      Object.prototype.hasOwnProperty.call(object, key) && keys.push(key);\n    return keys;\n  }, util2.find = (arr, checker) => {\n    for (const item of arr)\n      if (checker(item))\n        return item;\n  }, util2.isInteger = typeof Number.isInteger == \"function\" ? (val) => Number.isInteger(val) : (val) => typeof val == \"number\" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = \" | \") {\n    return array.map((val) => typeof val == \"string\" ? \\`'\\${val}'\\` : val).join(separator);\n  }\n  util2.joinValues = joinValues, util2.jsonStringifyReplacer = (_, value) => typeof value == \"bigint\" ? value.toString() : value;\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => ({\n    ...first,\n    ...second\n    // second overwrites first\n  });\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]), getParsedType = (data) => {\n  switch (typeof data) {\n    case \"undefined\":\n      return ZodParsedType.undefined;\n    case \"string\":\n      return ZodParsedType.string;\n    case \"number\":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case \"boolean\":\n      return ZodParsedType.boolean;\n    case \"function\":\n      return ZodParsedType.function;\n    case \"bigint\":\n      return ZodParsedType.bigint;\n    case \"symbol\":\n      return ZodParsedType.symbol;\n    case \"object\":\n      return Array.isArray(data) ? ZodParsedType.array : data === null ? ZodParsedType.null : data.then && typeof data.then == \"function\" && data.catch && typeof data.catch == \"function\" ? ZodParsedType.promise : typeof Map < \"u\" && data instanceof Map ? ZodParsedType.map : typeof Set < \"u\" && data instanceof Set ? ZodParsedType.set : typeof Date < \"u\" && data instanceof Date ? ZodParsedType.date : ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n}, ZodIssueCode = util.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]), quotelessJson = (obj) => JSON.stringify(obj, null, 2).replace(/\"([^\"]+)\":/g, \"$1:\"), ZodError = class _ZodError extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(issues) {\n    super(), this.issues = [], this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    }, this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    Object.setPrototypeOf ? Object.setPrototypeOf(this, actualProto) : this.__proto__ = actualProto, this.name = \"ZodError\", this.issues = issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    }, fieldErrors = { _errors: [] }, processError = (error) => {\n      for (const issue of error.issues)\n        if (issue.code === \"invalid_union\")\n          issue.unionErrors.map(processError);\n        else if (issue.code === \"invalid_return_type\")\n          processError(issue.returnTypeError);\n        else if (issue.code === \"invalid_arguments\")\n          processError(issue.argumentsError);\n        else if (issue.path.length === 0)\n          fieldErrors._errors.push(mapper(issue));\n        else {\n          let curr = fieldErrors, i = 0;\n          for (; i < issue.path.length; ) {\n            const el = issue.path[i];\n            i === issue.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;\n          }\n        }\n    };\n    return processError(this), fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof _ZodError))\n      throw new Error(\\`Not a ZodError: \\${value}\\`);\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {}, formErrors = [];\n    for (const sub of this.issues)\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0];\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [], fieldErrors[firstEl].push(mapper(sub));\n      } else\n        formErrors.push(mapper(sub));\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => new ZodError(issues);\nvar errorMap = (issue, _ctx) => {\n  let message;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      issue.received === ZodParsedType.undefined ? message = \"Required\" : message = \\`Expected \\${issue.expected}, received \\${issue.received}\\`;\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = \\`Invalid literal value, expected \\${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}\\`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = \\`Unrecognized key(s) in object: \\${util.joinValues(issue.keys, \", \")}\\`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = \"Invalid input\";\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = \\`Invalid discriminator value. Expected \\${util.joinValues(issue.options)}\\`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = \\`Invalid enum value. Expected \\${util.joinValues(issue.options)}, received '\\${issue.received}'\\`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = \"Invalid function arguments\";\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = \"Invalid function return type\";\n      break;\n    case ZodIssueCode.invalid_date:\n      message = \"Invalid date\";\n      break;\n    case ZodIssueCode.invalid_string:\n      typeof issue.validation == \"object\" ? \"includes\" in issue.validation ? (message = \\`Invalid input: must include \"\\${issue.validation.includes}\"\\`, typeof issue.validation.position == \"number\" && (message = \\`\\${message} at one or more positions greater than or equal to \\${issue.validation.position}\\`)) : \"startsWith\" in issue.validation ? message = \\`Invalid input: must start with \"\\${issue.validation.startsWith}\"\\` : \"endsWith\" in issue.validation ? message = \\`Invalid input: must end with \"\\${issue.validation.endsWith}\"\\` : util.assertNever(issue.validation) : issue.validation !== \"regex\" ? message = \\`Invalid \\${issue.validation}\\` : message = \"Invalid\";\n      break;\n    case ZodIssueCode.too_small:\n      issue.type === \"array\" ? message = \\`Array must contain \\${issue.exact ? \"exactly\" : issue.inclusive ? \"at least\" : \"more than\"} \\${issue.minimum} element(s)\\` : issue.type === \"string\" ? message = \\`String must contain \\${issue.exact ? \"exactly\" : issue.inclusive ? \"at least\" : \"over\"} \\${issue.minimum} character(s)\\` : issue.type === \"number\" ? message = \\`Number must be \\${issue.exact ? \"exactly equal to \" : issue.inclusive ? \"greater than or equal to \" : \"greater than \"}\\${issue.minimum}\\` : issue.type === \"bigint\" ? message = \\`Number must be \\${issue.exact ? \"exactly equal to \" : issue.inclusive ? \"greater than or equal to \" : \"greater than \"}\\${issue.minimum}\\` : issue.type === \"date\" ? message = \\`Date must be \\${issue.exact ? \"exactly equal to \" : issue.inclusive ? \"greater than or equal to \" : \"greater than \"}\\${new Date(Number(issue.minimum))}\\` : message = \"Invalid input\";\n      break;\n    case ZodIssueCode.too_big:\n      issue.type === \"array\" ? message = \\`Array must contain \\${issue.exact ? \"exactly\" : issue.inclusive ? \"at most\" : \"less than\"} \\${issue.maximum} element(s)\\` : issue.type === \"string\" ? message = \\`String must contain \\${issue.exact ? \"exactly\" : issue.inclusive ? \"at most\" : \"under\"} \\${issue.maximum} character(s)\\` : issue.type === \"number\" ? message = \\`Number must be \\${issue.exact ? \"exactly\" : issue.inclusive ? \"less than or equal to\" : \"less than\"} \\${issue.maximum}\\` : issue.type === \"bigint\" ? message = \\`BigInt must be \\${issue.exact ? \"exactly\" : issue.inclusive ? \"less than or equal to\" : \"less than\"} \\${issue.maximum}\\` : issue.type === \"date\" ? message = \\`Date must be \\${issue.exact ? \"exactly\" : issue.inclusive ? \"smaller than or equal to\" : \"smaller than\"} \\${new Date(Number(issue.maximum))}\\` : message = \"Invalid input\";\n      break;\n    case ZodIssueCode.custom:\n      message = \"Invalid input\";\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = \"Intersection results could not be merged\";\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = \\`Number must be a multiple of \\${issue.multipleOf}\\`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = \"Number must be finite\";\n      break;\n    default:\n      message = _ctx.defaultError, util.assertNever(issue);\n  }\n  return { message };\n}, en_default = errorMap, overrideErrorMap = en_default;\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\nvar makeIssue = (params) => {\n  const { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== void 0)\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  let errorMessage = \"\";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map of maps)\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n}, EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap(), issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      // contextual error map is first priority\n      ctx.schemaErrorMap,\n      // then schema-bound map if available\n      overrideMap,\n      // then global override map\n      overrideMap === en_default ? void 0 : en_default\n      // then global default map\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    this.value === \"valid\" && (this.value = \"dirty\");\n  }\n  abort() {\n    this.value !== \"aborted\" && (this.value = \"aborted\");\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === \"aborted\")\n        return INVALID;\n      s.status === \"dirty\" && status.dirty(), arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key, value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return _ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === \"aborted\" || value.status === \"aborted\")\n        return INVALID;\n      key.status === \"dirty\" && status.dirty(), value.status === \"dirty\" && status.dirty(), key.value !== \"__proto__\" && (typeof value.value < \"u\" || pair.alwaysSet) && (finalObject[key.value] = value.value);\n    }\n    return { status: status.value, value: finalObject };\n  }\n}, INVALID = Object.freeze({\n  status: \"aborted\"\n}), DIRTY = (value) => ({ status: \"dirty\", value }), OK = (value) => ({ status: \"valid\", value }), isAborted = (x) => x.status === \"aborted\", isDirty = (x) => x.status === \"dirty\", isValid = (x) => x.status === \"valid\", isAsync = (x) => typeof Promise < \"u\" && x instanceof Promise, errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message == \"string\" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message == \"string\" ? message : message == null ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;\n  }\n  get path() {\n    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n  }\n}, handleResult = (ctx, result) => {\n  if (isValid(result))\n    return { success: !0, data: result.value };\n  if (!ctx.common.issues.length)\n    throw new Error(\"Validation failed but no issues detected.\");\n  return {\n    success: !1,\n    get error() {\n      if (this._error)\n        return this._error;\n      const error = new ZodError(ctx.common.issues);\n      return this._error = error, this._error;\n    }\n  };\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error))\n    throw new Error(\\`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.\\`);\n  return errorMap2 ? { errorMap: errorMap2, description } : { errorMap: (iss, ctx) => {\n    const { message } = params;\n    return iss.code === \"invalid_enum_value\" ? { message: message ?? ctx.defaultError } : typeof ctx.data > \"u\" ? { message: message ?? required_error ?? ctx.defaultError } : iss.code !== \"invalid_type\" ? { message: ctx.defaultError } : { message: message ?? invalid_type_error ?? ctx.defaultError };\n  }, description };\n}\nvar ZodType = class {\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result))\n      throw new Error(\"Synchronous parse encountered promise.\");\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: (params == null ? void 0 : params.async) ?? !1,\n        contextualErrorMap: params == null ? void 0 : params.errorMap\n      },\n      path: (params == null ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    }, result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  \"~validate\"(data) {\n    var _a, _b;\n    const ctx = {\n      common: {\n        issues: [],\n        async: !!this[\"~standard\"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    if (!this[\"~standard\"].async)\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        };\n      } catch (err) {\n        (_b = (_a = err == null ? void 0 : err.message) == null ? void 0 : _a.toLowerCase()) != null && _b.includes(\"encountered\") && (this[\"~standard\"].async = !0), ctx.common = {\n          issues: [],\n          async: !0\n        };\n      }\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\n      value: result.value\n    } : {\n      issues: ctx.common.issues\n    });\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params == null ? void 0 : params.errorMap,\n        async: !0\n      },\n      path: (params == null ? void 0 : params.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check, message) {\n    const getIssueProperties = (val) => typeof message == \"string\" || typeof message > \"u\" ? { message } : typeof message == \"function\" ? message(val) : message;\n    return this._refinement((val, ctx) => {\n      const result = check(val), setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      return typeof Promise < \"u\" && result instanceof Promise ? result.then((data) => data ? !0 : (setError(), !1)) : result ? !0 : (setError(), !1);\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => check(val) ? !0 : (ctx.addIssue(typeof refinementData == \"function\" ? refinementData(val, ctx) : refinementData), !1));\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"refinement\", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  constructor(def) {\n    this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (data) => this[\"~validate\"](data)\n    };\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: \"transform\", transform }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def == \"function\" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def == \"function\" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}, cuidRegex = /^c[^\\\\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i, uuidRegex = /^[0-9a-fA-F]{8}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{4}\\\\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, jwtRegex = /^[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]+\\\\.[A-Za-z0-9-_]*$/, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\\\d+Y)|(?:[-+]?\\\\d+[.,]\\\\d+Y$))?(?:(?:[-+]?\\\\d+M)|(?:[-+]?\\\\d+[.,]\\\\d+M$))?(?:(?:[-+]?\\\\d+W)|(?:[-+]?\\\\d+[.,]\\\\d+W$))?(?:(?:[-+]?\\\\d+D)|(?:[-+]?\\\\d+[.,]\\\\d+D$))?(?:T(?=[\\\\d+-])(?:(?:[-+]?\\\\d+H)|(?:[-+]?\\\\d+[.,]\\\\d+H$))?(?:(?:[-+]?\\\\d+M)|(?:[-+]?\\\\d+[.,]\\\\d+M$))?(?:[-+]?\\\\d+(?:[.,]\\\\d+)?S)?)??$/, emailRegex = /^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Z0-9_'+\\\\-\\\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\\\-]*\\\\.)+[A-Z]{2,}$/i, _emojiRegex = \"^(\\\\\\\\p{Extended_Pictographic}|\\\\\\\\p{Emoji_Component})+$\", emojiRegex, ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\\\/(3[0-2]|[12]?[0-9])$/, ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dateRegexSource = \"((\\\\\\\\d\\\\\\\\d[2468][048]|\\\\\\\\d\\\\\\\\d[13579][26]|\\\\\\\\d\\\\\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\\\\\d|30)|(02)-(0[1-9]|1\\\\\\\\d|2[0-8])))\", dateRegex = new RegExp(\\`^\\${dateRegexSource}$\\`);\nfunction timeRegexSource(args) {\n  let secondsRegexSource = \"[0-5]\\\\\\\\d\";\n  args.precision ? secondsRegexSource = \\`\\${secondsRegexSource}\\\\\\\\.\\\\\\\\d{\\${args.precision}}\\` : args.precision == null && (secondsRegexSource = \\`\\${secondsRegexSource}(\\\\\\\\.\\\\\\\\d+)?\\`);\n  const secondsQuantifier = args.precision ? \"+\" : \"?\";\n  return \\`([01]\\\\\\\\d|2[0-3]):[0-5]\\\\\\\\d(:\\${secondsRegexSource})\\${secondsQuantifier}\\`;\n}\nfunction timeRegex(args) {\n  return new RegExp(\\`^\\${timeRegexSource(args)}$\\`);\n}\nfunction datetimeRegex(args) {\n  let regex = \\`\\${dateRegexSource}T\\${timeRegexSource(args)}\\`;\n  const opts = [];\n  return opts.push(args.local ? \"Z?\" : \"Z\"), args.offset && opts.push(\"([+-]\\\\\\\\d{2}:?\\\\\\\\d{2})\"), regex = \\`\\${regex}(\\${opts.join(\"|\")})\\`, new RegExp(\\`^\\${regex}$\\`);\n}\nfunction isValidIP(ip, version) {\n  return !!((version === \"v4\" || !version) && ipv4Regex.test(ip) || (version === \"v6\" || !version) && ipv6Regex.test(ip));\n}\nfunction isValidJWT(jwt, alg) {\n  if (!jwtRegex.test(jwt))\n    return !1;\n  try {\n    const [header] = jwt.split(\".\");\n    if (!header)\n      return !1;\n    const base64 = header.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(header.length + (4 - header.length % 4) % 4, \"=\"), decoded = JSON.parse(atob(base64));\n    return !(typeof decoded != \"object\" || decoded === null || \"typ\" in decoded && (decoded == null ? void 0 : decoded.typ) !== \"JWT\" || !decoded.alg || alg && decoded.alg !== alg);\n  } catch {\n    return !1;\n  }\n}\nfunction isValidCidr(ip, version) {\n  return !!((version === \"v4\" || !version) && ipv4CidrRegex.test(ip) || (version === \"v6\" || !version) && ipv6CidrRegex.test(ip));\n}\nvar ZodString = class _ZodString extends ZodType {\n  _parse(input) {\n    if (this._def.coerce && (input.data = String(input.data)), this._getType(input) !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      }), INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx;\n    for (const check of this._def.checks)\n      if (check.kind === \"min\")\n        input.data.length < check.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: check.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"max\")\n        input.data.length > check.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: check.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"length\") {\n        const tooBig = input.data.length > check.value, tooSmall = input.data.length < check.value;\n        (tooBig || tooSmall) && (ctx = this._getOrReturnCtx(input, ctx), tooBig ? addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: check.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: check.message\n        }) : tooSmall && addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: check.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: check.message\n        }), status.dirty());\n      } else if (check.kind === \"email\")\n        emailRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"email\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"emoji\")\n        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, \"u\")), emojiRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"emoji\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"uuid\")\n        uuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"uuid\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"nanoid\")\n        nanoidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"nanoid\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"cuid\")\n        cuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"cuid\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"cuid2\")\n        cuid2Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"cuid2\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"ulid\")\n        ulidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n          validation: \"ulid\",\n          code: ZodIssueCode.invalid_string,\n          message: check.message\n        }), status.dirty());\n      else if (check.kind === \"url\")\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n            validation: \"url\",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          }), status.dirty();\n        }\n      else check.kind === \"regex\" ? (check.regex.lastIndex = 0, check.regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"regex\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty())) : check.kind === \"trim\" ? input.data = input.data.trim() : check.kind === \"includes\" ? input.data.includes(check.value, check.position) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_string,\n        validation: { includes: check.value, position: check.position },\n        message: check.message\n      }), status.dirty()) : check.kind === \"toLowerCase\" ? input.data = input.data.toLowerCase() : check.kind === \"toUpperCase\" ? input.data = input.data.toUpperCase() : check.kind === \"startsWith\" ? input.data.startsWith(check.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_string,\n        validation: { startsWith: check.value },\n        message: check.message\n      }), status.dirty()) : check.kind === \"endsWith\" ? input.data.endsWith(check.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_string,\n        validation: { endsWith: check.value },\n        message: check.message\n      }), status.dirty()) : check.kind === \"datetime\" ? datetimeRegex(check).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_string,\n        validation: \"datetime\",\n        message: check.message\n      }), status.dirty()) : check.kind === \"date\" ? dateRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_string,\n        validation: \"date\",\n        message: check.message\n      }), status.dirty()) : check.kind === \"time\" ? timeRegex(check).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_string,\n        validation: \"time\",\n        message: check.message\n      }), status.dirty()) : check.kind === \"duration\" ? durationRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"duration\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty()) : check.kind === \"ip\" ? isValidIP(input.data, check.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"ip\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty()) : check.kind === \"jwt\" ? isValidJWT(input.data, check.alg) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"jwt\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty()) : check.kind === \"cidr\" ? isValidCidr(input.data, check.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"cidr\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty()) : check.kind === \"base64\" ? base64Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"base64\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty()) : check.kind === \"base64url\" ? base64urlRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        validation: \"base64url\",\n        code: ZodIssueCode.invalid_string,\n        message: check.message\n      }), status.dirty()) : util.assertNever(check);\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check) {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n  }\n  emoji(message) {\n    return this._addCheck({ kind: \"emoji\", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message) {\n    return this._addCheck({ kind: \"nanoid\", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n  }\n  cuid2(message) {\n    return this._addCheck({ kind: \"cuid2\", ...errorUtil.errToObj(message) });\n  }\n  ulid(message) {\n    return this._addCheck({ kind: \"ulid\", ...errorUtil.errToObj(message) });\n  }\n  base64(message) {\n    return this._addCheck({ kind: \"base64\", ...errorUtil.errToObj(message) });\n  }\n  base64url(message) {\n    return this._addCheck({\n      kind: \"base64url\",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  jwt(options) {\n    return this._addCheck({ kind: \"jwt\", ...errorUtil.errToObj(options) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: \"ip\", ...errorUtil.errToObj(options) });\n  }\n  cidr(options) {\n    return this._addCheck({ kind: \"cidr\", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    return typeof options == \"string\" ? this._addCheck({\n      kind: \"datetime\",\n      precision: null,\n      offset: !1,\n      local: !1,\n      message: options\n    }) : this._addCheck({\n      kind: \"datetime\",\n      precision: typeof (options == null ? void 0 : options.precision) > \"u\" ? null : options == null ? void 0 : options.precision,\n      offset: (options == null ? void 0 : options.offset) ?? !1,\n      local: (options == null ? void 0 : options.local) ?? !1,\n      ...errorUtil.errToObj(options == null ? void 0 : options.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({ kind: \"date\", message });\n  }\n  time(options) {\n    return typeof options == \"string\" ? this._addCheck({\n      kind: \"time\",\n      precision: null,\n      message: options\n    }) : this._addCheck({\n      kind: \"time\",\n      precision: typeof (options == null ? void 0 : options.precision) > \"u\" ? null : options == null ? void 0 : options.precision,\n      ...errorUtil.errToObj(options == null ? void 0 : options.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({ kind: \"duration\", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: \"includes\",\n      value,\n      position: options == null ? void 0 : options.position,\n      ...errorUtil.errToObj(options == null ? void 0 : options.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: \"length\",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  /**\n   * Equivalent to \\`.min(1)\\`\n   */\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64\");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((ch) => ch.kind === \"base64url\");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"min\" && (min === null || ch.value > min) && (min = ch.value);\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"max\" && (max === null || ch.value < max) && (max = ch.value);\n    return max;\n  }\n};\nZodString.create = (params) => new ZodString({\n  checks: [],\n  typeName: ZodFirstPartyTypeKind.ZodString,\n  coerce: (params == null ? void 0 : params.coerce) ?? !1,\n  ...processCreateParams(params)\n});\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(\".\")[1] || \"\").length, stepDecCount = (step.toString().split(\".\")[1] || \"\").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(\".\", \"\")), stepInt = Number.parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n  return valInt % stepInt / 10 ** decCount;\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce && (input.data = Number(input.data)), this._getType(input) !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      }), INVALID;\n    }\n    let ctx;\n    const status = new ParseStatus();\n    for (const check of this._def.checks)\n      check.kind === \"int\" ? util.isInteger(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: \"integer\",\n        received: \"float\",\n        message: check.message\n      }), status.dirty()) : check.kind === \"min\" ? (check.inclusive ? input.data < check.value : input.data <= check.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: check.value,\n        type: \"number\",\n        inclusive: check.inclusive,\n        exact: !1,\n        message: check.message\n      }), status.dirty()) : check.kind === \"max\" ? (check.inclusive ? input.data > check.value : input.data >= check.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: check.value,\n        type: \"number\",\n        inclusive: check.inclusive,\n        exact: !1,\n        message: check.message\n      }), status.dirty()) : check.kind === \"multipleOf\" ? floatSafeRemainder(input.data, check.value) !== 0 && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.not_multiple_of,\n        multipleOf: check.value,\n        message: check.message\n      }), status.dirty()) : check.kind === \"finite\" ? Number.isFinite(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.not_finite,\n        message: check.message\n      }), status.dirty()) : util.assertNever(check);\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, !0, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, !1, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, !0, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, !1, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: \"int\",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !1,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !1,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !0,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !0,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: !0,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: !0,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"min\" && (min === null || ch.value > min) && (min = ch.value);\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"max\" && (max === null || ch.value < max) && (max = ch.value);\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null, min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\")\n        return !0;\n      ch.kind === \"min\" ? (min === null || ch.value > min) && (min = ch.value) : ch.kind === \"max\" && (max === null || ch.value < max) && (max = ch.value);\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n};\nZodNumber.create = (params) => new ZodNumber({\n  checks: [],\n  typeName: ZodFirstPartyTypeKind.ZodNumber,\n  coerce: (params == null ? void 0 : params.coerce) || !1,\n  ...processCreateParams(params)\n});\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce)\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    if (this._getType(input) !== ZodParsedType.bigint)\n      return this._getInvalidInput(input);\n    let ctx;\n    const status = new ParseStatus();\n    for (const check of this._def.checks)\n      check.kind === \"min\" ? (check.inclusive ? input.data < check.value : input.data <= check.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        type: \"bigint\",\n        minimum: check.value,\n        inclusive: check.inclusive,\n        message: check.message\n      }), status.dirty()) : check.kind === \"max\" ? (check.inclusive ? input.data > check.value : input.data >= check.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        type: \"bigint\",\n        maximum: check.value,\n        inclusive: check.inclusive,\n        message: check.message\n      }), status.dirty()) : check.kind === \"multipleOf\" ? input.data % check.value !== BigInt(0) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.not_multiple_of,\n        multipleOf: check.value,\n        message: check.message\n      }), status.dirty()) : util.assertNever(check);\n    return { status: status.value, value: input.data };\n  }\n  _getInvalidInput(input) {\n    const ctx = this._getOrReturnCtx(input);\n    return addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType\n    }), INVALID;\n  }\n  gte(value, message) {\n    return this.setLimit(\"min\", value, !0, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit(\"min\", value, !1, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit(\"max\", value, !0, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit(\"max\", value, !1, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"min\" && (min === null || ch.value > min) && (min = ch.value);\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"max\" && (max === null || ch.value < max) && (max = ch.value);\n    return max;\n  }\n};\nZodBigInt.create = (params) => new ZodBigInt({\n  checks: [],\n  typeName: ZodFirstPartyTypeKind.ZodBigInt,\n  coerce: (params == null ? void 0 : params.coerce) ?? !1,\n  ...processCreateParams(params)\n});\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    if (this._def.coerce && (input.data = !!input.data), this._getType(input) !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params) => new ZodBoolean({\n  typeName: ZodFirstPartyTypeKind.ZodBoolean,\n  coerce: (params == null ? void 0 : params.coerce) || !1,\n  ...processCreateParams(params)\n});\nvar ZodDate = class _ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce && (input.data = new Date(input.data)), this._getType(input) !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      }), INVALID;\n    }\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      }), INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx;\n    for (const check of this._def.checks)\n      check.kind === \"min\" ? input.data.getTime() < check.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        message: check.message,\n        inclusive: !0,\n        exact: !1,\n        minimum: check.value,\n        type: \"date\"\n      }), status.dirty()) : check.kind === \"max\" ? input.data.getTime() > check.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        message: check.message,\n        inclusive: !0,\n        exact: !1,\n        maximum: check.value,\n        type: \"date\"\n      }), status.dirty()) : util.assertNever(check);\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new _ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: \"min\",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: \"max\",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"min\" && (min === null || ch.value > min) && (min = ch.value);\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks)\n      ch.kind === \"max\" && (max === null || ch.value < max) && (max = ch.value);\n    return max != null ? new Date(max) : null;\n  }\n};\nZodDate.create = (params) => new ZodDate({\n  checks: [],\n  coerce: (params == null ? void 0 : params.coerce) || !1,\n  typeName: ZodFirstPartyTypeKind.ZodDate,\n  ...processCreateParams(params)\n});\nvar ZodSymbol = class extends ZodType {\n  _parse(input) {\n    if (this._getType(input) !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodSymbol.create = (params) => new ZodSymbol({\n  typeName: ZodFirstPartyTypeKind.ZodSymbol,\n  ...processCreateParams(params)\n});\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    if (this._getType(input) !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params) => new ZodUndefined({\n  typeName: ZodFirstPartyTypeKind.ZodUndefined,\n  ...processCreateParams(params)\n});\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    if (this._getType(input) !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params) => new ZodNull({\n  typeName: ZodFirstPartyTypeKind.ZodNull,\n  ...processCreateParams(params)\n});\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments), this._any = !0;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params) => new ZodAny({\n  typeName: ZodFirstPartyTypeKind.ZodAny,\n  ...processCreateParams(params)\n});\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments), this._unknown = !0;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params) => new ZodUnknown({\n  typeName: ZodFirstPartyTypeKind.ZodUnknown,\n  ...processCreateParams(params)\n});\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    return addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    }), INVALID;\n  }\n};\nZodNever.create = (params) => new ZodNever({\n  typeName: ZodFirstPartyTypeKind.ZodNever,\n  ...processCreateParams(params)\n});\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    if (this._getType(input) !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params) => new ZodVoid({\n  typeName: ZodFirstPartyTypeKind.ZodVoid,\n  ...processCreateParams(params)\n});\nvar ZodArray = class _ZodArray extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input), def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      }), INVALID;\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;\n      (tooBig || tooSmall) && (addIssueToContext(ctx, {\n        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n        minimum: tooSmall ? def.exactLength.value : void 0,\n        maximum: tooBig ? def.exactLength.value : void 0,\n        type: \"array\",\n        inclusive: !0,\n        exact: !0,\n        message: def.exactLength.message\n      }), status.dirty());\n    }\n    if (def.minLength !== null && ctx.data.length < def.minLength.value && (addIssueToContext(ctx, {\n      code: ZodIssueCode.too_small,\n      minimum: def.minLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: def.minLength.message\n    }), status.dirty()), def.maxLength !== null && ctx.data.length > def.maxLength.value && (addIssueToContext(ctx, {\n      code: ZodIssueCode.too_big,\n      maximum: def.maxLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: def.maxLength.message\n    }), status.dirty()), ctx.common.async)\n      return Promise.all([...ctx.data].map((item, i) => def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result2) => ParseStatus.mergeArray(status, result2));\n    const result = [...ctx.data].map((item, i) => def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return new _ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodArray.create = (schema, params) => new ZodArray({\n  type: schema,\n  minLength: null,\n  maxLength: null,\n  exactLength: null,\n  typeName: ZodFirstPartyTypeKind.ZodArray,\n  ...processCreateParams(params)\n});\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else return schema instanceof ZodArray ? new ZodArray({\n    ...schema._def,\n    type: deepPartialify(schema.element)\n  }) : schema instanceof ZodOptional ? ZodOptional.create(deepPartialify(schema.unwrap())) : schema instanceof ZodNullable ? ZodNullable.create(deepPartialify(schema.unwrap())) : schema instanceof ZodTuple ? ZodTuple.create(schema.items.map((item) => deepPartialify(item))) : schema;\n}\nvar ZodObject = class _ZodObject extends ZodType {\n  constructor() {\n    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape(), keys = util.objectKeys(shape);\n    return this._cached = { shape, keys }, this._cached;\n  }\n  _parse(input) {\n    if (this._getType(input) !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      }), INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\"))\n      for (const key in ctx.data)\n        shapeKeys.includes(key) || extraKeys.push(key);\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key], value = ctx.data[key];\n      pairs.push({\n        key: { status: \"valid\", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === \"passthrough\")\n        for (const key of extraKeys)\n          pairs.push({\n            key: { status: \"valid\", value: key },\n            value: { status: \"valid\", value: ctx.data[key] }\n          });\n      else if (unknownKeys === \"strict\")\n        extraKeys.length > 0 && (addIssueToContext(ctx, {\n          code: ZodIssueCode.unrecognized_keys,\n          keys: extraKeys\n        }), status.dirty());\n      else if (unknownKeys !== \"strip\") throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: \"valid\", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    return ctx.common.async ? Promise.resolve().then(async () => {\n      const syncPairs = [];\n      for (const pair of pairs) {\n        const key = await pair.key, value = await pair.value;\n        syncPairs.push({\n          key,\n          value,\n          alwaysSet: pair.alwaysSet\n        });\n      }\n      return syncPairs;\n    }).then((syncPairs) => ParseStatus.mergeObjectSync(status, syncPairs)) : ParseStatus.mergeObjectSync(status, pairs);\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    return errorUtil.errToObj, new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...message !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          var _a, _b;\n          const defaultError = ((_b = (_a = this._def).errorMap) == null ? void 0 : _b.call(_a, issue, ctx).message) ?? ctx.defaultError;\n          return issue.code === \"unrecognized_keys\" ? {\n            message: errorUtil.errToObj(message).message ?? defaultError\n          } : {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(augmentation) {\n    return new _ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(merging) {\n    return new _ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(index) {\n    return new _ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(mask))\n      mask[key] && this.shape[key] && (shape[key] = this.shape[key]);\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(this.shape))\n      mask[key] || (shape[key] = this.shape[key]);\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key];\n      mask && !mask[key] ? newShape[key] = fieldSchema : newShape[key] = fieldSchema.optional();\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape))\n      if (mask && !mask[key])\n        newShape[key] = this.shape[key];\n      else {\n        let newField = this.shape[key];\n        for (; newField instanceof ZodOptional; )\n          newField = newField._def.innerType;\n        newShape[key] = newField;\n      }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params) => new ZodObject({\n  shape: () => shape,\n  unknownKeys: \"strip\",\n  catchall: ZodNever.create(),\n  typeName: ZodFirstPartyTypeKind.ZodObject,\n  ...processCreateParams(params)\n});\nZodObject.strictCreate = (shape, params) => new ZodObject({\n  shape: () => shape,\n  unknownKeys: \"strict\",\n  catchall: ZodNever.create(),\n  typeName: ZodFirstPartyTypeKind.ZodObject,\n  ...processCreateParams(params)\n});\nZodObject.lazycreate = (shape, params) => new ZodObject({\n  shape,\n  unknownKeys: \"strip\",\n  catchall: ZodNever.create(),\n  typeName: ZodFirstPartyTypeKind.ZodObject,\n  ...processCreateParams(params)\n});\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input), options = this._def.options;\n    function handleResults(results) {\n      for (const result of results)\n        if (result.result.status === \"valid\")\n          return result.result;\n      for (const result of results)\n        if (result.result.status === \"dirty\")\n          return ctx.common.issues.push(...result.ctx.common.issues), result.result;\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      }), INVALID;\n    }\n    if (ctx.common.async)\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    {\n      let dirty;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        }, result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === \"valid\")\n          return result;\n        result.status === \"dirty\" && !dirty && (dirty = { result, ctx: childCtx }), childCtx.common.issues.length && issues.push(childCtx.common.issues);\n      }\n      if (dirty)\n        return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      }), INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params) => new ZodUnion({\n  options: types,\n  typeName: ZodFirstPartyTypeKind.ZodUnion,\n  ...processCreateParams(params)\n});\nvar getDiscriminator = (type) => type instanceof ZodLazy ? getDiscriminator(type.schema) : type instanceof ZodEffects ? getDiscriminator(type.innerType()) : type instanceof ZodLiteral ? [type.value] : type instanceof ZodEnum ? type.options : type instanceof ZodNativeEnum ? util.objectValues(type.enum) : type instanceof ZodDefault ? getDiscriminator(type._def.innerType) : type instanceof ZodUndefined ? [void 0] : type instanceof ZodNull ? [null] : type instanceof ZodOptional ? [void 0, ...getDiscriminator(type.unwrap())] : type instanceof ZodNullable ? [null, ...getDiscriminator(type.unwrap())] : type instanceof ZodBranded || type instanceof ZodReadonly ? getDiscriminator(type.unwrap()) : type instanceof ZodCatch ? getDiscriminator(type._def.innerType) : [], ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      }), INVALID;\n    const discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);\n    return option ? ctx.common.async ? option._parseAsync({\n      data: ctx.data,\n      path: ctx.path,\n      parent: ctx\n    }) : option._parseSync({\n      data: ctx.data,\n      path: ctx.path,\n      parent: ctx\n    }) : (addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_union_discriminator,\n      options: Array.from(this.optionsMap.keys()),\n      path: [discriminator]\n    }), INVALID);\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(discriminator, options, params) {\n    const optionsMap = /* @__PURE__ */ new Map();\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length)\n        throw new Error(\\`A discriminator value for key \\\\\\`\\${discriminator}\\\\\\` could not be extracted from all schema options\\`);\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value))\n          throw new Error(\\`Discriminator property \\${String(discriminator)} has duplicate value \\${String(value)}\\`);\n        optionsMap.set(value, type);\n      }\n    }\n    return new _ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n};\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a), bType = getParsedType(b);\n  if (a === b)\n    return { valid: !0, data: a };\n  if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b), sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid)\n        return { valid: !1 };\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: !0, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length)\n      return { valid: !1 };\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid)\n        return { valid: !1 };\n      newArray.push(sharedValue.data);\n    }\n    return { valid: !0, data: newArray };\n  } else return aType === ZodParsedType.date && bType === ZodParsedType.date && +a == +b ? { valid: !0, data: a } : { valid: !1 };\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight))\n        return INVALID;\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      return merged.valid ? ((isDirty(parsedLeft) || isDirty(parsedRight)) && status.dirty(), { status: status.value, value: merged.data }) : (addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_intersection_types\n      }), INVALID);\n    };\n    return ctx.common.async ? Promise.all([\n      this._def.left._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }),\n      this._def.right._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      })\n    ]).then(([left, right]) => handleParsed(left, right)) : handleParsed(this._def.left._parseSync({\n      data: ctx.data,\n      path: ctx.path,\n      parent: ctx\n    }), this._def.right._parseSync({\n      data: ctx.data,\n      path: ctx.path,\n      parent: ctx\n    }));\n  }\n};\nZodIntersection.create = (left, right, params) => new ZodIntersection({\n  left,\n  right,\n  typeName: ZodFirstPartyTypeKind.ZodIntersection,\n  ...processCreateParams(params)\n});\nvar ZodTuple = class _ZodTuple extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      }), INVALID;\n    if (ctx.data.length < this._def.items.length)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: !0,\n        exact: !1,\n        type: \"array\"\n      }), INVALID;\n    !this._def.rest && ctx.data.length > this._def.items.length && (addIssueToContext(ctx, {\n      code: ZodIssueCode.too_big,\n      maximum: this._def.items.length,\n      inclusive: !0,\n      exact: !1,\n      type: \"array\"\n    }), status.dirty());\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      return schema ? schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)) : null;\n    }).filter((x) => !!x);\n    return ctx.common.async ? Promise.all(items).then((results) => ParseStatus.mergeArray(status, results)) : ParseStatus.mergeArray(status, items);\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new _ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas))\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      }), INVALID;\n    const pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;\n    for (const key in ctx.data)\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    return ctx.common.async ? ParseStatus.mergeObjectAsync(status, pairs) : ParseStatus.mergeObjectSync(status, pairs);\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    return second instanceof ZodType ? new _ZodRecord({\n      keyType: first,\n      valueType: second,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(third)\n    }) : new _ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n}, ZodMap = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      }), INVALID;\n    const keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => ({\n      key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n      value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"]))\n    }));\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key, value = await pair.value;\n          if (key.status === \"aborted\" || value.status === \"aborted\")\n            return INVALID;\n          (key.status === \"dirty\" || value.status === \"dirty\") && status.dirty(), finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key, value = pair.value;\n        if (key.status === \"aborted\" || value.status === \"aborted\")\n          return INVALID;\n        (key.status === \"dirty\" || value.status === \"dirty\") && status.dirty(), finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params) => new ZodMap({\n  valueType,\n  keyType,\n  typeName: ZodFirstPartyTypeKind.ZodMap,\n  ...processCreateParams(params)\n});\nvar ZodSet = class _ZodSet extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      }), INVALID;\n    const def = this._def;\n    def.minSize !== null && ctx.data.size < def.minSize.value && (addIssueToContext(ctx, {\n      code: ZodIssueCode.too_small,\n      minimum: def.minSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: def.minSize.message\n    }), status.dirty()), def.maxSize !== null && ctx.data.size > def.maxSize.value && (addIssueToContext(ctx, {\n      code: ZodIssueCode.too_big,\n      maximum: def.maxSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: def.maxSize.message\n    }), status.dirty());\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === \"aborted\")\n          return INVALID;\n        element.status === \"dirty\" && status.dirty(), parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    return ctx.common.async ? Promise.all(elements).then((elements2) => finalizeSet(elements2)) : finalizeSet(elements);\n  }\n  min(minSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodSet.create = (valueType, params) => new ZodSet({\n  valueType,\n  minSize: null,\n  maxSize: null,\n  typeName: ZodFirstPartyTypeKind.ZodSet,\n  ...processCreateParams(params)\n});\nvar ZodFunction = class _ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments), this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      }), INVALID;\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me = this;\n      return OK(async function(...args) {\n        const error = new ZodError([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          throw error.addIssue(makeArgsIssue(args, e)), error;\n        }), result = await Reflect.apply(fn, this, parsedArgs);\n        return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {\n          throw error.addIssue(makeReturnsIssue(result, e)), error;\n        });\n      });\n    } else {\n      const me = this;\n      return OK(function(...args) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success)\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        const result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success)\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new _ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new _ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    return this.parse(func);\n  }\n  strictImplement(func) {\n    return this.parse(func);\n  }\n  static create(args, returns, params) {\n    return new _ZodFunction({\n      args: args || ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n}, ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params) => new ZodLazy({\n  getter,\n  typeName: ZodFirstPartyTypeKind.ZodLazy,\n  ...processCreateParams(params)\n});\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      }), INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params) => new ZodLiteral({\n  value,\n  typeName: ZodFirstPartyTypeKind.ZodLiteral,\n  ...processCreateParams(params)\n});\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n  _parse(input) {\n    if (typeof input.data != \"string\") {\n      const ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;\n      return addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      }), INVALID;\n    }\n    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;\n      return addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values)\n      enumValues[val] = val;\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values)\n      enumValues[val] = val;\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values)\n      enumValues[val] = val;\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return _ZodEnum.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n};\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      return addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      }), INVALID;\n    }\n    if (this._cache || (this._cache = new Set(util.getValidEnumValues(this._def.values))), !this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      return addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      }), INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nZodNativeEnum.create = (values, params) => new ZodNativeEnum({\n  values,\n  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n  ...processCreateParams(params)\n});\nvar ZodPromise = class extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      }), INVALID;\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => this._def.type.parseAsync(data, {\n      path: ctx.path,\n      errorMap: ctx.common.contextualErrorMap\n    })));\n  }\n};\nZodPromise.create = (schema, params) => new ZodPromise({\n  type: schema,\n  typeName: ZodFirstPartyTypeKind.ZodPromise,\n  ...processCreateParams(params)\n});\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg), arg.fatal ? status.abort() : status.dirty();\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === \"preprocess\") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async)\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === \"aborted\")\n            return INVALID;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          return result.status === \"aborted\" ? INVALID : result.status === \"dirty\" || status.value === \"dirty\" ? DIRTY(result.value) : result;\n        });\n      {\n        if (status.value === \"aborted\")\n          return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        return result.status === \"aborted\" ? INVALID : result.status === \"dirty\" || status.value === \"dirty\" ? DIRTY(result.value) : result;\n      }\n    }\n    if (effect.type === \"refinement\") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async)\n          return Promise.resolve(result);\n        if (result instanceof Promise)\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return acc;\n      };\n      if (ctx.common.async === !1) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        return inner.status === \"aborted\" ? INVALID : (inner.status === \"dirty\" && status.dirty(), executeRefinement(inner.value), { status: status.value, value: inner.value });\n      } else\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => inner.status === \"aborted\" ? INVALID : (inner.status === \"dirty\" && status.dirty(), executeRefinement(inner.value).then(() => ({ status: status.value, value: inner.value }))));\n    }\n    if (effect.type === \"transform\")\n      if (ctx.common.async === !1) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return INVALID;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise)\n          throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return { status: status.value, value: result };\n      } else\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => isValid(base) ? Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n          status: status.value,\n          value: result\n        })) : INVALID);\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema, effect, params) => new ZodEffects({\n  schema,\n  typeName: ZodFirstPartyTypeKind.ZodEffects,\n  effect,\n  ...processCreateParams(params)\n});\nZodEffects.createWithPreprocess = (preprocess, schema, params) => new ZodEffects({\n  schema,\n  effect: { type: \"preprocess\", transform: preprocess },\n  typeName: ZodFirstPartyTypeKind.ZodEffects,\n  ...processCreateParams(params)\n});\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    return this._getType(input) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type, params) => new ZodOptional({\n  innerType: type,\n  typeName: ZodFirstPartyTypeKind.ZodOptional,\n  ...processCreateParams(params)\n});\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    return this._getType(input) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type, params) => new ZodNullable({\n  innerType: type,\n  typeName: ZodFirstPartyTypeKind.ZodNullable,\n  ...processCreateParams(params)\n});\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    return ctx.parsedType === ZodParsedType.undefined && (data = this._def.defaultValue()), this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type, params) => new ZodDefault({\n  innerType: type,\n  typeName: ZodFirstPartyTypeKind.ZodDefault,\n  defaultValue: typeof params.default == \"function\" ? params.default : () => params.default,\n  ...processCreateParams(params)\n});\nvar ZodCatch = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input), newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    }, result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    return isAsync(result) ? result.then((result2) => ({\n      status: \"valid\",\n      value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n        get error() {\n          return new ZodError(newCtx.common.issues);\n        },\n        input: newCtx.data\n      })\n    })) : {\n      status: \"valid\",\n      value: result.status === \"valid\" ? result.value : this._def.catchValue({\n        get error() {\n          return new ZodError(newCtx.common.issues);\n        },\n        input: newCtx.data\n      })\n    };\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nZodCatch.create = (type, params) => new ZodCatch({\n  innerType: type,\n  typeName: ZodFirstPartyTypeKind.ZodCatch,\n  catchValue: typeof params.catch == \"function\" ? params.catch : () => params.catch,\n  ...processCreateParams(params)\n});\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    if (this._getType(input) !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      return addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      }), INVALID;\n    }\n    return { status: \"valid\", value: input.data };\n  }\n};\nZodNaN.create = (params) => new ZodNaN({\n  typeName: ZodFirstPartyTypeKind.ZodNaN,\n  ...processCreateParams(params)\n});\nvar BRAND = Symbol(\"zod_brand\"), ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input), data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}, ZodPipeline = class _ZodPipeline extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async)\n      return (async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        return inResult.status === \"aborted\" ? INVALID : inResult.status === \"dirty\" ? (status.dirty(), DIRTY(inResult.value)) : this._def.out._parseAsync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      })();\n    {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      return inResult.status === \"aborted\" ? INVALID : inResult.status === \"dirty\" ? (status.dirty(), {\n        status: \"dirty\",\n        value: inResult.value\n      }) : this._def.out._parseSync({\n        data: inResult.value,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  static create(a, b) {\n    return new _ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n}, ZodReadonly = class extends ZodType {\n  _parse(input) {\n    const result = this._def.innerType._parse(input), freeze = (data) => (isValid(data) && (data.value = Object.freeze(data.value)), data);\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodReadonly.create = (type, params) => new ZodReadonly({\n  innerType: type,\n  typeName: ZodFirstPartyTypeKind.ZodReadonly,\n  ...processCreateParams(params)\n});\nfunction cleanParams(params, data) {\n  const p = typeof params == \"function\" ? params(data) : typeof params == \"string\" ? { message: params } : params;\n  return typeof p == \"string\" ? { message: p } : p;\n}\nfunction custom(check, _params = {}, fatal) {\n  return check ? ZodAny.create().superRefine((data, ctx) => {\n    const r2 = check(data);\n    if (r2 instanceof Promise)\n      return r2.then((r22) => {\n        if (!r22) {\n          const params = cleanParams(_params, data), _fatal = params.fatal ?? fatal ?? !0;\n          ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n        }\n      });\n    if (!r2) {\n      const params = cleanParams(_params, data), _fatal = params.fatal ?? fatal ?? !0;\n      ctx.addIssue({ code: \"custom\", ...params, fatal: _fatal });\n    }\n  }) : ZodAny.create();\n}\nvar late = {\n  object: ZodObject.lazycreate\n}, ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2.ZodString = \"ZodString\", ZodFirstPartyTypeKind2.ZodNumber = \"ZodNumber\", ZodFirstPartyTypeKind2.ZodNaN = \"ZodNaN\", ZodFirstPartyTypeKind2.ZodBigInt = \"ZodBigInt\", ZodFirstPartyTypeKind2.ZodBoolean = \"ZodBoolean\", ZodFirstPartyTypeKind2.ZodDate = \"ZodDate\", ZodFirstPartyTypeKind2.ZodSymbol = \"ZodSymbol\", ZodFirstPartyTypeKind2.ZodUndefined = \"ZodUndefined\", ZodFirstPartyTypeKind2.ZodNull = \"ZodNull\", ZodFirstPartyTypeKind2.ZodAny = \"ZodAny\", ZodFirstPartyTypeKind2.ZodUnknown = \"ZodUnknown\", ZodFirstPartyTypeKind2.ZodNever = \"ZodNever\", ZodFirstPartyTypeKind2.ZodVoid = \"ZodVoid\", ZodFirstPartyTypeKind2.ZodArray = \"ZodArray\", ZodFirstPartyTypeKind2.ZodObject = \"ZodObject\", ZodFirstPartyTypeKind2.ZodUnion = \"ZodUnion\", ZodFirstPartyTypeKind2.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", ZodFirstPartyTypeKind2.ZodIntersection = \"ZodIntersection\", ZodFirstPartyTypeKind2.ZodTuple = \"ZodTuple\", ZodFirstPartyTypeKind2.ZodRecord = \"ZodRecord\", ZodFirstPartyTypeKind2.ZodMap = \"ZodMap\", ZodFirstPartyTypeKind2.ZodSet = \"ZodSet\", ZodFirstPartyTypeKind2.ZodFunction = \"ZodFunction\", ZodFirstPartyTypeKind2.ZodLazy = \"ZodLazy\", ZodFirstPartyTypeKind2.ZodLiteral = \"ZodLiteral\", ZodFirstPartyTypeKind2.ZodEnum = \"ZodEnum\", ZodFirstPartyTypeKind2.ZodEffects = \"ZodEffects\", ZodFirstPartyTypeKind2.ZodNativeEnum = \"ZodNativeEnum\", ZodFirstPartyTypeKind2.ZodOptional = \"ZodOptional\", ZodFirstPartyTypeKind2.ZodNullable = \"ZodNullable\", ZodFirstPartyTypeKind2.ZodDefault = \"ZodDefault\", ZodFirstPartyTypeKind2.ZodCatch = \"ZodCatch\", ZodFirstPartyTypeKind2.ZodPromise = \"ZodPromise\", ZodFirstPartyTypeKind2.ZodBranded = \"ZodBranded\", ZodFirstPartyTypeKind2.ZodPipeline = \"ZodPipeline\", ZodFirstPartyTypeKind2.ZodReadonly = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: \\`Input not instance of \\${cls.name}\\`\n}) => custom((data) => data instanceof cls, params), stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create, ostring = () => stringType().optional(), onumber = () => numberType().optional(), oboolean = () => booleanType().optional(), coerce = {\n  string: (arg) => ZodString.create({ ...arg, coerce: !0 }),\n  number: (arg) => ZodNumber.create({ ...arg, coerce: !0 }),\n  boolean: (arg) => ZodBoolean.create({\n    ...arg,\n    coerce: !0\n  }),\n  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: !0 }),\n  date: (arg) => ZodDate.create({ ...arg, coerce: !0 })\n}, NEVER = INVALID, AgentAvailabilityError = /* @__PURE__ */ ((AgentAvailabilityError2) => (AgentAvailabilityError2.NO_CONNECTION = \"no_connection\", AgentAvailabilityError2.NO_AUTHENTICATION = \"no_authentication\", AgentAvailabilityError2.INCOMPATIBLE_VERSION = \"incompatible_version\", AgentAvailabilityError2.OTHER = \"other\", AgentAvailabilityError2))(AgentAvailabilityError || {});\nexternal_exports.discriminatedUnion(\"isAvailable\", [\n  external_exports.object({\n    isAvailable: external_exports.literal(!0)\n  }),\n  external_exports.object({\n    isAvailable: external_exports.literal(!1),\n    error: external_exports.nativeEnum(AgentAvailabilityError),\n    errorMessage: external_exports.string().optional()\n  })\n]);\nvar AgentStateType = /* @__PURE__ */ ((AgentStateType2) => (AgentStateType2.IDLE = \"idle\", AgentStateType2.THINKING = \"thinking\", AgentStateType2.WORKING = \"working\", AgentStateType2.CALLING_TOOL = \"calling_tool\", AgentStateType2.WAITING_FOR_USER_RESPONSE = \"waiting_for_user_response\", AgentStateType2.FAILED = \"failed\", AgentStateType2.COMPLETED = \"completed\", AgentStateType2))(AgentStateType || {});\nexternal_exports.object({\n  state: external_exports.nativeEnum(AgentStateType),\n  description: external_exports.string().min(3).max(128).optional()\n});\nvar baseSelectedElementSchema = external_exports.object({\n  nodeType: external_exports.string().min(1).max(96).describe(\"The node type of the element.\"),\n  xpath: external_exports.string().min(1).max(1024).describe(\"The XPath of the element.\"),\n  attributes: external_exports.record(external_exports.union([external_exports.string(), external_exports.boolean(), external_exports.number()])).transform((obj) => {\n    const importantAttributes = /* @__PURE__ */ new Set([\n      \"class\",\n      \"id\",\n      \"style\",\n      \"name\",\n      \"role\",\n      \"href\",\n      \"for\",\n      \"placeholder\",\n      \"alt\",\n      \"title\",\n      \"ariaLabel\",\n      \"ariaRole\",\n      \"ariaDescription\",\n      \"ariaHidden\",\n      \"ariaDisabled\",\n      \"ariaExpanded\",\n      \"ariaSelected\"\n    ]), entries = Object.entries(obj), importantEntries = [], otherEntries = [];\n    for (const [key, value] of entries) {\n      const stringValue = typeof value == \"string\" ? value : String(value), truncatedValue = stringValue.length > 4096 ? \\`\\${stringValue.slice(0, 4096)}...[truncated]\\` : stringValue;\n      if (importantAttributes.has(key))\n        importantEntries.push([key, truncatedValue]);\n      else {\n        const processedValue = stringValue.length > 256 ? \\`\\${stringValue.slice(0, 256)}...[truncated]\\` : stringValue;\n        otherEntries.push([key, processedValue]);\n      }\n    }\n    const maxOtherAttributes = 100 - importantEntries.length, truncatedOtherEntries = otherEntries.slice(\n      0,\n      Math.max(0, maxOtherAttributes)\n    ), result = Object.fromEntries([\n      ...importantEntries,\n      ...truncatedOtherEntries\n    ]);\n    return otherEntries.length > maxOtherAttributes && maxOtherAttributes > 0 && (result.__truncated__ = \\`...[\\${otherEntries.length - maxOtherAttributes} more entries truncated]\\`), result;\n  }).describe(\n    \"A record of attributes of the element. Important attributes (class, id, style, etc.) are never truncated away. Other attributes may be truncated if there are too many total attributes.\"\n  ),\n  textContent: external_exports.string().transform((val) => val.length > 2048 ? \\`\\${val.slice(0, 2048)}...[truncated]\\` : val).describe(\n    \"Text content of the element. Will be truncated after 2048 characters.\"\n  ),\n  ownProperties: external_exports.record(external_exports.any()).transform((obj) => {\n    const entries = Object.entries(obj), truncatedEntries = entries.slice(0, 500), result = Object.fromEntries(truncatedEntries);\n    return entries.length > 500 && (result.__truncated__ = \\`...[\\${entries.length - 500} more entries truncated]\\`), result;\n  }).describe(\n    \"Custom properties that the underlying object may have. Will be truncated after 500 entries. Object are only copied up to 3 levels deep, all children and levels will be truncated equally. Only elements that are serializable will be sent over\"\n  ),\n  boundingClientRect: external_exports.object({\n    top: external_exports.number(),\n    left: external_exports.number(),\n    height: external_exports.number(),\n    width: external_exports.number()\n  }).strict(),\n  pluginInfo: external_exports.array(\n    external_exports.object({\n      pluginName: external_exports.string().max(128),\n      content: external_exports.string().max(4096)\n    })\n  )\n}), selectedElementSchema = baseSelectedElementSchema.extend({\n  parent: baseSelectedElementSchema.optional()\n}), userMessageMetadataSchema = external_exports.object({\n  currentUrl: external_exports.string().max(1024).url().nullable(),\n  currentTitle: external_exports.string().max(256).nullable(),\n  currentZoomLevel: external_exports.number(),\n  viewportMinScale: external_exports.number().optional(),\n  viewportMaxScale: external_exports.number().optional(),\n  viewportResolution: external_exports.object({\n    width: external_exports.number().min(0),\n    height: external_exports.number().min(0)\n  }),\n  devicePixelRatio: external_exports.number(),\n  userAgent: external_exports.string().max(1024),\n  locale: external_exports.string().max(64),\n  selectedElements: external_exports.array(selectedElementSchema)\n}), userMessageContentItemSchema = external_exports.discriminatedUnion(\"type\", [\n  external_exports.object({\n    type: external_exports.literal(\"text\"),\n    text: external_exports.string()\n  }),\n  external_exports.object({\n    type: external_exports.literal(\"image\"),\n    mimeType: external_exports.string().max(32),\n    data: external_exports.string().base64()\n  })\n]);\nexternal_exports.object({\n  id: external_exports.string(),\n  contentItems: external_exports.array(userMessageContentItemSchema),\n  createdAt: external_exports.date(),\n  metadata: userMessageMetadataSchema,\n  pluginContent: external_exports.record(external_exports.record(userMessageContentItemSchema)),\n  sentByPlugin: external_exports.boolean()\n});\nvar agentMessageContentItemPartSchema = external_exports.discriminatedUnion(\"type\", [\n  external_exports.object({\n    type: external_exports.literal(\"text\"),\n    text: external_exports.string()\n  }),\n  external_exports.object({\n    type: external_exports.literal(\"image\"),\n    mimeType: external_exports.string().max(32),\n    data: external_exports.string().base64(),\n    replacing: external_exports.boolean()\n  })\n]);\nexternal_exports.object({\n  messageId: external_exports.string().describe(\n    \"Make sure this stays consistent across all message parts for this message in order to properly concatenate the message parts\"\n  ),\n  updateParts: external_exports.array(\n    external_exports.object({\n      contentIndex: external_exports.number().min(0).describe(\n        \"The index of the content item in the message. This is used to concatenate the message parts properly. Make sure that the part type is consistent across all parts.\"\n      ),\n      part: agentMessageContentItemPartSchema.describe(\n        \"Part that will be concatenated to the previously existing content.\"\n      )\n    })\n  ),\n  createdAt: external_exports.date(),\n  resync: external_exports.boolean().describe(\n    \"If true, the update will be handled like a full resync of the complete message. It will thus replace the complete previous message.\"\n  )\n}).strict().describe(\n  \"Update for the existing message with the user. To clear a message, just send a empty message with a new ID.\"\n);\nvar DEFAULT_STARTING_PORT = 5746, DoubleIndexedKV = class {\n  constructor() {\n    this.keyToValue = /* @__PURE__ */ new Map(), this.valueToKey = /* @__PURE__ */ new Map();\n  }\n  set(key, value) {\n    this.keyToValue.set(key, value), this.valueToKey.set(value, key);\n  }\n  getByKey(key) {\n    return this.keyToValue.get(key);\n  }\n  getByValue(value) {\n    return this.valueToKey.get(value);\n  }\n  clear() {\n    this.keyToValue.clear(), this.valueToKey.clear();\n  }\n}, Registry = class {\n  constructor(generateIdentifier) {\n    this.generateIdentifier = generateIdentifier, this.kv = new DoubleIndexedKV();\n  }\n  register(value, identifier) {\n    this.kv.getByValue(value) || (identifier || (identifier = this.generateIdentifier(value)), this.kv.set(identifier, value));\n  }\n  clear() {\n    this.kv.clear();\n  }\n  getIdentifier(value) {\n    return this.kv.getByValue(value);\n  }\n  getValue(identifier) {\n    return this.kv.getByKey(identifier);\n  }\n}, ClassRegistry = class extends Registry {\n  constructor() {\n    super((c) => c.name), this.classToAllowedProps = /* @__PURE__ */ new Map();\n  }\n  register(value, options) {\n    typeof options == \"object\" ? (options.allowProps && this.classToAllowedProps.set(value, options.allowProps), super.register(value, options.identifier)) : super.register(value, options);\n  }\n  getAllowedProps(value) {\n    return this.classToAllowedProps.get(value);\n  }\n};\nfunction valuesOfObj(record) {\n  if (\"values\" in Object)\n    return Object.values(record);\n  const values = [];\n  for (const key in record)\n    record.hasOwnProperty(key) && values.push(record[key]);\n  return values;\n}\nfunction find(record, predicate) {\n  const values = valuesOfObj(record);\n  if (\"find\" in values)\n    return values.find(predicate);\n  const valuesNotNever = values;\n  for (let i = 0; i < valuesNotNever.length; i++) {\n    const value = valuesNotNever[i];\n    if (predicate(value))\n      return value;\n  }\n}\nfunction forEach(record, run2) {\n  Object.entries(record).forEach(([key, value]) => run2(value, key));\n}\nfunction includes(arr, value) {\n  return arr.indexOf(value) !== -1;\n}\nfunction findArr(record, predicate) {\n  for (let i = 0; i < record.length; i++) {\n    const value = record[i];\n    if (predicate(value))\n      return value;\n  }\n}\nvar CustomTransformerRegistry = class {\n  constructor() {\n    this.transfomers = {};\n  }\n  register(transformer2) {\n    this.transfomers[transformer2.name] = transformer2;\n  }\n  findApplicable(v) {\n    return find(this.transfomers, (transformer2) => transformer2.isApplicable(v));\n  }\n  findByName(name) {\n    return this.transfomers[name];\n  }\n}, getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1), isUndefined = (payload) => typeof payload > \"u\", isNull = (payload) => payload === null, isPlainObject = (payload) => typeof payload != \"object\" || payload === null || payload === Object.prototype ? !1 : Object.getPrototypeOf(payload) === null ? !0 : Object.getPrototypeOf(payload) === Object.prototype, isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0, isArray = (payload) => Array.isArray(payload), isString = (payload) => typeof payload == \"string\", isNumber$1 = (payload) => typeof payload == \"number\" && !isNaN(payload), isBoolean = (payload) => typeof payload == \"boolean\", isRegExp = (payload) => payload instanceof RegExp, isMap = (payload) => payload instanceof Map, isSet = (payload) => payload instanceof Set, isSymbol = (payload) => getType(payload) === \"Symbol\", isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf()), isError = (payload) => payload instanceof Error, isNaNValue = (payload) => typeof payload == \"number\" && isNaN(payload), isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber$1(payload) || isString(payload) || isSymbol(payload), isBigint = (payload) => typeof payload == \"bigint\", isInfinite = (payload) => payload === 1 / 0 || payload === -1 / 0, isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView), isURL = (payload) => payload instanceof URL, escapeKey = (key) => key.replace(/\\\\./g, \"\\\\\\\\.\"), stringifyPath = (path) => path.map(String).map(escapeKey).join(\".\"), parsePath = (string) => {\n  const result = [];\n  let segment = \"\";\n  for (let i = 0; i < string.length; i++) {\n    let char = string.charAt(i);\n    if (char === \"\\\\\\\\\" && string.charAt(i + 1) === \".\") {\n      segment += \".\", i++;\n      continue;\n    }\n    if (char === \".\") {\n      result.push(segment), segment = \"\";\n      continue;\n    }\n    segment += char;\n  }\n  const lastSegment = segment;\n  return result.push(lastSegment), result;\n};\nfunction simpleTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform\n  };\n}\nvar simpleRules = [\n  simpleTransformation(isUndefined, \"undefined\", () => null, () => {\n  }),\n  simpleTransformation(isBigint, \"bigint\", (v) => v.toString(), (v) => typeof BigInt < \"u\" ? BigInt(v) : (console.error(\"Please add a BigInt polyfill.\"), v)),\n  simpleTransformation(isDate, \"Date\", (v) => v.toISOString(), (v) => new Date(v)),\n  simpleTransformation(isError, \"Error\", (v, superJson) => {\n    const baseError = {\n      name: v.name,\n      message: v.message\n    };\n    return superJson.allowedErrorProps.forEach((prop) => {\n      baseError[prop] = v[prop];\n    }), baseError;\n  }, (v, superJson) => {\n    const e = new Error(v.message);\n    return e.name = v.name, e.stack = v.stack, superJson.allowedErrorProps.forEach((prop) => {\n      e[prop] = v[prop];\n    }), e;\n  }),\n  simpleTransformation(isRegExp, \"regexp\", (v) => \"\" + v, (regex) => {\n    const body = regex.slice(1, regex.lastIndexOf(\"/\")), flags = regex.slice(regex.lastIndexOf(\"/\") + 1);\n    return new RegExp(body, flags);\n  }),\n  simpleTransformation(\n    isSet,\n    \"set\",\n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    (v) => [...v.values()],\n    (v) => new Set(v)\n  ),\n  simpleTransformation(isMap, \"map\", (v) => [...v.entries()], (v) => new Map(v)),\n  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), \"number\", (v) => isNaNValue(v) ? \"NaN\" : v > 0 ? \"Infinity\" : \"-Infinity\", Number),\n  simpleTransformation((v) => v === 0 && 1 / v === -1 / 0, \"number\", () => \"-0\", Number),\n  simpleTransformation(isURL, \"URL\", (v) => v.toString(), (v) => new URL(v))\n];\nfunction compositeTransformation(isApplicable, annotation, transform, untransform) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform\n  };\n}\nvar symbolRule = compositeTransformation((s, superJson) => isSymbol(s) ? !!superJson.symbolRegistry.getIdentifier(s) : !1, (s, superJson) => [\"symbol\", superJson.symbolRegistry.getIdentifier(s)], (v) => v.description, (_, a, superJson) => {\n  const value = superJson.symbolRegistry.getValue(a[1]);\n  if (!value)\n    throw new Error(\"Trying to deserialize unknown symbol\");\n  return value;\n}), constructorToName = [\n  Int8Array,\n  Uint8Array,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  Uint8ClampedArray\n].reduce((obj, ctor) => (obj[ctor.name] = ctor, obj), {}), typedArrayRule = compositeTransformation(isTypedArray, (v) => [\"typed-array\", v.constructor.name], (v) => [...v], (v, a) => {\n  const ctor = constructorToName[a[1]];\n  if (!ctor)\n    throw new Error(\"Trying to deserialize unknown typed array\");\n  return new ctor(v);\n});\nfunction isInstanceOfRegisteredClass(potentialClass, superJson) {\n  return potentialClass != null && potentialClass.constructor ? !!superJson.classRegistry.getIdentifier(potentialClass.constructor) : !1;\n}\nvar classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => [\"class\", superJson.classRegistry.getIdentifier(clazz.constructor)], (clazz, superJson) => {\n  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);\n  if (!allowedProps)\n    return { ...clazz };\n  const result = {};\n  return allowedProps.forEach((prop) => {\n    result[prop] = clazz[prop];\n  }), result;\n}, (v, a, superJson) => {\n  const clazz = superJson.classRegistry.getValue(a[1]);\n  if (!clazz)\n    throw new Error(\\`Trying to deserialize unknown class '\\${a[1]}' - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564\\`);\n  return Object.assign(Object.create(clazz.prototype), v);\n}), customRule = compositeTransformation((value, superJson) => !!superJson.customTransformerRegistry.findApplicable(value), (value, superJson) => [\"custom\", superJson.customTransformerRegistry.findApplicable(value).name], (value, superJson) => superJson.customTransformerRegistry.findApplicable(value).serialize(value), (v, a, superJson) => {\n  const transformer2 = superJson.customTransformerRegistry.findByName(a[1]);\n  if (!transformer2)\n    throw new Error(\"Trying to deserialize unknown custom value\");\n  return transformer2.deserialize(v);\n}), compositeRules = [classRule, symbolRule, customRule, typedArrayRule], transformValue = (value, superJson) => {\n  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value, superJson));\n  if (applicableCompositeRule)\n    return {\n      value: applicableCompositeRule.transform(value, superJson),\n      type: applicableCompositeRule.annotation(value, superJson)\n    };\n  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value, superJson));\n  if (applicableSimpleRule)\n    return {\n      value: applicableSimpleRule.transform(value, superJson),\n      type: applicableSimpleRule.annotation\n    };\n}, simpleRulesByAnnotation = {};\nsimpleRules.forEach((rule) => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\nvar untransformValue = (json, type, superJson) => {\n  if (isArray(type))\n    switch (type[0]) {\n      case \"symbol\":\n        return symbolRule.untransform(json, type, superJson);\n      case \"class\":\n        return classRule.untransform(json, type, superJson);\n      case \"custom\":\n        return customRule.untransform(json, type, superJson);\n      case \"typed-array\":\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error(\"Unknown transformation: \" + type);\n    }\n  else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation)\n      throw new Error(\"Unknown transformation: \" + type);\n    return transformation.untransform(json, superJson);\n  }\n}, getNthKey = (value, n) => {\n  if (n > value.size)\n    throw new Error(\"index out of bounds\");\n  const keys = value.keys();\n  for (; n > 0; )\n    keys.next(), n--;\n  return keys.next().value;\n};\nfunction validatePath(path) {\n  if (includes(path, \"__proto__\"))\n    throw new Error(\"__proto__ is not allowed as a property\");\n  if (includes(path, \"prototype\"))\n    throw new Error(\"prototype is not allowed as a property\");\n  if (includes(path, \"constructor\"))\n    throw new Error(\"constructor is not allowed as a property\");\n}\nvar getDeep = (object, path) => {\n  validatePath(path);\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    if (isSet(object))\n      object = getNthKey(object, +key);\n    else if (isMap(object)) {\n      const row = +key, type = +path[++i] == 0 ? \"key\" : \"value\", keyOfRow = getNthKey(object, row);\n      switch (type) {\n        case \"key\":\n          object = keyOfRow;\n          break;\n        case \"value\":\n          object = object.get(keyOfRow);\n          break;\n      }\n    } else\n      object = object[key];\n  }\n  return object;\n}, setDeep = (object, path, mapper) => {\n  if (validatePath(path), path.length === 0)\n    return mapper(object);\n  let parent = object;\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (isArray(parent)) {\n      const index = +key;\n      parent = parent[index];\n    } else if (isPlainObject(parent))\n      parent = parent[key];\n    else if (isSet(parent)) {\n      const row = +key;\n      parent = getNthKey(parent, row);\n    } else if (isMap(parent)) {\n      if (i === path.length - 2)\n        break;\n      const row = +key, type = +path[++i] == 0 ? \"key\" : \"value\", keyOfRow = getNthKey(parent, row);\n      switch (type) {\n        case \"key\":\n          parent = keyOfRow;\n          break;\n        case \"value\":\n          parent = parent.get(keyOfRow);\n          break;\n      }\n    }\n  }\n  const lastKey = path[path.length - 1];\n  if (isArray(parent) ? parent[+lastKey] = mapper(parent[+lastKey]) : isPlainObject(parent) && (parent[lastKey] = mapper(parent[lastKey])), isSet(parent)) {\n    const oldValue = getNthKey(parent, +lastKey), newValue = mapper(oldValue);\n    oldValue !== newValue && (parent.delete(oldValue), parent.add(newValue));\n  }\n  if (isMap(parent)) {\n    const row = +path[path.length - 2], keyToRow = getNthKey(parent, row);\n    switch (+lastKey == 0 ? \"key\" : \"value\") {\n      case \"key\": {\n        const newKey = mapper(keyToRow);\n        parent.set(newKey, parent.get(keyToRow)), newKey !== keyToRow && parent.delete(keyToRow);\n        break;\n      }\n      case \"value\": {\n        parent.set(keyToRow, mapper(parent.get(keyToRow)));\n        break;\n      }\n    }\n  }\n  return object;\n};\nfunction traverse(tree, walker2, origin = []) {\n  if (!tree)\n    return;\n  if (!isArray(tree)) {\n    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));\n    return;\n  }\n  const [nodeValue, children] = tree;\n  children && forEach(children, (child, key) => {\n    traverse(child, walker2, [...origin, ...parsePath(key)]);\n  }), walker2(nodeValue, origin);\n}\nfunction applyValueAnnotations(plain, annotations, superJson) {\n  return traverse(annotations, (type, path) => {\n    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));\n  }), plain;\n}\nfunction applyReferentialEqualityAnnotations(plain, annotations) {\n  function apply(identicalPaths, path) {\n    const object = getDeep(plain, parsePath(path));\n    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {\n      plain = setDeep(plain, identicalObjectPath, () => object);\n    });\n  }\n  if (isArray(annotations)) {\n    const [root, other] = annotations;\n    root.forEach((identicalPath) => {\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\n    }), other && forEach(other, apply);\n  } else\n    forEach(annotations, apply);\n  return plain;\n}\nvar isDeep = (object, superJson) => isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);\nfunction addIdentity(object, path, identities) {\n  const existingSet = identities.get(object);\n  existingSet ? existingSet.push(path) : identities.set(object, [path]);\n}\nfunction generateReferentialEqualityAnnotations(identitites, dedupe) {\n  const result = {};\n  let rootEqualityPaths;\n  return identitites.forEach((paths) => {\n    if (paths.length <= 1)\n      return;\n    dedupe || (paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length));\n    const [representativePath, ...identicalPaths] = paths;\n    representativePath.length === 0 ? rootEqualityPaths = identicalPaths.map(stringifyPath) : result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);\n  }), rootEqualityPaths ? isEmptyObject(result) ? [rootEqualityPaths] : [rootEqualityPaths, result] : isEmptyObject(result) ? void 0 : result;\n}\nvar walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {\n  const primitive = isPrimitive(object);\n  if (!primitive) {\n    addIdentity(object, path, identities);\n    const seen = seenObjects.get(object);\n    if (seen)\n      return dedupe ? {\n        transformedValue: null\n      } : seen;\n  }\n  if (!isDeep(object, superJson)) {\n    const transformed2 = transformValue(object, superJson), result2 = transformed2 ? {\n      transformedValue: transformed2.value,\n      annotations: [transformed2.type]\n    } : {\n      transformedValue: object\n    };\n    return primitive || seenObjects.set(object, result2), result2;\n  }\n  if (includes(objectsInThisPath, object))\n    return {\n      transformedValue: null\n    };\n  const transformationResult = transformValue(object, superJson), transformed = (transformationResult == null ? void 0 : transformationResult.value) ?? object, transformedValue = isArray(transformed) ? [] : {}, innerAnnotations = {};\n  forEach(transformed, (value, index) => {\n    if (index === \"__proto__\" || index === \"constructor\" || index === \"prototype\")\n      throw new Error(\\`Detected property \\${index}. This is a prototype pollution risk, please remove it from your object.\\`);\n    const recursiveResult = walker(value, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);\n    transformedValue[index] = recursiveResult.transformedValue, isArray(recursiveResult.annotations) ? innerAnnotations[index] = recursiveResult.annotations : isPlainObject(recursiveResult.annotations) && forEach(recursiveResult.annotations, (tree, key) => {\n      innerAnnotations[escapeKey(index) + \".\" + key] = tree;\n    });\n  });\n  const result = isEmptyObject(innerAnnotations) ? {\n    transformedValue,\n    annotations: transformationResult ? [transformationResult.type] : void 0\n  } : {\n    transformedValue,\n    annotations: transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations\n  };\n  return primitive || seenObjects.set(object, result), result;\n};\nfunction getType2(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\nfunction isArray2(payload) {\n  return getType2(payload) === \"Array\";\n}\nfunction isPlainObject2(payload) {\n  if (getType2(payload) !== \"Object\")\n    return !1;\n  const prototype = Object.getPrototypeOf(payload);\n  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? \"enumerable\" : \"nonenumerable\";\n  propType === \"enumerable\" && (carry[key] = newVal), includeNonenumerable && propType === \"nonenumerable\" && Object.defineProperty(carry, key, {\n    value: newVal,\n    enumerable: !1,\n    writable: !0,\n    configurable: !0\n  });\n}\nfunction copy(target, options = {}) {\n  if (isArray2(target))\n    return target.map((item) => copy(item, options));\n  if (!isPlainObject2(target))\n    return target;\n  const props = Object.getOwnPropertyNames(target), symbols = Object.getOwnPropertySymbols(target);\n  return [...props, ...symbols].reduce((carry, key) => {\n    if (isArray2(options.props) && !options.props.includes(key))\n      return carry;\n    const val = target[key], newVal = copy(val, options);\n    return assignProp(carry, key, newVal, target, options.nonenumerable), carry;\n  }, {});\n}\nvar SuperJSON = class {\n  /**\n   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with \\`null\\`.\n   */\n  constructor({ dedupe = !1 } = {}) {\n    this.classRegistry = new ClassRegistry(), this.symbolRegistry = new Registry((s) => s.description ?? \"\"), this.customTransformerRegistry = new CustomTransformerRegistry(), this.allowedErrorProps = [], this.dedupe = dedupe;\n  }\n  serialize(object) {\n    const identities = /* @__PURE__ */ new Map(), output = walker(object, identities, this, this.dedupe), res = {\n      json: output.transformedValue\n    };\n    output.annotations && (res.meta = {\n      ...res.meta,\n      values: output.annotations\n    });\n    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);\n    return equalityAnnotations && (res.meta = {\n      ...res.meta,\n      referentialEqualities: equalityAnnotations\n    }), res;\n  }\n  deserialize(payload) {\n    const { json, meta } = payload;\n    let result = copy(json);\n    return meta != null && meta.values && (result = applyValueAnnotations(result, meta.values, this)), meta != null && meta.referentialEqualities && (result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities)), result;\n  }\n  stringify(object) {\n    return JSON.stringify(this.serialize(object));\n  }\n  parse(string) {\n    return this.deserialize(JSON.parse(string));\n  }\n  registerClass(v, options) {\n    this.classRegistry.register(v, options);\n  }\n  registerSymbol(v, identifier) {\n    this.symbolRegistry.register(v, identifier);\n  }\n  registerCustom(transformer2, name) {\n    this.customTransformerRegistry.register({\n      name,\n      ...transformer2\n    });\n  }\n  allowErrorProps(...props) {\n    this.allowedErrorProps.push(...props);\n  }\n};\nSuperJSON.defaultInstance = new SuperJSON();\nSuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);\nSuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);\nSuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);\nSuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);\nSuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);\nSuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);\nSuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);\nSuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);\nSuperJSON.serialize;\nSuperJSON.deserialize;\nSuperJSON.stringify;\nSuperJSON.parse;\nSuperJSON.registerClass;\nSuperJSON.registerCustom;\nSuperJSON.registerSymbol;\nSuperJSON.allowErrorProps;\nvar transformer = SuperJSON;\nconst agentContext = createContext({\n  availableAgents: [],\n  connected: null,\n  connectedUnavailable: !1,\n  requiresUserAttention: !1,\n  isInitialLoad: !0,\n  connectAgent: () => {\n  },\n  disconnectAgent: () => {\n  },\n  refreshAgentList: () => {\n  },\n  isRefreshing: !1\n});\nfunction getAgentUniqueKey(agent) {\n  return \\`\\${agent.name}|||\\${agent.description}|||\\${agent.port}\\`;\n}\nfunction persistSelectedAgent(agent) {\n  try {\n    const uniqueKey = getAgentUniqueKey(agent);\n    sessionStorage.setItem(\"stagewise_toolbar_selected_agent\", uniqueKey), console.debug(\\`[AgentProvider] Persisted selected agent: \\${uniqueKey}\\`);\n  } catch (error) {\n    console.warn(\"[AgentProvider] Failed to persist selected agent:\", error);\n  }\n}\nfunction getPersistedAgentKey() {\n  try {\n    return sessionStorage.getItem(\"stagewise_toolbar_selected_agent\");\n  } catch (error) {\n    return console.warn(\"[AgentProvider] Failed to retrieve persisted agent:\", error), null;\n  }\n}\nfunction findPersistedAgent(availableAgents) {\n  const persistedKey = getPersistedAgentKey();\n  if (!persistedKey)\n    return null;\n  const matchingAgent = availableAgents.find(\n    (agent) => getAgentUniqueKey(agent) === persistedKey\n  );\n  return matchingAgent && console.debug(\n    \\`[AgentProvider] Found persisted agent: \\${matchingAgent.name} (port \\${matchingAgent.port})\\`\n  ), matchingAgent || null;\n}\nasync function checkAgentOnPort(port) {\n  console.debug(\\`[AgentProvider] Checking for agent on port \\${port}...\\`);\n  try {\n    const hostname = window.parent.location.hostname, response = await fetch(\\`http://\\${hostname}:\\${port}/stagewise/info\\`, {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      signal: AbortSignal.timeout(2e3)\n      // 2 second timeout\n    });\n    if (response.ok) {\n      const info = await response.json();\n      if (info && typeof info.name == \"string\" && typeof info.description == \"string\" && info.capabilities)\n        return console.debug(\n          \\`[AgentProvider] Found agent \"\\${info.name}\" on port \\${port}: \\${info.description}\\`\n        ), {\n          port,\n          name: info.name,\n          description: info.description,\n          info\n        };\n      console.warn(\n        \\`[AgentProvider] Invalid agent info received on port \\${port}\\`\n      );\n    } else\n      console.debug(\n        \\`[AgentProvider] HTTP \\${response.status} response on port \\${port}\\`\n      );\n  } catch (error) {\n    error instanceof Error && !error.message.includes(\"timeout\") && console.debug(\n      \\`[AgentProvider] Error checking port \\${port}: \\${error.message}\\`\n    );\n  }\n  return null;\n}\nasync function scanForAgents(startPort = DEFAULT_STARTING_PORT) {\n  console.info(\n    \\`[stagewise] The following errors are expected \n\nThey happen because we're searching for available agents...\\`\n  ), console.debug(\n    \\`[AgentProvider] Starting agent scan from port \\${startPort}...\\`\n  );\n  const agents = [];\n  let currentPort = startPort, consecutiveFailures = 0;\n  const maxConsecutiveFailures = 2, initialScanCount = 2, expandedScanCount = 1;\n  for (let i = 0; i < initialScanCount; i++) {\n    const agent = await checkAgentOnPort(currentPort);\n    agent ? (agents.push(agent), consecutiveFailures = 0) : consecutiveFailures++, currentPort++;\n  }\n  for (; consecutiveFailures < maxConsecutiveFailures; ) {\n    let foundInThisChunk = !1;\n    for (let i = 0; i < expandedScanCount; i++) {\n      const agent = await checkAgentOnPort(currentPort);\n      agent && (agents.push(agent), foundInThisChunk = !0, consecutiveFailures = 0), currentPort++;\n    }\n    foundInThisChunk || consecutiveFailures++;\n  }\n  return console.debug(\n    \\`[AgentProvider] Scan complete! Found \\${agents.length} total agents:\\`,\n    agents.map((a) => \\`\\${a.name} (port \\${a.port})\\`)\n  ), agents;\n}\nfunction createWebSocketClient(port, onConnectionLost, onConnectionEstablished, onConnectionFailed, connectionStabilityTimeoutRef) {\n  console.debug(\n    \\`[AgentProvider] Creating WebSocket client for port \\${port}...\\`\n  );\n  let isConnectionStable = !1, connectionFailedCalled = !1;\n  const hostname = window.parent.location.hostname, wsClient = createWSClient({\n    url: \\`ws://\\${hostname}:\\${port}/stagewise/ws\\`,\n    onClose(cause) {\n      console.debug(\n        \\`[AgentProvider] WebSocket closed for port \\${port}: \\${cause}\\`\n      ), connectionStabilityTimeoutRef.current && !isConnectionStable && (console.debug(\n        \\`[AgentProvider] Connection closed before stability timeout - clearing timeout for port \\${port}\\`\n      ), clearTimeout(connectionStabilityTimeoutRef.current), connectionStabilityTimeoutRef.current = null, connectionFailedCalled || (console.debug(\n        \\`[AgentProvider] Unstable connection detected for port \\${port} - calling onConnectionFailed\\`\n      ), connectionFailedCalled = !0, onConnectionFailed())), isConnectionStable && (console.debug(\n        \\`[AgentProvider] Stable connection lost for port \\${port} - calling onConnectionLost\\`\n      ), onConnectionLost());\n    },\n    onOpen() {\n      console.debug(\n        \\`[AgentProvider] WebSocket opened for port \\${port} - starting stability check...\\`\n      ), connectionStabilityTimeoutRef.current && clearTimeout(connectionStabilityTimeoutRef.current), connectionStabilityTimeoutRef.current = setTimeout(() => {\n        console.debug(\n          \\`[AgentProvider] Connection stability confirmed for port \\${port}\\`\n        ), isConnectionStable = !0, connectionStabilityTimeoutRef.current = null, onConnectionEstablished();\n      }, 200);\n    }\n  }), client = createTRPCClient({\n    links: [\n      wsLink({\n        client: wsClient,\n        transformer\n      })\n    ]\n  });\n  return console.debug(\\`[AgentProvider] WebSocket client created for port \\${port}\\`), { client, wsClient };\n}\nfunction AgentProvider({ children }) {\n  console.debug(\"[AgentProvider] AgentProvider component initializing...\");\n  const [availableAgents, setAvailableAgents] = useState([]), connected = useRef(null), connectedWsClient = useRef(\n    null\n  ), [connectedPort, setConnectedPort] = useState(null), [isRefreshing, setIsRefreshing] = useState(!1), [finishedInitialScan, setFinishedInitialScan] = useState(!1), [connectedUnavailable, setConnectedUnavailable] = useState(!1), [requiresUserAttention, setRequiresUserAttention] = useState(!1), [isInitialLoad, setIsInitialLoad] = useState(!0), previouslySelectedPortRef = useRef(null), retryIntervalRef = useRef(null), retryCountRef = useRef(0), isManualSelectionRef = useRef(!1), delayTimeoutRef = useRef(null), connectionStabilityTimeoutRef = useRef(null), startRetryConnection = useCallback(\n    (port) => {\n      console.debug(\n        \\`[AgentProvider] Starting retry connection logic for port \\${port}...\\`\n      ), retryIntervalRef.current && (console.debug(\"[AgentProvider] Clearing existing retry interval...\"), clearInterval(retryIntervalRef.current)), retryCountRef.current = 0, isManualSelectionRef.current ? console.debug(\n        \"[AgentProvider] Skipping retry setup - this was a manual selection change\"\n      ) : (console.debug(\n        \\`[AgentProvider] Setting up retry interval (every 2s) for port \\${port} (max 5 retries)...\\`\n      ), retryIntervalRef.current = setInterval(() => {\n        if (retryCountRef.current >= 5) {\n          console.debug(\n            \\`[AgentProvider] Maximum retry attempts (5) reached for port \\${port}, stopping retries\\`\n          ), retryIntervalRef.current && (clearInterval(retryIntervalRef.current), retryIntervalRef.current = void 0);\n          return;\n        }\n        previouslySelectedPortRef.current === port && !connected.current && !isManualSelectionRef.current ? (retryCountRef.current++, console.debug(\n          \\`[AgentProvider] Retrying connection to agent on port \\${port} (attempt \\${retryCountRef.current}/5)...\\`\n        ), connectAgentInternal(port, !1)) : (console.debug(\n          \\`[AgentProvider] Stopping retry attempts for port \\${port} (conditions no longer met)\\`\n        ), retryIntervalRef.current && (clearInterval(retryIntervalRef.current), retryIntervalRef.current = void 0));\n      }, 2e3));\n    },\n    [connected]\n  ), stopRetryConnection = useCallback(() => {\n    retryIntervalRef.current && (console.debug(\"[AgentProvider] Stopping retry connection attempts...\"), clearInterval(retryIntervalRef.current), retryIntervalRef.current = void 0);\n  }, []), scanAgents = useCallback(async () => {\n    console.debug(\n      \\`[AgentProvider] Starting agent scan... (finishedInitialScan: \\${finishedInitialScan}, connected: \\${!!connected.current})\\`\n    ), setIsRefreshing(!0);\n    try {\n      const agents = await scanForAgents(), previousCount = availableAgents.length, newCount = agents.length;\n      if (previousCount !== newCount && console.debug(\n        \\`[AgentProvider] Available agents changed: \\${previousCount}  \\${newCount}\\`\n      ), setAvailableAgents(agents), console.debug(\n        \\`[AgentProvider] Scanned: \\${agents.length} agents found, connected: \\${!!connected.current}\\`\n      ), console.debug(\n        \\`[AgentProvider] finishedInitialScan: \\${finishedInitialScan}, connected: \\${!!connected.current}\\`\n      ), !finishedInitialScan && !connected.current && agents.length > 0) {\n        const persistedAgent = findPersistedAgent(agents);\n        persistedAgent ? (console.debug(\n          \\`[AgentProvider] Auto-connecting to persisted agent: \\${persistedAgent.name} (port \\${persistedAgent.port})\\`\n        ), connectAgentInternal(persistedAgent.port, !1)) : agents.length === 1 && (console.debug(\n          \\`[AgentProvider] Auto-connecting to single available agent: \\${agents[0].name} (port \\${agents[0].port})\\`\n        ), connectAgentInternal(agents[0].port, !1));\n      }\n      if (!connected && previouslySelectedPortRef.current && !isManualSelectionRef.current) {\n        const previousAgent = agents.find(\n          (agent) => agent.port === previouslySelectedPortRef.current\n        );\n        previousAgent ? (console.debug(\n          \\`[AgentProvider] Attempting to reconnect to previously selected agent: \\${previousAgent.name} (port \\${previousAgent.port})\\`\n        ), connectAgentInternal(previousAgent.port, !1)) : console.debug(\n          \\`[AgentProvider] Previously selected agent (port \\${previouslySelectedPortRef.current}) is no longer available\\`\n        );\n      }\n    } catch (error) {\n      console.error(\"[AgentProvider] Failed to scan for agents:\", error);\n    } finally {\n      setIsRefreshing(!1), setFinishedInitialScan(!0), console.debug(\"[AgentProvider] Agent scan complete. Refreshing: false\");\n    }\n  }, [connected, finishedInitialScan, availableAgents.length]), connectAgentInternal = useCallback(\n    async (port, isManual = !1) => {\n      console.debug(\n        \\`[AgentProvider] Attempting to connect to agent on port \\${port} (manual: \\${isManual})...\\`\n      ), previouslySelectedPortRef.current = port, isManualSelectionRef.current = isManual;\n      try {\n        if (stopRetryConnection(), connected.current) {\n          console.debug(\n            \\`[AgentProvider] Cleaning up existing connection (port \\${connectedPort})...\\`\n          ), connectionStabilityTimeoutRef.current && (clearTimeout(connectionStabilityTimeoutRef.current), connectionStabilityTimeoutRef.current = null);\n          const wsClient2 = connectedWsClient.current;\n          if (wsClient2)\n            try {\n              console.debug(\n                \"[AgentProvider] Explicitly closing existing WebSocket connection\"\n              ), wsClient2.close();\n            } catch (error) {\n              console.debug(\n                \"[AgentProvider] Error closing existing WebSocket:\",\n                error\n              );\n            }\n          connected.current = null, connectedWsClient.current = null, setConnectedPort(null), await new Promise((resolve) => setTimeout(resolve, 100)), console.debug(\"[AgentProvider] WebSocket cleanup delay complete\");\n        }\n        const { client, wsClient } = createWebSocketClient(\n          port,\n          () => {\n            console.debug(\n              \\`[AgentProvider] Connection lost to agent on port \\${port}\\`\n            ), setConnectedUnavailable(!0);\n            const wsClient2 = connectedWsClient.current;\n            if (wsClient2)\n              try {\n                console.debug(\n                  \"[AgentProvider] Explicitly closing WebSocket after connection loss\"\n                ), wsClient2.close();\n              } catch (error) {\n                console.debug(\n                  \"[AgentProvider] Error closing WebSocket after connection loss:\",\n                  error\n                );\n              }\n            connected.current = null, connectedWsClient.current = null, setConnectedPort(null), console.info(\n              \"[stagewise] Searching for available agents after connection loss...\"\n            ), scanAgents(), isManualSelectionRef.current ? console.debug(\n              \"[AgentProvider] Not starting retry attempts (manual disconnection)\"\n            ) : (console.debug(\n              \\`[AgentProvider] Starting retry attempts for port \\${port}...\\`\n            ), startRetryConnection(port));\n          },\n          () => {\n            if (console.debug(\n              \\`[AgentProvider] Connection established to agent on port \\${port}\\`\n            ), setConnectedPort(port), setConnectedUnavailable(!1), retryCountRef.current = 0, setIsInitialLoad(!1), !isManual) {\n              const agentToPersist = availableAgents.find(\n                (agent) => agent.port === port\n              );\n              agentToPersist && persistSelectedAgent(agentToPersist);\n            }\n            isManual ? console.debug(\n              \"[AgentProvider] Skipping agent list refresh for manual connection\"\n            ) : (console.debug(\n              \"[AgentProvider] Refreshing agent list after automatic reconnection...\"\n            ), scanAgents());\n          },\n          () => {\n            console.debug(\n              \\`[AgentProvider] Connection failed for agent on port \\${port} (unstable)\\`\n            ), connected.current = null, connectedWsClient.current = null, setConnectedPort(null), setConnectedUnavailable(!0), isManual || (console.debug(\n              \\`[AgentProvider] Starting retry attempts for unstable connection on port \\${port}...\\`\n            ), startRetryConnection(port));\n          },\n          connectionStabilityTimeoutRef\n        );\n        connected.current = client, connectedWsClient.current = wsClient, console.debug(\n          \\`[AgentProvider] WebSocket client created for port \\${port} - waiting for stability confirmation...\\`\n        );\n      } catch (error) {\n        console.error(\n          \\`[AgentProvider] Failed to connect to agent on port \\${port}:\\`,\n          error\n        ), connectionStabilityTimeoutRef.current && (clearTimeout(connectionStabilityTimeoutRef.current), connectionStabilityTimeoutRef.current = null);\n        const wsClient = connectedWsClient.current;\n        if (wsClient)\n          try {\n            console.debug(\n              \"[AgentProvider] Explicitly closing WebSocket after connection failure\"\n            ), wsClient.close();\n          } catch (closeError) {\n            console.debug(\n              \"[AgentProvider] Error closing WebSocket after connection failure:\",\n              closeError\n            );\n          }\n        connected.current = null, connectedWsClient.current = null, setConnectedPort(null), setConnectedUnavailable(!0), isManual || (console.debug(\n          \\`[AgentProvider] Failed to connect to agent on port \\${port}, starting retry attempts...\\`\n        ), startRetryConnection(port));\n      }\n    },\n    [\n      connectedPort,\n      startRetryConnection,\n      stopRetryConnection,\n      scanAgents,\n      availableAgents\n    ]\n  ), disconnectAgent = useCallback(() => {\n    console.debug(\n      \\`[AgentProvider] Manual disconnect requested (current port: \\${connectedPort})...\\`\n    ), stopRetryConnection(), connectionStabilityTimeoutRef.current && (clearTimeout(connectionStabilityTimeoutRef.current), connectionStabilityTimeoutRef.current = null);\n    const wsClient = connectedWsClient.current;\n    if (wsClient)\n      try {\n        console.debug(\n          \"[AgentProvider] Explicitly closing WebSocket for manual disconnect\"\n        ), wsClient.close();\n      } catch (error) {\n        console.debug(\n          \"[AgentProvider] Error closing WebSocket during manual disconnect:\",\n          error\n        );\n      }\n    connected.current = null, connectedWsClient.current = null, setConnectedPort(null), setConnectedUnavailable(!1), previouslySelectedPortRef.current = null, isManualSelectionRef.current = !0, console.debug(\"[AgentProvider] Successfully disconnected from agent\");\n  }, [connectedPort, stopRetryConnection]), connectAgent = useCallback(\n    (port) => {\n      console.debug(\n        \\`[AgentProvider] Manual connection requested to port \\${port}...\\`\n      );\n      const agentToPersist = availableAgents.find(\n        (agent) => agent.port === port\n      );\n      agentToPersist && persistSelectedAgent(agentToPersist), stopRetryConnection(), setTimeout(() => {\n        console.debug(\n          \"[AgentProvider] Resetting manual selection flag to allow future auto-reconnects...\"\n        ), isManualSelectionRef.current = !1;\n      }, 100), connectAgentInternal(port, !0);\n    },\n    [connectAgentInternal, stopRetryConnection, availableAgents]\n  ), refreshAgentList = useCallback(() => {\n    console.debug(\"[AgentProvider] Manual refresh of agent list requested...\"), scanAgents();\n  }, [scanAgents]);\n  useEffect(() => {\n    console.debug(\n      \\`[AgentProvider] State change - Available agents: \\${availableAgents.length}\\`,\n      availableAgents.map((a) => \\`\\${a.name} (\\${a.port})\\`)\n    );\n  }, [availableAgents]), useEffect(() => {\n    console.debug(\n      \\`[AgentProvider] Connection state changed: \\${connected ? \\`Connected to port \\${connectedPort}\\` : \"Not connected\"}\\`\n    );\n  }, [connected, connectedPort]), useEffect(() => {\n    console.debug(\\`[AgentProvider] Refreshing state changed: \\${isRefreshing}\\`);\n  }, [isRefreshing]), useEffect(() => {\n    console.debug(\n      \"[AgentProvider] Component mounted, starting initial agent scan...\"\n    ), scanAgents();\n  }, []), useEffect(() => {\n    const timeout = setTimeout(() => {\n      setIsInitialLoad(!1);\n    }, 1e3);\n    return () => clearTimeout(timeout);\n  }, []), useEffect(() => (connected.current && !connectedUnavailable ? (delayTimeoutRef.current && (clearTimeout(delayTimeoutRef.current), delayTimeoutRef.current = null), setRequiresUserAttention(!1)) : delayTimeoutRef.current || (delayTimeoutRef.current = setTimeout(() => {\n    setRequiresUserAttention(!0), delayTimeoutRef.current = null;\n  }, 500)), () => {\n    delayTimeoutRef.current && (clearTimeout(delayTimeoutRef.current), delayTimeoutRef.current = null);\n  }), [connectedPort, connectedUnavailable]), useEffect(() => () => {\n    console.debug(\"[AgentProvider] Component unmounting, cleaning up...\"), stopRetryConnection(), delayTimeoutRef.current && clearTimeout(delayTimeoutRef.current), connectionStabilityTimeoutRef.current && clearTimeout(connectionStabilityTimeoutRef.current);\n    const wsClient = connectedWsClient.current;\n    if (wsClient)\n      try {\n        console.debug(\n          \"[AgentProvider] Explicitly closing WebSocket connection on unmount\"\n        ), wsClient.close();\n      } catch (error) {\n        console.debug(\n          \"[AgentProvider] Error closing WebSocket on unmount:\",\n          error\n        );\n      }\n    console.debug(\"[AgentProvider] Cleanup complete\");\n  }, [stopRetryConnection]);\n  const agentGetter = useMemo(() => ({\n    agent: connected.current\n  }), [connectedPort]), providerInterface = useMemo(\n    () => ({\n      availableAgents,\n      connected: connected.current ? {\n        agent: connected.current,\n        ...availableAgents.find((a) => a.port === connectedPort)\n      } : null,\n      connectedUnavailable,\n      requiresUserAttention,\n      isInitialLoad,\n      connectAgent,\n      disconnectAgent,\n      refreshAgentList,\n      isRefreshing\n    }),\n    [\n      availableAgents,\n      agentGetter,\n      connectAgent,\n      disconnectAgent,\n      refreshAgentList,\n      isRefreshing,\n      connectedUnavailable,\n      requiresUserAttention,\n      isInitialLoad\n    ]\n  );\n  return /* @__PURE__ */ jsx(agentContext.Provider, { value: providerInterface, children });\n}\nconst useAgents = () => useContext(agentContext), agentMessagingContext = createContext({\n  sendMessage: () => {\n  },\n  agentMessage: null\n}), AgentMessagingProvider = ({\n  children\n}) => {\n  const providerId = useMemo(() => Math.random().toString(36).substr(2, 9), []), agent = useAgents().connected, [agentMessage, setAgentMessage] = useState(null), processedUpdatesRef = useRef(/* @__PURE__ */ new Set()), handleMessageUpdate = useCallback(\n    (update) => {\n      var _a;\n      const updateKey = \\`\\${update.messageId}-\\${(_a = update.createdAt) == null ? void 0 : _a.getTime()}-\\${update.resync}\\`;\n      if (!processedUpdatesRef.current.has(updateKey)) {\n        if (processedUpdatesRef.current.add(updateKey), processedUpdatesRef.current.size > 100) {\n          const entries = Array.from(processedUpdatesRef.current);\n          processedUpdatesRef.current = new Set(entries.slice(-50));\n        }\n        setAgentMessage((prev) => {\n          if (!prev || prev.id !== update.messageId || update.resync)\n            return {\n              id: update.messageId,\n              contentItems: update.updateParts.sort((a, b) => a.contentIndex - b.contentIndex).map((part) => part.part)\n            };\n          {\n            const newContentItems = [...prev.contentItems];\n            for (const part of update.updateParts) {\n              const existingItem = newContentItems[part.contentIndex];\n              if (existingItem && part.part.type !== existingItem.type)\n                throw new Error(\"Cannot update a part of a different type\");\n              if (existingItem && existingItem.type === \"text\" && part.part.type === \"text\") {\n                const updatedItem = {\n                  ...existingItem,\n                  text: existingItem.text + part.part.text\n                };\n                newContentItems[part.contentIndex] = updatedItem;\n              } else if (existingItem && existingItem.type === \"image\" && part.part.type === \"image\") {\n                let updatedItem;\n                existingItem.data && part.part.data ? updatedItem = {\n                  ...existingItem,\n                  data: existingItem.data + part.part.data\n                } : updatedItem = part.part, newContentItems[part.contentIndex] = updatedItem;\n              } else\n                newContentItems[part.contentIndex] = part.part;\n            }\n            return {\n              id: update.messageId,\n              contentItems: newContentItems\n            };\n          }\n        });\n      }\n    },\n    [providerId]\n  );\n  useEffect(() => {\n    if (agent !== null) {\n      const subscription = agent.agent.messaging.getMessage.subscribe(\n        void 0,\n        {\n          onData: (value) => {\n            handleMessageUpdate(value);\n          },\n          onError: () => {\n            setAgentMessage(null);\n          }\n        }\n      );\n      return () => {\n        try {\n          subscription.unsubscribe();\n        } catch (error) {\n          console.debug(\n            \"[AgentMessagingProvider] Error unsubscribing from messaging:\",\n            error\n          );\n        }\n      };\n    } else\n      setAgentMessage(null);\n  }, [agent, handleMessageUpdate]);\n  const handleUserMessage = (message) => {\n    agent == null || agent.agent.messaging.sendUserMessage.mutate(message);\n  };\n  return /* @__PURE__ */ jsx(\n    agentMessagingContext.Provider,\n    {\n      value: { agentMessage, sendMessage: handleUserMessage },\n      children\n    }\n  );\n}, useAgentMessaging = () => useContext(agentMessagingContext);\nfunction r(e) {\n  var t, f, n = \"\";\n  if (typeof e == \"string\" || typeof e == \"number\") n += e;\n  else if (typeof e == \"object\") if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n  } else for (f in e) e[f] && (n && (n += \" \"), n += f);\n  return n;\n}\nfunction clsx() {\n  for (var e, t, f = 0, n = \"\", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += \" \"), n += t);\n  return n;\n}\nconst CLASS_PART_SEPARATOR = \"-\", createClassGroupUtils = (config) => {\n  const classMap = createClassMap(config), {\n    conflictingClassGroups,\n    conflictingClassGroupModifiers\n  } = config;\n  return {\n    getClassGroupId: (className) => {\n      const classParts = className.split(CLASS_PART_SEPARATOR);\n      return classParts[0] === \"\" && classParts.length !== 1 && classParts.shift(), getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n    },\n    getConflictingClassGroupIds: (classGroupId, hasPostfixModifier) => {\n      const conflicts = conflictingClassGroups[classGroupId] || [];\n      return hasPostfixModifier && conflictingClassGroupModifiers[classGroupId] ? [...conflicts, ...conflictingClassGroupModifiers[classGroupId]] : conflicts;\n    }\n  };\n}, getGroupRecursive = (classParts, classPartObject) => {\n  var _a;\n  if (classParts.length === 0)\n    return classPartObject.classGroupId;\n  const currentClassPart = classParts[0], nextClassPartObject = classPartObject.nextPart.get(currentClassPart), classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;\n  if (classGroupFromNextClassPart)\n    return classGroupFromNextClassPart;\n  if (classPartObject.validators.length === 0)\n    return;\n  const classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return (_a = classPartObject.validators.find(({\n    validator\n  }) => validator(classRest))) == null ? void 0 : _a.classGroupId;\n}, arbitraryPropertyRegex = /^\\\\[(.+)\\\\]$/, getGroupIdForArbitraryProperty = (className) => {\n  if (arbitraryPropertyRegex.test(className)) {\n    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1], property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(\":\"));\n    if (property)\n      return \"arbitrary..\" + property;\n  }\n}, createClassMap = (config) => {\n  const {\n    theme,\n    classGroups\n  } = config, classMap = {\n    nextPart: /* @__PURE__ */ new Map(),\n    validators: []\n  };\n  for (const classGroupId in classGroups)\n    processClassesRecursively(classGroups[classGroupId], classMap, classGroupId, theme);\n  return classMap;\n}, processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {\n  classGroup.forEach((classDefinition) => {\n    if (typeof classDefinition == \"string\") {\n      const classPartObjectToEdit = classDefinition === \"\" ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n    if (typeof classDefinition == \"function\") {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId\n      });\n      return;\n    }\n    Object.entries(classDefinition).forEach(([key, classGroup2]) => {\n      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n}, getPart = (classPartObject, path) => {\n  let currentClassPartObject = classPartObject;\n  return path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {\n    currentClassPartObject.nextPart.has(pathPart) || currentClassPartObject.nextPart.set(pathPart, {\n      nextPart: /* @__PURE__ */ new Map(),\n      validators: []\n    }), currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  }), currentClassPartObject;\n}, isThemeGetter = (func) => func.isThemeGetter, createLruCache = (maxCacheSize) => {\n  if (maxCacheSize < 1)\n    return {\n      get: () => {\n      },\n      set: () => {\n      }\n    };\n  let cacheSize = 0, cache = /* @__PURE__ */ new Map(), previousCache = /* @__PURE__ */ new Map();\n  const update = (key, value) => {\n    cache.set(key, value), cacheSize++, cacheSize > maxCacheSize && (cacheSize = 0, previousCache = cache, cache = /* @__PURE__ */ new Map());\n  };\n  return {\n    get(key) {\n      let value = cache.get(key);\n      if (value !== void 0)\n        return value;\n      if ((value = previousCache.get(key)) !== void 0)\n        return update(key, value), value;\n    },\n    set(key, value) {\n      cache.has(key) ? cache.set(key, value) : update(key, value);\n    }\n  };\n}, IMPORTANT_MODIFIER = \"!\", MODIFIER_SEPARATOR = \":\", MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length, createParseClassName = (config) => {\n  const {\n    prefix,\n    experimentalParseClassName\n  } = config;\n  let parseClassName = (className) => {\n    const modifiers = [];\n    let bracketDepth = 0, parenDepth = 0, modifierStart = 0, postfixModifierPosition;\n    for (let index = 0; index < className.length; index++) {\n      let currentCharacter = className[index];\n      if (bracketDepth === 0 && parenDepth === 0) {\n        if (currentCharacter === MODIFIER_SEPARATOR) {\n          modifiers.push(className.slice(modifierStart, index)), modifierStart = index + MODIFIER_SEPARATOR_LENGTH;\n          continue;\n        }\n        if (currentCharacter === \"/\") {\n          postfixModifierPosition = index;\n          continue;\n        }\n      }\n      currentCharacter === \"[\" ? bracketDepth++ : currentCharacter === \"]\" ? bracketDepth-- : currentCharacter === \"(\" ? parenDepth++ : currentCharacter === \")\" && parenDepth--;\n    }\n    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart), baseClassName = stripImportantModifier(baseClassNameWithImportantModifier), hasImportantModifier = baseClassName !== baseClassNameWithImportantModifier, maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;\n    return {\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    };\n  };\n  if (prefix) {\n    const fullPrefix = prefix + MODIFIER_SEPARATOR, parseClassNameOriginal = parseClassName;\n    parseClassName = (className) => className.startsWith(fullPrefix) ? parseClassNameOriginal(className.substring(fullPrefix.length)) : {\n      isExternal: !0,\n      modifiers: [],\n      hasImportantModifier: !1,\n      baseClassName: className,\n      maybePostfixModifierPosition: void 0\n    };\n  }\n  if (experimentalParseClassName) {\n    const parseClassNameOriginal = parseClassName;\n    parseClassName = (className) => experimentalParseClassName({\n      className,\n      parseClassName: parseClassNameOriginal\n    });\n  }\n  return parseClassName;\n}, stripImportantModifier = (baseClassName) => baseClassName.endsWith(IMPORTANT_MODIFIER) ? baseClassName.substring(0, baseClassName.length - 1) : baseClassName.startsWith(IMPORTANT_MODIFIER) ? baseClassName.substring(1) : baseClassName, createSortModifiers = (config) => {\n  const orderSensitiveModifiers = Object.fromEntries(config.orderSensitiveModifiers.map((modifier) => [modifier, !0]));\n  return (modifiers) => {\n    if (modifiers.length <= 1)\n      return modifiers;\n    const sortedModifiers = [];\n    let unsortedModifiers = [];\n    return modifiers.forEach((modifier) => {\n      modifier[0] === \"[\" || orderSensitiveModifiers[modifier] ? (sortedModifiers.push(...unsortedModifiers.sort(), modifier), unsortedModifiers = []) : unsortedModifiers.push(modifier);\n    }), sortedModifiers.push(...unsortedModifiers.sort()), sortedModifiers;\n  };\n}, createConfigUtils = (config) => ({\n  cache: createLruCache(config.cacheSize),\n  parseClassName: createParseClassName(config),\n  sortModifiers: createSortModifiers(config),\n  ...createClassGroupUtils(config)\n}), SPLIT_CLASSES_REGEX = /\\\\s+/, mergeClassList = (classList, configUtils) => {\n  const {\n    parseClassName,\n    getClassGroupId,\n    getConflictingClassGroupIds,\n    sortModifiers\n  } = configUtils, classGroupsInConflict = [], classNames = classList.trim().split(SPLIT_CLASSES_REGEX);\n  let result = \"\";\n  for (let index = classNames.length - 1; index >= 0; index -= 1) {\n    const originalClassName = classNames[index], {\n      isExternal,\n      modifiers,\n      hasImportantModifier,\n      baseClassName,\n      maybePostfixModifierPosition\n    } = parseClassName(originalClassName);\n    if (isExternal) {\n      result = originalClassName + (result.length > 0 ? \" \" + result : result);\n      continue;\n    }\n    let hasPostfixModifier = !!maybePostfixModifierPosition, classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);\n    if (!classGroupId) {\n      if (!hasPostfixModifier) {\n        result = originalClassName + (result.length > 0 ? \" \" + result : result);\n        continue;\n      }\n      if (classGroupId = getClassGroupId(baseClassName), !classGroupId) {\n        result = originalClassName + (result.length > 0 ? \" \" + result : result);\n        continue;\n      }\n      hasPostfixModifier = !1;\n    }\n    const variantModifier = sortModifiers(modifiers).join(\":\"), modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier, classId = modifierId + classGroupId;\n    if (classGroupsInConflict.includes(classId))\n      continue;\n    classGroupsInConflict.push(classId);\n    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);\n    for (let i = 0; i < conflictGroups.length; ++i) {\n      const group = conflictGroups[i];\n      classGroupsInConflict.push(modifierId + group);\n    }\n    result = originalClassName + (result.length > 0 ? \" \" + result : result);\n  }\n  return result;\n};\nfunction twJoin() {\n  let index = 0, argument, resolvedValue, string = \"\";\n  for (; index < arguments.length; )\n    (argument = arguments[index++]) && (resolvedValue = toValue(argument)) && (string && (string += \" \"), string += resolvedValue);\n  return string;\n}\nconst toValue = (mix) => {\n  if (typeof mix == \"string\")\n    return mix;\n  let resolvedValue, string = \"\";\n  for (let k = 0; k < mix.length; k++)\n    mix[k] && (resolvedValue = toValue(mix[k])) && (string && (string += \" \"), string += resolvedValue);\n  return string;\n};\nfunction createTailwindMerge(createConfigFirst, ...createConfigRest) {\n  let configUtils, cacheGet, cacheSet, functionToCall = initTailwindMerge;\n  function initTailwindMerge(classList) {\n    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());\n    return configUtils = createConfigUtils(config), cacheGet = configUtils.cache.get, cacheSet = configUtils.cache.set, functionToCall = tailwindMerge, tailwindMerge(classList);\n  }\n  function tailwindMerge(classList) {\n    const cachedResult = cacheGet(classList);\n    if (cachedResult)\n      return cachedResult;\n    const result = mergeClassList(classList, configUtils);\n    return cacheSet(classList, result), result;\n  }\n  return function() {\n    return functionToCall(twJoin.apply(null, arguments));\n  };\n}\nconst fromTheme = (key) => {\n  const themeGetter = (theme) => theme[key] || [];\n  return themeGetter.isThemeGetter = !0, themeGetter;\n}, arbitraryValueRegex = /^\\\\[(?:(\\\\w[\\\\w-]*):)?(.+)\\\\]$/i, arbitraryVariableRegex = /^\\\\((?:(\\\\w[\\\\w-]*):)?(.+)\\\\)$/i, fractionRegex = /^\\\\d+\\\\/\\\\d+$/, tshirtUnitRegex = /^(\\\\d+(\\\\.\\\\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex = /\\\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\\\b(calc|min|max|clamp)\\\\(.+\\\\)|^0$/, colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\\\\(.+\\\\)$/, shadowRegex = /^(inset_)?-?((\\\\d+)?\\\\.?(\\\\d+)[a-z]+|0)_-?((\\\\d+)?\\\\.?(\\\\d+)[a-z]+|0)/, imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\\\(.+\\\\)$/, isFraction = (value) => fractionRegex.test(value), isNumber = (value) => !!value && !Number.isNaN(Number(value)), isInteger = (value) => !!value && Number.isInteger(Number(value)), isPercent = (value) => value.endsWith(\"%\") && isNumber(value.slice(0, -1)), isTshirtSize = (value) => tshirtUnitRegex.test(value), isAny = () => !0, isLengthOnly = (value) => (\n  // \\`colorFunctionRegex\\` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.\n  // For example, \\`hsl(0 0% 0%)\\` would be classified as a length without this check.\n  // I could also use lookbehind assertion in \\`lengthUnitRegex\\` but that isn't supported widely enough.\n  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)\n), isNever = () => !1, isShadow = (value) => shadowRegex.test(value), isImage = (value) => imageRegex.test(value), isAnyNonArbitrary = (value) => !isArbitraryValue(value) && !isArbitraryVariable(value), isArbitrarySize = (value) => getIsArbitraryValue(value, isLabelSize, isNever), isArbitraryValue = (value) => arbitraryValueRegex.test(value), isArbitraryLength = (value) => getIsArbitraryValue(value, isLabelLength, isLengthOnly), isArbitraryNumber = (value) => getIsArbitraryValue(value, isLabelNumber, isNumber), isArbitraryPosition = (value) => getIsArbitraryValue(value, isLabelPosition, isNever), isArbitraryImage = (value) => getIsArbitraryValue(value, isLabelImage, isImage), isArbitraryShadow = (value) => getIsArbitraryValue(value, isLabelShadow, isShadow), isArbitraryVariable = (value) => arbitraryVariableRegex.test(value), isArbitraryVariableLength = (value) => getIsArbitraryVariable(value, isLabelLength), isArbitraryVariableFamilyName = (value) => getIsArbitraryVariable(value, isLabelFamilyName), isArbitraryVariablePosition = (value) => getIsArbitraryVariable(value, isLabelPosition), isArbitraryVariableSize = (value) => getIsArbitraryVariable(value, isLabelSize), isArbitraryVariableImage = (value) => getIsArbitraryVariable(value, isLabelImage), isArbitraryVariableShadow = (value) => getIsArbitraryVariable(value, isLabelShadow, !0), getIsArbitraryValue = (value, testLabel, testValue) => {\n  const result = arbitraryValueRegex.exec(value);\n  return result ? result[1] ? testLabel(result[1]) : testValue(result[2]) : !1;\n}, getIsArbitraryVariable = (value, testLabel, shouldMatchNoLabel = !1) => {\n  const result = arbitraryVariableRegex.exec(value);\n  return result ? result[1] ? testLabel(result[1]) : shouldMatchNoLabel : !1;\n}, isLabelPosition = (label) => label === \"position\" || label === \"percentage\", isLabelImage = (label) => label === \"image\" || label === \"url\", isLabelSize = (label) => label === \"length\" || label === \"size\" || label === \"bg-size\", isLabelLength = (label) => label === \"length\", isLabelNumber = (label) => label === \"number\", isLabelFamilyName = (label) => label === \"family-name\", isLabelShadow = (label) => label === \"shadow\", getDefaultConfig = () => {\n  const themeColor = fromTheme(\"color\"), themeFont = fromTheme(\"font\"), themeText = fromTheme(\"text\"), themeFontWeight = fromTheme(\"font-weight\"), themeTracking = fromTheme(\"tracking\"), themeLeading = fromTheme(\"leading\"), themeBreakpoint = fromTheme(\"breakpoint\"), themeContainer = fromTheme(\"container\"), themeSpacing = fromTheme(\"spacing\"), themeRadius = fromTheme(\"radius\"), themeShadow = fromTheme(\"shadow\"), themeInsetShadow = fromTheme(\"inset-shadow\"), themeTextShadow = fromTheme(\"text-shadow\"), themeDropShadow = fromTheme(\"drop-shadow\"), themeBlur = fromTheme(\"blur\"), themePerspective = fromTheme(\"perspective\"), themeAspect = fromTheme(\"aspect\"), themeEase = fromTheme(\"ease\"), themeAnimate = fromTheme(\"animate\"), scaleBreak = () => [\"auto\", \"avoid\", \"all\", \"avoid-page\", \"page\", \"left\", \"right\", \"column\"], scalePosition = () => [\n    \"center\",\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"top-left\",\n    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n    \"left-top\",\n    \"top-right\",\n    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n    \"right-top\",\n    \"bottom-right\",\n    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n    \"right-bottom\",\n    \"bottom-left\",\n    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378\n    \"left-bottom\"\n  ], scalePositionWithArbitrary = () => [...scalePosition(), isArbitraryVariable, isArbitraryValue], scaleOverflow = () => [\"auto\", \"hidden\", \"clip\", \"visible\", \"scroll\"], scaleOverscroll = () => [\"auto\", \"contain\", \"none\"], scaleUnambiguousSpacing = () => [isArbitraryVariable, isArbitraryValue, themeSpacing], scaleInset = () => [isFraction, \"full\", \"auto\", ...scaleUnambiguousSpacing()], scaleGridTemplateColsRows = () => [isInteger, \"none\", \"subgrid\", isArbitraryVariable, isArbitraryValue], scaleGridColRowStartAndEnd = () => [\"auto\", {\n    span: [\"full\", isInteger, isArbitraryVariable, isArbitraryValue]\n  }, isInteger, isArbitraryVariable, isArbitraryValue], scaleGridColRowStartOrEnd = () => [isInteger, \"auto\", isArbitraryVariable, isArbitraryValue], scaleGridAutoColsRows = () => [\"auto\", \"min\", \"max\", \"fr\", isArbitraryVariable, isArbitraryValue], scaleAlignPrimaryAxis = () => [\"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\", \"stretch\", \"baseline\", \"center-safe\", \"end-safe\"], scaleAlignSecondaryAxis = () => [\"start\", \"end\", \"center\", \"stretch\", \"center-safe\", \"end-safe\"], scaleMargin = () => [\"auto\", ...scaleUnambiguousSpacing()], scaleSizing = () => [isFraction, \"auto\", \"full\", \"dvw\", \"dvh\", \"lvw\", \"lvh\", \"svw\", \"svh\", \"min\", \"max\", \"fit\", ...scaleUnambiguousSpacing()], scaleColor = () => [themeColor, isArbitraryVariable, isArbitraryValue], scaleBgPosition = () => [...scalePosition(), isArbitraryVariablePosition, isArbitraryPosition, {\n    position: [isArbitraryVariable, isArbitraryValue]\n  }], scaleBgRepeat = () => [\"no-repeat\", {\n    repeat: [\"\", \"x\", \"y\", \"space\", \"round\"]\n  }], scaleBgSize = () => [\"auto\", \"cover\", \"contain\", isArbitraryVariableSize, isArbitrarySize, {\n    size: [isArbitraryVariable, isArbitraryValue]\n  }], scaleGradientStopPosition = () => [isPercent, isArbitraryVariableLength, isArbitraryLength], scaleRadius = () => [\n    // Deprecated since Tailwind CSS v4.0.0\n    \"\",\n    \"none\",\n    \"full\",\n    themeRadius,\n    isArbitraryVariable,\n    isArbitraryValue\n  ], scaleBorderWidth = () => [\"\", isNumber, isArbitraryVariableLength, isArbitraryLength], scaleLineStyle = () => [\"solid\", \"dashed\", \"dotted\", \"double\"], scaleBlendMode = () => [\"normal\", \"multiply\", \"screen\", \"overlay\", \"darken\", \"lighten\", \"color-dodge\", \"color-burn\", \"hard-light\", \"soft-light\", \"difference\", \"exclusion\", \"hue\", \"saturation\", \"color\", \"luminosity\"], scaleMaskImagePosition = () => [isNumber, isPercent, isArbitraryVariablePosition, isArbitraryPosition], scaleBlur = () => [\n    // Deprecated since Tailwind CSS v4.0.0\n    \"\",\n    \"none\",\n    themeBlur,\n    isArbitraryVariable,\n    isArbitraryValue\n  ], scaleRotate = () => [\"none\", isNumber, isArbitraryVariable, isArbitraryValue], scaleScale = () => [\"none\", isNumber, isArbitraryVariable, isArbitraryValue], scaleSkew = () => [isNumber, isArbitraryVariable, isArbitraryValue], scaleTranslate = () => [isFraction, \"full\", ...scaleUnambiguousSpacing()];\n  return {\n    cacheSize: 500,\n    theme: {\n      animate: [\"spin\", \"ping\", \"pulse\", \"bounce\"],\n      aspect: [\"video\"],\n      blur: [isTshirtSize],\n      breakpoint: [isTshirtSize],\n      color: [isAny],\n      container: [isTshirtSize],\n      \"drop-shadow\": [isTshirtSize],\n      ease: [\"in\", \"out\", \"in-out\"],\n      font: [isAnyNonArbitrary],\n      \"font-weight\": [\"thin\", \"extralight\", \"light\", \"normal\", \"medium\", \"semibold\", \"bold\", \"extrabold\", \"black\"],\n      \"inset-shadow\": [isTshirtSize],\n      leading: [\"none\", \"tight\", \"snug\", \"normal\", \"relaxed\", \"loose\"],\n      perspective: [\"dramatic\", \"near\", \"normal\", \"midrange\", \"distant\", \"none\"],\n      radius: [isTshirtSize],\n      shadow: [isTshirtSize],\n      spacing: [\"px\", isNumber],\n      text: [isTshirtSize],\n      \"text-shadow\": [isTshirtSize],\n      tracking: [\"tighter\", \"tight\", \"normal\", \"wide\", \"wider\", \"widest\"]\n    },\n    classGroups: {\n      // --------------\n      // --- Layout ---\n      // --------------\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: [\"auto\", \"square\", isFraction, isArbitraryValue, isArbitraryVariable, themeAspect]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       * @deprecated since Tailwind CSS v4.0.0\n       */\n      container: [\"container\"],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [isNumber, isArbitraryValue, isArbitraryVariable, themeContainer]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      \"break-after\": [{\n        \"break-after\": scaleBreak()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      \"break-before\": [{\n        \"break-before\": scaleBreak()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      \"break-inside\": [{\n        \"break-inside\": [\"auto\", \"avoid\", \"avoid-page\", \"avoid-column\"]\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      \"box-decoration\": [{\n        \"box-decoration\": [\"slice\", \"clone\"]\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: [\"border\", \"content\"]\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: [\"block\", \"inline-block\", \"inline\", \"flex\", \"inline-flex\", \"table\", \"inline-table\", \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\", \"table-footer-group\", \"table-header-group\", \"table-row-group\", \"table-row\", \"flow-root\", \"grid\", \"inline-grid\", \"contents\", \"list-item\", \"hidden\"],\n      /**\n       * Screen Reader Only\n       * @see https://tailwindcss.com/docs/display#screen-reader-only\n       */\n      sr: [\"sr-only\", \"not-sr-only\"],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: [\"right\", \"left\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: [\"left\", \"right\", \"both\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: [\"isolate\", \"isolation-auto\"],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      \"object-fit\": [{\n        object: [\"contain\", \"cover\", \"fill\", \"none\", \"scale-down\"]\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      \"object-position\": [{\n        object: scalePositionWithArbitrary()\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: scaleOverflow()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-x\": [{\n        \"overflow-x\": scaleOverflow()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-y\": [{\n        \"overflow-y\": scaleOverflow()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: scaleOverscroll()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-x\": [{\n        \"overscroll-x\": scaleOverscroll()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-y\": [{\n        \"overscroll-y\": scaleOverscroll()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: [\"static\", \"fixed\", \"absolute\", \"relative\", \"sticky\"],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: scaleInset()\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-x\": [{\n        \"inset-x\": scaleInset()\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-y\": [{\n        \"inset-y\": scaleInset()\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: scaleInset()\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: scaleInset()\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: scaleInset()\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: scaleInset()\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: scaleInset()\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: scaleInset()\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: [\"visible\", \"invisible\", \"collapse\"],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: [isInteger, \"auto\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // ------------------------\n      // --- Flexbox and Grid ---\n      // ------------------------\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: [isFraction, \"full\", \"auto\", themeContainer, ...scaleUnambiguousSpacing()]\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      \"flex-direction\": [{\n        flex: [\"row\", \"row-reverse\", \"col\", \"col-reverse\"]\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      \"flex-wrap\": [{\n        flex: [\"nowrap\", \"wrap\", \"wrap-reverse\"]\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: [isNumber, isFraction, \"auto\", \"initial\", \"none\", isArbitraryValue]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: [isInteger, \"first\", \"last\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      \"grid-cols\": [{\n        \"grid-cols\": scaleGridTemplateColsRows()\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start-end\": [{\n        col: scaleGridColRowStartAndEnd()\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start\": [{\n        \"col-start\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-end\": [{\n        \"col-end\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      \"grid-rows\": [{\n        \"grid-rows\": scaleGridTemplateColsRows()\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start-end\": [{\n        row: scaleGridColRowStartAndEnd()\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start\": [{\n        \"row-start\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-end\": [{\n        \"row-end\": scaleGridColRowStartOrEnd()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      \"grid-flow\": [{\n        \"grid-flow\": [\"row\", \"col\", \"dense\", \"row-dense\", \"col-dense\"]\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      \"auto-cols\": [{\n        \"auto-cols\": scaleGridAutoColsRows()\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      \"auto-rows\": [{\n        \"auto-rows\": scaleGridAutoColsRows()\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-x\": [{\n        \"gap-x\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-y\": [{\n        \"gap-y\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      \"justify-content\": [{\n        justify: [...scaleAlignPrimaryAxis(), \"normal\"]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      \"justify-items\": [{\n        \"justify-items\": [...scaleAlignSecondaryAxis(), \"normal\"]\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      \"justify-self\": [{\n        \"justify-self\": [\"auto\", ...scaleAlignSecondaryAxis()]\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      \"align-content\": [{\n        content: [\"normal\", ...scaleAlignPrimaryAxis()]\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      \"align-items\": [{\n        items: [...scaleAlignSecondaryAxis(), {\n          baseline: [\"\", \"last\"]\n        }]\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      \"align-self\": [{\n        self: [\"auto\", ...scaleAlignSecondaryAxis(), {\n          baseline: [\"\", \"last\"]\n        }]\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      \"place-content\": [{\n        \"place-content\": scaleAlignPrimaryAxis()\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      \"place-items\": [{\n        \"place-items\": [...scaleAlignSecondaryAxis(), \"baseline\"]\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      \"place-self\": [{\n        \"place-self\": [\"auto\", ...scaleAlignSecondaryAxis()]\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: scaleMargin()\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: scaleMargin()\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: scaleMargin()\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: scaleMargin()\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: scaleMargin()\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: scaleMargin()\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: scaleMargin()\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: scaleMargin()\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: scaleMargin()\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-x\": [{\n        \"space-x\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-x-reverse\": [\"space-x-reverse\"],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-y\": [{\n        \"space-y\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/margin#adding-space-between-children\n       */\n      \"space-y-reverse\": [\"space-y-reverse\"],\n      // --------------\n      // --- Sizing ---\n      // --------------\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height\n       */\n      size: [{\n        size: scaleSizing()\n      }],\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: [themeContainer, \"screen\", ...scaleSizing()]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      \"min-w\": [{\n        \"min-w\": [\n          themeContainer,\n          \"screen\",\n          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n          \"none\",\n          ...scaleSizing()\n        ]\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      \"max-w\": [{\n        \"max-w\": [\n          themeContainer,\n          \"screen\",\n          \"none\",\n          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n          \"prose\",\n          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n          {\n            screen: [themeBreakpoint]\n          },\n          ...scaleSizing()\n        ]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [\"screen\", \"lh\", ...scaleSizing()]\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      \"min-h\": [{\n        \"min-h\": [\"screen\", \"lh\", \"none\", ...scaleSizing()]\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      \"max-h\": [{\n        \"max-h\": [\"screen\", \"lh\", ...scaleSizing()]\n      }],\n      // ------------------\n      // --- Typography ---\n      // ------------------\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      \"font-size\": [{\n        text: [\"base\", themeText, isArbitraryVariableLength, isArbitraryLength]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      \"font-smoothing\": [\"antialiased\", \"subpixel-antialiased\"],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      \"font-style\": [\"italic\", \"not-italic\"],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      \"font-weight\": [{\n        font: [themeFontWeight, isArbitraryVariable, isArbitraryNumber]\n      }],\n      /**\n       * Font Stretch\n       * @see https://tailwindcss.com/docs/font-stretch\n       */\n      \"font-stretch\": [{\n        \"font-stretch\": [\"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", \"ultra-expanded\", isPercent, isArbitraryValue]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      \"font-family\": [{\n        font: [isArbitraryVariableFamilyName, isArbitraryValue, themeFont]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-normal\": [\"normal-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-ordinal\": [\"ordinal\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-slashed-zero\": [\"slashed-zero\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-figure\": [\"lining-nums\", \"oldstyle-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-spacing\": [\"proportional-nums\", \"tabular-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-fraction\": [\"diagonal-fractions\", \"stacked-fractions\"],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: [themeTracking, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      \"line-clamp\": [{\n        \"line-clamp\": [isNumber, \"none\", isArbitraryVariable, isArbitraryNumber]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: [\n          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */\n          themeLeading,\n          ...scaleUnambiguousSpacing()\n        ]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      \"list-image\": [{\n        \"list-image\": [\"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      \"list-style-position\": [{\n        list: [\"inside\", \"outside\"]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      \"list-style-type\": [{\n        list: [\"disc\", \"decimal\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      \"text-alignment\": [{\n        text: [\"left\", \"center\", \"right\", \"justify\", \"start\", \"end\"]\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://v3.tailwindcss.com/docs/placeholder-color\n       */\n      \"placeholder-color\": [{\n        placeholder: scaleColor()\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      \"text-color\": [{\n        text: scaleColor()\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      \"text-decoration\": [\"underline\", \"overline\", \"line-through\", \"no-underline\"],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      \"text-decoration-style\": [{\n        decoration: [...scaleLineStyle(), \"wavy\"]\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      \"text-decoration-thickness\": [{\n        decoration: [isNumber, \"from-font\", \"auto\", isArbitraryVariable, isArbitraryLength]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      \"text-decoration-color\": [{\n        decoration: scaleColor()\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      \"underline-offset\": [{\n        \"underline-offset\": [isNumber, \"auto\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      \"text-transform\": [\"uppercase\", \"lowercase\", \"capitalize\", \"normal-case\"],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      \"text-overflow\": [\"truncate\", \"text-ellipsis\", \"text-clip\"],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      \"text-wrap\": [{\n        text: [\"wrap\", \"nowrap\", \"balance\", \"pretty\"]\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: scaleUnambiguousSpacing()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      \"vertical-align\": [{\n        align: [\"baseline\", \"top\", \"middle\", \"bottom\", \"text-top\", \"text-bottom\", \"sub\", \"super\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: [\"normal\", \"nowrap\", \"pre\", \"pre-line\", \"pre-wrap\", \"break-spaces\"]\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: [\"normal\", \"words\", \"all\", \"keep\"]\n      }],\n      /**\n       * Overflow Wrap\n       * @see https://tailwindcss.com/docs/overflow-wrap\n       */\n      wrap: [{\n        wrap: [\"break-word\", \"anywhere\", \"normal\"]\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: [\"none\", \"manual\", \"auto\"]\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: [\"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // -------------------\n      // --- Backgrounds ---\n      // -------------------\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      \"bg-attachment\": [{\n        bg: [\"fixed\", \"local\", \"scroll\"]\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      \"bg-clip\": [{\n        \"bg-clip\": [\"border\", \"padding\", \"content\", \"text\"]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      \"bg-origin\": [{\n        \"bg-origin\": [\"border\", \"padding\", \"content\"]\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      \"bg-position\": [{\n        bg: scaleBgPosition()\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      \"bg-repeat\": [{\n        bg: scaleBgRepeat()\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      \"bg-size\": [{\n        bg: scaleBgSize()\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      \"bg-image\": [{\n        bg: [\"none\", {\n          linear: [{\n            to: [\"t\", \"tr\", \"r\", \"br\", \"b\", \"bl\", \"l\", \"tl\"]\n          }, isInteger, isArbitraryVariable, isArbitraryValue],\n          radial: [\"\", isArbitraryVariable, isArbitraryValue],\n          conic: [isInteger, isArbitraryVariable, isArbitraryValue]\n        }, isArbitraryVariableImage, isArbitraryImage]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      \"bg-color\": [{\n        bg: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from-pos\": [{\n        from: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via-pos\": [{\n        via: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to-pos\": [{\n        to: scaleGradientStopPosition()\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from\": [{\n        from: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via\": [{\n        via: scaleColor()\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to\": [{\n        to: scaleColor()\n      }],\n      // ---------------\n      // --- Borders ---\n      // ---------------\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: scaleRadius()\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-s\": [{\n        \"rounded-s\": scaleRadius()\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-e\": [{\n        \"rounded-e\": scaleRadius()\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-t\": [{\n        \"rounded-t\": scaleRadius()\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-r\": [{\n        \"rounded-r\": scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-b\": [{\n        \"rounded-b\": scaleRadius()\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-l\": [{\n        \"rounded-l\": scaleRadius()\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ss\": [{\n        \"rounded-ss\": scaleRadius()\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-se\": [{\n        \"rounded-se\": scaleRadius()\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ee\": [{\n        \"rounded-ee\": scaleRadius()\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-es\": [{\n        \"rounded-es\": scaleRadius()\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tl\": [{\n        \"rounded-tl\": scaleRadius()\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tr\": [{\n        \"rounded-tr\": scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-br\": [{\n        \"rounded-br\": scaleRadius()\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-bl\": [{\n        \"rounded-bl\": scaleRadius()\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w\": [{\n        border: scaleBorderWidth()\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-x\": [{\n        \"border-x\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-y\": [{\n        \"border-y\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-s\": [{\n        \"border-s\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-e\": [{\n        \"border-e\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-t\": [{\n        \"border-t\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-r\": [{\n        \"border-r\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-b\": [{\n        \"border-b\": scaleBorderWidth()\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-l\": [{\n        \"border-l\": scaleBorderWidth()\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-x\": [{\n        \"divide-x\": scaleBorderWidth()\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-x-reverse\": [\"divide-x-reverse\"],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-y\": [{\n        \"divide-y\": scaleBorderWidth()\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/border-width#between-children\n       */\n      \"divide-y-reverse\": [\"divide-y-reverse\"],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      \"border-style\": [{\n        border: [...scaleLineStyle(), \"hidden\", \"none\"]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style\n       */\n      \"divide-style\": [{\n        divide: [...scaleLineStyle(), \"hidden\", \"none\"]\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color\": [{\n        border: scaleColor()\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-x\": [{\n        \"border-x\": scaleColor()\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-y\": [{\n        \"border-y\": scaleColor()\n      }],\n      /**\n       * Border Color S\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-s\": [{\n        \"border-s\": scaleColor()\n      }],\n      /**\n       * Border Color E\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-e\": [{\n        \"border-e\": scaleColor()\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-t\": [{\n        \"border-t\": scaleColor()\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-r\": [{\n        \"border-r\": scaleColor()\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-b\": [{\n        \"border-b\": scaleColor()\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-l\": [{\n        \"border-l\": scaleColor()\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      \"divide-color\": [{\n        divide: scaleColor()\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      \"outline-style\": [{\n        outline: [...scaleLineStyle(), \"none\", \"hidden\"]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      \"outline-offset\": [{\n        \"outline-offset\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      \"outline-w\": [{\n        outline: [\"\", isNumber, isArbitraryVariableLength, isArbitraryLength]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      \"outline-color\": [{\n        outline: scaleColor()\n      }],\n      // ---------------\n      // --- Effects ---\n      // ---------------\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: [\n          // Deprecated since Tailwind CSS v4.0.0\n          \"\",\n          \"none\",\n          themeShadow,\n          isArbitraryVariableShadow,\n          isArbitraryShadow\n        ]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color\n       */\n      \"shadow-color\": [{\n        shadow: scaleColor()\n      }],\n      /**\n       * Inset Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow\n       */\n      \"inset-shadow\": [{\n        \"inset-shadow\": [\"none\", themeInsetShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Inset Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color\n       */\n      \"inset-shadow-color\": [{\n        \"inset-shadow\": scaleColor()\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring\n       */\n      \"ring-w\": [{\n        ring: scaleBorderWidth()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      \"ring-w-inset\": [\"ring-inset\"],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color\n       */\n      \"ring-color\": [{\n        ring: scaleColor()\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://v3.tailwindcss.com/docs/ring-offset-width\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      \"ring-offset-w\": [{\n        \"ring-offset\": [isNumber, isArbitraryLength]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://v3.tailwindcss.com/docs/ring-offset-color\n       * @deprecated since Tailwind CSS v4.0.0\n       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158\n       */\n      \"ring-offset-color\": [{\n        \"ring-offset\": scaleColor()\n      }],\n      /**\n       * Inset Ring Width\n       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring\n       */\n      \"inset-ring-w\": [{\n        \"inset-ring\": scaleBorderWidth()\n      }],\n      /**\n       * Inset Ring Color\n       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color\n       */\n      \"inset-ring-color\": [{\n        \"inset-ring\": scaleColor()\n      }],\n      /**\n       * Text Shadow\n       * @see https://tailwindcss.com/docs/text-shadow\n       */\n      \"text-shadow\": [{\n        \"text-shadow\": [\"none\", themeTextShadow, isArbitraryVariableShadow, isArbitraryShadow]\n      }],\n      /**\n       * Text Shadow Color\n       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color\n       */\n      \"text-shadow-color\": [{\n        \"text-shadow\": scaleColor()\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      \"mix-blend\": [{\n        \"mix-blend\": [...scaleBlendMode(), \"plus-darker\", \"plus-lighter\"]\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      \"bg-blend\": [{\n        \"bg-blend\": scaleBlendMode()\n      }],\n      /**\n       * Mask Clip\n       * @see https://tailwindcss.com/docs/mask-clip\n       */\n      \"mask-clip\": [{\n        \"mask-clip\": [\"border\", \"padding\", \"content\", \"fill\", \"stroke\", \"view\"]\n      }, \"mask-no-clip\"],\n      /**\n       * Mask Composite\n       * @see https://tailwindcss.com/docs/mask-composite\n       */\n      \"mask-composite\": [{\n        mask: [\"add\", \"subtract\", \"intersect\", \"exclude\"]\n      }],\n      /**\n       * Mask Image\n       * @see https://tailwindcss.com/docs/mask-image\n       */\n      \"mask-image-linear-pos\": [{\n        \"mask-linear\": [isNumber]\n      }],\n      \"mask-image-linear-from-pos\": [{\n        \"mask-linear-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-linear-to-pos\": [{\n        \"mask-linear-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-linear-from-color\": [{\n        \"mask-linear-from\": scaleColor()\n      }],\n      \"mask-image-linear-to-color\": [{\n        \"mask-linear-to\": scaleColor()\n      }],\n      \"mask-image-t-from-pos\": [{\n        \"mask-t-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-t-to-pos\": [{\n        \"mask-t-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-t-from-color\": [{\n        \"mask-t-from\": scaleColor()\n      }],\n      \"mask-image-t-to-color\": [{\n        \"mask-t-to\": scaleColor()\n      }],\n      \"mask-image-r-from-pos\": [{\n        \"mask-r-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-r-to-pos\": [{\n        \"mask-r-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-r-from-color\": [{\n        \"mask-r-from\": scaleColor()\n      }],\n      \"mask-image-r-to-color\": [{\n        \"mask-r-to\": scaleColor()\n      }],\n      \"mask-image-b-from-pos\": [{\n        \"mask-b-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-b-to-pos\": [{\n        \"mask-b-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-b-from-color\": [{\n        \"mask-b-from\": scaleColor()\n      }],\n      \"mask-image-b-to-color\": [{\n        \"mask-b-to\": scaleColor()\n      }],\n      \"mask-image-l-from-pos\": [{\n        \"mask-l-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-l-to-pos\": [{\n        \"mask-l-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-l-from-color\": [{\n        \"mask-l-from\": scaleColor()\n      }],\n      \"mask-image-l-to-color\": [{\n        \"mask-l-to\": scaleColor()\n      }],\n      \"mask-image-x-from-pos\": [{\n        \"mask-x-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-x-to-pos\": [{\n        \"mask-x-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-x-from-color\": [{\n        \"mask-x-from\": scaleColor()\n      }],\n      \"mask-image-x-to-color\": [{\n        \"mask-x-to\": scaleColor()\n      }],\n      \"mask-image-y-from-pos\": [{\n        \"mask-y-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-y-to-pos\": [{\n        \"mask-y-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-y-from-color\": [{\n        \"mask-y-from\": scaleColor()\n      }],\n      \"mask-image-y-to-color\": [{\n        \"mask-y-to\": scaleColor()\n      }],\n      \"mask-image-radial\": [{\n        \"mask-radial\": [isArbitraryVariable, isArbitraryValue]\n      }],\n      \"mask-image-radial-from-pos\": [{\n        \"mask-radial-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-radial-to-pos\": [{\n        \"mask-radial-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-radial-from-color\": [{\n        \"mask-radial-from\": scaleColor()\n      }],\n      \"mask-image-radial-to-color\": [{\n        \"mask-radial-to\": scaleColor()\n      }],\n      \"mask-image-radial-shape\": [{\n        \"mask-radial\": [\"circle\", \"ellipse\"]\n      }],\n      \"mask-image-radial-size\": [{\n        \"mask-radial\": [{\n          closest: [\"side\", \"corner\"],\n          farthest: [\"side\", \"corner\"]\n        }]\n      }],\n      \"mask-image-radial-pos\": [{\n        \"mask-radial-at\": scalePosition()\n      }],\n      \"mask-image-conic-pos\": [{\n        \"mask-conic\": [isNumber]\n      }],\n      \"mask-image-conic-from-pos\": [{\n        \"mask-conic-from\": scaleMaskImagePosition()\n      }],\n      \"mask-image-conic-to-pos\": [{\n        \"mask-conic-to\": scaleMaskImagePosition()\n      }],\n      \"mask-image-conic-from-color\": [{\n        \"mask-conic-from\": scaleColor()\n      }],\n      \"mask-image-conic-to-color\": [{\n        \"mask-conic-to\": scaleColor()\n      }],\n      /**\n       * Mask Mode\n       * @see https://tailwindcss.com/docs/mask-mode\n       */\n      \"mask-mode\": [{\n        mask: [\"alpha\", \"luminance\", \"match\"]\n      }],\n      /**\n       * Mask Origin\n       * @see https://tailwindcss.com/docs/mask-origin\n       */\n      \"mask-origin\": [{\n        \"mask-origin\": [\"border\", \"padding\", \"content\", \"fill\", \"stroke\", \"view\"]\n      }],\n      /**\n       * Mask Position\n       * @see https://tailwindcss.com/docs/mask-position\n       */\n      \"mask-position\": [{\n        mask: scaleBgPosition()\n      }],\n      /**\n       * Mask Repeat\n       * @see https://tailwindcss.com/docs/mask-repeat\n       */\n      \"mask-repeat\": [{\n        mask: scaleBgRepeat()\n      }],\n      /**\n       * Mask Size\n       * @see https://tailwindcss.com/docs/mask-size\n       */\n      \"mask-size\": [{\n        mask: scaleBgSize()\n      }],\n      /**\n       * Mask Type\n       * @see https://tailwindcss.com/docs/mask-type\n       */\n      \"mask-type\": [{\n        \"mask-type\": [\"alpha\", \"luminance\"]\n      }],\n      /**\n       * Mask Image\n       * @see https://tailwindcss.com/docs/mask-image\n       */\n      \"mask-image\": [{\n        mask: [\"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // ---------------\n      // --- Filters ---\n      // ---------------\n      /**\n       * Filter\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: [\n          // Deprecated since Tailwind CSS v3.0.0\n          \"\",\n          \"none\",\n          isArbitraryVariable,\n          isArbitraryValue\n        ]\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: scaleBlur()\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      \"drop-shadow\": [{\n        \"drop-shadow\": [\n          // Deprecated since Tailwind CSS v4.0.0\n          \"\",\n          \"none\",\n          themeDropShadow,\n          isArbitraryVariableShadow,\n          isArbitraryShadow\n        ]\n      }],\n      /**\n       * Drop Shadow Color\n       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color\n       */\n      \"drop-shadow-color\": [{\n        \"drop-shadow\": scaleColor()\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      \"hue-rotate\": [{\n        \"hue-rotate\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Filter\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      \"backdrop-filter\": [{\n        \"backdrop-filter\": [\n          // Deprecated since Tailwind CSS v3.0.0\n          \"\",\n          \"none\",\n          isArbitraryVariable,\n          isArbitraryValue\n        ]\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      \"backdrop-blur\": [{\n        \"backdrop-blur\": scaleBlur()\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      \"backdrop-brightness\": [{\n        \"backdrop-brightness\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      \"backdrop-contrast\": [{\n        \"backdrop-contrast\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      \"backdrop-grayscale\": [{\n        \"backdrop-grayscale\": [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      \"backdrop-hue-rotate\": [{\n        \"backdrop-hue-rotate\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      \"backdrop-invert\": [{\n        \"backdrop-invert\": [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      \"backdrop-opacity\": [{\n        \"backdrop-opacity\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      \"backdrop-saturate\": [{\n        \"backdrop-saturate\": [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      \"backdrop-sepia\": [{\n        \"backdrop-sepia\": [\"\", isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      // --------------\n      // --- Tables ---\n      // --------------\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      \"border-collapse\": [{\n        border: [\"collapse\", \"separate\"]\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing\": [{\n        \"border-spacing\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-x\": [{\n        \"border-spacing-x\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-y\": [{\n        \"border-spacing-y\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      \"table-layout\": [{\n        table: [\"auto\", \"fixed\"]\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: [\"top\", \"bottom\"]\n      }],\n      // ---------------------------------\n      // --- Transitions and Animation ---\n      // ---------------------------------\n      /**\n       * Transition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: [\"\", \"all\", \"colors\", \"opacity\", \"shadow\", \"transform\", \"none\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Behavior\n       * @see https://tailwindcss.com/docs/transition-behavior\n       */\n      \"transition-behavior\": [{\n        transition: [\"normal\", \"discrete\"]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: [isNumber, \"initial\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: [\"linear\", \"initial\", themeEase, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: [isNumber, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: [\"none\", themeAnimate, isArbitraryVariable, isArbitraryValue]\n      }],\n      // ------------------\n      // --- Transforms ---\n      // ------------------\n      /**\n       * Backface Visibility\n       * @see https://tailwindcss.com/docs/backface-visibility\n       */\n      backface: [{\n        backface: [\"hidden\", \"visible\"]\n      }],\n      /**\n       * Perspective\n       * @see https://tailwindcss.com/docs/perspective\n       */\n      perspective: [{\n        perspective: [themePerspective, isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Perspective Origin\n       * @see https://tailwindcss.com/docs/perspective-origin\n       */\n      \"perspective-origin\": [{\n        \"perspective-origin\": scalePositionWithArbitrary()\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: scaleRotate()\n      }],\n      /**\n       * Rotate X\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      \"rotate-x\": [{\n        \"rotate-x\": scaleRotate()\n      }],\n      /**\n       * Rotate Y\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      \"rotate-y\": [{\n        \"rotate-y\": scaleRotate()\n      }],\n      /**\n       * Rotate Z\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      \"rotate-z\": [{\n        \"rotate-z\": scaleRotate()\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: scaleScale()\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-x\": [{\n        \"scale-x\": scaleScale()\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-y\": [{\n        \"scale-y\": scaleScale()\n      }],\n      /**\n       * Scale Z\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-z\": [{\n        \"scale-z\": scaleScale()\n      }],\n      /**\n       * Scale 3D\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-3d\": [\"scale-3d\"],\n      /**\n       * Skew\n       * @see https://tailwindcss.com/docs/skew\n       */\n      skew: [{\n        skew: scaleSkew()\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-x\": [{\n        \"skew-x\": scaleSkew()\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-y\": [{\n        \"skew-y\": scaleSkew()\n      }],\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: [isArbitraryVariable, isArbitraryValue, \"\", \"none\", \"gpu\", \"cpu\"]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      \"transform-origin\": [{\n        origin: scalePositionWithArbitrary()\n      }],\n      /**\n       * Transform Style\n       * @see https://tailwindcss.com/docs/transform-style\n       */\n      \"transform-style\": [{\n        transform: [\"3d\", \"flat\"]\n      }],\n      /**\n       * Translate\n       * @see https://tailwindcss.com/docs/translate\n       */\n      translate: [{\n        translate: scaleTranslate()\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-x\": [{\n        \"translate-x\": scaleTranslate()\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-y\": [{\n        \"translate-y\": scaleTranslate()\n      }],\n      /**\n       * Translate Z\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-z\": [{\n        \"translate-z\": scaleTranslate()\n      }],\n      /**\n       * Translate None\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-none\": [\"translate-none\"],\n      // ---------------------\n      // --- Interactivity ---\n      // ---------------------\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: scaleColor()\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: [\"none\", \"auto\"]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      \"caret-color\": [{\n        caret: scaleColor()\n      }],\n      /**\n       * Color Scheme\n       * @see https://tailwindcss.com/docs/color-scheme\n       */\n      \"color-scheme\": [{\n        scheme: [\"normal\", \"dark\", \"light\", \"light-dark\", \"only-dark\", \"only-light\"]\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: [\"auto\", \"default\", \"pointer\", \"wait\", \"text\", \"move\", \"help\", \"not-allowed\", \"none\", \"context-menu\", \"progress\", \"cell\", \"crosshair\", \"vertical-text\", \"alias\", \"copy\", \"no-drop\", \"grab\", \"grabbing\", \"all-scroll\", \"col-resize\", \"row-resize\", \"n-resize\", \"e-resize\", \"s-resize\", \"w-resize\", \"ne-resize\", \"nw-resize\", \"se-resize\", \"sw-resize\", \"ew-resize\", \"ns-resize\", \"nesw-resize\", \"nwse-resize\", \"zoom-in\", \"zoom-out\", isArbitraryVariable, isArbitraryValue]\n      }],\n      /**\n       * Field Sizing\n       * @see https://tailwindcss.com/docs/field-sizing\n       */\n      \"field-sizing\": [{\n        \"field-sizing\": [\"fixed\", \"content\"]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      \"pointer-events\": [{\n        \"pointer-events\": [\"auto\", \"none\"]\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: [\"none\", \"\", \"y\", \"x\"]\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      \"scroll-behavior\": [{\n        scroll: [\"auto\", \"smooth\"]\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-m\": [{\n        \"scroll-m\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mx\": [{\n        \"scroll-mx\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-my\": [{\n        \"scroll-my\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ms\": [{\n        \"scroll-ms\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-me\": [{\n        \"scroll-me\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mt\": [{\n        \"scroll-mt\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mr\": [{\n        \"scroll-mr\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mb\": [{\n        \"scroll-mb\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ml\": [{\n        \"scroll-ml\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-p\": [{\n        \"scroll-p\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-px\": [{\n        \"scroll-px\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-py\": [{\n        \"scroll-py\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-ps\": [{\n        \"scroll-ps\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pe\": [{\n        \"scroll-pe\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pt\": [{\n        \"scroll-pt\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pr\": [{\n        \"scroll-pr\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pb\": [{\n        \"scroll-pb\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pl\": [{\n        \"scroll-pl\": scaleUnambiguousSpacing()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      \"snap-align\": [{\n        snap: [\"start\", \"end\", \"center\", \"align-none\"]\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      \"snap-stop\": [{\n        snap: [\"normal\", \"always\"]\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-type\": [{\n        snap: [\"none\", \"x\", \"y\", \"both\"]\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-strictness\": [{\n        snap: [\"mandatory\", \"proximity\"]\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: [\"auto\", \"none\", \"manipulation\"]\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-x\": [{\n        \"touch-pan\": [\"x\", \"left\", \"right\"]\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-y\": [{\n        \"touch-pan\": [\"y\", \"up\", \"down\"]\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-pz\": [\"touch-pinch-zoom\"],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: [\"none\", \"text\", \"all\", \"auto\"]\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      \"will-change\": [{\n        \"will-change\": [\"auto\", \"scroll\", \"contents\", \"transform\", isArbitraryVariable, isArbitraryValue]\n      }],\n      // -----------\n      // --- SVG ---\n      // -----------\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [\"none\", ...scaleColor()]\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      \"stroke-w\": [{\n        stroke: [isNumber, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [\"none\", ...scaleColor()]\n      }],\n      // ---------------------\n      // --- Accessibility ---\n      // ---------------------\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      \"forced-color-adjust\": [{\n        \"forced-color-adjust\": [\"auto\", \"none\"]\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: [\"overflow-x\", \"overflow-y\"],\n      overscroll: [\"overscroll-x\", \"overscroll-y\"],\n      inset: [\"inset-x\", \"inset-y\", \"start\", \"end\", \"top\", \"right\", \"bottom\", \"left\"],\n      \"inset-x\": [\"right\", \"left\"],\n      \"inset-y\": [\"top\", \"bottom\"],\n      flex: [\"basis\", \"grow\", \"shrink\"],\n      gap: [\"gap-x\", \"gap-y\"],\n      p: [\"px\", \"py\", \"ps\", \"pe\", \"pt\", \"pr\", \"pb\", \"pl\"],\n      px: [\"pr\", \"pl\"],\n      py: [\"pt\", \"pb\"],\n      m: [\"mx\", \"my\", \"ms\", \"me\", \"mt\", \"mr\", \"mb\", \"ml\"],\n      mx: [\"mr\", \"ml\"],\n      my: [\"mt\", \"mb\"],\n      size: [\"w\", \"h\"],\n      \"font-size\": [\"leading\"],\n      \"fvn-normal\": [\"fvn-ordinal\", \"fvn-slashed-zero\", \"fvn-figure\", \"fvn-spacing\", \"fvn-fraction\"],\n      \"fvn-ordinal\": [\"fvn-normal\"],\n      \"fvn-slashed-zero\": [\"fvn-normal\"],\n      \"fvn-figure\": [\"fvn-normal\"],\n      \"fvn-spacing\": [\"fvn-normal\"],\n      \"fvn-fraction\": [\"fvn-normal\"],\n      \"line-clamp\": [\"display\", \"overflow\"],\n      rounded: [\"rounded-s\", \"rounded-e\", \"rounded-t\", \"rounded-r\", \"rounded-b\", \"rounded-l\", \"rounded-ss\", \"rounded-se\", \"rounded-ee\", \"rounded-es\", \"rounded-tl\", \"rounded-tr\", \"rounded-br\", \"rounded-bl\"],\n      \"rounded-s\": [\"rounded-ss\", \"rounded-es\"],\n      \"rounded-e\": [\"rounded-se\", \"rounded-ee\"],\n      \"rounded-t\": [\"rounded-tl\", \"rounded-tr\"],\n      \"rounded-r\": [\"rounded-tr\", \"rounded-br\"],\n      \"rounded-b\": [\"rounded-br\", \"rounded-bl\"],\n      \"rounded-l\": [\"rounded-tl\", \"rounded-bl\"],\n      \"border-spacing\": [\"border-spacing-x\", \"border-spacing-y\"],\n      \"border-w\": [\"border-w-x\", \"border-w-y\", \"border-w-s\", \"border-w-e\", \"border-w-t\", \"border-w-r\", \"border-w-b\", \"border-w-l\"],\n      \"border-w-x\": [\"border-w-r\", \"border-w-l\"],\n      \"border-w-y\": [\"border-w-t\", \"border-w-b\"],\n      \"border-color\": [\"border-color-x\", \"border-color-y\", \"border-color-s\", \"border-color-e\", \"border-color-t\", \"border-color-r\", \"border-color-b\", \"border-color-l\"],\n      \"border-color-x\": [\"border-color-r\", \"border-color-l\"],\n      \"border-color-y\": [\"border-color-t\", \"border-color-b\"],\n      translate: [\"translate-x\", \"translate-y\", \"translate-none\"],\n      \"translate-none\": [\"translate\", \"translate-x\", \"translate-y\", \"translate-z\"],\n      \"scroll-m\": [\"scroll-mx\", \"scroll-my\", \"scroll-ms\", \"scroll-me\", \"scroll-mt\", \"scroll-mr\", \"scroll-mb\", \"scroll-ml\"],\n      \"scroll-mx\": [\"scroll-mr\", \"scroll-ml\"],\n      \"scroll-my\": [\"scroll-mt\", \"scroll-mb\"],\n      \"scroll-p\": [\"scroll-px\", \"scroll-py\", \"scroll-ps\", \"scroll-pe\", \"scroll-pt\", \"scroll-pr\", \"scroll-pb\", \"scroll-pl\"],\n      \"scroll-px\": [\"scroll-pr\", \"scroll-pl\"],\n      \"scroll-py\": [\"scroll-pt\", \"scroll-pb\"],\n      touch: [\"touch-x\", \"touch-y\", \"touch-pz\"],\n      \"touch-x\": [\"touch\"],\n      \"touch-y\": [\"touch\"],\n      \"touch-pz\": [\"touch\"]\n    },\n    conflictingClassGroupModifiers: {\n      \"font-size\": [\"leading\"]\n    },\n    orderSensitiveModifiers: [\"*\", \"**\", \"after\", \"backdrop\", \"before\", \"details-content\", \"file\", \"first-letter\", \"first-line\", \"marker\", \"placeholder\", \"selection\"]\n  };\n}, mergeConfigs = (baseConfig, {\n  cacheSize,\n  prefix,\n  experimentalParseClassName,\n  extend = {},\n  override = {}\n}) => (overrideProperty(baseConfig, \"cacheSize\", cacheSize), overrideProperty(baseConfig, \"prefix\", prefix), overrideProperty(baseConfig, \"experimentalParseClassName\", experimentalParseClassName), overrideConfigProperties(baseConfig.theme, override.theme), overrideConfigProperties(baseConfig.classGroups, override.classGroups), overrideConfigProperties(baseConfig.conflictingClassGroups, override.conflictingClassGroups), overrideConfigProperties(baseConfig.conflictingClassGroupModifiers, override.conflictingClassGroupModifiers), overrideProperty(baseConfig, \"orderSensitiveModifiers\", override.orderSensitiveModifiers), mergeConfigProperties(baseConfig.theme, extend.theme), mergeConfigProperties(baseConfig.classGroups, extend.classGroups), mergeConfigProperties(baseConfig.conflictingClassGroups, extend.conflictingClassGroups), mergeConfigProperties(baseConfig.conflictingClassGroupModifiers, extend.conflictingClassGroupModifiers), mergeArrayProperties(baseConfig, extend, \"orderSensitiveModifiers\"), baseConfig), overrideProperty = (baseObject, overrideKey, overrideValue) => {\n  overrideValue !== void 0 && (baseObject[overrideKey] = overrideValue);\n}, overrideConfigProperties = (baseObject, overrideObject) => {\n  if (overrideObject)\n    for (const key in overrideObject)\n      overrideProperty(baseObject, key, overrideObject[key]);\n}, mergeConfigProperties = (baseObject, mergeObject) => {\n  if (mergeObject)\n    for (const key in mergeObject)\n      mergeArrayProperties(baseObject, mergeObject, key);\n}, mergeArrayProperties = (baseObject, mergeObject, key) => {\n  const mergeValue = mergeObject[key];\n  mergeValue !== void 0 && (baseObject[key] = baseObject[key] ? baseObject[key].concat(mergeValue) : mergeValue);\n}, extendTailwindMerge = (configExtension, ...createConfig) => typeof configExtension == \"function\" ? createTailwindMerge(getDefaultConfig, configExtension, ...createConfig) : createTailwindMerge(() => mergeConfigs(getDefaultConfig(), configExtension), ...createConfig);\nfunction getElementAtPoint(x, y) {\n  return window.parent.document.elementsFromPoint(\n    x,\n    y\n  ).find(\n    (element) => !element.closest(\"svg\") && !element.closest(\"STAGEWISE-TOOLBAR\") && isElementAtPoint(element, x, y)\n  ) || window.parent.document.body;\n}\nconst isElementAtPoint = (element, clientX, clientY) => {\n  const boundingRect = element.getBoundingClientRect(), isInHorizontalBounds = clientX > boundingRect.left && clientX < boundingRect.left + boundingRect.width, isInVerticalBounds = clientY > boundingRect.top && clientY < boundingRect.top + boundingRect.height;\n  return isInHorizontalBounds && isInVerticalBounds;\n}, getXPathForElement = (element, useId) => {\n  if (element.id && useId)\n    return \\`/*[@id=\"\\${element.id}\"]\\`;\n  let nodeElem = element;\n  const parts = [];\n  for (; nodeElem && Node.ELEMENT_NODE === nodeElem.nodeType; ) {\n    let nbOfPreviousSiblings = 0, hasNextSiblings = !1, sibling = nodeElem.previousSibling;\n    for (; sibling; )\n      sibling.nodeType !== Node.DOCUMENT_TYPE_NODE && sibling.nodeName === nodeElem.nodeName && nbOfPreviousSiblings++, sibling = sibling.previousSibling;\n    for (sibling = nodeElem.nextSibling; sibling; ) {\n      if (sibling.nodeName === nodeElem.nodeName) {\n        hasNextSiblings = !0;\n        break;\n      }\n      sibling = sibling.nextSibling;\n    }\n    const prefix = nodeElem.prefix ? \\`\\${nodeElem.prefix}:\\` : \"\", nth = nbOfPreviousSiblings || hasNextSiblings ? \\`[\\${nbOfPreviousSiblings + 1}]\\` : \"\";\n    parts.push(prefix + nodeElem.localName + nth), nodeElem = nodeElem.parentElement;\n  }\n  return parts.length ? \\`/\\${parts.reverse().join(\"/\")}\\` : \"\";\n};\nvar HotkeyActions = /* @__PURE__ */ ((HotkeyActions2) => (HotkeyActions2[HotkeyActions2.ESC = 0] = \"ESC\", HotkeyActions2[HotkeyActions2.CTRL_ALT_C = 1] = \"CTRL_ALT_C\", HotkeyActions2))(HotkeyActions || {});\nconst hotkeyActionDefinitions = {\n  0: {\n    keyComboDefault: \"Esc\",\n    keyComboMac: \"esc\",\n    isEventMatching: (ev) => ev.code === \"Escape\"\n  },\n  1: {\n    keyComboDefault: \"Ctrl+Alt+C\",\n    keyComboMac: \"++C\",\n    isEventMatching: (ev) => ev.code === \"KeyC\" && (ev.ctrlKey || ev.metaKey) && ev.altKey\n  }\n}, customTwMerge = extendTailwindMerge({\n  extend: {\n    classGroups: {\n      \"bg-image\": [\n        \"bg-gradient\",\n        \"bg-gradient-light-1\",\n        \"bg-gradient-light-2\",\n        \"bg-gradient-light-3\"\n      ]\n    }\n  }\n});\nfunction cn(...inputs) {\n  return customTwMerge(clsx(inputs));\n}\nconst generateId = (length = 16) => Math.random().toString(36).substring(2, length + 2), copyObject = (obj, depth = 0, maxDepth = 3) => {\n  if (obj == null)\n    return obj;\n  if (typeof obj != \"object\")\n    return typeof obj == \"function\" ? void 0 : obj;\n  if (depth >= maxDepth)\n    return Array.isArray(obj) ? [] : {};\n  if (Array.isArray(obj))\n    return obj.map((item) => copyObject(item, depth + 1, maxDepth)).filter((item) => item !== void 0);\n  const result = {};\n  for (const key of Object.getOwnPropertyNames(obj))\n    if (!excludedProperties.has(key))\n      try {\n        const value = obj[key];\n        if (typeof value == \"function\")\n          continue;\n        const copiedValue = copyObject(value, depth + 1, maxDepth);\n        copiedValue !== void 0 && (result[key] = copiedValue);\n      } catch {\n        continue;\n      }\n  return result;\n}, excludedProperties = /* @__PURE__ */ new Set([\n  \"constructor\",\n  \"__proto__\",\n  \"prototype\",\n  \"__defineGetter__\",\n  \"__defineSetter__\",\n  \"__lookupGetter__\",\n  \"__lookupSetter__\",\n  \"hasOwnProperty\",\n  \"isPrototypeOf\",\n  \"propertyIsEnumerable\",\n  \"toString\",\n  \"valueOf\",\n  \"toLocaleString\"\n]), truncateString = (str, maxLength) => str.length <= maxLength ? str : \\`\\${str.substring(0, maxLength - 3)}...\\`, truncateAttributes = (attributes) => {\n  const result = {}, limitedEntries = Object.entries(attributes).slice(0, 100);\n  for (const [key, value] of limitedEntries) {\n    if (value == null) continue;\n    (/* @__PURE__ */ new Set([\n      \"class\",\n      \"id\",\n      \"style\",\n      \"name\",\n      \"role\",\n      \"href\",\n      \"for\",\n      \"placeholder\",\n      \"alt\",\n      \"title\",\n      \"ariaLabel\",\n      \"ariaRole\",\n      \"ariaDescription\"\n    ])).has(key) ? result[key] = truncateString(value, 4096) : result[key] = truncateString(value, 256);\n  }\n  return result;\n}, truncateOwnProperties = (properties) => {\n  const result = {}, limitedEntries = Object.entries(properties).slice(0, 500);\n  for (const [key, value] of limitedEntries)\n    result[key] = truncateValue(value, 0, 2);\n  return result;\n}, truncateValue = (value, currentDepth, maxDepth) => {\n  if (value == null) return value;\n  if (currentDepth >= maxDepth)\n    return Array.isArray(value) ? [] : typeof value == \"object\" ? {} : value;\n  if (typeof value == \"string\")\n    return truncateString(value, 1024);\n  if (Array.isArray(value))\n    return value.slice(0, 50).map((item) => truncateValue(item, currentDepth + 1, maxDepth));\n  if (typeof value == \"object\") {\n    const result = {}, limitedEntries = Object.entries(value).slice(0, 50);\n    for (const [key, val] of limitedEntries)\n      result[key] = truncateValue(val, currentDepth + 1, maxDepth);\n    return result;\n  }\n  return value;\n}, truncatePluginInfo = (pluginInfo) => pluginInfo.map((plugin) => ({\n  pluginName: truncateString(plugin.pluginName, 128),\n  content: truncateString(plugin.content, 4096)\n})), getSelectedElementInfo = (element, callDepth) => {\n  const boundingRect = element.getBoundingClientRect(), rawAttributes = element.getAttributeNames().reduce(\n    (acc, name) => {\n      const value = element.getAttribute(name);\n      return value !== null && (acc[name] = value), acc;\n    },\n    {}\n  ), rawOwnProperties = Object.getOwnPropertyNames(element).filter((prop) => !excludedProperties.has(prop)).reduce(\n    (acc, prop) => {\n      try {\n        const value = element[prop];\n        typeof value != \"function\" && (acc[prop] = copyObject(value, 0, 2));\n      } catch {\n      }\n      return acc;\n    },\n    {}\n  );\n  return {\n    nodeType: truncateString(element.nodeName, 96),\n    xpath: truncateString(getXPathForElement(element, !1), 1024),\n    attributes: truncateAttributes(rawAttributes),\n    textContent: truncateString(element.textContent || \"\", 512),\n    ownProperties: truncateOwnProperties(rawOwnProperties),\n    boundingClientRect: {\n      top: boundingRect.top,\n      left: boundingRect.left,\n      height: boundingRect.height,\n      width: boundingRect.width\n    },\n    parent: element.parentElement && (callDepth ?? 0) < 10 ? getSelectedElementInfo(element.parentElement, (callDepth ?? 0) + 1) : null,\n    pluginInfo: truncatePluginInfo([])\n  };\n}, collectUserMessageMetadata = (selectedElements) => ({\n  currentUrl: truncateString(window.parent.location.href, 1024),\n  currentTitle: truncateString(window.parent.document.title, 256),\n  currentZoomLevel: 0,\n  devicePixelRatio: window.parent.devicePixelRatio,\n  userAgent: truncateString(window.parent.navigator.userAgent, 1024),\n  locale: truncateString(window.parent.navigator.language, 64),\n  selectedElements,\n  viewportResolution: {\n    width: window.parent.innerWidth,\n    height: window.parent.innerHeight\n  }\n}), AppContext = createContext(null), STORAGE_KEY$1 = \"stgws:companion\";\nfunction loadStateFromStorage() {\n  try {\n    const stored = sessionStorage.getItem(STORAGE_KEY$1);\n    return stored ? JSON.parse(stored) : {};\n  } catch (error) {\n    return console.error(\"Failed to load state from storage:\", error), {};\n  }\n}\nfunction saveStateToStorage(state) {\n  try {\n    sessionStorage.setItem(STORAGE_KEY$1, JSON.stringify(state));\n  } catch (error) {\n    console.error(\"Failed to save state to storage:\", error);\n  }\n}\nfunction AppStateProvider({ children }) {\n  const [state, setState] = useState(() => {\n    const storedState = loadStateFromStorage();\n    return {\n      appBlockRequestList: [],\n      appUnblockRequestList: [],\n      lastBlockRequestNumber: 0,\n      lastUnblockRequestNumber: 0,\n      isMainAppBlocked: !1,\n      toolbarBoxRef: createRef(),\n      minimized: storedState.minimized ?? !1,\n      requestMainAppBlock: () => 0,\n      // These will be replaced by the actual implementations\n      requestMainAppUnblock: () => 0,\n      discardMainAppBlock: () => {\n      },\n      discardMainAppUnblock: () => {\n      },\n      setToolbarBoxRef: () => {\n      },\n      unsetToolbarBoxRef: () => {\n      },\n      minimize: () => {\n      },\n      expand: () => {\n      }\n    };\n  });\n  useEffect(() => {\n    saveStateToStorage({\n      minimized: state.minimized\n    });\n  }, [state.minimized]);\n  const requestMainAppBlock = useCallback(() => {\n    let newHandleValue = 0;\n    return setState((prev) => (newHandleValue = prev.lastBlockRequestNumber + 1, {\n      ...prev,\n      appBlockRequestList: [...prev.appBlockRequestList, newHandleValue],\n      lastBlockRequestNumber: newHandleValue,\n      isMainAppBlocked: prev.appUnblockRequestList.length === 0\n    })), newHandleValue;\n  }, []), requestMainAppUnblock = useCallback(() => {\n    let newHandleValue = 0;\n    return setState((prev) => (newHandleValue = prev.lastUnblockRequestNumber + 1, {\n      ...prev,\n      appUnblockRequestList: [...prev.appUnblockRequestList, newHandleValue],\n      lastUnblockRequestNumber: newHandleValue,\n      isMainAppBlocked: !1\n    })), newHandleValue;\n  }, []), discardMainAppBlock = useCallback((handle) => {\n    setState((prev) => {\n      const newBlockRequestList = prev.appBlockRequestList.filter(\n        (h) => h !== handle\n      );\n      return {\n        ...prev,\n        appBlockRequestList: newBlockRequestList,\n        isMainAppBlocked: newBlockRequestList.length > 0 && prev.appUnblockRequestList.length === 0\n      };\n    });\n  }, []), discardMainAppUnblock = useCallback((handle) => {\n    setState((prev) => {\n      const newUnblockRequestList = prev.appUnblockRequestList.filter(\n        (h) => h !== handle\n      );\n      return {\n        ...prev,\n        appUnblockRequestList: newUnblockRequestList,\n        isMainAppBlocked: prev.appBlockRequestList.length > 0 && newUnblockRequestList.length === 0\n      };\n    });\n  }, []), setToolbarBoxRef = useCallback((ref) => {\n    setState((prev) => ({ ...prev, toolbarBoxRef: ref }));\n  }, []), unsetToolbarBoxRef = useCallback(() => {\n    setState((prev) => ({ ...prev, toolbarBoxRef: createRef() }));\n  }, []), minimize = useCallback(() => {\n    setState((prev) => ({ ...prev, minimized: !0 }));\n  }, []), expand = useCallback(() => {\n    setState((prev) => ({ ...prev, minimized: !1 }));\n  }, []), value = {\n    requestMainAppBlock,\n    requestMainAppUnblock,\n    discardMainAppBlock,\n    discardMainAppUnblock,\n    isMainAppBlocked: state.isMainAppBlocked,\n    toolbarBoxRef: state.toolbarBoxRef,\n    setToolbarBoxRef,\n    unsetToolbarBoxRef,\n    minimized: state.minimized,\n    minimize,\n    expand\n  };\n  return /* @__PURE__ */ jsx(AppContext.Provider, { value, children });\n}\nfunction useAppState() {\n  const context = useContext(AppContext);\n  if (!context)\n    throw new Error(\"useAppState must be used within an AppStateProvider\");\n  return context;\n}\nconst agentAvailabilityContext = createContext({\n  isAvailable: !1,\n  error: AgentAvailabilityError.NO_CONNECTION\n});\nfunction AgentAvailabilityProvider({\n  children\n}) {\n  const agent = useAgents().connected, [availability, setAvailability] = useState({\n    isAvailable: !1,\n    error: AgentAvailabilityError.NO_CONNECTION\n  });\n  return useEffect(() => {\n    if (agent !== null) {\n      const subscription = agent.agent.availability.getAvailability.subscribe(\n        void 0,\n        {\n          onData: (value) => {\n            setAvailability(value);\n          },\n          onError: () => {\n            setAvailability({\n              isAvailable: !1,\n              error: AgentAvailabilityError.NO_CONNECTION\n            });\n          }\n        }\n      );\n      return () => {\n        try {\n          subscription.unsubscribe();\n        } catch (error) {\n          console.debug(\n            \"[AgentAvailabilityProvider] Error unsubscribing from availability:\",\n            error\n          );\n        }\n      };\n    } else\n      setAvailability({\n        isAvailable: !1,\n        error: AgentAvailabilityError.NO_CONNECTION\n      });\n  }, [agent]), /* @__PURE__ */ jsx(agentAvailabilityContext.Provider, { value: availability, children });\n}\nconst useAgentAvailability = () => useContext(agentAvailabilityContext), STORAGE_KEY = \"stagewise_toolbar_open_panels\", loadPersistedState = () => {\n  try {\n    const stored = sessionStorage.getItem(STORAGE_KEY);\n    return stored ? JSON.parse(stored) : {};\n  } catch (error) {\n    return console.warn(\"[PanelsProvider] Failed to load persisted state:\", error), {};\n  }\n}, savePersistedState = (state) => {\n  try {\n    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n  } catch (error) {\n    console.warn(\"[PanelsProvider] Failed to save persisted state:\", error);\n  }\n}, PanelsContext = createContext({\n  isSettingsOpen: !1,\n  openSettings: () => null,\n  closeSettings: () => null,\n  isChatOpen: !1,\n  openChat: () => null,\n  closeChat: () => null,\n  openPluginName: null,\n  openPlugin: () => null,\n  closePlugin: () => null,\n  isAgentConnectivityOpen: !1,\n  openAgentConnectivity: () => null,\n  closeAgentConnectivity: () => null\n}), PanelsProvider = ({\n  children\n}) => {\n  const { minimized } = useAppState(), persistedState = useMemo(() => loadPersistedState(), []), [isSettingsOpenInternal, setIsSettingsOpen] = useState(\n    persistedState.isSettingsOpen ?? !1\n  ), [isChatOpenInternal, setIsChatOpen] = useState(\n    persistedState.isChatOpen ?? !1\n  ), [openPluginInternal, setOpenPlugin] = useState(\n    persistedState.openPlugin ?? null\n  ), {\n    connected,\n    connectedUnavailable,\n    requiresUserAttention,\n    isInitialLoad\n  } = useAgents(), availabilityStatus = useAgentAvailability(), [\n    agentConnectivityManuallyDismissed,\n    setAgentConnectivityManuallyDismissed\n  ] = useState(persistedState.agentConnectivityManuallyDismissed ?? !1);\n  useEffect(() => {\n    savePersistedState({\n      isSettingsOpen: isSettingsOpenInternal,\n      isChatOpen: isChatOpenInternal,\n      openPlugin: openPluginInternal,\n      agentConnectivityManuallyDismissed\n    });\n  }, [\n    isSettingsOpenInternal,\n    isChatOpenInternal,\n    openPluginInternal,\n    agentConnectivityManuallyDismissed\n  ]), useEffect(() => {\n    connected && !connectedUnavailable && availabilityStatus.isAvailable && setAgentConnectivityManuallyDismissed(!1);\n  }, [connected, connectedUnavailable, availabilityStatus]);\n  const isAgentConnectivityOpen = useMemo(() => {\n    const result = (requiresUserAttention || !availabilityStatus.isAvailable) && !agentConnectivityManuallyDismissed && !minimized && !isInitialLoad;\n    return console.debug(\"[PanelsProvider] isAgentConnectivityOpen calculation:\", {\n      requiresUserAttention,\n      availabilityStatus: availabilityStatus.isAvailable,\n      agentConnectivityManuallyDismissed,\n      minimized,\n      isInitialLoad,\n      result\n    }), result;\n  }, [\n    requiresUserAttention,\n    agentConnectivityManuallyDismissed,\n    minimized,\n    isInitialLoad,\n    availabilityStatus\n  ]), isSettingsOpen = useMemo(() => !requiresUserAttention && availabilityStatus.isAvailable && isSettingsOpenInternal && !minimized && !isInitialLoad, [\n    requiresUserAttention,\n    availabilityStatus,\n    isSettingsOpenInternal,\n    minimized,\n    isInitialLoad\n  ]), isChatOpen = useMemo(() => !requiresUserAttention && availabilityStatus.isAvailable && isChatOpenInternal && !minimized && !isInitialLoad, [\n    requiresUserAttention,\n    availabilityStatus,\n    isChatOpenInternal,\n    minimized,\n    isInitialLoad\n  ]), openPluginName = useMemo(() => !requiresUserAttention && availabilityStatus.isAvailable && !isInitialLoad && !minimized ? openPluginInternal : null, [\n    requiresUserAttention,\n    availabilityStatus,\n    openPluginInternal,\n    minimized,\n    isInitialLoad\n  ]);\n  return /* @__PURE__ */ jsx(\n    PanelsContext.Provider,\n    {\n      value: {\n        isSettingsOpen,\n        openSettings: () => setIsSettingsOpen(!0),\n        closeSettings: () => setIsSettingsOpen(!1),\n        isChatOpen,\n        openChat: () => setIsChatOpen(!0),\n        closeChat: () => setIsChatOpen(!1),\n        openPluginName,\n        openPlugin: (pluginName) => setOpenPlugin(pluginName),\n        closePlugin: () => setOpenPlugin(null),\n        isAgentConnectivityOpen,\n        openAgentConnectivity: () => setAgentConnectivityManuallyDismissed(!1),\n        closeAgentConnectivity: () => setAgentConnectivityManuallyDismissed(!0)\n      },\n      children\n    }\n  );\n}, usePanels = () => useContext(PanelsContext), PluginContext = createContext({\n  plugins: [],\n  toolbarContext: {\n    sendPrompt: () => {\n    },\n    mainAppWindow: window.parent\n  }\n});\nfunction PluginProvider({ children }) {\n  const { config } = useConfig(), { sendMessage } = useAgentMessaging(), { openChat } = usePanels(), plugins = (config == null ? void 0 : config.plugins) || [], toolbarContext = useMemo(() => ({\n    sendPrompt: async (prompt) => {\n      const userMessage = {\n        ...prompt,\n        id: generateId(),\n        createdAt: /* @__PURE__ */ new Date(),\n        sentByPlugin: !0,\n        metadata: collectUserMessageMetadata([]),\n        pluginContent: {}\n      };\n      sendMessage(userMessage), openChat();\n    },\n    mainAppWindow: window.parent\n  }), [sendMessage]), pluginsLoadedRef = useRef(!1);\n  useEffect(() => {\n    pluginsLoadedRef.current || (pluginsLoadedRef.current = !0, plugins.forEach((plugin) => {\n      var _a;\n      (_a = plugin.onLoad) == null || _a.call(plugin, toolbarContext);\n    }));\n  }, [plugins, toolbarContext]);\n  const value = useMemo(() => ({\n    plugins,\n    toolbarContext\n  }), [plugins, toolbarContext]);\n  return /* @__PURE__ */ jsx(PluginContext.Provider, { value, children });\n}\nfunction usePlugins() {\n  return useContext(PluginContext);\n}\nconst glassyBoxClassName = \\`\n  z-0\n  before:absolute before:content-normal before:size-full before:inset-0 before:border before:border-zinc-950/20 before:ring-inset before:ring-[1.5px] before:ring-white/30 before:backdrop-blur-sm before:-z-20 before:bg-white/85 before:rounded-[inherit]\n  after:absolute after:pointer-events-none after:rounded-[inherit] after:block after:size-full after:inset-0 after:shadow-glass\n\\`;\nfunction Glassy({\n  className,\n  as,\n  ref,\n  children,\n  ...props\n}) {\n  return /* @__PURE__ */ jsxs(\n    as || \"div\",\n    {\n      ref,\n      className: cn(glassyBoxClassName, className),\n      ...props,\n      children: [\n        /* @__PURE__ */ jsx(\"div\", { className: \"-z-10 pointer-events-none absolute inset-0 flex size-full items-center justify-center overflow-hidden rounded-[inherit]\", children: /* @__PURE__ */ jsx(\"div\", { className: \"size-full min-h-48 min-w-48 bg-[image:var(--glass-texture)] bg-center bg-cover bg-no-repeat opacity-30\" }) }),\n        children\n      ]\n    }\n  );\n}\nfunction Panel({\n  children,\n  alwaysFullHeight = !1,\n  className\n}) {\n  return /* @__PURE__ */ jsx(\n    Glassy,\n    {\n      as: \"section\",\n      className: cn(\n        \"pointer-events-auto flex max-h-full min-h-48 flex-col items-stretch justify-start rounded-3xl\",\n        alwaysFullHeight && \"h-full\",\n        className\n      ),\n      children\n    }\n  );\n}\nfunction PanelHeader({\n  title,\n  description,\n  iconArea,\n  actionArea,\n  className\n}) {\n  return /* @__PURE__ */ jsxs(\n    \"header\",\n    {\n      className: cn(\n        \"flex w-auto flex-row items-center justify-between gap-2 rounded-t-[inherit] border-zinc-500/15 border-b bg-gradient-to-b from-transparent via-transparent to-white/5 pt-3 pr-3 pb-2 pl-4 text-foreground\",\n        className\n      ),\n      children: [\n        iconArea,\n        /* @__PURE__ */ jsxs(\"div\", { className: \"flex flex-1 flex-col\", children: [\n          title && /* @__PURE__ */ jsx(\"h3\", { className: \"font-medium text-lg\", children: title }),\n          description && /* @__PURE__ */ jsx(\"p\", { className: \"font-medium text-foreground/70\", children: description })\n        ] }),\n        actionArea,\n        /* @__PURE__ */ jsx(\"div\", { className: \"pointer-events-none absolute right-0 bottom-0 left-0 h-px w-full bg-gradient-to-r from-white/10 via-white/30 to-white/10\" })\n      ]\n    }\n  );\n}\nfunction PanelContent({ children, className, ...props }) {\n  return /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      ...props,\n      className: cn(\n        \"flex flex-1 flex-col gap-2 overflow-y-auto px-4 py-4 text-foreground\",\n        className\n      ),\n      children\n    }\n  );\n}\nfunction PanelFooter({\n  children,\n  className\n}) {\n  return /* @__PURE__ */ jsxs(\n    \"footer\",\n    {\n      className: cn(\n        \"flex flex-row items-end justify-end gap-2 rounded-b-[inherit] border-zinc-500/15 border-t bg-white/5 pt-2 pr-3 pb-3 pl-4 text-foreground/80 text-sm\",\n        className\n      ),\n      children: [\n        /* @__PURE__ */ jsx(\"div\", { className: \"absolute top-0 right-0 left-0 h-px w-full bg-gradient-to-r from-zinc-100/10 via-zinc-100/30 to-zinc-100/10\" }),\n        children\n      ]\n    }\n  );\n}\nfunction Button({\n  children,\n  variant = \"primary\",\n  size = \"md\",\n  glassy = !0,\n  asChild,\n  className,\n  ...props\n}) {\n  return asChild ? /* @__PURE__ */ jsx(\"button\", { ...props, className: \"cursor-pointer\", children }) : /* @__PURE__ */ jsx(\n    \"button\",\n    {\n      ...props,\n      className: cn(\n        \"flex h-12 cursor-pointer items-center justify-center rounded-lg px-4 py-2 font-medium text-sm text-white\",\n        size === \"sm\" && \"h-8\",\n        size === \"md\" && \"h-12\",\n        size === \"lg\" && \"h-16\",\n        variant === \"primary\" && \"bg-blue-600\",\n        variant === \"secondary\" && \"bg-black/5 text-zinc-950/70\",\n        variant === \"outline\" && \"border border-zinc-500 bg-white text-blue-500\",\n        variant === \"ghost\" && \"bg-transparent text-blue-500\",\n        glassy && \"origin-center rounded-xl border border-black/10 ring-1 ring-white/20 transition-all duration-150 ease-out after:absolute after:inset-0 after:size-full after:content-normal after:rounded-[inherit] after:bg-gradient-to-b after:from-white/5 after:to-white/0 after:transition-colors after:duration-150 after:ease-out hover:border-black/5 hover:shadow-xs hover:after:from-blue-50/20 hover:after:to-blue-50/15 active:scale-[98%] active:border-black/15 active:shadow-inset active:after:from-transparent active:after:to-transparent disabled:pointer-events-none disabled:bg-black/5 disabled:text-foreground/60 disabled:opacity-30\",\n        className\n      ),\n      type: \"submit\",\n      children\n    }\n  );\n}\nconst falsyToString = (value) => typeof value == \"boolean\" ? \\`\\${value}\\` : value === 0 ? \"0\" : value, cx = clsx, cva = (base, config) => (props) => {\n  var _config_compoundVariants;\n  if ((config == null ? void 0 : config.variants) == null) return cx(base, props == null ? void 0 : props.class, props == null ? void 0 : props.className);\n  const { variants, defaultVariants } = config, getVariantClassNames = Object.keys(variants).map((variant) => {\n    const variantProp = props == null ? void 0 : props[variant], defaultVariantProp = defaultVariants == null ? void 0 : defaultVariants[variant];\n    if (variantProp === null) return null;\n    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);\n    return variants[variant][variantKey];\n  }), propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {\n    let [key, value] = param;\n    return value === void 0 || (acc[key] = value), acc;\n  }, {}), getCompoundVariantClassNames = config == null || (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {\n    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;\n    return Object.entries(compoundVariantOptions).every((param2) => {\n      let [key, value] = param2;\n      return Array.isArray(value) ? value.includes({\n        ...defaultVariants,\n        ...propsWithoutUndefined\n      }[key]) : {\n        ...defaultVariants,\n        ...propsWithoutUndefined\n      }[key] === value;\n    }) ? [\n      ...acc,\n      cvClass,\n      cvClassName\n    ] : acc;\n  }, []);\n  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props == null ? void 0 : props.class, props == null ? void 0 : props.className);\n};\nexport {\n  AgentStateType as A,\n  Button as B,\n  ConfigProvider as C,\n  Glassy as G,\n  HotkeyActions as H,\n  PanelsProvider as P,\n  useAppState as a,\n  usePlugins as b,\n  useAgentMessaging as c,\n  usePanels as d,\n  collectUserMessageMetadata as e,\n  generateId as f,\n  getSelectedElementInfo as g,\n  AgentProvider as h,\n  AgentAvailabilityProvider as i,\n  AgentMessagingProvider as j,\n  PluginProvider as k,\n  hotkeyActionDefinitions as l,\n  cn as m,\n  getElementAtPoint as n,\n  getXPathForElement as o,\n  useAgentAvailability as p,\n  glassyBoxClassName as q,\n  Panel as r,\n  PanelHeader as s,\n  PanelContent as t,\n  useAgents as u,\n  PanelFooter as v,\n  cva as w,\n  AgentAvailabilityError as x,\n  AppStateProvider as y\n};\n`, \"index.js\": `import * as React from \"react\";\nimport React__default, { createContext, useState, useEffect, useContext, useCallback, useMemo, useRef, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, useReducer, useSyncExternalStore, StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport { jsx, jsxs, Fragment as Fragment$1 } from \"react/jsx-runtime\";\nimport { A as AgentStateType, u as useAgents, a as useAppState, b as usePlugins, c as useAgentMessaging, d as usePanels, e as collectUserMessageMetadata, g as getSelectedElementInfo, f as generateId, C as ConfigProvider, h as AgentProvider, i as AgentAvailabilityProvider, j as AgentMessagingProvider, P as PanelsProvider, k as PluginProvider, H as HotkeyActions, l as hotkeyActionDefinitions, m as cn, n as getElementAtPoint, o as getXPathForElement, p as useAgentAvailability, G as Glassy, q as glassyBoxClassName, r as Panel, s as PanelHeader, t as PanelContent, v as PanelFooter, B as Button, w as cva, x as AgentAvailabilityError, y as AppStateProvider } from \"index-DsC5zpes.js\";\nimport * as ReactDOM from \"react-dom\";\nimport { createPortal, flushSync } from \"react-dom\";\nimport config from \"@stagewise/toolbar/config\";\nconst appStyle = '/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports ((-webkit-hyphens:none) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-translate-x:0;--tw-translate-y:0;--tw-translate-z:0;--tw-scale-x:1;--tw-scale-y:1;--tw-scale-z:1;--tw-rotate-x:initial;--tw-rotate-y:initial;--tw-rotate-z:initial;--tw-skew-x:initial;--tw-skew-y:initial;--tw-space-y-reverse:0;--tw-space-x-reverse:0;--tw-divide-y-reverse:0;--tw-border-style:solid;--tw-gradient-position:initial;--tw-gradient-from:#0000;--tw-gradient-via:#0000;--tw-gradient-to:#0000;--tw-gradient-stops:initial;--tw-gradient-via-stops:initial;--tw-gradient-from-position:0%;--tw-gradient-via-position:50%;--tw-gradient-to-position:100%;--tw-font-weight:initial;--tw-shadow:0 0 #0000;--tw-shadow-color:initial;--tw-shadow-alpha:100%;--tw-inset-shadow:0 0 #0000;--tw-inset-shadow-color:initial;--tw-inset-shadow-alpha:100%;--tw-ring-color:initial;--tw-ring-shadow:0 0 #0000;--tw-inset-ring-color:initial;--tw-inset-ring-shadow:0 0 #0000;--tw-ring-inset:initial;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-offset-shadow:0 0 #0000;--tw-outline-style:solid;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-backdrop-blur:initial;--tw-backdrop-brightness:initial;--tw-backdrop-contrast:initial;--tw-backdrop-grayscale:initial;--tw-backdrop-hue-rotate:initial;--tw-backdrop-invert:initial;--tw-backdrop-opacity:initial;--tw-backdrop-saturate:initial;--tw-backdrop-sepia:initial;--tw-duration:initial;--tw-ease:initial;--tw-content:\"\"}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace;--color-red-100:oklch(93.6% .032 17.717);--color-red-200:oklch(88.5% .062 18.334);--color-red-500:oklch(63.7% .237 25.331);--color-orange-50:oklch(98% .016 73.684);--color-orange-100:oklch(95.4% .038 75.164);--color-orange-200:oklch(90.1% .076 70.697);--color-orange-300:oklch(83.7% .128 66.29);--color-orange-500:oklch(70.5% .213 47.604);--color-orange-600:oklch(64.6% .222 41.116);--color-orange-700:oklch(55.3% .195 38.402);--color-orange-900:oklch(40.8% .123 38.172);--color-yellow-500:oklch(79.5% .184 86.047);--color-lime-200:oklch(93.8% .127 124.321);--color-green-300:oklch(87.1% .15 154.449);--color-green-400:oklch(79.2% .209 151.711);--color-green-500:oklch(72.3% .219 149.579);--color-green-600:oklch(62.7% .194 149.214);--color-emerald-500:oklch(69.6% .17 162.48);--color-teal-300:oklch(85.5% .138 181.071);--color-teal-400:oklch(77.7% .152 181.912);--color-teal-500:oklch(70.4% .14 182.503);--color-cyan-200:oklch(91.7% .08 205.041);--color-sky-100:oklch(95.1% .026 236.824);--color-sky-300:oklch(82.8% .111 230.318);--color-sky-500:oklch(68.5% .169 237.323);--color-blue-50:oklch(97% .014 254.604);--color-blue-100:oklch(93.2% .032 255.585);--color-blue-200:oklch(88.2% .059 254.128);--color-blue-400:oklch(70.7% .165 254.624);--color-blue-500:oklch(62.3% .214 259.815);--color-blue-600:oklch(54.6% .245 262.881);--color-blue-950:oklch(28.2% .091 267.935);--color-indigo-200:oklch(87% .065 274.039);--color-indigo-300:oklch(78.5% .115 274.713);--color-indigo-400:oklch(67.3% .182 276.935);--color-indigo-500:oklch(58.5% .233 277.117);--color-violet-400:oklch(70.2% .183 293.541);--color-violet-600:oklch(54.1% .281 293.009);--color-purple-200:oklch(90.2% .063 306.703);--color-purple-500:oklch(62.7% .265 303.9);--color-fuchsia-400:oklch(74% .238 322.16);--color-fuchsia-700:oklch(51.8% .253 323.949);--color-pink-500:oklch(65.6% .241 354.308);--color-rose-300:oklch(81% .117 11.638);--color-rose-600:oklch(58.6% .253 17.585);--color-zinc-100:oklch(96.7% .001 286.375);--color-zinc-400:oklch(70.5% .015 286.067);--color-zinc-500:oklch(55.2% .016 285.938);--color-zinc-600:oklch(44.2% .017 285.786);--color-zinc-700:oklch(37% .013 285.805);--color-zinc-900:oklch(21% .006 285.885);--color-zinc-950:oklch(14.1% .005 285.823);--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-base:1rem;--text-base--line-height: 1.5 ;--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-normal:400;--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-sm:.25rem;--radius-md:.375rem;--radius-lg:.5rem;--radius-xl:.75rem;--radius-3xl:1.5rem;--shadow-lg:0 10px 15px -3px #0000001a,0 4px 6px -4px #0000001a;--drop-shadow-xl:0 9px 7px #0000001a;--ease-out:cubic-bezier(0,0,.2,1);--ease-in-out:cubic-bezier(.4,0,.2,1);--animate-spin:spin 1s linear infinite;--animate-pulse:pulse 2s cubic-bezier(.4,0,.6,1)infinite;--blur-sm:8px;--blur-md:12px;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono);--color-foreground:var(--color-zinc-950);--color-muted-foreground:var(--color-zinc-700);--color-border:var(--color-zinc-500);--ease-spring:linear(0,-.00946,.0219,.0793,.152,.237,.326,.419,.509,.597,.68,.755,.823,.882,.933,.976,1.01,1.04,1.06,1.07,1.08,1.09,1.09,1.09,1.09,1.08,1.07,1.07,1.06,1.05,1.04,1.03,1.03,1.02,1.01,1.01,1,1,.998,.996,.994,.993,.992,.992,.992,.992,.992,.993,.994,.994,.995,.996,.997,.997,.998,.998,.999,.999,1);--ease-spring-soft:linear(0,-.0531,.117,.293,.46,.61,.738,.838,.913,.965,1,1.02,1.03,1.03,1.03,1.03,1.03,1.02,1.01,1.01,1.01,1,1,1,1);--glass-texture:url(data:image/png;base64,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);--gradient:url(data:image/png;base64,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Lkj8yHXZ5TfOBYf9PFMw0sl5YoFYLLSx3MasaKjE08RhRdUo359xWeG8xVktV1nznvyFoZy2kuI6zWHEsIQ4EhAho4oSyrAQoVUjxUSS9qMe/iHHnyCXTK4SGDkWUIEKyfGD/8Hvbs381KSbFIoCnS+2/TEKBHeBRs22v49tu3ECBJ6BK63lr9SB2U/Say0tfAT0bwMX1y1N3gMud4DBJ10yJEcK0PTn88D7GX1TFhi4BbrX3N6a+zh9ANLU1fINcHAIjBUoe93j3V3tvf17ptnfD1oXcp3/D10UAAAN92lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNC40LjAtRXhpdjIiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICB4bWxuczpzdEV2dD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlRXZlbnQjIgogICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgeG1sbnM6R0lNUD0iaHR0cDovL3d3dy5naW1wLm9yZy94bXAvIgogICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iCiAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgIHhtcE1NOkRvY3VtZW50SUQ9ImdpbXA6ZG9jaWQ6Z2ltcDozYmQzMGE4My01MzllLTQ4MzYtODM3NC02NDJjZmYwYjMwYTEiCiAgIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ZDYyMDQ1MTEtZDhhZS00ZWEzLTk4N2QtODcwZmI3ODRlM2ZmIgogICB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9InhtcC5kaWQ6ZWNmN2VkZGUtY2IyYy00MjY1LWExNTUtOTBlNWJmOTk2MGIxIgogICBkYzpGb3JtYXQ9ImltYWdlL3BuZyIKICAgR0lNUDpBUEk9IjIuMCIKICAgR0lNUDpQbGF0Zm9ybT0iV2luZG93cyIKICAgR0lNUDpUaW1lU3RhbXA9IjE3MTE5MTU5MTA3NTc3NjAiCiAgIEdJTVA6VmVyc2lvbj0iMi4xMC4yNCIKICAgdGlmZjpPcmllbnRhdGlvbj0iMSIKICAgeG1wOkNyZWF0b3JUb29sPSJHSU1QIDIuMTAiPgogICA8eG1wTU06SGlzdG9yeT4KICAgIDxyZGY6U2VxPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpiY2M3MDgxNi1jYjIzLTQxNDItYjg0Yy1lNWMzODhiOGM3ODIiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjQtMDMtMjZUMTA6MTk6MzYiLz4KICAgICA8cmRmOmxpCiAgICAgIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiCiAgICAgIHN0RXZ0OmNoYW5nZWQ9Ii8iCiAgICAgIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6ZThjNGJjZjEtYmQ4Ni00YjVkLTg5MzktOGJmNzBlY2MyZGZkIgogICAgICBzdEV2dDpzb2Z0d2FyZUFnZW50PSJHaW1wIDIuMTAgKFdpbmRvd3MpIgogICAgICBzdEV2dDp3aGVuPSIyMDI0LTAzLTMxVDIyOjExOjUwIi8+CiAgICA8L3JkZjpTZXE+CiAgIDwveG1wTU06SGlzdG9yeT4KICA8L3JkZjpEZXNjcmlwdGlvbj4KIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PlE6FucAAAAGYktHRAD/AP8A/6C9p5MAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfoAx8UCzJJFY2xAAAFJUlEQVRYw3WW0ZbbNgxEL0iQlJymzS/1/5/6JU16dmNbEok+EKJpNZUPjrRaSTMYDAEKf/5lhABNwAx2g+OAxwYfT/h4wI8HPB7AHdiBAzBAPCIQPIR+NH/uAJ4edz8//LyjIB1cxL9p/d1GJ3QYHOeNOn3UHEj8/pWATc+f79pEvD+vtPMdg2ZQDVrroHuDvUKrU+aHX9eJQLjESaBdSFxVayi1MY5mUB14qx4HtGMisE3X53GWIE4AswrtknkcaihbBXEZqgM/dnju/byf4LuDn1H/I+fr49dSMIHyRkS5b73+SK/3dnTwn1uPurlhtksZ5qyaA3BRYCZngF48UVE+7iDB1bJe8/sBP5+wb8Otr9ofk6wziE0ZhktZ5qNNUVH+uTNWghlsrStQ92m5bBfw2c1caps80/McLurYZNCG8v2zK4B0E7Y2ZTuD71PWXOquCIpQMBJGcgJnxHelxKOvgo9fNJDqsf1P41GnED0ygUQgA5lG5qBwDBW0J6kBMhAMooE0FD6mevEmz7vhZBAVhEggoRQSSkLJTqDQyGxkHmTuKKYJbhHWMFXmLAGfTiD+YumcTj+BowMHFiLFCfRfJlAwMpXCRiaTCSnx8bvCl5OAQHqVQeHnRCBMXUqmWgsBQQksBFYiK8oyCGSUjJCdQOZJQUOGr4nn18j+20zAy9AJPFyTOJ15I6VECpGVyG0CX0hDgUgaBA4KmUxcE+1L4vFb5PtJIDsB4SzBfllWMsAjEUVZSawoNyI3v1488kQAEtXNF8nYmthXZV2U7+uFQDhb8Wv0jbUaHLyQWUncPPq1TvJ3+ymJgAKZSmIjETTRSmIriaUoMUdqFijiQo8SyHB4X1JKRlnJI27kQWBxRQqRjJJcJSHRSFS0q6GJPSWKKjkpSw58pmkVRINg6AncP6Oe9RmFlcLNlTgJdPdHsr8VUIRIQ9n9usZIDpEUIzkGlhD4jGHq0E5AvV5lAlwpLBRuLIPMMoEvI/Me4p5p3piMSJZAEiEhJBHKOfCQ1/TF0BuFQmZhfSOwsjiREzy56XRkrgQCASFgRKq35oqwNyGaoAbaILe+9M18x4WBgX5jpfivZ7sMBTp49uV2gqtXuTtGHNQI7IQxmONuxGrEClqNXI3lMO7Rt3rBZ8FXVpf4JFEGpQ6cB3hy6U/wMLXnOu0KAkY4jLgbejTyLpTd+D027sKYA2DoH6xkMmcpCoubLZNHj5vBe94R8exfXaT3T+uamBEfDX0KaROWJ3wVeJrwPfq8MVeguNRl+EEHeBqy944YvS2HAS5Tw27uitaH9IegN6FkWKNxmNAOyNH4pPFsDf3C4pn3pZameqfh9rM14eAyjS0bs7LPyTa2IHGD/AFFjRuGVSEorMH4RmUzJ5Dd5a+s+6TrwPI2K0+Zr4dgXhQh0MbeKP+AKoY1I+xCVthiY7dGbQ3tDjh7el9iycfuuchkVFpoNDff+8A2f+b0R2/MfZtpfxuyNfSLUCLs0ag0jtrQMkmd3eE989dwFocy3xu0aW7YRKaXwFyphgIFQwjop1B+wiZwOIHWGqoOqGNF94/0rBrNBZehRHP7yeQE8Te7AmnSp4+2xo5wGGSDo7VOgIaGUTfxnYB5DjZl+lJCEKqDyyAhw4q9FRvqNLsf+pb1cB0P7EXgZSMbvza23kwUzAFOlcI4y9hPBqB6AZv/7+WL6ATUCVQqei6k5gazIbj53/i9V52jb0q7Uc3rHt72kr1PNBTxHYf5HbxPdMR/Af2SQINNgRTNAAAAAElFTkSuQmCC)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;-moz-tab-size:4;-o-tab-size:4;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\",\"Segoe UI Symbol\",\"Noto Color Emoji\");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,\"Liberation Mono\",\"Courier New\",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::-moz-placeholder{opacity:1}::placeholder{opacity:1}@supports (not (-webkit-appearance:-apple-pay-button)) or (contain-intrinsic-size:1px){::-moz-placeholder{color:currentColor}::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::-moz-placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){-webkit-appearance:button;-moz-appearance:button;appearance:button}::file-selector-button{-webkit-appearance:button;-moz-appearance:button;appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}*{min-width:0;min-height:0;position:relative}body{all:initial;color:var(--color-zinc-950);letter-spacing:normal!important;font-family:Inter,Noto Color Emoji,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,SF Compact,SF Pro,Helvetica Neue,sans-serif!important;font-weight:400!important;line-height:normal!important}@supports (font-variation-settings:normal){body{font-optical-sizing:auto!important;font-family:InterVariable,Noto Color Emoji,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,SF Compact,SF Pro,Helvetica Neue,sans-serif!important}}*{scrollbar-color:initial;scrollbar-width:initial}}@layer components{.chat-loading-gradient{background:linear-gradient(#f8fafccc,#f8fafccc) padding-box padding-box,linear-gradient(45deg,#8b5cf6,#06b6d4,#8b5cf6) 0 0/400% 400% border-box;border:2px solid #0000;animation:2s infinite gradient-animation}.chat-success-border{animation:2s ease-out blink-green-fade}.chat-error-border{animation:1s ease-out blink-red-fade}@keyframes blink-green-fade{0%,50%{box-shadow:0 0 0 2px #22c55eb3}to{box-shadow:0 0 0 2px #22c55e00}}@keyframes blink-red-fade{0%,50%{box-shadow:0 0 0 2px #ef4444}to{box-shadow:0 0 0 2px #ef444400}}@property --chat-grad-bg-bg-color{syntax: \"<color>\"; inherits: true; initial-value: #0d253f;}@property --chat-grad-bg-c1{syntax: \"<color>\"; inherits: true; initial-value: #1e40af;}@property --chat-grad-bg-c2{syntax: \"<color>\"; inherits: true; initial-value: #2563eb;}@property --chat-grad-bg-c3{syntax: \"<color>\"; inherits: true; initial-value: #3b82f6;}@property --chat-grad-bg-c4{syntax: \"<color>\"; inherits: true; initial-value: #60a5fa;}@property --chat-grad-bg-opacity-slow{syntax: \"<number>\"; inherits: true; initial-value: 1;}@property --chat-grad-bg-opacity-medium{syntax: \"<number>\"; inherits: true; initial-value: 0;}@property --chat-grad-bg-opacity-fast{syntax: \"<number>\"; inherits: true; initial-value: 0;}@property --chat-grad-bg-overall-opacity{syntax: \"<number>\"; inherits: true; initial-value: 1;}@keyframes chat-grad-bg-move{0%{transform:translate(0)}20%{transform:translate(15vw,-10vh)scale(1.1)}40%{transform:translate(-10vw,15vh)scale(.9)}60%{transform:translate(10vw,10vh)scale(1.2)}80%{transform:translate(5vw,-15vh)scale(1)}to{transform:translate(0)}}.shape-anim{transition:fill 1s ease-in-out;animation-name:chat-grad-bg-move;animation-timing-function:ease-in-out;animation-iteration-count:infinite}.g-slow{opacity:var(--chat-grad-bg-opacity-slow);transition:opacity 1s ease-in-out}.g-medium{opacity:var(--chat-grad-bg-opacity-medium);transition:opacity 1s ease-in-out}.g-fast{opacity:var(--chat-grad-bg-opacity-fast);transition:opacity 1s ease-in-out}}@layer utilities{.pointer-events-auto{pointer-events:auto}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.-inset-\\\\\\\\[25\\\\\\\\%\\\\\\\\]{top:-25%;right:-25%;bottom:-25%;left:-25%}.inset-0{inset:calc(var(--spacing)*0)}.inset-4{inset:calc(var(--spacing)*4)}.top-0{top:calc(var(--spacing)*0)}.top-0\\\\\\\\.5{top:calc(var(--spacing)*.5)}.top-\\\\\\\\[25\\\\\\\\%\\\\\\\\]{top:25%}.right-0{right:calc(var(--spacing)*0)}.right-12{right:calc(var(--spacing)*12)}.bottom-0{bottom:calc(var(--spacing)*0)}.bottom-3{bottom:calc(var(--spacing)*3)}.left-0{left:calc(var(--spacing)*0)}.left-0\\\\\\\\.5{left:calc(var(--spacing)*.5)}.left-3{left:calc(var(--spacing)*3)}.left-12{left:calc(var(--spacing)*12)}.left-\\\\\\\\[25\\\\\\\\%\\\\\\\\]{left:25%}.-z-10{z-index:-10}.z-0{z-index:0}.z-10{z-index:10}.z-50{z-index:50}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.m-1{margin:calc(var(--spacing)*1)}.mt-0{margin-top:calc(var(--spacing)*0)}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-3{margin-top:calc(var(--spacing)*3)}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-px{margin-right:1px}.mb-0{margin-bottom:calc(var(--spacing)*0)}.mb-1\\\\\\\\.5{margin-bottom:calc(var(--spacing)*1.5)}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-3{margin-bottom:calc(var(--spacing)*3)}.mb-px{margin-bottom:1px}.ml-2{margin-left:calc(var(--spacing)*2)}.scrollbar-thin::-webkit-scrollbar-track{background-color:var(--scrollbar-track);border-radius:var(--scrollbar-track-radius)}.scrollbar-thin::-webkit-scrollbar-thumb{background-color:var(--scrollbar-thumb);border-radius:var(--scrollbar-thumb-radius)}.scrollbar-thin::-webkit-scrollbar-corner{background-color:var(--scrollbar-corner);border-radius:var(--scrollbar-corner-radius)}.scrollbar-thin{scrollbar-width:thin;scrollbar-color:var(--scrollbar-thumb,initial)var(--scrollbar-track,initial)}.scrollbar-thin::-webkit-scrollbar{width:8px;height:8px;display:block}.block{display:block}.contents{display:contents}.flex{display:flex}.hidden{display:none}.inline{display:inline}.aspect-square{aspect-ratio:1}.size-0{width:calc(var(--spacing)*0);height:calc(var(--spacing)*0)}.size-1\\\\\\\\.5{width:calc(var(--spacing)*1.5);height:calc(var(--spacing)*1.5)}.size-1\\\\\\\\/2{width:50%;height:50%}.size-2\\\\\\\\/3{width:66.6667%;height:66.6667%}.size-3{width:calc(var(--spacing)*3);height:calc(var(--spacing)*3)}.size-4{width:calc(var(--spacing)*4);height:calc(var(--spacing)*4)}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.size-6{width:calc(var(--spacing)*6);height:calc(var(--spacing)*6)}.size-8{width:calc(var(--spacing)*8);height:calc(var(--spacing)*8)}.size-10{width:calc(var(--spacing)*10);height:calc(var(--spacing)*10)}.size-12{width:calc(var(--spacing)*12);height:calc(var(--spacing)*12)}.size-auto{width:auto;height:auto}.size-full{width:100%;height:100%}.\\\\\\\\!h-\\\\\\\\[calc-size\\\\\\\\(auto\\\\\\\\,size\\\\\\\\)\\\\\\\\]{height:calc-size(auto,size)!important}.h-0{height:calc(var(--spacing)*0)}.h-3{height:calc(var(--spacing)*3)}.h-5{height:calc(var(--spacing)*5)}.h-8{height:calc(var(--spacing)*8)}.h-12{height:calc(var(--spacing)*12)}.h-16{height:calc(var(--spacing)*16)}.h-24{height:calc(var(--spacing)*24)}.h-36{height:calc(var(--spacing)*36)}.h-\\\\\\\\[1\\\\\\\\.2em\\\\\\\\]{height:1.2em}.h-\\\\\\\\[35vh\\\\\\\\]{height:35vh}.h-\\\\\\\\[50\\\\\\\\%\\\\\\\\]{height:50%}.h-\\\\\\\\[150\\\\\\\\%\\\\\\\\]{height:150%}.h-\\\\\\\\[calc-size\\\\\\\\(auto\\\\\\\\,size\\\\\\\\)\\\\\\\\]{height:calc-size(auto,size)}.h-auto{height:auto}.h-full{height:100%}.h-px{height:1px}.h-screen{height:100vh}.max-h-\\\\\\\\[50vh\\\\\\\\]{max-height:50vh}.max-h-full{max-height:100%}.min-h-0{min-height:calc(var(--spacing)*0)}.min-h-48{min-height:calc(var(--spacing)*48)}.min-h-\\\\\\\\[20vh\\\\\\\\]{min-height:20vh}.w-96{width:calc(var(--spacing)*96)}.w-\\\\\\\\[50\\\\\\\\%\\\\\\\\]{width:50%}.w-\\\\\\\\[150\\\\\\\\%\\\\\\\\]{width:150%}.w-auto{width:auto}.w-fit{width:-moz-fit-content;width:fit-content}.w-full{width:100%}.w-max{width:-moz-max-content;width:max-content}.w-screen{width:100vw}.max-w-8{max-width:calc(var(--spacing)*8)}.max-w-24{max-width:calc(var(--spacing)*24)}.max-w-90{max-width:calc(var(--spacing)*90)}.max-w-\\\\\\\\[calc\\\\\\\\(100\\\\\\\\%-48px\\\\\\\\)\\\\\\\\]{max-width:calc(100% - 48px)}.max-w-full{max-width:100%}.min-w-0{min-width:calc(var(--spacing)*0)}.min-w-3{min-width:calc(var(--spacing)*3)}.min-w-24{min-width:calc(var(--spacing)*24)}.min-w-48{min-width:calc(var(--spacing)*48)}.min-w-fit{min-width:-moz-fit-content;min-width:fit-content}.flex-1{flex:1}.shrink-0{flex-shrink:0}.basis-\\\\\\\\[initial\\\\\\\\]{flex-basis:initial}.origin-bottom{transform-origin:bottom}.origin-center{transform-origin:50%}.origin-left{transform-origin:0}.origin-right{transform-origin:100%}.origin-top{transform-origin:top}.-translate-y-2{--tw-translate-y:calc(var(--spacing)*-2);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-0{--tw-translate-y:calc(var(--spacing)*0);translate:var(--tw-translate-x)var(--tw-translate-y)}.translate-y-2{--tw-translate-y:calc(var(--spacing)*2);translate:var(--tw-translate-x)var(--tw-translate-y)}.scale-0{--tw-scale-x:0%;--tw-scale-y:0%;--tw-scale-z:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-25{--tw-scale-x:25%;--tw-scale-y:25%;--tw-scale-z:25%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-50{--tw-scale-x:50%;--tw-scale-y:50%;--tw-scale-z:50%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-95{--tw-scale-x:95%;--tw-scale-y:95%;--tw-scale-z:95%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-100{--tw-scale-x:100%;--tw-scale-y:100%;--tw-scale-z:100%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-110{--tw-scale-x:110%;--tw-scale-y:110%;--tw-scale-z:110%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-x-75{--tw-scale-x:75%;scale:var(--tw-scale-x)var(--tw-scale-y)}.scale-y-0{--tw-scale-y:0%;scale:var(--tw-scale-x)var(--tw-scale-y)}.transform{transform:var(--tw-rotate-x,)var(--tw-rotate-y,)var(--tw-rotate-z,)var(--tw-skew-x,)var(--tw-skew-y,)}.animate-pulse{animation:var(--animate-pulse)}.animate-spin{animation:var(--animate-spin)}.cursor-copy{cursor:copy}.cursor-default{cursor:default}.cursor-not-allowed{cursor:not-allowed}.cursor-pointer{cursor:pointer}.resize{resize:both}.resize-none{resize:none}.snap-start{scroll-snap-align:start}.list-inside{list-style-position:inside}.list-decimal{list-style-type:decimal}.flex-col{flex-direction:column}.flex-col-reverse{flex-direction:column-reverse}.flex-row{flex-direction:row}.flex-row-reverse{flex-direction:row-reverse}.items-center{align-items:center}.items-end{align-items:flex-end}.items-start{align-items:flex-start}.items-stretch{align-items:stretch}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.justify-end{justify-content:flex-end}.justify-start{justify-content:flex-start}.gap-0{gap:calc(var(--spacing)*0)}.gap-0\\\\\\\\.5{gap:calc(var(--spacing)*.5)}.gap-1{gap:calc(var(--spacing)*1)}.gap-2{gap:calc(var(--spacing)*2)}:where(.space-y-1>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*1)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*1)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-2>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*2)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-y-3>:not(:last-child)){--tw-space-y-reverse:0;margin-block-start:calc(calc(var(--spacing)*3)*var(--tw-space-y-reverse));margin-block-end:calc(calc(var(--spacing)*3)*calc(1 - var(--tw-space-y-reverse)))}:where(.space-x-2>:not(:last-child)){--tw-space-x-reverse:0;margin-inline-start:calc(calc(var(--spacing)*2)*var(--tw-space-x-reverse));margin-inline-end:calc(calc(var(--spacing)*2)*calc(1 - var(--tw-space-x-reverse)))}:where(.divide-y>:not(:last-child)){--tw-divide-y-reverse:0;border-bottom-style:var(--tw-border-style);border-top-style:var(--tw-border-style);border-top-width:calc(1px*var(--tw-divide-y-reverse));border-bottom-width:calc(1px*calc(1 - var(--tw-divide-y-reverse)))}:where(.divide-y-reverse>:not(:last-child)){--tw-divide-y-reverse:1}:where(.divide-border\\\\\\\\/20>:not(:last-child)){border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){:where(.divide-border\\\\\\\\/20>:not(:last-child)){border-color:color-mix(in oklab,var(--color-border)20%,transparent)}}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.overflow-hidden{overflow:hidden}.overflow-visible{overflow:visible}.overflow-x-auto{overflow-x:auto}.overflow-y-auto{overflow-y:auto}.overflow-y-scroll{overflow-y:scroll}.overscroll-contain{overscroll-behavior:contain}.rounded-3xl{border-radius:var(--radius-3xl)}.rounded-\\\\\\\\[inherit\\\\\\\\]{border-radius:inherit}.rounded-full{border-radius:3.40282e38px}.rounded-lg{border-radius:var(--radius-lg)}.rounded-md{border-radius:var(--radius-md)}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.rounded-t-3xl{border-top-left-radius:var(--radius-3xl);border-top-right-radius:var(--radius-3xl)}.rounded-t-\\\\\\\\[inherit\\\\\\\\]{border-top-left-radius:inherit;border-top-right-radius:inherit}.rounded-t-lg{border-top-left-radius:var(--radius-lg);border-top-right-radius:var(--radius-lg)}.rounded-t-none{border-top-left-radius:0;border-top-right-radius:0}.rounded-b-3xl{border-bottom-right-radius:var(--radius-3xl);border-bottom-left-radius:var(--radius-3xl)}.rounded-b-\\\\\\\\[inherit\\\\\\\\]{border-bottom-right-radius:inherit;border-bottom-left-radius:inherit}.rounded-b-lg{border-bottom-right-radius:var(--radius-lg);border-bottom-left-radius:var(--radius-lg)}.border{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-t{border-top-style:var(--tw-border-style);border-top-width:1px}.border-b{border-bottom-style:var(--tw-border-style);border-bottom-width:1px}.border-dotted{--tw-border-style:dotted;border-style:dotted}.border-black\\\\\\\\/10{border-color:#0000001a}@supports (color:color-mix(in lab,red,red)){.border-black\\\\\\\\/10{border-color:color-mix(in oklab,var(--color-black)10%,transparent)}}.border-black\\\\\\\\/15{border-color:#00000026}@supports (color:color-mix(in lab,red,red)){.border-black\\\\\\\\/15{border-color:color-mix(in oklab,var(--color-black)15%,transparent)}}.border-blue-500{border-color:var(--color-blue-500)}.border-blue-600\\\\\\\\/70{border-color:#155dfcb3}@supports (color:color-mix(in lab,red,red)){.border-blue-600\\\\\\\\/70{border-color:color-mix(in oklab,var(--color-blue-600)70%,transparent)}}.border-border\\\\\\\\/20{border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){.border-border\\\\\\\\/20{border-color:color-mix(in oklab,var(--color-border)20%,transparent)}}.border-green-500{border-color:var(--color-green-500)}.border-orange-500{border-color:var(--color-orange-500)}.border-pink-500{border-color:var(--color-pink-500)}.border-purple-500{border-color:var(--color-purple-500)}.border-red-500{border-color:var(--color-red-500)}.border-transparent{border-color:#0000}.border-yellow-500{border-color:var(--color-yellow-500)}.border-zinc-500{border-color:var(--color-zinc-500)}.border-zinc-500\\\\\\\\/15{border-color:#71717b26}@supports (color:color-mix(in lab,red,red)){.border-zinc-500\\\\\\\\/15{border-color:color-mix(in oklab,var(--color-zinc-500)15%,transparent)}}.border-zinc-500\\\\\\\\/20{border-color:#71717b33}@supports (color:color-mix(in lab,red,red)){.border-zinc-500\\\\\\\\/20{border-color:color-mix(in oklab,var(--color-zinc-500)20%,transparent)}}.border-zinc-600\\\\\\\\/70{border-color:#52525cb3}@supports (color:color-mix(in lab,red,red)){.border-zinc-600\\\\\\\\/70{border-color:color-mix(in oklab,var(--color-zinc-600)70%,transparent)}}.border-zinc-950\\\\\\\\/10{border-color:#09090b1a}@supports (color:color-mix(in lab,red,red)){.border-zinc-950\\\\\\\\/10{border-color:color-mix(in oklab,var(--color-zinc-950)10%,transparent)}}.bg-black\\\\\\\\/5{background-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.bg-black\\\\\\\\/5{background-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.bg-blue-400\\\\\\\\/10{background-color:#54a2ff1a}@supports (color:color-mix(in lab,red,red)){.bg-blue-400\\\\\\\\/10{background-color:color-mix(in oklab,var(--color-blue-400)10%,transparent)}}.bg-blue-500{background-color:var(--color-blue-500)}.bg-blue-600{background-color:var(--color-blue-600)}.bg-blue-600\\\\\\\\/5{background-color:#155dfc0d}@supports (color:color-mix(in lab,red,red)){.bg-blue-600\\\\\\\\/5{background-color:color-mix(in oklab,var(--color-blue-600)5%,transparent)}}.bg-blue-950\\\\\\\\/80{background-color:#162456cc}@supports (color:color-mix(in lab,red,red)){.bg-blue-950\\\\\\\\/80{background-color:color-mix(in oklab,var(--color-blue-950)80%,transparent)}}.bg-green-500{background-color:var(--color-green-500)}.bg-orange-200\\\\\\\\/50{background-color:#ffd7a880}@supports (color:color-mix(in lab,red,red)){.bg-orange-200\\\\\\\\/50{background-color:color-mix(in oklab,var(--color-orange-200)50%,transparent)}}.bg-orange-500{background-color:var(--color-orange-500)}.bg-pink-500{background-color:var(--color-pink-500)}.bg-purple-500{background-color:var(--color-purple-500)}.bg-red-500{background-color:var(--color-red-500)}.bg-rose-600{background-color:var(--color-rose-600)}.bg-sky-100\\\\\\\\/60{background-color:#dff2fe99}@supports (color:color-mix(in lab,red,red)){.bg-sky-100\\\\\\\\/60{background-color:color-mix(in oklab,var(--color-sky-100)60%,transparent)}}.bg-transparent{background-color:#0000}.bg-white{background-color:var(--color-white)}.bg-white\\\\\\\\/5{background-color:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.bg-white\\\\\\\\/5{background-color:color-mix(in oklab,var(--color-white)5%,transparent)}}.bg-white\\\\\\\\/10{background-color:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.bg-white\\\\\\\\/10{background-color:color-mix(in oklab,var(--color-white)10%,transparent)}}.bg-yellow-500{background-color:var(--color-yellow-500)}.bg-zinc-500{background-color:var(--color-zinc-500)}.bg-zinc-500\\\\\\\\/10{background-color:#71717b1a}@supports (color:color-mix(in lab,red,red)){.bg-zinc-500\\\\\\\\/10{background-color:color-mix(in oklab,var(--color-zinc-500)10%,transparent)}}.bg-zinc-700\\\\\\\\/80{background-color:#3f3f46cc}@supports (color:color-mix(in lab,red,red)){.bg-zinc-700\\\\\\\\/80{background-color:color-mix(in oklab,var(--color-zinc-700)80%,transparent)}}.bg-zinc-950\\\\\\\\/5{background-color:#09090b0d}@supports (color:color-mix(in lab,red,red)){.bg-zinc-950\\\\\\\\/5{background-color:color-mix(in oklab,var(--color-zinc-950)5%,transparent)}}.bg-gradient-to-b{--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-gradient-to-r{--tw-gradient-position:to right in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.bg-radial{--tw-gradient-position:in oklab;background-image:radial-gradient(var(--tw-gradient-stops))}.bg-\\\\\\\\[image\\\\\\\\:var\\\\\\\\(--glass-texture\\\\\\\\)\\\\\\\\]{background-image:var(--glass-texture)}.bg-\\\\\\\\[image\\\\\\\\:var\\\\\\\\(--gradient\\\\\\\\)\\\\\\\\]{background-image:var(--gradient)}.from-transparent{--tw-gradient-from:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-white\\\\\\\\/10{--tw-gradient-from:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.from-white\\\\\\\\/10{--tw-gradient-from:color-mix(in oklab,var(--color-white)10%,transparent)}}.from-white\\\\\\\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-zinc-100\\\\\\\\/10{--tw-gradient-from:#f4f4f51a}@supports (color:color-mix(in lab,red,red)){.from-zinc-100\\\\\\\\/10{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)10%,transparent)}}.from-zinc-100\\\\\\\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-zinc-100\\\\\\\\/60{--tw-gradient-from:#f4f4f599}@supports (color:color-mix(in lab,red,red)){.from-zinc-100\\\\\\\\/60{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)60%,transparent)}}.from-zinc-100\\\\\\\\/60{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.from-30\\\\\\\\%{--tw-gradient-from-position:30%}.via-transparent{--tw-gradient-via:transparent;--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-white\\\\\\\\/30{--tw-gradient-via:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.via-white\\\\\\\\/30{--tw-gradient-via:color-mix(in oklab,var(--color-white)30%,transparent)}}.via-white\\\\\\\\/30{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.via-zinc-100\\\\\\\\/30{--tw-gradient-via:#f4f4f54d}@supports (color:color-mix(in lab,red,red)){.via-zinc-100\\\\\\\\/30{--tw-gradient-via:color-mix(in oklab,var(--color-zinc-100)30%,transparent)}}.via-zinc-100\\\\\\\\/30{--tw-gradient-via-stops:var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-via)var(--tw-gradient-via-position),var(--tw-gradient-to)var(--tw-gradient-to-position);--tw-gradient-stops:var(--tw-gradient-via-stops)}.to-transparent{--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-white\\\\\\\\/5{--tw-gradient-to:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.to-white\\\\\\\\/5{--tw-gradient-to:color-mix(in oklab,var(--color-white)5%,transparent)}}.to-white\\\\\\\\/5{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-white\\\\\\\\/10{--tw-gradient-to:#ffffff1a}@supports (color:color-mix(in lab,red,red)){.to-white\\\\\\\\/10{--tw-gradient-to:color-mix(in oklab,var(--color-white)10%,transparent)}}.to-white\\\\\\\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-100\\\\\\\\/0{--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.to-zinc-100\\\\\\\\/0{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)0%,transparent)}}.to-zinc-100\\\\\\\\/0{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-zinc-100\\\\\\\\/10{--tw-gradient-to:#f4f4f51a}@supports (color:color-mix(in lab,red,red)){.to-zinc-100\\\\\\\\/10{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)10%,transparent)}}.to-zinc-100\\\\\\\\/10{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.to-75\\\\\\\\%{--tw-gradient-to-position:75%}.mask-\\\\\\\\[linear-gradient\\\\\\\\(to_bottom\\\\\\\\,transparent_0\\\\\\\\%\\\\\\\\,black_5\\\\\\\\%\\\\\\\\,black_95\\\\\\\\%\\\\\\\\,transparent_100\\\\\\\\%\\\\\\\\)\\\\\\\\]{-webkit-mask-image:linear-gradient(#0000 0%,#000 5% 95%,#0000 100%);mask-image:linear-gradient(#0000,#000 5%,#000 95%,#0000)}.bg-cover{background-size:cover}.bg-center{background-position:50%}.bg-no-repeat{background-repeat:no-repeat}.mask-alpha{-webkit-mask-source-type:alpha;mask-mode:alpha}.fill-\\\\\\\\[var\\\\\\\\(--active\\\\\\\\)\\\\\\\\]{fill:var(--active)}.fill-current{fill:currentColor}.fill-white{fill:var(--color-white)}.fill-zinc-500\\\\\\\\/50{fill:#71717b80}@supports (color:color-mix(in lab,red,red)){.fill-zinc-500\\\\\\\\/50{fill:color-mix(in oklab,var(--color-zinc-500)50%,transparent)}}.fill-zinc-950{fill:var(--color-zinc-950)}.stroke-\\\\\\\\[var\\\\\\\\(--active\\\\\\\\)\\\\\\\\]{stroke:var(--active)}.stroke-\\\\\\\\[var\\\\\\\\(--primary\\\\\\\\)\\\\\\\\]{stroke:var(--primary)}.stroke-black\\\\\\\\/30{stroke:#0000004d}@supports (color:color-mix(in lab,red,red)){.stroke-black\\\\\\\\/30{stroke:color-mix(in oklab,var(--color-black)30%,transparent)}}.stroke-blue-600{stroke:var(--color-blue-600)}.stroke-fuchsia-700{stroke:var(--color-fuchsia-700)}.stroke-green-600{stroke:var(--color-green-600)}.stroke-none{stroke:none}.stroke-rose-600{stroke:var(--color-rose-600)}.stroke-violet-600{stroke:var(--color-violet-600)}.stroke-white{stroke:var(--color-white)}.stroke-1{stroke-width:1px}.stroke-3{stroke-width:3px}.p-0{padding:calc(var(--spacing)*0)}.p-0\\\\\\\\.5{padding:calc(var(--spacing)*.5)}.p-1{padding:calc(var(--spacing)*1)}.p-2{padding:calc(var(--spacing)*2)}.p-3{padding:calc(var(--spacing)*3)}.px-0\\\\\\\\.5{padding-inline:calc(var(--spacing)*.5)}.px-1{padding-inline:calc(var(--spacing)*1)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-3{padding-inline:calc(var(--spacing)*3)}.px-4{padding-inline:calc(var(--spacing)*4)}.py-0{padding-block:calc(var(--spacing)*0)}.py-0\\\\\\\\.5{padding-block:calc(var(--spacing)*.5)}.py-1{padding-block:calc(var(--spacing)*1)}.py-1\\\\\\\\.5{padding-block:calc(var(--spacing)*1.5)}.py-2{padding-block:calc(var(--spacing)*2)}.py-4{padding-block:calc(var(--spacing)*4)}.pt-1{padding-top:calc(var(--spacing)*1)}.pt-2{padding-top:calc(var(--spacing)*2)}.pt-3{padding-top:calc(var(--spacing)*3)}.pr-3{padding-right:calc(var(--spacing)*3)}.pr-6{padding-right:calc(var(--spacing)*6)}.pb-1{padding-bottom:calc(var(--spacing)*1)}.pb-2{padding-bottom:calc(var(--spacing)*2)}.pb-3{padding-bottom:calc(var(--spacing)*3)}.pl-2{padding-left:calc(var(--spacing)*2)}.pl-3{padding-left:calc(var(--spacing)*3)}.pl-4{padding-left:calc(var(--spacing)*4)}.text-base{font-size:var(--text-base);line-height:var(--tw-leading,var(--text-base--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.text-\\\\\\\\[0\\\\\\\\.5em\\\\\\\\]{font-size:.5em}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-normal{--tw-font-weight:var(--font-weight-normal);font-weight:var(--font-weight-normal)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.whitespace-pre-wrap{white-space:pre-wrap}.text-\\\\\\\\[var\\\\\\\\(--active\\\\\\\\)\\\\\\\\]{color:var(--active)}.text-\\\\\\\\[var\\\\\\\\(--primary\\\\\\\\)\\\\\\\\]{color:var(--primary)}.text-blue-500{color:var(--color-blue-500)}.text-current{color:currentColor}.text-foreground{color:var(--color-foreground)}.text-foreground\\\\\\\\/40{color:#09090b66}@supports (color:color-mix(in lab,red,red)){.text-foreground\\\\\\\\/40{color:color-mix(in oklab,var(--color-foreground)40%,transparent)}}.text-foreground\\\\\\\\/70{color:#09090bb3}@supports (color:color-mix(in lab,red,red)){.text-foreground\\\\\\\\/70{color:color-mix(in oklab,var(--color-foreground)70%,transparent)}}.text-foreground\\\\\\\\/80{color:#09090bcc}@supports (color:color-mix(in lab,red,red)){.text-foreground\\\\\\\\/80{color:color-mix(in oklab,var(--color-foreground)80%,transparent)}}.text-muted-foreground{color:var(--color-muted-foreground)}.text-white{color:var(--color-white)}.text-zinc-950{color:var(--color-zinc-950)}.text-zinc-950\\\\\\\\/70{color:#09090bb3}@supports (color:color-mix(in lab,red,red)){.text-zinc-950\\\\\\\\/70{color:color-mix(in oklab,var(--color-zinc-950)70%,transparent)}}.opacity-0{opacity:0}.opacity-30{opacity:.3}.opacity-50{opacity:.5}.opacity-80{opacity:.8}.opacity-100{opacity:1}.shadow-2xs{--tw-shadow:0 1px var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-lg{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-md{--tw-shadow:0 4px 6px -1px var(--tw-shadow-color,#0000001a),0 2px 4px -2px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-sm{--tw-shadow:0 1px 3px 0 var(--tw-shadow-color,#0000001a),0 1px 2px -1px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.ring-1{--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.shadow-black\\\\\\\\/50{--tw-shadow-color:#00000080}@supports (color:color-mix(in lab,red,red)){.shadow-black\\\\\\\\/50{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-black)50%,transparent)var(--tw-shadow-alpha),transparent)}}.shadow-sky-500\\\\\\\\/10{--tw-shadow-color:#00a5ef1a}@supports (color:color-mix(in lab,red,red)){.shadow-sky-500\\\\\\\\/10{--tw-shadow-color:color-mix(in oklab,color-mix(in oklab,var(--color-sky-500)10%,transparent)var(--tw-shadow-alpha),transparent)}}.ring-white\\\\\\\\/20{--tw-ring-color:#fff3}@supports (color:color-mix(in lab,red,red)){.ring-white\\\\\\\\/20{--tw-ring-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.outline{outline-style:var(--tw-outline-style);outline-width:1px}.blur{--tw-blur:blur(8px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-\\\\\\\\[0\\\\\\\\.2px\\\\\\\\]{--tw-blur:blur(.2px);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-md{--tw-blur:blur(var(--blur-md));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-none{--tw-blur: ;filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.blur-sm{--tw-blur:blur(var(--blur-sm));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.brightness-75{--tw-brightness:brightness(75%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.brightness-90{--tw-brightness:brightness(90%);filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.drop-shadow-xl{--tw-drop-shadow-size:drop-shadow(0 9px 7px var(--tw-drop-shadow-color,#0000001a));--tw-drop-shadow:drop-shadow(var(--drop-shadow-xl));filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.backdrop-saturate-150{--tw-backdrop-saturate:saturate(150%);-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-all{transition-property:all;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-colors{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.transition-transform{transition-property:transform,translate,scale,rotate;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.duration-100{--tw-duration:.1s;transition-duration:.1s}.duration-150{--tw-duration:.15s;transition-duration:.15s}.duration-300{--tw-duration:.3s;transition-duration:.3s}.duration-500{--tw-duration:.5s;transition-duration:.5s}.duration-1000{--tw-duration:1s;transition-duration:1s}.ease-in-out{--tw-ease:var(--ease-in-out);transition-timing-function:var(--ease-in-out)}.ease-out{--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.ease-spring{--tw-ease:var(--ease-spring);transition-timing-function:var(--ease-spring)}.ease-spring-soft{--tw-ease:var(--ease-spring-soft);transition-timing-function:var(--ease-spring-soft)}.outline-none{--tw-outline-style:none;outline-style:none}.select-none{-webkit-user-select:none;-moz-user-select:none;user-select:none}.\\\\\\\\[--active-secondary\\\\\\\\:var\\\\\\\\(--color-blue-100\\\\\\\\)\\\\\\\\]{--active-secondary:var(--color-blue-100)}.\\\\\\\\[--active-secondary\\\\\\\\:var\\\\\\\\(--color-orange-100\\\\\\\\)\\\\\\\\]{--active-secondary:var(--color-orange-100)}.\\\\\\\\[--active\\\\\\\\:var\\\\\\\\(--color-blue-600\\\\\\\\)\\\\\\\\]{--active:var(--color-blue-600)}.\\\\\\\\[--active\\\\\\\\:var\\\\\\\\(--color-orange-600\\\\\\\\)\\\\\\\\]{--active:var(--color-orange-600)}.\\\\\\\\[--color-foreground\\\\\\\\:var\\\\\\\\(--color-orange-700\\\\\\\\)\\\\\\\\]{--color-foreground:var(--color-orange-700)}.\\\\\\\\[--color-muted-foreground\\\\\\\\:var\\\\\\\\(--color-orange-600\\\\\\\\)\\\\\\\\]{--color-muted-foreground:var(--color-orange-600)}.\\\\\\\\[--primary\\\\\\\\:var\\\\\\\\(--color-orange-900\\\\\\\\)\\\\\\\\]{--primary:var(--color-orange-900)}.\\\\\\\\[--primary\\\\\\\\:var\\\\\\\\(--color-zinc-950\\\\\\\\)\\\\\\\\]{--primary:var(--color-zinc-950)}.\\\\\\\\[--secondary\\\\\\\\:var\\\\\\\\(--color-orange-100\\\\\\\\)\\\\\\\\]{--secondary:var(--color-orange-100)}.\\\\\\\\[--secondary\\\\\\\\:var\\\\\\\\(--color-zinc-400\\\\\\\\)\\\\\\\\]{--secondary:var(--color-zinc-400)}:is(.\\\\\\\\*\\\\\\\\:size-full>*){width:100%;height:100%}.before\\\\\\\\:absolute:before{content:var(--tw-content);position:absolute}.before\\\\\\\\:inset-0:before{content:var(--tw-content);inset:calc(var(--spacing)*0)}.before\\\\\\\\:-z-20:before{content:var(--tw-content);z-index:-20}.before\\\\\\\\:size-full:before{content:var(--tw-content);width:100%;height:100%}.before\\\\\\\\:content-normal:before{content:var(--tw-content);align-content:normal}.before\\\\\\\\:rounded-\\\\\\\\[inherit\\\\\\\\]:before{content:var(--tw-content);border-radius:inherit}.before\\\\\\\\:border:before{content:var(--tw-content);border-style:var(--tw-border-style);border-width:1px}.before\\\\\\\\:border-zinc-950\\\\\\\\/20:before{content:var(--tw-content);border-color:#09090b33}@supports (color:color-mix(in lab,red,red)){.before\\\\\\\\:border-zinc-950\\\\\\\\/20:before{border-color:color-mix(in oklab,var(--color-zinc-950)20%,transparent)}}.before\\\\\\\\:bg-orange-50\\\\\\\\/80:before{content:var(--tw-content);background-color:#fff7edcc}@supports (color:color-mix(in lab,red,red)){.before\\\\\\\\:bg-orange-50\\\\\\\\/80:before{background-color:color-mix(in oklab,var(--color-orange-50)80%,transparent)}}.before\\\\\\\\:bg-white\\\\\\\\/85:before{content:var(--tw-content);background-color:#ffffffd9}@supports (color:color-mix(in lab,red,red)){.before\\\\\\\\:bg-white\\\\\\\\/85:before{background-color:color-mix(in oklab,var(--color-white)85%,transparent)}}.before\\\\\\\\:ring-\\\\\\\\[1\\\\\\\\.5px\\\\\\\\]:before{content:var(--tw-content);--tw-ring-shadow:var(--tw-ring-inset,)0 0 0 calc(1.5px + var(--tw-ring-offset-width))var(--tw-ring-color,currentcolor);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.before\\\\\\\\:ring-white\\\\\\\\/30:before{content:var(--tw-content);--tw-ring-color:#ffffff4d}@supports (color:color-mix(in lab,red,red)){.before\\\\\\\\:ring-white\\\\\\\\/30:before{--tw-ring-color:color-mix(in oklab,var(--color-white)30%,transparent)}}.before\\\\\\\\:backdrop-blur-sm:before{content:var(--tw-content);--tw-backdrop-blur:blur(var(--blur-sm));-webkit-backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,);backdrop-filter:var(--tw-backdrop-blur,)var(--tw-backdrop-brightness,)var(--tw-backdrop-contrast,)var(--tw-backdrop-grayscale,)var(--tw-backdrop-hue-rotate,)var(--tw-backdrop-invert,)var(--tw-backdrop-opacity,)var(--tw-backdrop-saturate,)var(--tw-backdrop-sepia,)}.before\\\\\\\\:ring-inset:before{content:var(--tw-content);--tw-ring-inset:inset}.after\\\\\\\\:pointer-events-none:after{content:var(--tw-content);pointer-events:none}.after\\\\\\\\:absolute:after{content:var(--tw-content);position:absolute}.after\\\\\\\\:inset-0:after{content:var(--tw-content);inset:calc(var(--spacing)*0)}.after\\\\\\\\:block:after{content:var(--tw-content);display:block}.after\\\\\\\\:size-full:after{content:var(--tw-content);width:100%;height:100%}.after\\\\\\\\:content-normal:after{content:var(--tw-content);align-content:normal}.after\\\\\\\\:rounded-\\\\\\\\[inherit\\\\\\\\]:after{content:var(--tw-content);border-radius:inherit}.after\\\\\\\\:bg-gradient-to-b:after{content:var(--tw-content);--tw-gradient-position:to bottom in oklab;background-image:linear-gradient(var(--tw-gradient-stops))}.after\\\\\\\\:from-white\\\\\\\\/5:after{content:var(--tw-content);--tw-gradient-from:#ffffff0d}@supports (color:color-mix(in lab,red,red)){.after\\\\\\\\:from-white\\\\\\\\/5:after{--tw-gradient-from:color-mix(in oklab,var(--color-white)5%,transparent)}}.after\\\\\\\\:from-white\\\\\\\\/5:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.after\\\\\\\\:to-white\\\\\\\\/0:after{content:var(--tw-content);--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.after\\\\\\\\:to-white\\\\\\\\/0:after{--tw-gradient-to:color-mix(in oklab,var(--color-white)0%,transparent)}}.after\\\\\\\\:to-white\\\\\\\\/0:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.after\\\\\\\\:shadow-glass:after{content:var(--tw-content);--tw-shadow:var(--shadow-lg),0px -48px 48px -48px var(--tw-shadow-color,#0000000d)inset,0 5px 42px -5px var(--tw-shadow-color,#ffffff40)inset;box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.after\\\\\\\\:transition-colors:after{content:var(--tw-content);transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.after\\\\\\\\:duration-150:after{content:var(--tw-content);--tw-duration:.15s;transition-duration:.15s}.after\\\\\\\\:ease-out:after{content:var(--tw-content);--tw-ease:var(--ease-out);transition-timing-function:var(--ease-out)}.focus-within\\\\\\\\:outline-none:focus-within{--tw-outline-style:none;outline-style:none}@media (hover:hover){.hover\\\\\\\\:border-black\\\\\\\\/5:hover{border-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:border-black\\\\\\\\/5:hover{border-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.hover\\\\\\\\:border-border\\\\\\\\/40:hover{border-color:#71717b66}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:border-border\\\\\\\\/40:hover{border-color:color-mix(in oklab,var(--color-border)40%,transparent)}}.hover\\\\\\\\:border-rose-600\\\\\\\\/70:hover{border-color:#e70044b3}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:border-rose-600\\\\\\\\/70:hover{border-color:color-mix(in oklab,var(--color-rose-600)70%,transparent)}}.hover\\\\\\\\:bg-rose-600\\\\\\\\/5:hover{background-color:#e700440d}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:bg-rose-600\\\\\\\\/5:hover{background-color:color-mix(in oklab,var(--color-rose-600)5%,transparent)}}.hover\\\\\\\\:bg-white\\\\\\\\/0:hover{background-color:#0000}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:bg-white\\\\\\\\/0:hover{background-color:color-mix(in oklab,var(--color-white)0%,transparent)}}.hover\\\\\\\\:bg-white\\\\\\\\/20:hover{background-color:#fff3}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:bg-white\\\\\\\\/20:hover{background-color:color-mix(in oklab,var(--color-white)20%,transparent)}}.hover\\\\\\\\:bg-zinc-950\\\\\\\\/10:hover{background-color:#09090b1a}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:bg-zinc-950\\\\\\\\/10:hover{background-color:color-mix(in oklab,var(--color-zinc-950)10%,transparent)}}.hover\\\\\\\\:from-zinc-100\\\\\\\\/40:hover{--tw-gradient-from:#f4f4f566}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:from-zinc-100\\\\\\\\/40:hover{--tw-gradient-from:color-mix(in oklab,var(--color-zinc-100)40%,transparent)}}.hover\\\\\\\\:from-zinc-100\\\\\\\\/40:hover{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\\\\\\\:from-20\\\\\\\\%:hover{--tw-gradient-from-position:20%}.hover\\\\\\\\:to-zinc-100\\\\\\\\/0:hover{--tw-gradient-to:#0000}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:to-zinc-100\\\\\\\\/0:hover{--tw-gradient-to:color-mix(in oklab,var(--color-zinc-100)0%,transparent)}}.hover\\\\\\\\:to-zinc-100\\\\\\\\/0:hover{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\\\\\\\:to-75\\\\\\\\%:hover{--tw-gradient-to-position:75%}.hover\\\\\\\\:text-red-500:hover{color:var(--color-red-500)}.hover\\\\\\\\:opacity-90:hover{opacity:.9}.hover\\\\\\\\:opacity-100:hover{opacity:1}.hover\\\\\\\\:shadow-lg:hover{--tw-shadow:0 10px 15px -3px var(--tw-shadow-color,#0000001a),0 4px 6px -4px var(--tw-shadow-color,#0000001a);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\\\\\\\:shadow-xs:hover{--tw-shadow:0 1px 2px 0 var(--tw-shadow-color,#0000000d);box-shadow:var(--tw-inset-shadow),var(--tw-inset-ring-shadow),var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow)}.hover\\\\\\\\:after\\\\\\\\:from-blue-50\\\\\\\\/20:hover:after{content:var(--tw-content);--tw-gradient-from:#eff6ff33}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:after\\\\\\\\:from-blue-50\\\\\\\\/20:hover:after{--tw-gradient-from:color-mix(in oklab,var(--color-blue-50)20%,transparent)}}.hover\\\\\\\\:after\\\\\\\\:from-blue-50\\\\\\\\/20:hover:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.hover\\\\\\\\:after\\\\\\\\:to-blue-50\\\\\\\\/15:hover:after{content:var(--tw-content);--tw-gradient-to:#eff6ff26}@supports (color:color-mix(in lab,red,red)){.hover\\\\\\\\:after\\\\\\\\:to-blue-50\\\\\\\\/15:hover:after{--tw-gradient-to:color-mix(in oklab,var(--color-blue-50)15%,transparent)}}.hover\\\\\\\\:after\\\\\\\\:to-blue-50\\\\\\\\/15:hover:after{--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}}.focus\\\\\\\\:border-zinc-500:focus{border-color:var(--color-zinc-500)}.focus\\\\\\\\:text-zinc-900:focus{color:var(--color-zinc-900)}.focus\\\\\\\\:outline-none:focus{--tw-outline-style:none;outline-style:none}.active\\\\\\\\:scale-\\\\\\\\[98\\\\\\\\%\\\\\\\\]:active{scale:98%}.active\\\\\\\\:border-black\\\\\\\\/15:active{border-color:#00000026}@supports (color:color-mix(in lab,red,red)){.active\\\\\\\\:border-black\\\\\\\\/15:active{border-color:color-mix(in oklab,var(--color-black)15%,transparent)}}.active\\\\\\\\:after\\\\\\\\:from-transparent:active:after{content:var(--tw-content);--tw-gradient-from:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.active\\\\\\\\:after\\\\\\\\:to-transparent:active:after{content:var(--tw-content);--tw-gradient-to:transparent;--tw-gradient-stops:var(--tw-gradient-via-stops,var(--tw-gradient-position),var(--tw-gradient-from)var(--tw-gradient-from-position),var(--tw-gradient-to)var(--tw-gradient-to-position))}.disabled\\\\\\\\:pointer-events-none:disabled{pointer-events:none}.disabled\\\\\\\\:bg-black\\\\\\\\/5:disabled{background-color:#0000000d}@supports (color:color-mix(in lab,red,red)){.disabled\\\\\\\\:bg-black\\\\\\\\/5:disabled{background-color:color-mix(in oklab,var(--color-black)5%,transparent)}}.disabled\\\\\\\\:text-foreground\\\\\\\\/60:disabled{color:#09090b99}@supports (color:color-mix(in lab,red,red)){.disabled\\\\\\\\:text-foreground\\\\\\\\/60:disabled{color:color-mix(in oklab,var(--color-foreground)60%,transparent)}}.disabled\\\\\\\\:opacity-30:disabled{opacity:.3}.data-focus\\\\\\\\:outline-none[data-focus]{--tw-outline-style:none;outline-style:none}.animate-shake{animation:.5s ease-in-out 2 shake}}:root{color-scheme:normal;font-feature-settings:\"liga\" 1,\"calt\" 1;background-color:#0000}body{background-color:#0000}@keyframes shake{0%,to{transform:translate(0)}10%,30%,50%,70%,90%{transform:translate(-2px)}20%,40%,60%,80%{transform:translate(2px)}}@keyframes gradient-animation{0%{background-position:0%}50%{background-position:100%}to{background-position:0%}}#headlessui-portal-root{z-index:50;width:100vw;height:100vh;position:fixed}#headlessui-portal-root>*{pointer-events:auto}@property --tw-translate-x{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-y{syntax:\"*\";inherits:false;initial-value:0}@property --tw-translate-z{syntax:\"*\";inherits:false;initial-value:0}@property --tw-scale-x{syntax:\"*\";inherits:false;initial-value:1}@property --tw-scale-y{syntax:\"*\";inherits:false;initial-value:1}@property --tw-scale-z{syntax:\"*\";inherits:false;initial-value:1}@property --tw-rotate-x{syntax:\"*\";inherits:false}@property --tw-rotate-y{syntax:\"*\";inherits:false}@property --tw-rotate-z{syntax:\"*\";inherits:false}@property --tw-skew-x{syntax:\"*\";inherits:false}@property --tw-skew-y{syntax:\"*\";inherits:false}@property --tw-space-y-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-space-x-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-divide-y-reverse{syntax:\"*\";inherits:false;initial-value:0}@property --tw-border-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-gradient-position{syntax:\"*\";inherits:false}@property --tw-gradient-from{syntax:\"<color>\";inherits:false;initial-value:#0000}@property --tw-gradient-via{syntax:\"<color>\";inherits:false;initial-value:#0000}@property --tw-gradient-to{syntax:\"<color>\";inherits:false;initial-value:#0000}@property --tw-gradient-stops{syntax:\"*\";inherits:false}@property --tw-gradient-via-stops{syntax:\"*\";inherits:false}@property --tw-gradient-from-position{syntax:\"<length-percentage>\";inherits:false;initial-value:0%}@property --tw-gradient-via-position{syntax:\"<length-percentage>\";inherits:false;initial-value:50%}@property --tw-gradient-to-position{syntax:\"<length-percentage>\";inherits:false;initial-value:100%}@property --tw-font-weight{syntax:\"*\";inherits:false}@property --tw-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-shadow-color{syntax:\"*\";inherits:false}@property --tw-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-inset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-shadow-color{syntax:\"*\";inherits:false}@property --tw-inset-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-ring-color{syntax:\"*\";inherits:false}@property --tw-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-inset-ring-color{syntax:\"*\";inherits:false}@property --tw-inset-ring-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-ring-inset{syntax:\"*\";inherits:false}@property --tw-ring-offset-width{syntax:\"<length>\";inherits:false;initial-value:0}@property --tw-ring-offset-color{syntax:\"*\";inherits:false;initial-value:#fff}@property --tw-ring-offset-shadow{syntax:\"*\";inherits:false;initial-value:0 0 #0000}@property --tw-outline-style{syntax:\"*\";inherits:false;initial-value:solid}@property --tw-blur{syntax:\"*\";inherits:false}@property --tw-brightness{syntax:\"*\";inherits:false}@property --tw-contrast{syntax:\"*\";inherits:false}@property --tw-grayscale{syntax:\"*\";inherits:false}@property --tw-hue-rotate{syntax:\"*\";inherits:false}@property --tw-invert{syntax:\"*\";inherits:false}@property --tw-opacity{syntax:\"*\";inherits:false}@property --tw-saturate{syntax:\"*\";inherits:false}@property --tw-sepia{syntax:\"*\";inherits:false}@property --tw-drop-shadow{syntax:\"*\";inherits:false}@property --tw-drop-shadow-color{syntax:\"*\";inherits:false}@property --tw-drop-shadow-alpha{syntax:\"<percentage>\";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:\"*\";inherits:false}@property --tw-backdrop-blur{syntax:\"*\";inherits:false}@property --tw-backdrop-brightness{syntax:\"*\";inherits:false}@property --tw-backdrop-contrast{syntax:\"*\";inherits:false}@property --tw-backdrop-grayscale{syntax:\"*\";inherits:false}@property --tw-backdrop-hue-rotate{syntax:\"*\";inherits:false}@property --tw-backdrop-invert{syntax:\"*\";inherits:false}@property --tw-backdrop-opacity{syntax:\"*\";inherits:false}@property --tw-backdrop-saturate{syntax:\"*\";inherits:false}@property --tw-backdrop-sepia{syntax:\"*\";inherits:false}@property --tw-duration{syntax:\"*\";inherits:false}@property --tw-ease{syntax:\"*\";inherits:false}@property --tw-content{syntax:\"*\";inherits:false;initial-value:\"\"}@keyframes spin{to{transform:rotate(360deg)}}@keyframes pulse{50%{opacity:.5}}', fallbackState = {\n  state: AgentStateType.IDLE\n}, agentStateContext = createContext(fallbackState);\nfunction AgentStateProvider({ children }) {\n  const agent = useAgents().connected, [state, setState] = useState(fallbackState);\n  return useEffect(() => {\n    if (agent !== null) {\n      const subscription = agent.agent.state.getState.subscribe(void 0, {\n        onData: (value) => {\n          setState(value);\n        },\n        onError: () => {\n          setState(fallbackState);\n        }\n      });\n      return () => {\n        try {\n          subscription.unsubscribe();\n        } catch (error2) {\n          console.debug(\n            \"[AgentStateProvider] Error unsubscribing from agent state:\",\n            error2\n          );\n        }\n      };\n    } else\n      setState(fallbackState);\n  }, [agent]), /* @__PURE__ */ jsx(agentStateContext.Provider, { value: state, children });\n}\nconst useAgentState = () => useContext(agentStateContext), ChatContext = createContext({\n  chatInput: \"\",\n  setChatInput: () => {\n  },\n  domContextElements: [],\n  addChatDomContext: () => {\n  },\n  removeChatDomContext: () => {\n  },\n  sendMessage: () => {\n  },\n  isPromptCreationActive: !1,\n  startPromptCreation: () => {\n  },\n  stopPromptCreation: () => {\n  },\n  isSending: !1\n}), ChatStateProvider = ({ children }) => {\n  const [chatInput, setChatInput] = useState(\"\"), [isPromptCreationMode, setIsPromptCreationMode] = useState(!1), [isSending, setIsSending] = useState(!1), [domContextElements, setDomContextElements] = useState([]), { minimized } = useAppState(), { plugins } = usePlugins(), { sendMessage: sendAgentMessage } = useAgentMessaging(), { isChatOpen } = usePanels(), agentState = useAgentState(), startPromptCreation = useCallback(() => {\n    setIsPromptCreationMode(!0), plugins.forEach((plugin) => {\n      var _a;\n      (_a = plugin.onPromptingStart) == null || _a.call(plugin);\n    });\n  }, [plugins]), stopPromptCreation = useCallback(() => {\n    setIsPromptCreationMode(!1), setDomContextElements([]), plugins.forEach((plugin) => {\n      var _a;\n      (_a = plugin.onPromptingAbort) == null || _a.call(plugin);\n    });\n  }, [plugins]);\n  useEffect(() => {\n    isChatOpen || stopPromptCreation();\n  }, [isChatOpen, stopPromptCreation]), useEffect(() => {\n    minimized && stopPromptCreation();\n  }, [minimized]), useEffect(() => {\n    const allowedStates = [\n      AgentStateType.IDLE,\n      AgentStateType.WAITING_FOR_USER_RESPONSE\n    ];\n    isPromptCreationMode && agentState.state && !allowedStates.includes(agentState.state) && stopPromptCreation();\n  }, [agentState.state, isPromptCreationMode, stopPromptCreation]);\n  const addChatDomContext = useCallback(\n    (element) => {\n      const pluginsWithContextGetters = plugins.filter(\n        (plugin) => plugin.onContextElementSelect\n      );\n      setDomContextElements((prev) => [\n        ...prev,\n        {\n          element,\n          pluginContext: pluginsWithContextGetters.map((plugin) => {\n            var _a;\n            return {\n              pluginName: plugin.pluginName,\n              context: (_a = plugin.onContextElementSelect) == null ? void 0 : _a.call(plugin, element)\n            };\n          })\n        }\n      ]);\n    },\n    [plugins]\n  ), removeChatDomContext = useCallback((element) => {\n    setDomContextElements(\n      (prev) => prev.filter((item) => item.element !== element)\n    );\n  }, []), sendMessage = useCallback(async () => {\n    if (chatInput.trim()) {\n      setIsSending(!0);\n      try {\n        const baseUserMessage = {\n          id: generateId(),\n          createdAt: /* @__PURE__ */ new Date(),\n          contentItems: [\n            {\n              type: \"text\",\n              text: chatInput\n            }\n          ],\n          metadata: collectUserMessageMetadata(\n            domContextElements.map(\n              (item) => getSelectedElementInfo(item.element)\n            )\n          ),\n          pluginContent: {},\n          sentByPlugin: !1\n        }, pluginProcessingPromises = plugins.map(async (plugin) => {\n          var _a;\n          const handlerResult = await ((_a = plugin.onPromptSend) == null ? void 0 : _a.call(plugin, baseUserMessage));\n          if (!handlerResult || !handlerResult.contextSnippets || handlerResult.contextSnippets.length === 0)\n            return null;\n          const snippetPromises = handlerResult.contextSnippets.map(\n            async (snippet) => {\n              const resolvedContent = typeof snippet.content == \"string\" ? snippet.content : await snippet.content();\n              return {\n                promptContextName: snippet.promptContextName,\n                content: resolvedContent\n              };\n            }\n          ), resolvedSnippets = await Promise.all(snippetPromises);\n          return resolvedSnippets.length > 0 ? {\n            pluginName: plugin.pluginName,\n            contextSnippets: resolvedSnippets\n          } : null;\n        }), allPluginContexts = await Promise.all(pluginProcessingPromises), pluginContent = {};\n        allPluginContexts.forEach((context) => {\n          context && (pluginContent[context.pluginName] = {}, context.contextSnippets.forEach((snippet) => {\n            pluginContent[context.pluginName][snippet.promptContextName] = {\n              type: \"text\",\n              text: \\`\\${snippet.content}\\`\n            };\n          }));\n        });\n        const userMessageInput = {\n          ...baseUserMessage,\n          pluginContent\n        };\n        sendAgentMessage(userMessageInput), setChatInput(\"\"), setDomContextElements([]), setIsPromptCreationMode(!1);\n      } finally {\n        setIsSending(!1);\n      }\n    }\n  }, [chatInput, domContextElements, plugins, sendAgentMessage]), value = {\n    chatInput,\n    setChatInput,\n    domContextElements,\n    addChatDomContext,\n    removeChatDomContext,\n    sendMessage,\n    isPromptCreationActive: isPromptCreationMode,\n    startPromptCreation,\n    stopPromptCreation,\n    isSending\n  };\n  return /* @__PURE__ */ jsx(ChatContext.Provider, { value, children });\n};\nfunction useChatState() {\n  const context = useContext(ChatContext);\n  if (!context)\n    throw new Error(\"useChatState must be used within a ChatStateProvider\");\n  return context;\n}\nfunction ContextProviders({\n  children,\n  config: config2\n}) {\n  return /* @__PURE__ */ jsx(ConfigProvider, { config: config2, children: /* @__PURE__ */ jsx(AgentProvider, { children: /* @__PURE__ */ jsx(AgentAvailabilityProvider, { children: /* @__PURE__ */ jsx(AgentStateProvider, { children: /* @__PURE__ */ jsx(AgentMessagingProvider, { children: /* @__PURE__ */ jsx(PanelsProvider, { children: /* @__PURE__ */ jsx(PluginProvider, { children: /* @__PURE__ */ jsx(ChatStateProvider, { children }) }) }) }) }) }) }) });\n}\nfunction useEventListener(eventName, handler, options, element = window) {\n  useEffect(() => {\n    if (!(typeof window > \"u\") && element)\n      return element.addEventListener(eventName, handler, options), () => element.removeEventListener(eventName, handler, options);\n  }, [eventName, handler, element, options]);\n}\nfunction HotkeyListener() {\n  const { startPromptCreation, stopPromptCreation, isPromptCreationActive } = useChatState(), { isChatOpen, closeChat } = usePanels(), hotKeyHandlerMap = useMemo(\n    () => ({\n      // Functions that return true will prevent further propagation of the event.\n      [HotkeyActions.CTRL_ALT_C]: () => isPromptCreationActive ? !1 : (startPromptCreation(), !0),\n      [HotkeyActions.ESC]: () => isPromptCreationActive ? (stopPromptCreation(), !0) : isChatOpen ? (closeChat(), !0) : !1\n    }),\n    [\n      startPromptCreation,\n      stopPromptCreation,\n      isPromptCreationActive,\n      isChatOpen,\n      closeChat\n    ]\n  ), hotKeyListener = useCallback(\n    (ev) => {\n      for (const [action, definition] of Object.entries(\n        hotkeyActionDefinitions\n      ))\n        if (definition.isEventMatching(ev)) {\n          hotKeyHandlerMap[action]() && (ev.preventDefault(), ev.stopPropagation());\n          break;\n        }\n    },\n    [hotKeyHandlerMap]\n  );\n  return useEventListener(\"keydown\", hotKeyListener, {\n    capture: !0\n  }), null;\n}\nfunction useWindowSize() {\n  const [size2, setSize] = useState({\n    width: window.innerWidth,\n    height: window.innerHeight\n  }), handleResize = useCallback(\n    () => setSize({\n      width: window.innerWidth,\n      height: window.innerHeight\n    }),\n    []\n  );\n  return useEventListener(\"resize\", handleResize), size2;\n}\nfunction useCyclicUpdate(func, frameRate) {\n  const animationFrameHandle = useRef(void 0), timeBetweenFrames = useMemo(\n    () => 1e3 / frameRate,\n    [frameRate]\n  ), lastCallFrameTime = useRef(0), update = useCallback(\n    (frameTime) => {\n      frameTime - lastCallFrameTime.current >= timeBetweenFrames && (func(), lastCallFrameTime.current = frameTime), animationFrameHandle.current = requestAnimationFrame(update);\n    },\n    [func, timeBetweenFrames]\n  );\n  useEffect(() => (animationFrameHandle.current = requestAnimationFrame(update), () => {\n    animationFrameHandle.current && (cancelAnimationFrame(animationFrameHandle.current), animationFrameHandle.current = void 0);\n  }), [frameRate, update]);\n}\nfunction HoveredItem({ refElement, ...props }) {\n  const boxRef = useRef(null), windowSize = useWindowSize(), { plugins } = usePlugins(), hoveredElementPluginContext = useMemo(() => refElement ? plugins.filter(\n    (plugin) => plugin.onContextElementSelect\n  ).map((plugin) => {\n    var _a;\n    return {\n      pluginName: plugin.pluginName,\n      context: (_a = plugin.onContextElementSelect) == null ? void 0 : _a.call(plugin, refElement)\n    };\n  }) : [], [refElement]), updateBoxPosition = useCallback(() => {\n    if (boxRef.current && refElement) {\n      const referenceRect = refElement.getBoundingClientRect();\n      boxRef.current.style.top = \\`\\${referenceRect.top - 2}px\\`, boxRef.current.style.left = \\`\\${referenceRect.left - 2}px\\`, boxRef.current.style.width = \\`\\${referenceRect.width + 4}px\\`, boxRef.current.style.height = \\`\\${referenceRect.height + 4}px\\`, boxRef.current.style.display = void 0;\n    } else\n      boxRef.current.style.height = \"0px\", boxRef.current.style.width = \"0px\", boxRef.current.style.top = \\`\\${windowSize.height / 2}px\\`, boxRef.current.style.left = \\`\\${windowSize.width / 2}px\\`, boxRef.current.style.display = \"none\";\n  }, [refElement, windowSize.height, windowSize.width]);\n  return useCyclicUpdate(updateBoxPosition, 30), /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      ...props,\n      className: cn(\n        \"fixed z-10 flex items-center justify-center rounded-sm border-2 border-blue-600/70 border-dotted bg-blue-600/5 text-white transition-all duration-100\"\n      ),\n      ref: boxRef,\n      children: /* @__PURE__ */ jsxs(\"div\", { className: \"absolute top-0.5 left-0.5 flex w-full flex-row items-start justify-start gap-1\", children: [\n        /* @__PURE__ */ jsx(\"div\", { className: \"flex flex-row items-center justify-center gap-0.5 overflow-hidden rounded-md bg-zinc-700/80 px-1 py-0 font-medium text-white text-xs\", children: /* @__PURE__ */ jsx(\"span\", { className: \"truncate\", children: refElement.tagName.toLowerCase() }) }),\n        hoveredElementPluginContext.filter((plugin) => plugin.context.annotation).map((plugin) => {\n          var _a;\n          return /* @__PURE__ */ jsxs(\n            \"div\",\n            {\n              className: \"flex flex-row items-center justify-center gap-0.5 overflow-hidden rounded-md bg-zinc-700/80 px-1 py-0 font-medium text-white text-xs\",\n              children: [\n                /* @__PURE__ */ jsx(\"span\", { className: \"size-3 shrink-0 stroke-white text-white *:size-full\", children: (_a = plugins.find((p2) => p2.pluginName === plugin.pluginName)) == null ? void 0 : _a.iconSvg }),\n                /* @__PURE__ */ jsx(\"span\", { className: \"truncate\", children: plugin.context.annotation })\n              ]\n            },\n            plugin.pluginName\n          );\n        })\n      ] })\n    }\n  );\n}\nconst ContextChipHoverContext = createContext(void 0);\nfunction ContextChipHoverProvider({\n  children\n}) {\n  const [hoveredElement, setHoveredElement] = useState(\n    null\n  ), { domContextElements } = useChatState();\n  return useEffect(() => {\n    hoveredElement && (domContextElements.some(\n      (contextEl) => contextEl.element === hoveredElement\n    ) || setHoveredElement(null));\n  }, [hoveredElement, domContextElements]), /* @__PURE__ */ jsx(\n    ContextChipHoverContext.Provider,\n    {\n      value: { hoveredElement, setHoveredElement },\n      children\n    }\n  );\n}\nfunction useContextChipHover() {\n  const context = useContext(ContextChipHoverContext);\n  if (context === void 0)\n    throw new Error(\n      \"useContextChipHover must be used within a ContextChipHoverProvider\"\n    );\n  return context;\n}\nfunction SelectedItem({\n  refElement,\n  isChipHovered,\n  ...props\n}) {\n  const boxRef = useRef(null), windowSize = useWindowSize(), updateBoxPosition = useCallback(() => {\n    if (boxRef.current)\n      if (refElement) {\n        const referenceRect = refElement.getBoundingClientRect();\n        boxRef.current.style.top = \\`\\${referenceRect.top - 2}px\\`, boxRef.current.style.left = \\`\\${referenceRect.left - 2}px\\`, boxRef.current.style.width = \\`\\${referenceRect.width + 4}px\\`, boxRef.current.style.height = \\`\\${referenceRect.height + 4}px\\`, boxRef.current.style.display = void 0;\n      } else\n        boxRef.current.style.height = \"0px\", boxRef.current.style.width = \"0px\", boxRef.current.style.top = \\`\\${windowSize.height / 2}px\\`, boxRef.current.style.left = \\`\\${windowSize.width / 2}px\\`, boxRef.current.style.opacity = \"none\";\n  }, [refElement, windowSize.height, windowSize.width]);\n  return useCyclicUpdate(updateBoxPosition, 30), /* @__PURE__ */ jsx(\n    \"button\",\n    {\n      ...props,\n      className: cn(\n        \"pointer-events-auto fixed flex cursor-not-allowed items-center justify-center rounded-sm border-2 border-zinc-600/70 border-dotted transition-all duration-100 hover:border-rose-600/70 hover:bg-rose-600/5\",\n        isChipHovered && \"border-blue-600/70 bg-blue-600/5\"\n      ),\n      onClick: props.onRemoveClick,\n      ref: boxRef\n    }\n  );\n}\nfunction DOMContextSelector() {\n  const {\n    domContextElements,\n    addChatDomContext,\n    isPromptCreationActive,\n    removeChatDomContext\n  } = useChatState(), shouldShow = isPromptCreationActive, [hoveredElement, setHoveredElement] = useState(\n    null\n  ), { hoveredElement: chipHoveredElement } = useContextChipHover(), handleElementSelected = useCallback(\n    (el) => {\n      domContextElements.find(\n        (contextEl) => contextEl.element === el\n      ) || addChatDomContext(el);\n    },\n    [addChatDomContext, domContextElements]\n  ), hoveredSelectedElement = hoveredElement ? domContextElements.find((el) => el.element === hoveredElement) : null, selectedItems = useMemo(() => domContextElements.map((el) => el.element), [domContextElements]), lastHoveredElement = useRef(null), mouseState = useRef(null), nextUpdateTimeout = useRef(null), [hoversAddable, setHoversAddable] = useState(!1), updateHoveredElement = useCallback(() => {\n    if (!mouseState.current) return;\n    const refElement = getElementAtPoint(\n      mouseState.current.lastX,\n      mouseState.current.lastY\n    );\n    if (selectedItems.includes(refElement)) {\n      setHoversAddable(!1), lastHoveredElement.current = null, setHoveredElement(null);\n      return;\n    }\n    lastHoveredElement.current !== refElement && (lastHoveredElement.current = refElement, setHoveredElement(refElement), setHoversAddable(!0));\n  }, [selectedItems]);\n  useEffect(() => {\n    updateHoveredElement();\n  }, [updateHoveredElement]);\n  const handleMouseMove = useCallback(\n    (event) => {\n      var _a, _b, _c, _d, _e, _f;\n      const currentTimestamp = performance.now(), deltaX = event.clientX - (((_a = mouseState.current) == null ? void 0 : _a.lastX) ?? event.clientX), deltaY = event.clientY - (((_b = mouseState.current) == null ? void 0 : _b.lastY) ?? event.clientY), deltaTime = currentTimestamp - (((_c = mouseState.current) == null ? void 0 : _c.lastTimestamp) ?? currentTimestamp), distance = Math.hypot(deltaX, deltaY);\n      mouseState.current = {\n        lastX: deltaTime > 0 ? event.clientX : (_d = mouseState.current) == null ? void 0 : _d.lastX,\n        lastY: deltaTime > 0 ? event.clientY : (_e = mouseState.current) == null ? void 0 : _e.lastY,\n        velocity: deltaTime > 0 ? distance / deltaTime * 1e3 : 0,\n        lastTimestamp: currentTimestamp\n      }, ((_f = mouseState.current) == null ? void 0 : _f.velocity) > 30 ? (nextUpdateTimeout.current && clearTimeout(nextUpdateTimeout.current), nextUpdateTimeout.current = setTimeout(updateHoveredElement, 1e3 / 28)) : nextUpdateTimeout.current || (nextUpdateTimeout.current = setTimeout(updateHoveredElement, 1e3 / 28));\n    },\n    [updateHoveredElement]\n  ), handleMouseLeave = useCallback(() => {\n    clearTimeout(nextUpdateTimeout.current), lastHoveredElement.current = null, setHoveredElement(null);\n  }, []), handleMouseClick = useCallback(\n    (event) => {\n      event.preventDefault(), event.stopPropagation(), lastHoveredElement.current && (selectedItems.includes(lastHoveredElement.current) || handleElementSelected(lastHoveredElement.current));\n    },\n    [handleElementSelected, selectedItems]\n  );\n  return shouldShow ? /* @__PURE__ */ jsxs(\n    \"div\",\n    {\n      className: cn(\n        \"pointer-events-auto fixed inset-0 h-screen w-screen\",\n        hoversAddable ? \"cursor-copy\" : \"cursor-default\"\n      ),\n      id: \"element-selector\",\n      onMouseMove: handleMouseMove,\n      onMouseLeave: handleMouseLeave,\n      onClick: handleMouseClick,\n      role: \"button\",\n      tabIndex: 0,\n      children: [\n        hoveredElement && !hoveredSelectedElement && /* @__PURE__ */ jsx(HoveredItem, { refElement: hoveredElement }),\n        domContextElements.map((el) => /* @__PURE__ */ jsx(\n          SelectedItem,\n          {\n            refElement: el.element,\n            isChipHovered: chipHoveredElement === el.element,\n            onRemoveClick: () => removeChatDomContext(el.element)\n          },\n          getXPathForElement(el.element, !0)\n        ))\n      ]\n    }\n  ) : null;\n}\nconst DraggableContext = createContext(\n  null\n), DraggableProvider = ({\n  containerRef,\n  children,\n  snapAreas,\n  onDragStart,\n  onDragEnd\n}) => {\n  const [borderLocation, setBorderLocation] = useState({\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  });\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const updateBorderLocation = () => {\n      if (containerRef.current) {\n        const rect = containerRef.current.getBoundingClientRect();\n        setBorderLocation({\n          top: rect.top,\n          left: rect.left,\n          right: rect.right,\n          bottom: rect.bottom\n        });\n      }\n    };\n    updateBorderLocation();\n    const resizeObserver = new ResizeObserver(updateBorderLocation);\n    return resizeObserver.observe(containerRef.current), window.addEventListener(\"resize\", updateBorderLocation), () => {\n      containerRef.current && resizeObserver.unobserve(containerRef.current), resizeObserver.disconnect(), window.removeEventListener(\"resize\", updateBorderLocation);\n    };\n  }, [containerRef]);\n  const dragStartListeners = useRef(/* @__PURE__ */ new Set()), dragEndListeners = useRef(/* @__PURE__ */ new Set()), registerDragStart = useCallback((cb) => (dragStartListeners.current.add(cb), () => dragStartListeners.current.delete(cb)), []), registerDragEnd = useCallback((cb) => (dragEndListeners.current.add(cb), () => dragEndListeners.current.delete(cb)), []), emitDragStart = useCallback(() => {\n    onDragStart && onDragStart(), dragStartListeners.current.forEach((cb) => cb());\n  }, [onDragStart]), emitDragEnd = useCallback(() => {\n    onDragEnd && onDragEnd(), dragEndListeners.current.forEach((cb) => cb());\n  }, [onDragEnd]), contextValue = {\n    borderLocation,\n    snapAreas,\n    registerDragStart,\n    registerDragEnd,\n    emitDragStart,\n    emitDragEnd\n  };\n  return /* @__PURE__ */ jsx(DraggableContext.Provider, { value: contextValue, children: contextValue.borderLocation.right - contextValue.borderLocation.left > 0 && contextValue.borderLocation.bottom - contextValue.borderLocation.top > 0 && children });\n};\nfunction useDraggable(config2) {\n  const providerData = useContext(DraggableContext), latestProviderDataRef = useRef(providerData);\n  useEffect(() => {\n    latestProviderDataRef.current = providerData;\n  }, [providerData]);\n  const movingElementRef = useRef(null), dragInitiatorRef = useRef(null), [movingElementNode, setMovingElementNode] = useState(null), [dragInitiatorNode, setDragInitiatorNode] = useState(null), mouseToDraggableCenterOffsetRef = useRef(null), mouseDownPosRef = useRef(null), currentMousePosRef = useRef(null), isDraggingRef = useRef(!1), [isDragging, setIsDragging] = useState(!1), persistedRelativeCenterRef = useRef(config2.initialRelativeCenter), [currentSnapArea, setCurrentSnapArea] = useState(null), {\n    startThreshold = 3,\n    areaSnapThreshold = 60,\n    // px, default threshold for snapping\n    onDragStart,\n    onDragEnd,\n    initialSnapArea,\n    springStiffness = 0.2,\n    // Default spring stiffness\n    springDampness = 0.55\n    // Default spring dampness\n    // initialRelativeCenter is used to initialize persistedRelativeCenterRef\n  } = config2, animatedPositionRef = useRef(null), velocityRef = useRef({ x: 0, y: 0 }), hasAnimatedOnceRef = useRef(!1);\n  useEffect(() => {\n    if (initialSnapArea && providerData && providerData.borderLocation && providerData.snapAreas && providerData.snapAreas[initialSnapArea] && !isDraggingRef.current) {\n      const { top, left, right, bottom } = providerData.borderLocation, width = right - left, height = bottom - top, center = {\n        topLeft: { x: left, y: top },\n        topRight: { x: right, y: top },\n        bottomLeft: { x: left, y: bottom },\n        bottomRight: { x: right, y: bottom }\n      }[initialSnapArea];\n      if (center && width > 0 && height > 0) {\n        const relX = (center.x - left) / width, relY = (center.y - top) / height;\n        persistedRelativeCenterRef.current = { x: relX, y: relY };\n      } else center && console.warn(\n        \"useDraggable: Container for initialSnapArea has zero width or height. Cannot calculate relative center from snap area. Falling back to initialRelativeCenter or undefined.\"\n      );\n    }\n  }, [initialSnapArea, providerData]);\n  function getSnapAreaCenters(borderLocation) {\n    const { top, left, right, bottom } = borderLocation, centerX = (left + right) / 2;\n    return {\n      topLeft: { x: left, y: top },\n      topCenter: { x: centerX, y: top },\n      topRight: { x: right, y: top },\n      bottomLeft: { x: left, y: bottom },\n      bottomCenter: { x: centerX, y: bottom },\n      bottomRight: { x: right, y: bottom }\n    };\n  }\n  const updateDraggablePosition = useCallback(() => {\n    var _a, _b;\n    const draggableEl = movingElementRef.current;\n    if (!draggableEl) return;\n    const draggableWidth = draggableEl.offsetWidth, draggableHeight = draggableEl.offsetHeight, offsetParent = draggableEl.offsetParent;\n    let parentViewportLeft = 0, parentViewportTop = 0, parentWidth = window.innerWidth, parentHeight = window.innerHeight;\n    if (offsetParent) {\n      const opRect = offsetParent.getBoundingClientRect();\n      parentViewportLeft = opRect.left, parentViewportTop = opRect.top, parentWidth = offsetParent.offsetWidth || window.innerWidth, parentHeight = offsetParent.offsetHeight || window.innerHeight;\n    }\n    let targetViewportCenterX = null, targetViewportCenterY = null;\n    const currentDesiredRelativeCenter = persistedRelativeCenterRef.current;\n    let snapArea = null, snapTarget = null;\n    const provider = latestProviderDataRef.current;\n    let isTopHalf = !0, isLeftHalf = !0;\n    if (isDraggingRef.current && mouseToDraggableCenterOffsetRef.current && currentMousePosRef.current && provider && provider.borderLocation && provider.snapAreas) {\n      const dragCenter = {\n        x: currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x,\n        y: currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y\n      }, areaCenters = getSnapAreaCenters(provider.borderLocation);\n      let minDist = Number.POSITIVE_INFINITY, closestArea = null, closestCenter = null;\n      for (const area in provider.snapAreas)\n        if (provider.snapAreas[area]) {\n          const center = areaCenters[area];\n          if (!center) continue;\n          const dist = Math.hypot(\n            center.x - dragCenter.x,\n            center.y - dragCenter.y\n          );\n          dist < minDist && (minDist = dist, closestArea = area, closestCenter = center);\n        }\n      closestArea && closestCenter && minDist <= areaSnapThreshold && (snapArea = closestArea, snapTarget = closestCenter), isLeftHalf = (dragCenter.x - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (dragCenter.y - parentViewportTop) / parentHeight <= 0.5;\n    }\n    if (isDraggingRef.current && snapTarget)\n      targetViewportCenterX = snapTarget.x, targetViewportCenterY = snapTarget.y, setCurrentSnapArea(snapArea), isLeftHalf = (snapTarget.x - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (snapTarget.y - parentViewportTop) / parentHeight <= 0.5;\n    else if (isDraggingRef.current && mouseToDraggableCenterOffsetRef.current && currentMousePosRef.current)\n      targetViewportCenterX = currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x, targetViewportCenterY = currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y, setCurrentSnapArea(null), isLeftHalf = (targetViewportCenterX - parentViewportLeft) / parentWidth <= 0.5, isTopHalf = (targetViewportCenterY - parentViewportTop) / parentHeight <= 0.5;\n    else {\n      if (currentDesiredRelativeCenter && parentWidth > 0 && parentHeight > 0) {\n        if (isTopHalf = currentDesiredRelativeCenter.y <= 0.5, isLeftHalf = currentDesiredRelativeCenter.x <= 0.5, isLeftHalf) {\n          const targetCenterXInParent = parentWidth * currentDesiredRelativeCenter.x;\n          targetViewportCenterX = parentViewportLeft + targetCenterXInParent;\n        } else {\n          const targetCenterXInParent = parentWidth * (1 - currentDesiredRelativeCenter.x);\n          targetViewportCenterX = parentViewportLeft + parentWidth - targetCenterXInParent;\n        }\n        if (isTopHalf) {\n          const targetCenterYInParent = parentHeight * currentDesiredRelativeCenter.y;\n          targetViewportCenterY = parentViewportTop + targetCenterYInParent;\n        } else {\n          const targetCenterYInParent = parentHeight * (1 - currentDesiredRelativeCenter.y);\n          targetViewportCenterY = parentViewportTop + parentHeight - targetCenterYInParent;\n        }\n      } else {\n        !((_a = movingElementRef.current) != null && _a.style.left) && !((_b = movingElementRef.current) != null && _b.style.top) && console.warn(\n          \"useDraggable: Cannot determine position. Parent has no dimensions or initialRelativeCenter was not effectively set.\"\n        );\n        return;\n      }\n      setCurrentSnapArea(null);\n    }\n    if (targetViewportCenterX === null || targetViewportCenterY === null)\n      return;\n    const { borderLocation } = latestProviderDataRef.current || {\n      borderLocation: void 0\n    };\n    if (borderLocation && draggableWidth > 0 && draggableHeight > 0) {\n      const providerRectWidth = borderLocation.right - borderLocation.left, providerRectHeight = borderLocation.bottom - borderLocation.top;\n      let clampedCenterX = targetViewportCenterX, clampedCenterY = targetViewportCenterY;\n      if (draggableWidth >= providerRectWidth)\n        clampedCenterX = borderLocation.left + providerRectWidth / 2;\n      else {\n        const minX = borderLocation.left + draggableWidth / 2, maxX = borderLocation.right - draggableWidth / 2;\n        clampedCenterX = Math.max(minX, Math.min(clampedCenterX, maxX));\n      }\n      if (draggableHeight >= providerRectHeight)\n        clampedCenterY = borderLocation.top + providerRectHeight / 2;\n      else {\n        const minY = borderLocation.top + draggableHeight / 2, maxY = borderLocation.bottom - draggableHeight / 2;\n        clampedCenterY = Math.max(minY, Math.min(clampedCenterY, maxY));\n      }\n      targetViewportCenterX = clampedCenterX, targetViewportCenterY = clampedCenterY;\n    }\n    if (!animatedPositionRef.current) {\n      animatedPositionRef.current = {\n        x: targetViewportCenterX,\n        y: targetViewportCenterY\n      }, velocityRef.current = { x: 0, y: 0 };\n      const targetElementStyleX2 = targetViewportCenterX - draggableWidth / 2, targetElementStyleY2 = targetViewportCenterY - draggableHeight / 2, elStyle2 = draggableEl.style;\n      if (elStyle2.right = \"\", elStyle2.bottom = \"\", elStyle2.left = \"\", elStyle2.top = \"\", isLeftHalf) {\n        const styleLeftPx = targetElementStyleX2 - parentViewportLeft;\n        elStyle2.left = parentWidth > 0 ? \\`\\${(styleLeftPx / parentWidth * 100).toFixed(2)}%\\` : \"0px\", elStyle2.right = \"\";\n      } else {\n        const styleRightPx = parentViewportLeft + parentWidth - (targetElementStyleX2 + draggableWidth);\n        elStyle2.right = parentWidth > 0 ? \\`\\${(styleRightPx / parentWidth * 100).toFixed(2)}%\\` : \"0px\", elStyle2.left = \"\";\n      }\n      if (isTopHalf) {\n        const styleTopPx = targetElementStyleY2 - parentViewportTop;\n        elStyle2.top = parentHeight > 0 ? \\`\\${(styleTopPx / parentHeight * 100).toFixed(2)}%\\` : \"0px\", elStyle2.bottom = \"\";\n      } else {\n        const styleBottomPx = parentViewportTop + parentHeight - (targetElementStyleY2 + draggableHeight);\n        elStyle2.bottom = parentHeight > 0 ? \\`\\${(styleBottomPx / parentHeight * 100).toFixed(2)}%\\` : \"0px\", elStyle2.top = \"\";\n      }\n      hasAnimatedOnceRef.current = !0;\n      return;\n    }\n    if (!hasAnimatedOnceRef.current) {\n      hasAnimatedOnceRef.current = !0;\n      return;\n    }\n    const pos = animatedPositionRef.current, vel = velocityRef.current, dx = targetViewportCenterX - pos.x, dy = targetViewportCenterY - pos.y, ax = springStiffness * dx - springDampness * vel.x, ay = springStiffness * dy - springDampness * vel.y;\n    vel.x += ax, vel.y += ay, pos.x += vel.x, pos.y += vel.y;\n    const threshold = 0.5;\n    Math.abs(dx) < threshold && Math.abs(dy) < threshold && Math.abs(vel.x) < threshold && Math.abs(vel.y) < threshold && (pos.x = targetViewportCenterX, pos.y = targetViewportCenterY, vel.x = 0, vel.y = 0), animatedPositionRef.current = { ...pos }, velocityRef.current = { ...vel };\n    const targetElementStyleX = pos.x - draggableWidth / 2, targetElementStyleY = pos.y - draggableHeight / 2, elStyle = draggableEl.style;\n    if (elStyle.right = \"\", elStyle.bottom = \"\", elStyle.left = \"\", elStyle.top = \"\", isLeftHalf) {\n      const styleLeftPx = targetElementStyleX - parentViewportLeft;\n      elStyle.left = parentWidth > 0 ? \\`\\${(styleLeftPx / parentWidth * 100).toFixed(2)}%\\` : \"0px\", elStyle.right = \"\";\n    } else {\n      const styleRightPx = parentViewportLeft + parentWidth - (targetElementStyleX + draggableWidth);\n      elStyle.right = parentWidth > 0 ? \\`\\${(styleRightPx / parentWidth * 100).toFixed(2)}%\\` : \"0px\", elStyle.left = \"\";\n    }\n    if (isTopHalf) {\n      const styleTopPx = targetElementStyleY - parentViewportTop;\n      elStyle.top = parentHeight > 0 ? \\`\\${(styleTopPx / parentHeight * 100).toFixed(2)}%\\` : \"0px\", elStyle.bottom = \"\";\n    } else {\n      const styleBottomPx = parentViewportTop + parentHeight - (targetElementStyleY + draggableHeight);\n      elStyle.bottom = parentHeight > 0 ? \\`\\${(styleBottomPx / parentHeight * 100).toFixed(2)}%\\` : \"0px\", elStyle.top = \"\";\n    }\n    (Math.abs(pos.x - targetViewportCenterX) > threshold || Math.abs(pos.y - targetViewportCenterY) > threshold || Math.abs(vel.x) > threshold || Math.abs(vel.y) > threshold || isDraggingRef.current) && requestAnimationFrame(updateDraggablePosition);\n  }, [areaSnapThreshold, springStiffness, springDampness]), [wasDragged, setWasDragged] = useState(!1), mouseUpHandler = useCallback(\n    (_e) => {\n      var _a;\n      let finalSnapArea = null;\n      if (isDraggingRef.current) {\n        setWasDragged(!0), setTimeout(() => setWasDragged(!1), 20);\n        const draggableEl = movingElementRef.current, provider = latestProviderDataRef.current;\n        if (draggableEl && provider && provider.borderLocation) {\n          const draggableWidth = draggableEl.offsetWidth, draggableHeight = draggableEl.offsetHeight, offsetParent = draggableEl.offsetParent;\n          let parentViewportLeft = 0, parentViewportTop = 0, parentWidth = window.innerWidth, parentHeight = window.innerHeight;\n          if (offsetParent) {\n            const opRect = offsetParent.getBoundingClientRect();\n            parentViewportLeft = opRect.left, parentViewportTop = opRect.top, parentWidth = offsetParent.offsetWidth || window.innerWidth, parentHeight = offsetParent.offsetHeight || window.innerHeight;\n          }\n          let releasedCenterX = 0, releasedCenterY = 0;\n          currentMousePosRef.current && mouseToDraggableCenterOffsetRef.current ? (releasedCenterX = currentMousePosRef.current.x - mouseToDraggableCenterOffsetRef.current.x, releasedCenterY = currentMousePosRef.current.y - mouseToDraggableCenterOffsetRef.current.y) : animatedPositionRef.current && (releasedCenterX = animatedPositionRef.current.x, releasedCenterY = animatedPositionRef.current.y);\n          const borderLocation = provider.borderLocation, minX = borderLocation.left + draggableWidth / 2, maxX = borderLocation.right - draggableWidth / 2, minY = borderLocation.top + draggableHeight / 2, maxY = borderLocation.bottom - draggableHeight / 2;\n          releasedCenterX = Math.max(minX, Math.min(releasedCenterX, maxX)), releasedCenterY = Math.max(minY, Math.min(releasedCenterY, maxY));\n          const areaCenters = getSnapAreaCenters(borderLocation);\n          let minDist = Number.POSITIVE_INFINITY, closestArea = null, closestCenter = null;\n          for (const area in provider.snapAreas)\n            if (provider.snapAreas[area]) {\n              const center = areaCenters[area];\n              if (!center) continue;\n              const dist = Math.hypot(\n                center.x - releasedCenterX,\n                center.y - releasedCenterY\n              );\n              dist < minDist && (minDist = dist, closestArea = area, closestCenter = center);\n            }\n          if (closestArea && closestCenter) {\n            finalSnapArea = closestArea, setCurrentSnapArea(closestArea);\n            const relX = (closestCenter.x - parentViewportLeft) / parentWidth, relY = (closestCenter.y - parentViewportTop) / parentHeight;\n            persistedRelativeCenterRef.current = { x: relX, y: relY };\n          } else {\n            finalSnapArea = null, setCurrentSnapArea(null);\n            const relX = (releasedCenterX - parentViewportLeft) / parentWidth, relY = (releasedCenterY - parentViewportTop) / parentHeight;\n            persistedRelativeCenterRef.current = { x: relX, y: relY };\n          }\n        }\n        onDragEnd && onDragEnd(finalSnapArea), (_a = latestProviderDataRef.current) != null && _a.emitDragEnd && latestProviderDataRef.current.emitDragEnd();\n      }\n      mouseDownPosRef.current = null, isDraggingRef.current = !1, setIsDragging(!1), window.removeEventListener(\"mousemove\", mouseMoveHandler, {\n        capture: !0\n      }), window.removeEventListener(\"mouseup\", mouseUpHandler, {\n        capture: !0\n      }), movingElementRef.current && (movingElementRef.current.style.userSelect = \"\"), document.body.style.userSelect = \"\", document.body.style.cursor = \"\";\n    },\n    [onDragEnd]\n  ), mouseMoveHandler = useCallback(\n    (e2) => {\n      var _a;\n      if (!mouseDownPosRef.current) return;\n      Math.hypot(\n        e2.clientX - mouseDownPosRef.current.x,\n        e2.clientY - mouseDownPosRef.current.y\n      ) > startThreshold && !isDraggingRef.current && (isDraggingRef.current = !0, setIsDragging(!0), movingElementRef.current && (movingElementRef.current.style.userSelect = \"none\"), document.body.style.userSelect = \"none\", document.body.style.cursor = \"grabbing\", onDragStart && onDragStart(), (_a = latestProviderDataRef.current) != null && _a.emitDragStart && latestProviderDataRef.current.emitDragStart(), requestAnimationFrame(updateDraggablePosition)), currentMousePosRef.current = { x: e2.clientX, y: e2.clientY };\n    },\n    [startThreshold, onDragStart, updateDraggablePosition]\n  ), mouseDownHandler = useCallback(\n    (e2) => {\n      if (e2.button !== 0)\n        return;\n      const handleNode = dragInitiatorRef.current, draggableItemNode = movingElementRef.current;\n      if (handleNode) {\n        if (!handleNode.contains(e2.target) && e2.target !== handleNode)\n          return;\n      } else if (draggableItemNode) {\n        if (!draggableItemNode.contains(e2.target) && e2.target !== draggableItemNode)\n          return;\n      } else {\n        console.error(\n          \"Draggable element or handle ref not set in mouseDownHandler\"\n        );\n        return;\n      }\n      if (mouseDownPosRef.current = { x: e2.clientX, y: e2.clientY }, !movingElementRef.current) {\n        console.error(\"Draggable element ref not set in mouseDownHandler\");\n        return;\n      }\n      const rect = movingElementRef.current.getBoundingClientRect(), currentDraggableCenterX = rect.left + rect.width / 2, currentDraggableCenterY = rect.top + rect.height / 2;\n      mouseToDraggableCenterOffsetRef.current = {\n        x: e2.clientX - currentDraggableCenterX,\n        y: e2.clientY - currentDraggableCenterY\n      }, window.addEventListener(\"mousemove\", mouseMoveHandler, {\n        capture: !0\n      }), window.addEventListener(\"mouseup\", mouseUpHandler, {\n        capture: !0\n      });\n    },\n    [mouseMoveHandler, mouseUpHandler]\n  );\n  useEffect(() => {\n    const elementToListenOn = dragInitiatorNode || movingElementNode;\n    return elementToListenOn && elementToListenOn.addEventListener(\"mousedown\", mouseDownHandler), () => {\n      elementToListenOn && elementToListenOn.removeEventListener(\"mousedown\", mouseDownHandler), isDraggingRef.current && (onDragEnd && onDragEnd(currentSnapArea), isDraggingRef.current = !1, setIsDragging(!1), movingElementNode && (movingElementNode.style.userSelect = \"\"), document.body.style.userSelect = \"\", document.body.style.cursor = \"\");\n    };\n  }, [\n    movingElementNode,\n    dragInitiatorNode,\n    mouseDownHandler,\n    onDragEnd,\n    mouseMoveHandler,\n    mouseUpHandler,\n    currentSnapArea\n  ]), useEffect(() => {\n    movingElementRef.current && providerData && providerData.borderLocation && // Needed for calculations within updateDraggablePosition\n    persistedRelativeCenterRef.current && // Ensure we have a center to position to\n    !isDraggingRef.current && // Not currently dragging\n    !hasAnimatedOnceRef.current && requestAnimationFrame(() => {\n      movingElementRef.current && updateDraggablePosition();\n    });\n  }, [\n    movingElementNode,\n    // Run when element is available/changes\n    providerData,\n    // Run if provider context changes (for borderLocation)\n    config2.initialRelativeCenter,\n    // If this changes, persistedRelativeCenterRef might be re-initialized\n    initialSnapArea,\n    // If this changes, an effect updates persistedRelativeCenterRef\n    updateDraggablePosition\n    // Memoized callback for positioning\n    // hasAnimatedOnceRef is intentionally not a dep, its current value is checked inside.\n  ]);\n  const draggableRefCallback = useCallback((node) => {\n    setMovingElementNode(node), movingElementRef.current = node;\n  }, []), handleRefCallback = useCallback((node) => {\n    setDragInitiatorNode(node), dragInitiatorRef.current = node;\n  }, []);\n  return {\n    draggableRef: draggableRefCallback,\n    handleRef: handleRefCallback,\n    position: {\n      snapArea: currentSnapArea,\n      isTopHalf: persistedRelativeCenterRef.current ? persistedRelativeCenterRef.current.y <= 0.5 : !0,\n      isLeftHalf: persistedRelativeCenterRef.current ? persistedRelativeCenterRef.current.x <= 0.5 : !0\n    },\n    wasDragged,\n    isDragging\n  };\n}\nconst $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < \"u\" ? React__default.useLayoutEffect : () => {\n};\nfunction $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn) {\n  const ref = useRef(null);\n  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {\n    ref.current = fn;\n  }, [\n    fn\n  ]), useCallback((...args) => {\n    const f2 = ref.current;\n    return f2 == null ? void 0 : f2(...args);\n  }, []);\n}\nconst $431fbd86ca7dc216$export$b204af158042fbac = (el) => {\n  var _el_ownerDocument;\n  return (_el_ownerDocument = el == null ? void 0 : el.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;\n}, $431fbd86ca7dc216$export$f21a1ffae260145a = (el) => el && \"window\" in el && el.window === el ? el : $431fbd86ca7dc216$export$b204af158042fbac(el).defaultView || window;\nfunction $431fbd86ca7dc216$var$isNode(value) {\n  return value !== null && typeof value == \"object\" && \"nodeType\" in value && typeof value.nodeType == \"number\";\n}\nfunction $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {\n  return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in node;\n}\nlet $f4e2df6bd15f8569$var$_shadowDOM = !1;\nfunction $f4e2df6bd15f8569$export$98658e8c59125e6a() {\n  return $f4e2df6bd15f8569$var$_shadowDOM;\n}\nfunction $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {\n  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node ? node.contains(otherNode) : !1;\n  if (!node || !otherNode) return !1;\n  let currentNode = otherNode;\n  for (; currentNode !== null; ) {\n    if (currentNode === node) return !0;\n    currentNode.tagName === \"SLOT\" && currentNode.assignedSlot ? currentNode = currentNode.assignedSlot.parentNode : $431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode) ? currentNode = currentNode.host : currentNode = currentNode.parentNode;\n  }\n  return !1;\n}\nconst $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {\n  var _activeElement_shadowRoot;\n  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc.activeElement;\n  let activeElement = doc.activeElement;\n  for (; activeElement && \"shadowRoot\" in activeElement && (!((_activeElement_shadowRoot = activeElement.shadowRoot) === null || _activeElement_shadowRoot === void 0) && _activeElement_shadowRoot.activeElement); ) activeElement = activeElement.shadowRoot.activeElement;\n  return activeElement;\n};\nfunction $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {\n  return $f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot && event.composedPath ? event.composedPath()[0] : event.target;\n}\nvar define_process_env_default$4 = {};\nfunction $c87311424ea30a05$var$testUserAgent(re) {\n  var _window_navigator_userAgentData;\n  return typeof window > \"u\" || window.navigator == null ? !1 : ((_window_navigator_userAgentData = window.navigator.userAgentData) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re.test(brand.brand))) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n  var _window_navigator_userAgentData;\n  return typeof window < \"u\" && window.navigator != null ? re.test(((_window_navigator_userAgentData = window.navigator.userAgentData) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : !1;\n}\nfunction $c87311424ea30a05$var$cached(fn) {\n  if (define_process_env_default$4.NODE_ENV === \"test\") return fn;\n  let res = null;\n  return () => (res == null && (res = fn()), res);\n}\nconst $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {\n  return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {\n  return $c87311424ea30a05$var$testUserAgent(/Android/i);\n});\nfunction $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n  let globalListeners = useRef(/* @__PURE__ */ new Map()), addGlobalListener = useCallback((eventTarget, type, listener, options) => {\n    let fn = options != null && options.once ? (...args) => {\n      globalListeners.current.delete(listener), listener(...args);\n    } : listener;\n    globalListeners.current.set(listener, {\n      type,\n      eventTarget,\n      fn,\n      options\n    }), eventTarget.addEventListener(type, fn, options);\n  }, []), removeGlobalListener = useCallback((eventTarget, type, listener, options) => {\n    var _globalListeners_current_get;\n    let fn = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;\n    eventTarget.removeEventListener(type, fn, options), globalListeners.current.delete(listener);\n  }, []), removeAllGlobalListeners = useCallback(() => {\n    globalListeners.current.forEach((value, key) => {\n      removeGlobalListener(value.eventTarget, value.type, key, value.options);\n    });\n  }, [\n    removeGlobalListener\n  ]);\n  return useEffect(() => removeAllGlobalListeners, [\n    removeAllGlobalListeners\n  ]), {\n    addGlobalListener,\n    removeGlobalListener,\n    removeAllGlobalListeners\n  };\n}\nfunction $6a7db85432448f7f$export$60278871457622de(event) {\n  return event.mozInputSource === 0 && event.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType ? event.type === \"click\" && event.buttons === 1 : event.detail === 0 && !event.pointerType;\n}\nfunction $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent) {\n  let event = nativeEvent;\n  return event.nativeEvent = nativeEvent, event.isDefaultPrevented = () => event.defaultPrevented, event.isPropagationStopped = () => event.cancelBubble, event.persist = () => {\n  }, event;\n}\nfunction $8a9cb279dc87e130$export$c2b7abe5d61ec696(event, target) {\n  Object.defineProperty(event, \"target\", {\n    value: target\n  }), Object.defineProperty(event, \"currentTarget\", {\n    value: target\n  });\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n  let stateRef = useRef({\n    isFocused: !1,\n    observer: null\n  });\n  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {\n    const state = stateRef.current;\n    return () => {\n      state.observer && (state.observer.disconnect(), state.observer = null);\n    };\n  }, []);\n  let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {\n    onBlur == null || onBlur(e2);\n  });\n  return useCallback((e2) => {\n    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {\n      stateRef.current.isFocused = !0;\n      let target = e2.target, onBlurHandler = (e3) => {\n        if (stateRef.current.isFocused = !1, target.disabled) {\n          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(e3);\n          dispatchBlur(event);\n        }\n        stateRef.current.observer && (stateRef.current.observer.disconnect(), stateRef.current.observer = null);\n      };\n      target.addEventListener(\"focusout\", onBlurHandler, {\n        once: !0\n      }), stateRef.current.observer = new MutationObserver(() => {\n        if (stateRef.current.isFocused && target.disabled) {\n          var _stateRef_current_observer;\n          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 || _stateRef_current_observer.disconnect();\n          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;\n          target.dispatchEvent(new FocusEvent(\"blur\", {\n            relatedTarget: relatedTargetEl\n          })), target.dispatchEvent(new FocusEvent(\"focusout\", {\n            bubbles: !0,\n            relatedTarget: relatedTargetEl\n          }));\n        }\n      }), stateRef.current.observer.observe(target, {\n        attributes: !0,\n        attributeFilter: [\n          \"disabled\"\n        ]\n      });\n    }\n  }, [\n    dispatchBlur\n  ]);\n}\nlet $8a9cb279dc87e130$export$fda7da73ab5d4c48 = !1;\nvar define_process_env_default$3 = {};\nlet $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n  Tab: !0,\n  Escape: !0\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {\n  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e2);\n}\nfunction $507fabe10e71c6fb$var$isValidKey(e2) {\n  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === \"Control\" || e2.key === \"Shift\" || e2.key === \"Meta\");\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(e2) && ($507fabe10e71c6fb$var$currentModality = \"keyboard\", $507fabe10e71c6fb$var$triggerChangeHandlers(\"keyboard\", e2));\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e2) {\n  $507fabe10e71c6fb$var$currentModality = \"pointer\", (e2.type === \"mousedown\" || e2.type === \"pointerdown\") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers(\"pointer\", e2));\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e2) {\n  $6a7db85432448f7f$export$60278871457622de(e2) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = \"virtual\");\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e2) {\n  e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = \"virtual\", $507fabe10e71c6fb$var$triggerChangeHandlers(\"virtual\", e2)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;\n}\nfunction $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {\n  if (typeof window > \"u\" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;\n  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);\n  let focus = windowObject.HTMLElement.prototype.focus;\n  windowObject.HTMLElement.prototype.focus = function() {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, focus.apply(this, arguments);\n  }, documentObject.addEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.addEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.addEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.addEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, !0), windowObject.addEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < \"u\" ? (documentObject.addEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : define_process_env_default$3.NODE_ENV === \"test\" && (documentObject.addEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.addEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, !0)), windowObject.addEventListener(\"beforeunload\", () => {\n    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);\n  }, {\n    once: !0\n  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {\n    focus\n  });\n}\nconst $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {\n  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element), documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);\n  loadListener && documentObject.removeEventListener(\"DOMContentLoaded\", loadListener), $507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject) && (windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus, documentObject.removeEventListener(\"keydown\", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.removeEventListener(\"keyup\", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), documentObject.removeEventListener(\"click\", $507fabe10e71c6fb$var$handleClickEvent, !0), windowObject.removeEventListener(\"focus\", $507fabe10e71c6fb$var$handleFocusEvent, !0), windowObject.removeEventListener(\"blur\", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < \"u\" ? (documentObject.removeEventListener(\"pointerdown\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener(\"pointermove\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener(\"pointerup\", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : define_process_env_default$3.NODE_ENV === \"test\" && (documentObject.removeEventListener(\"mousedown\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener(\"mousemove\", $507fabe10e71c6fb$var$handlePointerEvent, !0), documentObject.removeEventListener(\"mouseup\", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject));\n};\nfunction $507fabe10e71c6fb$export$2f1888112f558a7d(element) {\n  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);\n  let loadListener;\n  return documentObject.readyState !== \"loading\" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) : (loadListener = () => {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);\n  }, documentObject.addEventListener(\"DOMContentLoaded\", loadListener)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);\n}\ntypeof document < \"u\" && $507fabe10e71c6fb$export$2f1888112f558a7d();\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n  return $507fabe10e71c6fb$var$currentModality !== \"pointer\";\n}\nconst $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([\n  \"checkbox\",\n  \"radio\",\n  \"range\",\n  \"color\",\n  \"file\",\n  \"image\",\n  \"button\",\n  \"submit\",\n  \"reset\"\n]);\nfunction $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {\n  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 == null ? void 0 : e2.target);\n  const IHTMLInputElement = typeof window < \"u\" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLInputElement : HTMLInputElement, IHTMLTextAreaElement = typeof window < \"u\" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement, IHTMLElement = typeof window < \"u\" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).HTMLElement : HTMLElement, IKeyboardEvent = typeof window < \"u\" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 == null ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;\n  return isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable, !(isTextInput && modality === \"keyboard\" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {\n    let handler = (modality, e2) => {\n      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts != null && opts.isTextInput), modality, e2) && fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n    };\n    return $507fabe10e71c6fb$var$changeHandlers.add(handler), () => {\n      $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n    };\n  }, deps);\n}\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;\n  const onBlur = useCallback((e2) => {\n    if (e2.target === e2.currentTarget)\n      return onBlurProp && onBlurProp(e2), onFocusChange && onFocusChange(!1), !0;\n  }, [\n    onBlurProp,\n    onFocusChange\n  ]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur), onFocus = useCallback((e2) => {\n    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target), activeElement = ownerDocument ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument) : $d4ee10de306f2510$export$cd4e5573fbe2b576();\n    e2.target === e2.currentTarget && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent) && (onFocusProp && onFocusProp(e2), onFocusChange && onFocusChange(!0), onSyntheticFocus(e2));\n  }, [\n    onFocusChange,\n    onFocusProp,\n    onSyntheticFocus\n  ]);\n  return {\n    focusProps: {\n      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,\n      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0\n    }\n  };\n}\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props, state = useRef({\n    isFocusWithin: !1\n  }), { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), onBlur = useCallback((e2) => {\n    e2.currentTarget.contains(e2.target) && state.current.isFocusWithin && !e2.currentTarget.contains(e2.relatedTarget) && (state.current.isFocusWithin = !1, removeAllGlobalListeners(), onBlurWithin && onBlurWithin(e2), onFocusWithinChange && onFocusWithinChange(!1));\n  }, [\n    onBlurWithin,\n    onFocusWithinChange,\n    state,\n    removeAllGlobalListeners\n  ]), onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur), onFocus = useCallback((e2) => {\n    if (!e2.currentTarget.contains(e2.target)) return;\n    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target), activeElement = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument);\n    if (!state.current.isFocusWithin && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {\n      onFocusWithin && onFocusWithin(e2), onFocusWithinChange && onFocusWithinChange(!0), state.current.isFocusWithin = !0, onSyntheticFocus(e2);\n      let currentTarget = e2.currentTarget;\n      addGlobalListener(ownerDocument, \"focus\", (e3) => {\n        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {\n          let nativeEvent = new ownerDocument.defaultView.FocusEvent(\"blur\", {\n            relatedTarget: e3.target\n          });\n          $8a9cb279dc87e130$export$c2b7abe5d61ec696(nativeEvent, currentTarget);\n          let event = $8a9cb279dc87e130$export$525bc4921d56d4a(nativeEvent);\n          onBlur(event);\n        }\n      }, {\n        capture: !0\n      });\n    }\n  }, [\n    onFocusWithin,\n    onFocusWithinChange,\n    onSyntheticFocus,\n    addGlobalListener,\n    onBlur\n  ]);\n  return isDisabled ? {\n    focusWithinProps: {\n      // These cannot be null, that would conflict in mergeProps\n      onFocus: void 0,\n      onBlur: void 0\n    }\n  } : {\n    focusWithinProps: {\n      onFocus,\n      onBlur\n    }\n  };\n}\nvar define_process_env_default$2 = {};\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;\n  }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {\n  e2.pointerType === \"touch\" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n  if (!(typeof document > \"u\"))\n    return typeof PointerEvent < \"u\" ? document.addEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent) : define_process_env_default$2.NODE_ENV === \"test\" && document.addEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {\n      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < \"u\" ? document.removeEventListener(\"pointerup\", $6179b936705e76d3$var$handleGlobalPointerEvent) : define_process_env_default$2.NODE_ENV === \"test\" && document.removeEventListener(\"touchend\", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props, [isHovered, setHovered] = useState(!1), state = useRef({\n    isHovered: !1,\n    ignoreEmulatedMouseEvents: !1,\n    pointerType: \"\",\n    target: null\n  }).current;\n  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6(), { hoverProps, triggerHoverEnd } = useMemo(() => {\n    let triggerHoverStart = (event, pointerType) => {\n      if (state.pointerType = pointerType, isDisabled || pointerType === \"touch\" || state.isHovered || !event.currentTarget.contains(event.target)) return;\n      state.isHovered = !0;\n      let target = event.currentTarget;\n      state.target = target, addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), \"pointerover\", (e2) => {\n        state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target) && triggerHoverEnd2(e2, e2.pointerType);\n      }, {\n        capture: !0\n      }), onHoverStart && onHoverStart({\n        type: \"hoverstart\",\n        target,\n        pointerType\n      }), onHoverChange && onHoverChange(!0), setHovered(!0);\n    }, triggerHoverEnd2 = (event, pointerType) => {\n      let target = state.target;\n      state.pointerType = \"\", state.target = null, !(pointerType === \"touch\" || !state.isHovered || !target) && (state.isHovered = !1, removeAllGlobalListeners(), onHoverEnd && onHoverEnd({\n        type: \"hoverend\",\n        target,\n        pointerType\n      }), onHoverChange && onHoverChange(!1), setHovered(!1));\n    }, hoverProps2 = {};\n    return typeof PointerEvent < \"u\" ? (hoverProps2.onPointerEnter = (e2) => {\n      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === \"mouse\" || triggerHoverStart(e2, e2.pointerType);\n    }, hoverProps2.onPointerLeave = (e2) => {\n      !isDisabled && e2.currentTarget.contains(e2.target) && triggerHoverEnd2(e2, e2.pointerType);\n    }) : define_process_env_default$2.NODE_ENV === \"test\" && (hoverProps2.onTouchStart = () => {\n      state.ignoreEmulatedMouseEvents = !0;\n    }, hoverProps2.onMouseEnter = (e2) => {\n      !state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && triggerHoverStart(e2, \"mouse\"), state.ignoreEmulatedMouseEvents = !1;\n    }, hoverProps2.onMouseLeave = (e2) => {\n      !isDisabled && e2.currentTarget.contains(e2.target) && triggerHoverEnd2(e2, \"mouse\");\n    }), {\n      hoverProps: hoverProps2,\n      triggerHoverEnd: triggerHoverEnd2\n    };\n  }, [\n    onHoverStart,\n    onHoverChange,\n    onHoverEnd,\n    isDisabled,\n    state,\n    addGlobalListener,\n    removeAllGlobalListeners\n  ]);\n  return useEffect(() => {\n    isDisabled && triggerHoverEnd({\n      currentTarget: state.target\n    }, state.pointerType);\n  }, [\n    isDisabled\n  ]), {\n    hoverProps,\n    isHovered\n  };\n}\nfunction $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {\n  let { autoFocus = !1, isTextInput, within } = props, state = useRef({\n    isFocused: !1,\n    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()\n  }), [isFocused, setFocused] = useState(!1), [isFocusVisibleState, setFocusVisible] = useState(() => state.current.isFocused && state.current.isFocusVisible), updateState = useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []), onFocusChange = useCallback((isFocused2) => {\n    state.current.isFocused = isFocused2, setFocused(isFocused2), updateState();\n  }, [\n    updateState\n  ]);\n  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {\n    state.current.isFocusVisible = isFocusVisible, updateState();\n  }, [], {\n    isTextInput\n  });\n  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({\n    isDisabled: within,\n    onFocusChange\n  }), { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({\n    isDisabled: !within,\n    onFocusWithinChange: onFocusChange\n  });\n  return {\n    isFocused,\n    isFocusVisible: isFocusVisibleState,\n    focusProps: within ? focusWithinProps : focusProps\n  };\n}\nvar i$6 = Object.defineProperty, d$3 = (t2, e2, n2) => e2 in t2 ? i$6(t2, e2, { enumerable: !0, configurable: !0, writable: !0, value: n2 }) : t2[e2] = n2, r$2 = (t2, e2, n2) => (d$3(t2, typeof e2 != \"symbol\" ? e2 + \"\" : e2, n2), n2);\nlet o$7 = class {\n  constructor() {\n    r$2(this, \"current\", this.detect()), r$2(this, \"handoffState\", \"pending\"), r$2(this, \"currentId\", 0);\n  }\n  set(e2) {\n    this.current !== e2 && (this.handoffState = \"pending\", this.currentId = 0, this.current = e2);\n  }\n  reset() {\n    this.set(this.detect());\n  }\n  nextId() {\n    return ++this.currentId;\n  }\n  get isServer() {\n    return this.current === \"server\";\n  }\n  get isClient() {\n    return this.current === \"client\";\n  }\n  detect() {\n    return typeof window > \"u\" || typeof document > \"u\" ? \"server\" : \"client\";\n  }\n  handoff() {\n    this.handoffState === \"pending\" && (this.handoffState = \"complete\");\n  }\n  get isHandoffComplete() {\n    return this.handoffState === \"complete\";\n  }\n}, s$7 = new o$7();\nfunction o$6(n2) {\n  var e2, r2;\n  return s$7.isServer ? null : n2 ? \"ownerDocument\" in n2 ? n2.ownerDocument : \"current\" in n2 ? (r2 = (e2 = n2.current) == null ? void 0 : e2.ownerDocument) != null ? r2 : document : null : document;\n}\nfunction t$3(e2) {\n  typeof queueMicrotask == \"function\" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o3) => setTimeout(() => {\n    throw o3;\n  }));\n}\nfunction o$5() {\n  let n2 = [], r2 = { addEventListener(e2, t2, s2, a3) {\n    return e2.addEventListener(t2, s2, a3), r2.add(() => e2.removeEventListener(t2, s2, a3));\n  }, requestAnimationFrame(...e2) {\n    let t2 = requestAnimationFrame(...e2);\n    return r2.add(() => cancelAnimationFrame(t2));\n  }, nextFrame(...e2) {\n    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));\n  }, setTimeout(...e2) {\n    let t2 = setTimeout(...e2);\n    return r2.add(() => clearTimeout(t2));\n  }, microTask(...e2) {\n    let t2 = { current: !0 };\n    return t$3(() => {\n      t2.current && e2[0]();\n    }), r2.add(() => {\n      t2.current = !1;\n    });\n  }, style(e2, t2, s2) {\n    let a3 = e2.style.getPropertyValue(t2);\n    return Object.assign(e2.style, { [t2]: s2 }), this.add(() => {\n      Object.assign(e2.style, { [t2]: a3 });\n    });\n  }, group(e2) {\n    let t2 = o$5();\n    return e2(t2), this.add(() => t2.dispose());\n  }, add(e2) {\n    return n2.includes(e2) || n2.push(e2), () => {\n      let t2 = n2.indexOf(e2);\n      if (t2 >= 0) for (let s2 of n2.splice(t2, 1)) s2();\n    };\n  }, dispose() {\n    for (let e2 of n2.splice(0)) e2();\n  } };\n  return r2;\n}\nfunction p$2() {\n  let [e2] = useState(o$5);\n  return useEffect(() => () => e2.dispose(), [e2]), e2;\n}\nlet n$3 = (e2, t2) => {\n  s$7.isServer ? useEffect(e2, t2) : useLayoutEffect(e2, t2);\n};\nfunction s$6(e2) {\n  let r2 = useRef(e2);\n  return n$3(() => {\n    r2.current = e2;\n  }, [e2]), r2;\n}\nlet o$4 = function(t2) {\n  let e2 = s$6(t2);\n  return React__default.useCallback((...r2) => e2.current(...r2), [e2]);\n};\nfunction E$1(e2) {\n  let t2 = e2.width / 2, n2 = e2.height / 2;\n  return { top: e2.clientY - n2, right: e2.clientX + t2, bottom: e2.clientY + n2, left: e2.clientX - t2 };\n}\nfunction P$3(e2, t2) {\n  return !(!e2 || !t2 || e2.right < t2.left || e2.left > t2.right || e2.bottom < t2.top || e2.top > t2.bottom);\n}\nfunction w$2({ disabled: e2 = !1 } = {}) {\n  let t2 = useRef(null), [n2, l2] = useState(!1), r2 = p$2(), o3 = o$4(() => {\n    t2.current = null, l2(!1), r2.dispose();\n  }), f2 = o$4((s2) => {\n    if (r2.dispose(), t2.current === null) {\n      t2.current = s2.currentTarget, l2(!0);\n      {\n        let i2 = o$6(s2.currentTarget);\n        r2.addEventListener(i2, \"pointerup\", o3, !1), r2.addEventListener(i2, \"pointermove\", (c2) => {\n          if (t2.current) {\n            let p2 = E$1(c2);\n            l2(P$3(p2, t2.current.getBoundingClientRect()));\n          }\n        }, !1), r2.addEventListener(i2, \"pointercancel\", o3, !1);\n      }\n    }\n  });\n  return { pressed: n2, pressProps: e2 ? {} : { onPointerDown: f2, onPointerUp: o3, onClick: o3 } };\n}\nlet e$3 = createContext(void 0);\nfunction a$9() {\n  return useContext(e$3);\n}\nfunction t$2(...r2) {\n  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == \"string\" ? n2.split(\" \") : []))).filter(Boolean).join(\" \");\n}\nfunction u$7(r2, n2, ...a3) {\n  if (r2 in n2) {\n    let e2 = n2[r2];\n    return typeof e2 == \"function\" ? e2(...a3) : e2;\n  }\n  let t2 = new Error(\\`Tried to handle \"\\${r2}\" but there is no handler defined. Only defined handlers are: \\${Object.keys(n2).map((e2) => \\`\"\\${e2}\"\\`).join(\", \")}.\\`);\n  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$7), t2;\n}\nvar O$1 = ((a3) => (a3[a3.None = 0] = \"None\", a3[a3.RenderStrategy = 1] = \"RenderStrategy\", a3[a3.Static = 2] = \"Static\", a3))(O$1 || {}), A$1 = ((e2) => (e2[e2.Unmount = 0] = \"Unmount\", e2[e2.Hidden = 1] = \"Hidden\", e2))(A$1 || {});\nfunction L$2() {\n  let n2 = U$2();\n  return useCallback((r2) => C$2({ mergeRefs: n2, ...r2 }), [n2]);\n}\nfunction C$2({ ourProps: n2, theirProps: r2, slot: e2, defaultTag: a3, features: s2, visible: t2 = !0, name: l2, mergeRefs: i2 }) {\n  i2 = i2 ?? $;\n  let o3 = P$2(r2, n2);\n  if (t2) return F$3(o3, e2, a3, l2, i2);\n  let y2 = s2 ?? 0;\n  if (y2 & 2) {\n    let { static: f2 = !1, ...u2 } = o3;\n    if (f2) return F$3(u2, e2, a3, l2, i2);\n  }\n  if (y2 & 1) {\n    let { unmount: f2 = !0, ...u2 } = o3;\n    return u$7(f2 ? 0 : 1, { 0() {\n      return null;\n    }, 1() {\n      return F$3({ ...u2, hidden: !0, style: { display: \"none\" } }, e2, a3, l2, i2);\n    } });\n  }\n  return F$3(o3, e2, a3, l2, i2);\n}\nfunction F$3(n2, r2 = {}, e2, a3, s2) {\n  let { as: t2 = e2, children: l2, refName: i2 = \"ref\", ...o3 } = h$4(n2, [\"unmount\", \"static\"]), y2 = n2.ref !== void 0 ? { [i2]: n2.ref } : {}, f2 = typeof l2 == \"function\" ? l2(r2) : l2;\n  \"className\" in o3 && o3.className && typeof o3.className == \"function\" && (o3.className = o3.className(r2)), o3[\"aria-labelledby\"] && o3[\"aria-labelledby\"] === o3.id && (o3[\"aria-labelledby\"] = void 0);\n  let u2 = {};\n  if (r2) {\n    let d2 = !1, p2 = [];\n    for (let [c2, T2] of Object.entries(r2)) typeof T2 == \"boolean\" && (d2 = !0), T2 === !0 && p2.push(c2.replace(/([A-Z])/g, (g2) => \\`-\\${g2.toLowerCase()}\\`));\n    if (d2) {\n      u2[\"data-headlessui-state\"] = p2.join(\" \");\n      for (let c2 of p2) u2[\\`data-\\${c2}\\`] = \"\";\n    }\n  }\n  if (t2 === Fragment && (Object.keys(m$4(o3)).length > 0 || Object.keys(m$4(u2)).length > 0)) if (!isValidElement(f2) || Array.isArray(f2) && f2.length > 1) {\n    if (Object.keys(m$4(o3)).length > 0) throw new Error(['Passing props on \"Fragment\"!', \"\", \\`The current component <\\${a3} /> is rendering a \"Fragment\".\\`, \"However we need to passthrough the following props:\", Object.keys(m$4(o3)).concat(Object.keys(m$4(u2))).map((d2) => \\`  - \\${d2}\\`).join(\\`\n\\`), \"\", \"You can apply a few solutions:\", ['Add an \\`as=\"...\"\\` prop, to ensure that we render an actual element instead of a \"Fragment\".', \"Render a single element as the child so that we can forward the props onto that element.\"].map((d2) => \\`  - \\${d2}\\`).join(\\`\n\\`)].join(\\`\n\\`));\n  } else {\n    let d2 = f2.props, p2 = d2 == null ? void 0 : d2.className, c2 = typeof p2 == \"function\" ? (...R2) => t$2(p2(...R2), o3.className) : t$2(p2, o3.className), T2 = c2 ? { className: c2 } : {}, g2 = P$2(f2.props, m$4(h$4(o3, [\"ref\"])));\n    for (let R2 in u2) R2 in g2 && delete u2[R2];\n    return cloneElement(f2, Object.assign({}, g2, u2, y2, { ref: s2(H$5(f2), y2.ref) }, T2));\n  }\n  return createElement(t2, Object.assign({}, h$4(o3, [\"ref\"]), t2 !== Fragment && y2, t2 !== Fragment && u2), f2);\n}\nfunction U$2() {\n  let n2 = useRef([]), r2 = useCallback((e2) => {\n    for (let a3 of n2.current) a3 != null && (typeof a3 == \"function\" ? a3(e2) : a3.current = e2);\n  }, []);\n  return (...e2) => {\n    if (!e2.every((a3) => a3 == null)) return n2.current = e2, r2;\n  };\n}\nfunction $(...n2) {\n  return n2.every((r2) => r2 == null) ? void 0 : (r2) => {\n    for (let e2 of n2) e2 != null && (typeof e2 == \"function\" ? e2(r2) : e2.current = r2);\n  };\n}\nfunction P$2(...n2) {\n  if (n2.length === 0) return {};\n  if (n2.length === 1) return n2[0];\n  let r2 = {}, e2 = {};\n  for (let s2 of n2) for (let t2 in s2) t2.startsWith(\"on\") && typeof s2[t2] == \"function\" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];\n  if (r2.disabled || r2[\"aria-disabled\"]) for (let s2 in e2) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s2) && (e2[s2] = [(t2) => {\n    var l2;\n    return (l2 = t2 == null ? void 0 : t2.preventDefault) == null ? void 0 : l2.call(t2);\n  }]);\n  for (let s2 in e2) Object.assign(r2, { [s2](t2, ...l2) {\n    let i2 = e2[s2];\n    for (let o3 of i2) {\n      if ((t2 instanceof Event || (t2 == null ? void 0 : t2.nativeEvent) instanceof Event) && t2.defaultPrevented) return;\n      o3(t2, ...l2);\n    }\n  } });\n  return r2;\n}\nfunction _$2(...n2) {\n  if (n2.length === 0) return {};\n  if (n2.length === 1) return n2[0];\n  let r2 = {}, e2 = {};\n  for (let s2 of n2) for (let t2 in s2) t2.startsWith(\"on\") && typeof s2[t2] == \"function\" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];\n  for (let s2 in e2) Object.assign(r2, { [s2](...t2) {\n    let l2 = e2[s2];\n    for (let i2 of l2) i2 == null || i2(...t2);\n  } });\n  return r2;\n}\nfunction K$1(n2) {\n  var r2;\n  return Object.assign(forwardRef(n2), { displayName: (r2 = n2.displayName) != null ? r2 : n2.name });\n}\nfunction m$4(n2) {\n  let r2 = Object.assign({}, n2);\n  for (let e2 in r2) r2[e2] === void 0 && delete r2[e2];\n  return r2;\n}\nfunction h$4(n2, r2 = []) {\n  let e2 = Object.assign({}, n2);\n  for (let a3 of r2) a3 in e2 && delete e2[a3];\n  return e2;\n}\nfunction H$5(n2) {\n  return React__default.version.split(\".\")[0] >= \"19\" ? n2.props.ref : n2.ref;\n}\nlet R$2 = \"button\";\nfunction v$1(a3, u2) {\n  var p2;\n  let l2 = a$9(), { disabled: e2 = l2 || !1, autoFocus: t2 = !1, ...o3 } = a3, { isFocusVisible: r2, focusProps: i2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: t2 }), { isHovered: s2, hoverProps: T2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), { pressed: n2, pressProps: d2 } = w$2({ disabled: e2 }), f2 = _$2({ ref: u2, type: (p2 = o3.type) != null ? p2 : \"button\", disabled: e2 || void 0, autoFocus: t2 }, i2, T2, d2), m2 = useMemo(() => ({ disabled: e2, hover: s2, focus: r2, active: n2, autofocus: t2 }), [e2, s2, r2, n2, t2]);\n  return L$2()({ ourProps: f2, theirProps: o3, slot: m2, defaultTag: R$2, name: \"Button\" });\n}\nlet H$4 = K$1(v$1), e$2 = createContext(void 0);\nfunction u$6() {\n  return useContext(e$2);\n}\nfunction r$1(n2) {\n  let e2 = n2.parentElement, l2 = null;\n  for (; e2 && !(e2 instanceof HTMLFieldSetElement); ) e2 instanceof HTMLLegendElement && (l2 = e2), e2 = e2.parentElement;\n  let t2 = (e2 == null ? void 0 : e2.getAttribute(\"disabled\")) === \"\";\n  return t2 && i$5(l2) ? !1 : t2;\n}\nfunction i$5(n2) {\n  if (!n2) return !1;\n  let e2 = n2.previousElementSibling;\n  for (; e2 !== null; ) {\n    if (e2 instanceof HTMLLegendElement) return !1;\n    e2 = e2.previousElementSibling;\n  }\n  return !0;\n}\nlet u$5 = Symbol();\nfunction T$3(t2, n2 = !0) {\n  return Object.assign(t2, { [u$5]: n2 });\n}\nfunction y$4(...t2) {\n  let n2 = useRef(t2);\n  useEffect(() => {\n    n2.current = t2;\n  }, [t2]);\n  let c2 = o$4((e2) => {\n    for (let o3 of n2.current) o3 != null && (typeof o3 == \"function\" ? o3(e2) : o3.current = e2);\n  });\n  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u$5])) ? void 0 : c2;\n}\nlet a$8 = createContext(null);\na$8.displayName = \"DescriptionContext\";\nfunction f$6() {\n  let r2 = useContext(a$8);\n  if (r2 === null) {\n    let e2 = new Error(\"You used a <Description /> component, but it is not inside a relevant parent.\");\n    throw Error.captureStackTrace && Error.captureStackTrace(e2, f$6), e2;\n  }\n  return r2;\n}\nfunction U$1() {\n  var r2, e2;\n  return (e2 = (r2 = useContext(a$8)) == null ? void 0 : r2.value) != null ? e2 : void 0;\n}\nfunction w$1() {\n  let [r2, e2] = useState([]);\n  return [r2.length > 0 ? r2.join(\" \") : void 0, useMemo(() => function(t2) {\n    let i2 = o$4((n2) => (e2((s2) => [...s2, n2]), () => e2((s2) => {\n      let o3 = s2.slice(), p2 = o3.indexOf(n2);\n      return p2 !== -1 && o3.splice(p2, 1), o3;\n    }))), l2 = useMemo(() => ({ register: i2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [i2, t2.slot, t2.name, t2.props, t2.value]);\n    return React__default.createElement(a$8.Provider, { value: l2 }, t2.children);\n  }, [e2])];\n}\nlet S$4 = \"p\";\nfunction C$1(r2, e2) {\n  let d2 = useId$1(), t2 = a$9(), { id: i2 = \\`headlessui-description-\\${d2}\\`, ...l2 } = r2, n2 = f$6(), s2 = y$4(e2);\n  n$3(() => n2.register(i2), [i2, n2.register]);\n  let o3 = t2 || !1, p2 = useMemo(() => ({ ...n2.slot, disabled: o3 }), [n2.slot, o3]), D2 = { ref: s2, ...n2.props, id: i2 };\n  return L$2()({ ourProps: D2, theirProps: l2, slot: p2, defaultTag: S$4, name: n2.name || \"Description\" });\n}\nlet _$1 = K$1(C$1);\nObject.assign(_$1, {});\nvar o$3 = ((r2) => (r2.Space = \" \", r2.Enter = \"Enter\", r2.Escape = \"Escape\", r2.Backspace = \"Backspace\", r2.Delete = \"Delete\", r2.ArrowLeft = \"ArrowLeft\", r2.ArrowUp = \"ArrowUp\", r2.ArrowRight = \"ArrowRight\", r2.ArrowDown = \"ArrowDown\", r2.Home = \"Home\", r2.End = \"End\", r2.PageUp = \"PageUp\", r2.PageDown = \"PageDown\", r2.Tab = \"Tab\", r2))(o$3 || {});\nlet c$5 = createContext(null);\nc$5.displayName = \"LabelContext\";\nfunction P$1() {\n  let r2 = useContext(c$5);\n  if (r2 === null) {\n    let l2 = new Error(\"You used a <Label /> component, but it is not inside a relevant parent.\");\n    throw Error.captureStackTrace && Error.captureStackTrace(l2, P$1), l2;\n  }\n  return r2;\n}\nfunction I$2(r2) {\n  var a3, e2, o3;\n  let l2 = (e2 = (a3 = useContext(c$5)) == null ? void 0 : a3.value) != null ? e2 : void 0;\n  return ((o3 = void 0) != null ? o3 : 0) > 0 ? [l2, ...r2].filter(Boolean).join(\" \") : l2;\n}\nfunction K({ inherit: r2 = !1 } = {}) {\n  let l2 = I$2(), [a3, e2] = useState([]), o3 = r2 ? [l2, ...a3].filter(Boolean) : a3;\n  return [o3.length > 0 ? o3.join(\" \") : void 0, useMemo(() => function(t2) {\n    let s2 = o$4((i2) => (e2((p2) => [...p2, i2]), () => e2((p2) => {\n      let u2 = p2.slice(), d2 = u2.indexOf(i2);\n      return d2 !== -1 && u2.splice(d2, 1), u2;\n    }))), m2 = useMemo(() => ({ register: s2, slot: t2.slot, name: t2.name, props: t2.props, value: t2.value }), [s2, t2.slot, t2.name, t2.props, t2.value]);\n    return React__default.createElement(c$5.Provider, { value: m2 }, t2.children);\n  }, [e2])];\n}\nlet N = \"label\";\nfunction G$1(r2, l2) {\n  var y2;\n  let a3 = useId$1(), e2 = P$1(), o3 = u$6(), g2 = a$9(), { id: t2 = \\`headlessui-label-\\${a3}\\`, htmlFor: s2 = o3 ?? ((y2 = e2.props) == null ? void 0 : y2.htmlFor), passive: m2 = !1, ...i2 } = r2, p2 = y$4(l2);\n  n$3(() => e2.register(t2), [t2, e2.register]);\n  let u2 = o$4((L2) => {\n    let b2 = L2.currentTarget;\n    if (b2 instanceof HTMLLabelElement && L2.preventDefault(), e2.props && \"onClick\" in e2.props && typeof e2.props.onClick == \"function\" && e2.props.onClick(L2), b2 instanceof HTMLLabelElement) {\n      let n2 = document.getElementById(b2.htmlFor);\n      if (n2) {\n        let E2 = n2.getAttribute(\"disabled\");\n        if (E2 === \"true\" || E2 === \"\") return;\n        let x2 = n2.getAttribute(\"aria-disabled\");\n        if (x2 === \"true\" || x2 === \"\") return;\n        (n2 instanceof HTMLInputElement && (n2.type === \"radio\" || n2.type === \"checkbox\") || n2.role === \"radio\" || n2.role === \"checkbox\" || n2.role === \"switch\") && n2.click(), n2.focus({ preventScroll: !0 });\n      }\n    }\n  }), d2 = g2 || !1, C2 = useMemo(() => ({ ...e2.slot, disabled: d2 }), [e2.slot, d2]), f2 = { ref: p2, ...e2.props, id: t2, htmlFor: s2, onClick: u2 };\n  return m2 && (\"onClick\" in f2 && (delete f2.htmlFor, delete f2.onClick), \"onClick\" in i2 && delete i2.onClick), L$2()({ ourProps: f2, theirProps: i2, slot: C2, defaultTag: s2 ? N : \"div\", name: e2.name || \"Label\" });\n}\nlet U = K$1(G$1);\nObject.assign(U, {});\nfunction f$5(e2) {\n  if (e2 === null) return { width: 0, height: 0 };\n  let { width: t2, height: r2 } = e2.getBoundingClientRect();\n  return { width: t2, height: r2 };\n}\nfunction d$2(e2, t2 = !1) {\n  let [r2, u2] = useReducer(() => ({}), {}), i2 = useMemo(() => f$5(e2), [e2, r2]);\n  return n$3(() => {\n    if (!e2) return;\n    let n2 = new ResizeObserver(u2);\n    return n2.observe(e2), () => {\n      n2.disconnect();\n    };\n  }, [e2]), t2 ? { width: \\`\\${i2.width}px\\`, height: \\`\\${i2.height}px\\` } : i2;\n}\nlet a$7 = class extends Map {\n  constructor(t2) {\n    super(), this.factory = t2;\n  }\n  get(t2) {\n    let e2 = super.get(t2);\n    return e2 === void 0 && (e2 = this.factory(t2), this.set(t2, e2)), e2;\n  }\n};\nfunction a$6(o3, r2) {\n  let t2 = o3(), n2 = /* @__PURE__ */ new Set();\n  return { getSnapshot() {\n    return t2;\n  }, subscribe(e2) {\n    return n2.add(e2), () => n2.delete(e2);\n  }, dispatch(e2, ...s2) {\n    let i2 = r2[e2].call(t2, ...s2);\n    i2 && (t2 = i2, n2.forEach((c2) => c2()));\n  } };\n}\nfunction o$2(t2) {\n  return useSyncExternalStore(t2.subscribe, t2.getSnapshot, t2.getSnapshot);\n}\nlet p$1 = new a$7(() => a$6(() => [], { ADD(r2) {\n  return this.includes(r2) ? this : [...this, r2];\n}, REMOVE(r2) {\n  let e2 = this.indexOf(r2);\n  if (e2 === -1) return this;\n  let t2 = this.slice();\n  return t2.splice(e2, 1), t2;\n} }));\nfunction x$2(r2, e2) {\n  let t2 = p$1.get(e2), i2 = useId$1(), h2 = o$2(t2);\n  if (n$3(() => {\n    if (r2) return t2.dispatch(\"ADD\", i2), () => t2.dispatch(\"REMOVE\", i2);\n  }, [t2, r2]), !r2) return !1;\n  let s2 = h2.indexOf(i2), o3 = h2.length;\n  return s2 === -1 && (s2 = o3, o3 += 1), s2 === o3 - 1;\n}\nlet f$4 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();\nfunction h$3(t2) {\n  var e2;\n  let r2 = (e2 = u$4.get(t2)) != null ? e2 : 0;\n  return u$4.set(t2, r2 + 1), r2 !== 0 ? () => m$3(t2) : (f$4.set(t2, { \"aria-hidden\": t2.getAttribute(\"aria-hidden\"), inert: t2.inert }), t2.setAttribute(\"aria-hidden\", \"true\"), t2.inert = !0, () => m$3(t2));\n}\nfunction m$3(t2) {\n  var i2;\n  let r2 = (i2 = u$4.get(t2)) != null ? i2 : 1;\n  if (r2 === 1 ? u$4.delete(t2) : u$4.set(t2, r2 - 1), r2 !== 1) return;\n  let e2 = f$4.get(t2);\n  e2 && (e2[\"aria-hidden\"] === null ? t2.removeAttribute(\"aria-hidden\") : t2.setAttribute(\"aria-hidden\", e2[\"aria-hidden\"]), t2.inert = e2.inert, f$4.delete(t2));\n}\nfunction y$3(t2, { allowed: r2, disallowed: e2 } = {}) {\n  let i2 = x$2(t2, \"inert-others\");\n  n$3(() => {\n    var d2, c2;\n    if (!i2) return;\n    let a3 = o$5();\n    for (let n2 of (d2 = e2 == null ? void 0 : e2()) != null ? d2 : []) n2 && a3.add(h$3(n2));\n    let s2 = (c2 = r2 == null ? void 0 : r2()) != null ? c2 : [];\n    for (let n2 of s2) {\n      if (!n2) continue;\n      let l2 = o$6(n2);\n      if (!l2) continue;\n      let o3 = n2.parentElement;\n      for (; o3 && o3 !== l2.body; ) {\n        for (let p2 of o3.children) s2.some((E2) => p2.contains(E2)) || a3.add(h$3(p2));\n        o3 = o3.parentElement;\n      }\n    }\n    return a3.dispose;\n  }, [i2, r2, e2]);\n}\nfunction m$2(s2, n2, l2) {\n  let i2 = s$6((t2) => {\n    let e2 = t2.getBoundingClientRect();\n    e2.x === 0 && e2.y === 0 && e2.width === 0 && e2.height === 0 && l2();\n  });\n  useEffect(() => {\n    if (!s2) return;\n    let t2 = n2 === null ? null : n2 instanceof HTMLElement ? n2 : n2.current;\n    if (!t2) return;\n    let e2 = o$5();\n    if (typeof ResizeObserver < \"u\") {\n      let r2 = new ResizeObserver(() => i2.current(t2));\n      r2.observe(t2), e2.add(() => r2.disconnect());\n    }\n    if (typeof IntersectionObserver < \"u\") {\n      let r2 = new IntersectionObserver(() => i2.current(t2));\n      r2.observe(t2), e2.add(() => r2.disconnect());\n    }\n    return () => e2.dispose();\n  }, [n2, i2, s2]);\n}\nlet f$3 = [\"[contentEditable=true]\", \"[tabindex]\", \"a[href]\", \"area[href]\", \"button:not([disabled])\", \"iframe\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].map((e2) => \\`\\${e2}:not([tabindex='-1'])\\`).join(\",\"), p = [\"[data-autofocus]\"].map((e2) => \\`\\${e2}:not([tabindex='-1'])\\`).join(\",\");\nvar F$2 = ((n2) => (n2[n2.First = 1] = \"First\", n2[n2.Previous = 2] = \"Previous\", n2[n2.Next = 4] = \"Next\", n2[n2.Last = 8] = \"Last\", n2[n2.WrapAround = 16] = \"WrapAround\", n2[n2.NoScroll = 32] = \"NoScroll\", n2[n2.AutoFocus = 64] = \"AutoFocus\", n2))(F$2 || {}), T$2 = ((o3) => (o3[o3.Error = 0] = \"Error\", o3[o3.Overflow = 1] = \"Overflow\", o3[o3.Success = 2] = \"Success\", o3[o3.Underflow = 3] = \"Underflow\", o3))(T$2 || {}), y$2 = ((t2) => (t2[t2.Previous = -1] = \"Previous\", t2[t2.Next = 1] = \"Next\", t2))(y$2 || {});\nfunction b$2(e2 = document.body) {\n  return e2 == null ? [] : Array.from(e2.querySelectorAll(f$3)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));\n}\nfunction S$3(e2 = document.body) {\n  return e2 == null ? [] : Array.from(e2.querySelectorAll(p)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));\n}\nvar h$2 = ((t2) => (t2[t2.Strict = 0] = \"Strict\", t2[t2.Loose = 1] = \"Loose\", t2))(h$2 || {});\nfunction A(e2, r2 = 0) {\n  var t2;\n  return e2 === ((t2 = o$6(e2)) == null ? void 0 : t2.body) ? !1 : u$7(r2, { 0() {\n    return e2.matches(f$3);\n  }, 1() {\n    let u2 = e2;\n    for (; u2 !== null; ) {\n      if (u2.matches(f$3)) return !0;\n      u2 = u2.parentElement;\n    }\n    return !1;\n  } });\n}\nfunction G(e2) {\n  let r2 = o$6(e2);\n  o$5().nextFrame(() => {\n    r2 && !A(r2.activeElement, 0) && I$1(e2);\n  });\n}\nvar H$3 = ((t2) => (t2[t2.Keyboard = 0] = \"Keyboard\", t2[t2.Mouse = 1] = \"Mouse\", t2))(H$3 || {});\ntypeof window < \"u\" && typeof document < \"u\" && (document.addEventListener(\"keydown\", (e2) => {\n  e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = \"\");\n}, !0), document.addEventListener(\"click\", (e2) => {\n  e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = \"\");\n}, !0));\nfunction I$1(e2) {\n  e2 == null || e2.focus({ preventScroll: !0 });\n}\nlet w = [\"textarea\", \"input\"].join(\",\");\nfunction O(e2) {\n  var r2, t2;\n  return (t2 = (r2 = e2 == null ? void 0 : e2.matches) == null ? void 0 : r2.call(e2, w)) != null ? t2 : !1;\n}\nfunction _(e2, r2 = (t2) => t2) {\n  return e2.slice().sort((t2, u2) => {\n    let o3 = r2(t2), c2 = r2(u2);\n    if (o3 === null || c2 === null) return 0;\n    let l2 = o3.compareDocumentPosition(c2);\n    return l2 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : l2 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;\n  });\n}\nfunction j$2(e2, r2) {\n  return P(b$2(), r2, { relativeTo: e2 });\n}\nfunction P(e2, r2, { sorted: t2 = !0, relativeTo: u2 = null, skipElements: o3 = [] } = {}) {\n  let c2 = Array.isArray(e2) ? e2.length > 0 ? e2[0].ownerDocument : document : e2.ownerDocument, l2 = Array.isArray(e2) ? t2 ? _(e2) : e2 : r2 & 64 ? S$3(e2) : b$2(e2);\n  o3.length > 0 && l2.length > 1 && (l2 = l2.filter((s2) => !o3.some((a3) => a3 != null && \"current\" in a3 ? (a3 == null ? void 0 : a3.current) === s2 : a3 === s2))), u2 = u2 ?? c2.activeElement;\n  let n2 = (() => {\n    if (r2 & 5) return 1;\n    if (r2 & 10) return -1;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })(), x2 = (() => {\n    if (r2 & 1) return 0;\n    if (r2 & 2) return Math.max(0, l2.indexOf(u2)) - 1;\n    if (r2 & 4) return Math.max(0, l2.indexOf(u2)) + 1;\n    if (r2 & 8) return l2.length - 1;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })(), M2 = r2 & 32 ? { preventScroll: !0 } : {}, m2 = 0, d2 = l2.length, i2;\n  do {\n    if (m2 >= d2 || m2 + d2 <= 0) return 0;\n    let s2 = x2 + m2;\n    if (r2 & 16) s2 = (s2 + d2) % d2;\n    else {\n      if (s2 < 0) return 3;\n      if (s2 >= d2) return 1;\n    }\n    i2 = l2[s2], i2 == null || i2.focus(M2), m2 += n2;\n  } while (i2 !== c2.activeElement);\n  return r2 & 6 && O(i2) && i2.select(), 2;\n}\nfunction t$1() {\n  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;\n}\nfunction i$4() {\n  return /Android/gi.test(window.navigator.userAgent);\n}\nfunction n$2() {\n  return t$1() || i$4();\n}\nfunction i$3(t2, e2, o3, n2) {\n  let u2 = s$6(o3);\n  useEffect(() => {\n    if (!t2) return;\n    function r2(m2) {\n      u2.current(m2);\n    }\n    return document.addEventListener(e2, r2, n2), () => document.removeEventListener(e2, r2, n2);\n  }, [t2, e2, n2]);\n}\nfunction s$5(t2, e2, o3, n2) {\n  let i2 = s$6(o3);\n  useEffect(() => {\n    if (!t2) return;\n    function r2(d2) {\n      i2.current(d2);\n    }\n    return window.addEventListener(e2, r2, n2), () => window.removeEventListener(e2, r2, n2);\n  }, [t2, e2, n2]);\n}\nconst E = 30;\nfunction R$1(p2, f2, C2) {\n  let u2 = x$2(p2, \"outside-click\"), m2 = s$6(C2), s2 = useCallback(function(e2, n2) {\n    if (e2.defaultPrevented) return;\n    let r2 = n2(e2);\n    if (r2 === null || !r2.getRootNode().contains(r2) || !r2.isConnected) return;\n    let h2 = function l2(o3) {\n      return typeof o3 == \"function\" ? l2(o3()) : Array.isArray(o3) || o3 instanceof Set ? o3 : [o3];\n    }(f2);\n    for (let l2 of h2) if (l2 !== null && (l2.contains(r2) || e2.composed && e2.composedPath().includes(l2))) return;\n    return !A(r2, h$2.Loose) && r2.tabIndex !== -1 && e2.preventDefault(), m2.current(e2, r2);\n  }, [m2, f2]), i2 = useRef(null);\n  i$3(u2, \"pointerdown\", (t2) => {\n    var e2, n2;\n    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;\n  }, !0), i$3(u2, \"mousedown\", (t2) => {\n    var e2, n2;\n    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;\n  }, !0), i$3(u2, \"click\", (t2) => {\n    n$2() || i2.current && (s2(t2, () => i2.current), i2.current = null);\n  }, !0);\n  let a3 = useRef({ x: 0, y: 0 });\n  i$3(u2, \"touchstart\", (t2) => {\n    a3.current.x = t2.touches[0].clientX, a3.current.y = t2.touches[0].clientY;\n  }, !0), i$3(u2, \"touchend\", (t2) => {\n    let e2 = { x: t2.changedTouches[0].clientX, y: t2.changedTouches[0].clientY };\n    if (!(Math.abs(e2.x - a3.current.x) >= E || Math.abs(e2.y - a3.current.y) >= E)) return s2(t2, () => t2.target instanceof HTMLElement ? t2.target : null);\n  }, !0), s$5(u2, \"blur\", (t2) => s2(t2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);\n}\nfunction n$1(...e2) {\n  return useMemo(() => o$6(...e2), [...e2]);\n}\nfunction e$1(t2, u2) {\n  return useMemo(() => {\n    var n2;\n    if (t2.type) return t2.type;\n    let r2 = (n2 = t2.as) != null ? n2 : \"button\";\n    if (typeof r2 == \"string\" && r2.toLowerCase() === \"button\" || (u2 == null ? void 0 : u2.tagName) === \"BUTTON\" && !u2.hasAttribute(\"type\")) return \"button\";\n  }, [t2.type, t2.as, u2]);\n}\nfunction d$1() {\n  let r2;\n  return { before({ doc: e2 }) {\n    var l2;\n    let o3 = e2.documentElement, t2 = (l2 = e2.defaultView) != null ? l2 : window;\n    r2 = Math.max(0, t2.innerWidth - o3.clientWidth);\n  }, after({ doc: e2, d: o3 }) {\n    let t2 = e2.documentElement, l2 = Math.max(0, t2.clientWidth - t2.offsetWidth), n2 = Math.max(0, r2 - l2);\n    o3.style(t2, \"paddingRight\", \\`\\${n2}px\\`);\n  } };\n}\nfunction d() {\n  return t$1() ? { before({ doc: r2, d: n2, meta: c2 }) {\n    function o3(a3) {\n      return c2.containers.flatMap((l2) => l2()).some((l2) => l2.contains(a3));\n    }\n    n2.microTask(() => {\n      var s2;\n      if (window.getComputedStyle(r2.documentElement).scrollBehavior !== \"auto\") {\n        let t2 = o$5();\n        t2.style(r2.documentElement, \"scrollBehavior\", \"auto\"), n2.add(() => n2.microTask(() => t2.dispose()));\n      }\n      let a3 = (s2 = window.scrollY) != null ? s2 : window.pageYOffset, l2 = null;\n      n2.addEventListener(r2, \"click\", (t2) => {\n        if (t2.target instanceof HTMLElement) try {\n          let e2 = t2.target.closest(\"a\");\n          if (!e2) return;\n          let { hash: f2 } = new URL(e2.href), i2 = r2.querySelector(f2);\n          i2 && !o3(i2) && (l2 = i2);\n        } catch {\n        }\n      }, !0), n2.addEventListener(r2, \"touchstart\", (t2) => {\n        if (t2.target instanceof HTMLElement) if (o3(t2.target)) {\n          let e2 = t2.target;\n          for (; e2.parentElement && o3(e2.parentElement); ) e2 = e2.parentElement;\n          n2.style(e2, \"overscrollBehavior\", \"contain\");\n        } else n2.style(t2.target, \"touchAction\", \"none\");\n      }), n2.addEventListener(r2, \"touchmove\", (t2) => {\n        if (t2.target instanceof HTMLElement) {\n          if (t2.target.tagName === \"INPUT\") return;\n          if (o3(t2.target)) {\n            let e2 = t2.target;\n            for (; e2.parentElement && e2.dataset.headlessuiPortal !== \"\" && !(e2.scrollHeight > e2.clientHeight || e2.scrollWidth > e2.clientWidth); ) e2 = e2.parentElement;\n            e2.dataset.headlessuiPortal === \"\" && t2.preventDefault();\n          } else t2.preventDefault();\n        }\n      }, { passive: !1 }), n2.add(() => {\n        var e2;\n        let t2 = (e2 = window.scrollY) != null ? e2 : window.pageYOffset;\n        a3 !== t2 && window.scrollTo(0, a3), l2 && l2.isConnected && (l2.scrollIntoView({ block: \"nearest\" }), l2 = null);\n      });\n    });\n  } } : {};\n}\nfunction r() {\n  return { before({ doc: e2, d: o3 }) {\n    o3.style(e2.documentElement, \"overflow\", \"hidden\");\n  } };\n}\nfunction m$1(e2) {\n  let n2 = {};\n  for (let t2 of e2) Object.assign(n2, t2(n2));\n  return n2;\n}\nlet a$5 = a$6(() => /* @__PURE__ */ new Map(), { PUSH(e2, n2) {\n  var o3;\n  let t2 = (o3 = this.get(e2)) != null ? o3 : { doc: e2, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };\n  return t2.count++, t2.meta.add(n2), this.set(e2, t2), this;\n}, POP(e2, n2) {\n  let t2 = this.get(e2);\n  return t2 && (t2.count--, t2.meta.delete(n2)), this;\n}, SCROLL_PREVENT({ doc: e2, d: n2, meta: t2 }) {\n  let o3 = { doc: e2, d: n2, meta: m$1(t2) }, c2 = [d(), d$1(), r()];\n  c2.forEach(({ before: r2 }) => r2 == null ? void 0 : r2(o3)), c2.forEach(({ after: r2 }) => r2 == null ? void 0 : r2(o3));\n}, SCROLL_ALLOW({ d: e2 }) {\n  e2.dispose();\n}, TEARDOWN({ doc: e2 }) {\n  this.delete(e2);\n} });\na$5.subscribe(() => {\n  let e2 = a$5.getSnapshot(), n2 = /* @__PURE__ */ new Map();\n  for (let [t2] of e2) n2.set(t2, t2.documentElement.style.overflow);\n  for (let t2 of e2.values()) {\n    let o3 = n2.get(t2.doc) === \"hidden\", c2 = t2.count !== 0;\n    (c2 && !o3 || !c2 && o3) && a$5.dispatch(t2.count > 0 ? \"SCROLL_PREVENT\" : \"SCROLL_ALLOW\", t2), t2.count === 0 && a$5.dispatch(\"TEARDOWN\", t2);\n  }\n});\nfunction a$4(r2, e2, n2 = () => ({ containers: [] })) {\n  let f2 = o$2(a$5), o3 = e2 ? f2.get(e2) : void 0, i2 = o3 ? o3.count > 0 : !1;\n  return n$3(() => {\n    if (!(!e2 || !r2)) return a$5.dispatch(\"PUSH\", e2, n2), () => a$5.dispatch(\"POP\", e2, n2);\n  }, [r2, e2]), i2;\n}\nfunction f$2(e2, c2, n2 = () => [document.body]) {\n  let r2 = x$2(e2, \"scroll-lock\");\n  a$4(r2, c2, (t2) => {\n    var o3;\n    return { containers: [...(o3 = t2.containers) != null ? o3 : [], n2] };\n  });\n}\nfunction t(e2) {\n  return [e2.screenX, e2.screenY];\n}\nfunction u$3() {\n  let e2 = useRef([-1, -1]);\n  return { wasMoved(r2) {\n    let n2 = t(r2);\n    return e2.current[0] === n2[0] && e2.current[1] === n2[1] ? !1 : (e2.current = n2, !0);\n  }, update(r2) {\n    e2.current = t(r2);\n  } };\n}\nfunction c$4(u2 = 0) {\n  let [t2, l2] = useState(u2), g2 = useCallback((e2) => l2(e2), [t2]), s2 = useCallback((e2) => l2((a3) => a3 | e2), [t2]), m2 = useCallback((e2) => (t2 & e2) === e2, [t2]), n2 = useCallback((e2) => l2((a3) => a3 & ~e2), [l2]), F2 = useCallback((e2) => l2((a3) => a3 ^ e2), [l2]);\n  return { flags: t2, setFlag: g2, addFlag: s2, hasFlag: m2, removeFlag: n2, toggleFlag: F2 };\n}\nvar define_process_env_default$1 = {}, T$1, b$1;\ntypeof process < \"u\" && typeof globalThis < \"u\" && typeof Element < \"u\" && ((T$1 = process == null ? void 0 : define_process_env_default$1) == null ? void 0 : T$1.NODE_ENV) === \"test\" && typeof ((b$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$1.getAnimations) > \"u\" && (Element.prototype.getAnimations = function() {\n  return console.warn([\"Headless UI has polyfilled \\`Element.prototype.getAnimations\\` for your tests.\", \"Please install a proper polyfill e.g. \\`jsdom-testing-mocks\\`, to silence these warnings.\", \"\", \"Example usage:\", \"\\`\\`\\`js\", \"import { mockAnimationsApi } from 'jsdom-testing-mocks'\", \"mockAnimationsApi()\", \"\\`\\`\\`\"].join(\\`\n\\`)), [];\n});\nvar L$1 = ((r2) => (r2[r2.None = 0] = \"None\", r2[r2.Closed = 1] = \"Closed\", r2[r2.Enter = 2] = \"Enter\", r2[r2.Leave = 4] = \"Leave\", r2))(L$1 || {});\nfunction R(t2) {\n  let n2 = {};\n  for (let e2 in t2) t2[e2] === !0 && (n2[\\`data-\\${e2}\\`] = \"\");\n  return n2;\n}\nfunction x$1(t2, n2, e2, i2) {\n  let [r2, o3] = useState(e2), { hasFlag: s2, addFlag: a3, removeFlag: l2 } = c$4(t2 && r2 ? 3 : 0), u2 = useRef(!1), f2 = useRef(!1), E2 = p$2();\n  return n$3(() => {\n    var d2;\n    if (t2) {\n      if (e2 && o3(!0), !n2) {\n        e2 && a3(3);\n        return;\n      }\n      return (d2 = void 0) == null || d2.call(i2, e2), C(n2, { inFlight: u2, prepare() {\n        f2.current ? f2.current = !1 : f2.current = u2.current, u2.current = !0, !f2.current && (e2 ? (a3(3), l2(4)) : (a3(4), l2(2)));\n      }, run() {\n        f2.current ? e2 ? (l2(3), a3(4)) : (l2(4), a3(3)) : e2 ? l2(1) : a3(1);\n      }, done() {\n        var p2;\n        f2.current && typeof n2.getAnimations == \"function\" && n2.getAnimations().length > 0 || (u2.current = !1, l2(7), e2 || o3(!1), (p2 = void 0) == null || p2.call(i2, e2));\n      } });\n    }\n  }, [t2, e2, n2, E2]), t2 ? [r2, { closed: s2(1), enter: s2(2), leave: s2(4), transition: s2(2) || s2(4) }] : [e2, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];\n}\nfunction C(t2, { prepare: n2, run: e2, done: i2, inFlight: r2 }) {\n  let o3 = o$5();\n  return j$1(t2, { prepare: n2, inFlight: r2 }), o3.nextFrame(() => {\n    e2(), o3.requestAnimationFrame(() => {\n      o3.add(M$2(t2, i2));\n    });\n  }), o3.dispose;\n}\nfunction M$2(t2, n2) {\n  var o3, s2;\n  let e2 = o$5();\n  if (!t2) return e2.dispose;\n  let i2 = !1;\n  e2.add(() => {\n    i2 = !0;\n  });\n  let r2 = (s2 = (o3 = t2.getAnimations) == null ? void 0 : o3.call(t2).filter((a3) => a3 instanceof CSSTransition)) != null ? s2 : [];\n  return r2.length === 0 ? (n2(), e2.dispose) : (Promise.allSettled(r2.map((a3) => a3.finished)).then(() => {\n    i2 || n2();\n  }), e2.dispose);\n}\nfunction j$1(t2, { inFlight: n2, prepare: e2 }) {\n  if (n2 != null && n2.current) {\n    e2();\n    return;\n  }\n  let i2 = t2.style.transition;\n  t2.style.transition = \"none\", e2(), t2.offsetHeight, t2.style.transition = i2;\n}\nfunction F$1(c2, { container: e2, accept: t2, walk: r2 }) {\n  let o3 = useRef(t2), l2 = useRef(r2);\n  useEffect(() => {\n    o3.current = t2, l2.current = r2;\n  }, [t2, r2]), n$3(() => {\n    if (!e2 || !c2) return;\n    let n2 = o$6(e2);\n    if (!n2) return;\n    let f2 = o3.current, p2 = l2.current, i2 = Object.assign((m2) => f2(m2), { acceptNode: f2 }), u2 = n2.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, i2, !1);\n    for (; u2.nextNode(); ) p2(u2.currentNode);\n  }, [e2, c2, o3, l2]);\n}\nfunction hasWindow$1() {\n  return typeof window < \"u\";\n}\nfunction getWindow$1(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction isElement$1(value) {\n  return hasWindow$1() ? value instanceof Element || value instanceof getWindow$1(value).Element : !1;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  return uaData && Array.isArray(uaData.brands) ? uaData.brands.map((_ref) => {\n    let {\n      brand,\n      version\n    } = _ref;\n    return brand + \"/\" + version;\n  }).join(\" \") : navigator.userAgent;\n}\nconst min$1 = Math.min, max$1 = Math.max, round$1 = Math.round;\nfunction evaluate$1(value, param) {\n  return typeof value == \"function\" ? value(param) : value;\n}\nconst min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (v2) => ({\n  x: v2,\n  y: v2\n}), oppositeSideMap = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n}, oppositeAlignmentMap = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value == \"function\" ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction getAxisLength(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nconst yAxisSides = /* @__PURE__ */ new Set([\"top\", \"bottom\"]);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? \"y\" : \"x\";\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  rtl === void 0 && (rtl = !1);\n  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === \"x\" ? alignment === (rtl ? \"end\" : \"start\") ? \"right\" : \"left\" : alignment === \"start\" ? \"bottom\" : \"top\";\n  return rects.reference[length] > rects.floating[length] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = [\"left\", \"right\"], rlPlacement = [\"right\", \"left\"], tbPlacement = [\"top\", \"bottom\"], btPlacement = [\"bottom\", \"top\"];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case \"top\":\n    case \"bottom\":\n      return rtl ? isStart ? rlPlacement : lrPlacement : isStart ? lrPlacement : rlPlacement;\n    case \"left\":\n    case \"right\":\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === \"start\", rtl);\n  return alignment && (list = list.map((side) => side + \"-\" + alignment), flipAlignment && (list = list.concat(list.map(getOppositeAlignmentPlacement)))), list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding != \"number\" ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x: x2,\n    y: y2,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y2,\n    left: x2,\n    right: x2 + width,\n    bottom: y2 + height,\n    x: x2,\n    y: y2\n  };\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === \"y\", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nconst computePosition$1 = async (reference, floating, config2) => {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config2, validMiddleware = middleware.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));\n  let rects = await platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  }), {\n    x: x2,\n    y: y2\n  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;\n  for (let i2 = 0; i2 < validMiddleware.length; i2++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i2], {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x: x2,\n      y: y2,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    }, reset && resetCount <= 50 && (resetCount++, typeof reset == \"object\" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({\n      reference,\n      floating,\n      strategy\n    }) : reset.rects), {\n      x: x2,\n      y: y2\n    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i2 = -1);\n  }\n  return {\n    x: x2,\n    y: y2,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\nasync function detectOverflow$1(state, options) {\n  var _await$platform$isEle;\n  options === void 0 && (options = {});\n  const {\n    x: x2,\n    y: y2,\n    platform: platform2,\n    rects,\n    elements,\n    strategy\n  } = state, {\n    boundary = \"clippingAncestors\",\n    rootBoundary = \"viewport\",\n    elementContext = \"floating\",\n    altBoundary = !1,\n    padding = 0\n  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === \"floating\" ? \"reference\" : \"floating\" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({\n    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),\n    boundary,\n    rootBoundary,\n    strategy\n  })), rect = elementContext === \"floating\" ? {\n    x: x2,\n    y: y2,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\nconst flip$2 = function(options) {\n  return options === void 0 && (options = {}), {\n    name: \"flip\",\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform: platform2,\n        elements\n      } = state, {\n        mainAxis: checkMainAxis = !0,\n        crossAxis: checkCrossAxis = !0,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = \"bestFit\",\n        fallbackAxisSideDirection = \"none\",\n        flipAlignment = !0,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)\n        return {};\n      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== \"none\";\n      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow$1(state, detectOverflowOptions), overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      if (overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }], !overflows.every((side2) => side2 <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];\n        if (nextPlacement && (!(checkCrossAxis === \"alignment\" ? initialSideAxis !== getSideAxis(nextPlacement) : !1) || // We leave the current main axis only if every placement on that axis\n        // overflows the main axis.\n        overflowsData.every((d2) => d2.overflows[0] > 0 && getSideAxis(d2.placement) === initialSideAxis)))\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n        if (!resetPlacement)\n          switch (fallbackStrategy) {\n            case \"bestFit\": {\n              var _overflowsData$filter2;\n              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {\n                if (hasFallbackAxisSideDirection) {\n                  const currentSideAxis = getSideAxis(d2.placement);\n                  return currentSideAxis === initialSideAxis || // Create a bias to the \\`y\\` side axis due to horizontal\n                  // reading directions favoring greater width.\n                  currentSideAxis === \"y\";\n                }\n                return !0;\n              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n              placement2 && (resetPlacement = placement2);\n              break;\n            }\n            case \"initialPlacement\":\n              resetPlacement = initialPlacement;\n              break;\n          }\n        if (placement !== resetPlacement)\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n      }\n      return {};\n    }\n  };\n}, originSides = /* @__PURE__ */ new Set([\"left\", \"top\"]);\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform: platform2,\n    elements\n  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === \"y\", mainAxisMulti = originSides.has(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue == \"number\" ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  return alignment && typeof alignmentAxis == \"number\" && (crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\nconst offset$2 = function(options) {\n  return options === void 0 && (options = 0), {\n    name: \"offset\",\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x: x2,\n        y: y2,\n        placement,\n        middlewareData\n      } = state, diffCoords = await convertValueToCoords(state, options);\n      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {\n        x: x2 + diffCoords.x,\n        y: y2 + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n}, shift$2 = function(options) {\n  return options === void 0 && (options = {}), {\n    name: \"shift\",\n    options,\n    async fn(state) {\n      const {\n        x: x2,\n        y: y2,\n        placement\n      } = state, {\n        mainAxis: checkMainAxis = !0,\n        crossAxis: checkCrossAxis = !1,\n        limiter = {\n          fn: (_ref) => {\n            let {\n              x: x3,\n              y: y3\n            } = _ref;\n            return {\n              x: x3,\n              y: y3\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state), coords = {\n        x: x2,\n        y: y2\n      }, overflow = await detectOverflow$1(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === \"y\" ? \"top\" : \"left\", maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min2, mainAxisCoord, max2);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === \"y\" ? \"top\" : \"left\", maxSide = crossAxis === \"y\" ? \"bottom\" : \"right\", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min2, crossAxisCoord, max2);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x2,\n          y: limitedCoords.y - y2,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n}, size$2 = function(options) {\n  return options === void 0 && (options = {}), {\n    name: \"size\",\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform: platform2,\n        elements\n      } = state, {\n        apply = () => {\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state), overflow = await detectOverflow$1(state, detectOverflowOptions), side = getSide(placement), alignment = getAlignment(placement), isYAxis = getSideAxis(placement) === \"y\", {\n        width,\n        height\n      } = rects.floating;\n      let heightSide, widthSide;\n      side === \"top\" || side === \"bottom\" ? (heightSide = side, widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? \"start\" : \"end\") ? \"left\" : \"right\") : (widthSide = side, heightSide = alignment === \"end\" ? \"top\" : \"bottom\");\n      const maximumClippingHeight = height - overflow.top - overflow.bottom, maximumClippingWidth = width - overflow.left - overflow.right, overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight), overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth), noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight, availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x && (availableWidth = maximumClippingWidth), (_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y && (availableHeight = maximumClippingHeight), noShift && !alignment) {\n        const xMin = max(overflow.left, 0), xMax = max(overflow.right, 0), yMin = max(overflow.top, 0), yMax = max(overflow.bottom, 0);\n        isYAxis ? availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform2.getDimensions(elements.floating);\n      return width !== nextDimensions.width || height !== nextDimensions.height ? {\n        reset: {\n          rects: !0\n        }\n      } : {};\n    }\n  };\n};\nfunction hasWindow() {\n  return typeof window < \"u\";\n}\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return hasWindow() ? value instanceof Node || value instanceof getWindow(value).Node : !1;\n}\nfunction isElement(value) {\n  return hasWindow() ? value instanceof Element || value instanceof getWindow(value).Element : !1;\n}\nfunction isHTMLElement(value) {\n  return hasWindow() ? value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement : !1;\n}\nfunction isShadowRoot(value) {\n  return !hasWindow() || typeof ShadowRoot > \"u\" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /* @__PURE__ */ new Set([\"inline\", \"contents\"]);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /* @__PURE__ */ new Set([\"table\", \"td\", \"th\"]);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [\":popover-open\", \":modal\"];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some((selector) => {\n    try {\n      return element.matches(selector);\n    } catch {\n      return !1;\n    }\n  });\n}\nconst transformProperties = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\"], willChangeValues = [\"transform\", \"translate\", \"scale\", \"rotate\", \"perspective\", \"filter\"], containValues = [\"paint\", \"layout\", \"strict\", \"content\"];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit(), css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;\n  return transformProperties.some((value) => css[value] ? css[value] !== \"none\" : !1) || (css.containerType ? css.containerType !== \"normal\" : !1) || !webkit && (css.backdropFilter ? css.backdropFilter !== \"none\" : !1) || !webkit && (css.filter ? css.filter !== \"none\" : !1) || willChangeValues.some((value) => (css.willChange || \"\").includes(value)) || containValues.some((value) => (css.contain || \"\").includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  for (; isHTMLElement(currentNode) && !isLastTraversableNode(currentNode); ) {\n    if (isContainingBlock(currentNode))\n      return currentNode;\n    if (isTopLayer(currentNode))\n      return null;\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nconst lastTraversableNodeNames = /* @__PURE__ */ new Set([\"html\", \"body\", \"#document\"]);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  return isElement(element) ? {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  } : {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\")\n    return node;\n  const result = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    node.assignedSlot || // DOM Element detected.\n    node.parentNode || // ShadowRoot detected.\n    isShadowRoot(node) && node.host || // Fallback.\n    getDocumentElement(node)\n  );\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  return isLastTraversableNode(parentNode) ? node.ownerDocument ? node.ownerDocument.body : node.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  list === void 0 && (list = []), traverseIframes === void 0 && (traverseIframes = !0);\n  const scrollableAncestor = getNearestOverflowAncestor(node), isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  let width = parseFloat(css.width) || 0, height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  return shouldFallback && (width = offsetWidth, height = offsetHeight), {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return isElement(element) ? element : element.contextElement;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement))\n    return createCoords(1);\n  const rect = domElement.getBoundingClientRect(), {\n    width,\n    height,\n    $: $2\n  } = getCssDimensions(domElement);\n  let x2 = ($2 ? round(rect.width) : rect.width) / width, y2 = ($2 ? round(rect.height) : rect.height) / height;\n  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {\n    x: x2,\n    y: y2\n  };\n}\nconst noOffsets = /* @__PURE__ */ createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  return !isWebKit() || !win.visualViewport ? noOffsets : {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);\n  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x2 = (clientRect.left + visualOffsets.x) / scale.x, y2 = (clientRect.top + visualOffsets.y) / scale.y, width = clientRect.width / scale.x, height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win, currentIFrame = getFrameElement(currentWin);\n    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {\n      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css = getComputedStyle$1(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x: x2,\n    y: y2\n  });\n}\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  return rect ? rect.left + leftScroll : getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  ignoreScrollbarX === void 0 && (ignoreScrollbarX = !1);\n  const htmlRect = documentElement.getBoundingClientRect(), x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (\n    // RTL <body> scrollbar.\n    getWindowScrollBarX(documentElement, htmlRect)\n  )), y2 = htmlRect.top + scroll.scrollTop;\n  return {\n    x: x2,\n    y: y2\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === \"fixed\", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;\n  if (offsetParent === documentElement || topLayer && isFixed)\n    return rect;\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, scale = createCoords(1);\n  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement(offsetParent))) {\n    const offsetRect = getBoundingClientRect(offsetParent);\n    scale = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, !0) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element), scroll = getNodeScroll(element), body = element.ownerDocument.body, width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth), height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y2 = -scroll.scrollTop;\n  return getComputedStyle$1(body).direction === \"rtl\" && (x2 += max(html.clientWidth, body.clientWidth) - width), {\n    width,\n    height,\n    x: x2,\n    y: y2\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element), html = getDocumentElement(element), visualViewport = win.visualViewport;\n  let width = html.clientWidth, height = html.clientHeight, x2 = 0, y2 = 0;\n  if (visualViewport) {\n    width = visualViewport.width, height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    (!visualViewportBased || visualViewportBased && strategy === \"fixed\") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);\n  }\n  return {\n    width,\n    height,\n    x: x2,\n    y: y2\n  };\n}\nconst absoluteOrFixed = /* @__PURE__ */ new Set([\"absolute\", \"fixed\"]);\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, !0, strategy === \"fixed\"), top = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale = isHTMLElement(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale.x, height = element.clientHeight * scale.y, x2 = left * scale.x, y2 = top * scale.y;\n  return {\n    width,\n    height,\n    x: x2,\n    y: y2\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === \"viewport\")\n    rect = getViewportRect(element, strategy);\n  else if (clippingAncestor === \"document\")\n    rect = getDocumentRect(getDocumentElement(element));\n  else if (isElement(clippingAncestor))\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  return parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$1(parentNode).position === \"fixed\" || hasFixedPositionAncestor(parentNode, stopNode);\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult)\n    return cachedResult;\n  let result = getOverflowAncestors(element, [], !1).filter((el) => isElement(el) && getNodeName(el) !== \"body\"), currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  for (; isElement(currentNode) && !isLastTraversableNode(currentNode); ) {\n    const computedStyle = getComputedStyle$1(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);\n    !currentNodeIsContaining && computedStyle.position === \"fixed\" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);\n  }\n  return cache.set(element, result), result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const clippingAncestors = [...boundary === \"clippingAncestors\" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    return accRect.top = max(rect.top, accRect.top), accRect.right = min(rect.right, accRect.right), accRect.bottom = min(rect.bottom, accRect.bottom), accRect.left = max(rect.left, accRect.left), accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === \"fixed\", rect = getBoundingClientRect(element, !0, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)\n    if ((getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else documentElement && setLeftRTLScrollbarOffset();\n  isFixed && !isOffsetParentAnElement && documentElement && setLeftRTLScrollbarOffset();\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0), x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x, y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x: x2,\n    y: y2,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return getComputedStyle$1(element).position === \"static\";\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === \"fixed\")\n    return null;\n  if (polyfill)\n    return polyfill(element);\n  let rawOffsetParent = element.offsetParent;\n  return getDocumentElement(element) === rawOffsetParent && (rawOffsetParent = rawOffsetParent.ownerDocument.body), rawOffsetParent;\n}\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element))\n    return win;\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))\n        return svgOffsetParent;\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win : offsetParent || getContainingBlock(element) || win;\n}\nconst getElementRects = async function(data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === \"rtl\";\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\nfunction rectsAreEqual(a3, b2) {\n  return a3.x === b2.x && a3.y === b2.y && a3.width === b2.width && a3.height === b2.height;\n}\nfunction observeMove(element, onMove) {\n  let io = null, timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;\n  }\n  function refresh(skip, threshold) {\n    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect(), {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (skip || onMove(), !width || !height)\n      return;\n    const insetTop = floor(top), insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top + height)), insetLeft = floor(left), options = {\n      rootMargin: -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\",\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = !0;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate)\n          return refresh();\n        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {\n          refresh(!1, 1e-7);\n        }, 1e3);\n      }\n      ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect()) && refresh(), isFirstUpdate = !1;\n    }\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  return refresh(!0), cleanup;\n}\nfunction autoUpdate(reference, floating, update, options) {\n  options === void 0 && (options = {});\n  const {\n    ancestorScroll = !0,\n    ancestorResize = !0,\n    elementResize = typeof ResizeObserver == \"function\",\n    layoutShift = typeof IntersectionObserver == \"function\",\n    animationFrame = !1\n  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: !0\n    }), ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1, resizeObserver = null;\n  elementResize && (resizeObserver = new ResizeObserver((_ref) => {\n    let [firstEntry] = _ref;\n    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {\n      var _resizeObserver;\n      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n    })), update();\n  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));\n  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  animationFrame && frameLoop();\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);\n  }\n  return update(), () => {\n    var _resizeObserver2;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update), ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    }), cleanupIo == null || cleanupIo(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);\n  };\n}\nconst detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, computePosition = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map(), mergedOptions = {\n    platform,\n    ...options\n  }, platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\nvar isClient = typeof document < \"u\", noop = function() {\n}, index$1 = isClient ? useLayoutEffect : noop;\nfunction deepEqual(a3, b2) {\n  if (a3 === b2)\n    return !0;\n  if (typeof a3 != typeof b2)\n    return !1;\n  if (typeof a3 == \"function\" && a3.toString() === b2.toString())\n    return !0;\n  let length, i2, keys;\n  if (a3 && b2 && typeof a3 == \"object\") {\n    if (Array.isArray(a3)) {\n      if (length = a3.length, length !== b2.length) return !1;\n      for (i2 = length; i2-- !== 0; )\n        if (!deepEqual(a3[i2], b2[i2]))\n          return !1;\n      return !0;\n    }\n    if (keys = Object.keys(a3), length = keys.length, length !== Object.keys(b2).length)\n      return !1;\n    for (i2 = length; i2-- !== 0; )\n      if (!{}.hasOwnProperty.call(b2, keys[i2]))\n        return !1;\n    for (i2 = length; i2-- !== 0; ) {\n      const key = keys[i2];\n      if (!(key === \"_owner\" && a3.$$typeof) && !deepEqual(a3[key], b2[key]))\n        return !1;\n    }\n    return !0;\n  }\n  return a3 !== a3 && b2 !== b2;\n}\nfunction getDPR(element) {\n  return typeof window > \"u\" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  return index$1(() => {\n    ref.current = value;\n  }), ref;\n}\nfunction useFloating$1(options) {\n  options === void 0 && (options = {});\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = !0,\n    whileElementsMounted,\n    open\n  } = options, [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: !1\n  }), [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  deepEqual(latestMiddleware, middleware) || setLatestMiddleware(middleware);\n  const [_reference, _setReference] = React.useState(null), [_floating, _setFloating] = React.useState(null), setReference = React.useCallback((node) => {\n    node !== referenceRef.current && (referenceRef.current = node, _setReference(node));\n  }, []), setFloating = React.useCallback((node) => {\n    node !== floatingRef.current && (floatingRef.current = node, _setFloating(node));\n  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React.useRef(null), floatingRef = React.useRef(null), dataRef = React.useRef(data), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef(whileElementsMounted), platformRef = useLatestRef(platform2), openRef = useLatestRef(open), update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current)\n      return;\n    const config2 = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    platformRef.current && (config2.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config2).then((data2) => {\n      const fullData = {\n        ...data2,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // \\`isPositioned\\` will be \\`false\\` initially on the next open, avoid\n        // setting it to \\`true\\` when \\`open === false\\` (must be specified).\n        isPositioned: openRef.current !== !1\n      };\n      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, ReactDOM.flushSync(() => {\n        setData(fullData);\n      }));\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index$1(() => {\n    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data2) => ({\n      ...data2,\n      isPositioned: !1\n    })));\n  }, [open]);\n  const isMountedRef = React.useRef(!1);\n  index$1(() => (isMountedRef.current = !0, () => {\n    isMountedRef.current = !1;\n  }), []), index$1(() => {\n    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current)\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]), elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]), floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating)\n      return initialStyles;\n    const x2 = roundByDPR(elements.floating, data.x), y2 = roundByDPR(elements.floating, data.y);\n    return transform ? {\n      ...initialStyles,\n      transform: \"translate(\" + x2 + \"px, \" + y2 + \"px)\",\n      ...getDPR(elements.floating) >= 1.5 && {\n        willChange: \"transform\"\n      }\n    } : {\n      position: strategy,\n      left: x2,\n      top: y2\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\nconst offset = (options, deps) => ({\n  ...offset$1(options),\n  options: [options, deps]\n}), shift = (options, deps) => ({\n  ...shift$1(options),\n  options: [options, deps]\n}), flip = (options, deps) => ({\n  ...flip$1(options),\n  options: [options, deps]\n}), size = (options, deps) => ({\n  ...size$1(options),\n  options: [options, deps]\n});\nvar define_process_env_default = {};\nconst SafeReact = {\n  ...React\n}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());\nfunction useEffectEvent(callback) {\n  const ref = React.useRef(() => {\n    if (define_process_env_default.NODE_ENV !== \"production\")\n      throw new Error(\"Cannot call an event handler while rendering.\");\n  });\n  return useSafeInsertionEffect(() => {\n    ref.current = callback;\n  }), React.useCallback(function() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)\n      args[_key] = arguments[_key];\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\nvar index = typeof document < \"u\" ? useLayoutEffect : useEffect;\nlet serverHandoffComplete = !1, count = 0;\nconst genId = () => (\n  // Ensure the id is unique with multiple independent versions of Floating UI\n  // on <React 18\n  \"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++\n);\nfunction useFloatingId() {\n  const [id, setId] = React.useState(() => serverHandoffComplete ? genId() : void 0);\n  return index(() => {\n    id == null && setId(genId());\n  }, []), React.useEffect(() => {\n    serverHandoffComplete = !0;\n  }, []), id;\n}\nconst useReactId = SafeReact.useId, useId = useReactId || useFloatingId;\nlet devMessageSet;\ndefine_process_env_default.NODE_ENV !== \"production\" && (devMessageSet = /* @__PURE__ */ new Set());\nfunction warn() {\n  for (var _devMessageSet, _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++)\n    messages[_key] = arguments[_key];\n  const message = \"Floating UI: \" + messages.join(\" \");\n  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n    var _devMessageSet2;\n    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message), console.warn(message);\n  }\n}\nfunction error() {\n  for (var _devMessageSet3, _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)\n    messages[_key2] = arguments[_key2];\n  const message = \"Floating UI: \" + messages.join(\" \");\n  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n    var _devMessageSet4;\n    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message), console.error(message);\n  }\n}\nfunction createPubSub() {\n  const map = /* @__PURE__ */ new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));\n    },\n    on(event, listener) {\n      map.set(event, [...map.get(event) || [], listener]);\n    },\n    off(event, listener) {\n      var _map$get2;\n      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l2) => l2 !== listener)) || []);\n    }\n  };\n}\nconst FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = React.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = \"data-floating-ui-focusable\";\nfunction useFloatingRootContext(options) {\n  const {\n    open = !1,\n    onOpenChange: onOpenChangeProp,\n    elements: elementsProp\n  } = options, floatingId = useId(), dataRef = React.useRef({}), [events] = React.useState(() => createPubSub()), nested = useFloatingParentNodeId() != null;\n  if (define_process_env_default.NODE_ENV !== \"production\") {\n    const optionDomReference = elementsProp.reference;\n    optionDomReference && !isElement$1(optionDomReference) && error(\"Cannot pass a virtual element to the \\`elements.reference\\` option,\", \"as it must be a real DOM element. Use \\`refs.setPositionReference()\\`\", \"instead.\");\n  }\n  const [positionReference, setPositionReference] = React.useState(elementsProp.reference), onOpenChange = useEffectEvent((open2, event, reason) => {\n    dataRef.current.openEvent = open2 ? event : void 0, events.emit(\"openchange\", {\n      open: open2,\n      event,\n      reason,\n      nested\n    }), onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);\n  }), refs = React.useMemo(() => ({\n    setPositionReference\n  }), []), elements = React.useMemo(() => ({\n    reference: positionReference || elementsProp.reference || null,\n    floating: elementsProp.floating || null,\n    domReference: elementsProp.reference\n  }), [positionReference, elementsProp.reference, elementsProp.floating]);\n  return React.useMemo(() => ({\n    dataRef,\n    open,\n    onOpenChange,\n    elements,\n    events,\n    floatingId,\n    refs\n  }), [open, onOpenChange, elements, events, floatingId, refs]);\n}\nfunction useFloating(options) {\n  options === void 0 && (options = {});\n  const {\n    nodeId\n  } = options, internalRootContext = useFloatingRootContext({\n    ...options,\n    elements: {\n      reference: null,\n      floating: null,\n      ...options.elements\n    }\n  }), rootContext = options.rootContext || internalRootContext, computedElements = rootContext.elements, [_domReference, setDomReference] = React.useState(null), [positionReference, _setPositionReference] = React.useState(null), domReference = (computedElements == null ? void 0 : computedElements.domReference) || _domReference, domReferenceRef = React.useRef(null), tree = useFloatingTree();\n  index(() => {\n    domReference && (domReferenceRef.current = domReference);\n  }, [domReference]);\n  const position = useFloating$1({\n    ...options,\n    elements: {\n      ...computedElements,\n      ...positionReference && {\n        reference: positionReference\n      }\n    }\n  }), setPositionReference = React.useCallback((node) => {\n    const computedPositionReference = isElement$1(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      contextElement: node\n    } : node;\n    _setPositionReference(computedPositionReference), position.refs.setReference(computedPositionReference);\n  }, [position.refs]), setReference = React.useCallback((node) => {\n    (isElement$1(node) || node === null) && (domReferenceRef.current = node, setDomReference(node)), (isElement$1(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to\n    // \\`null\\` to support \\`positionReference\\` + an unstable \\`reference\\`\n    // callback ref.\n    node !== null && !isElement$1(node)) && position.refs.setReference(node);\n  }, [position.refs]), refs = React.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]), elements = React.useMemo(() => ({\n    ...position.elements,\n    domReference\n  }), [position.elements, domReference]), context = React.useMemo(() => ({\n    ...position,\n    ...rootContext,\n    refs,\n    elements,\n    nodeId\n  }), [position, refs, elements, nodeId, rootContext]);\n  return index(() => {\n    rootContext.dataRef.current.floatingContext = context;\n    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);\n    node && (node.context = context);\n  }), React.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\nconst ACTIVE_KEY = \"active\", SELECTED_KEY = \"selected\";\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = /* @__PURE__ */ new Map(), isItem = elementKey === \"item\";\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _2,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...elementKey === \"floating\" && {\n      tabIndex: -1,\n      [FOCUSABLE_ATTRIBUTE]: \"\"\n    },\n    ...domUserProps,\n    ...propsList.map((value) => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      return typeof propsOrGetProps == \"function\" ? userProps ? propsOrGetProps(userProps) : null : propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => (props && Object.entries(props).forEach((_ref) => {\n      let [key, value] = _ref;\n      if (!(isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)))\n        if (key.indexOf(\"on\") === 0) {\n          if (map.has(key) || map.set(key, []), typeof value == \"function\") {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value), acc[key] = function() {\n              for (var _map$get2, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)\n                args[_key] = arguments[_key];\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);\n            };\n          }\n        } else\n          acc[key] = value;\n    }), acc), {})\n  };\n}\nfunction useInteractions(propsList) {\n  propsList === void 0 && (propsList = []);\n  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference), floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating), itemDeps = propsList.map((key) => key == null ? void 0 : key.item), getReferenceProps = React.useCallback(\n    (userProps) => mergeProps(userProps, propsList, \"reference\"),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    referenceDeps\n  ), getFloatingProps = React.useCallback(\n    (userProps) => mergeProps(userProps, propsList, \"floating\"),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    floatingDeps\n  ), getItemProps = React.useCallback(\n    (userProps) => mergeProps(userProps, propsList, \"item\"),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    itemDeps\n  );\n  return React.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\nconst inner = (props) => ({\n  name: \"inner\",\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index: index2 = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = evaluate$1(props, state), {\n      rects,\n      elements: {\n        floating\n      }\n    } = state, item = listRef.current[index2], scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating, clientTop = floating.clientTop || scrollEl.clientTop, floatingIsBordered = floating.clientTop !== 0, scrollElIsBordered = scrollEl.clientTop !== 0, floatingIsScrollEl = floating === scrollEl;\n    if (define_process_env_default.NODE_ENV !== \"production\" && (state.placement.startsWith(\"bottom\") || warn('\\`placement\\` side must be \"bottom\" when using the \\`inner\\`', \"middleware.\")), !item)\n      return {};\n    const nextArgs = {\n      ...state,\n      ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)\n    }, overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions), refOverflow = await detectOverflow(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: \"reference\"\n    }), diffY = max$1(0, overflow.top), nextY = nextArgs.y + diffY, maxHeight = (scrollEl.scrollHeight > scrollEl.clientHeight ? (v2) => v2 : round$1)(max$1(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max$1(0, overflow.bottom)));\n    if (scrollEl.style.maxHeight = maxHeight + \"px\", scrollEl.scrollTop = diffY, onFallbackChange) {\n      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min$1(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;\n      ReactDOM.flushSync(() => onFallbackChange(shouldFallback));\n    }\n    return overflowRef && (overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({\n      ...nextArgs,\n      y: nextY\n    }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions)), {\n      y: nextY\n    };\n  }\n});\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context, {\n    enabled = !0,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props, onChange = useEffectEvent(unstable_onChange), controlledScrollingRef = React.useRef(!1), prevScrollTopRef = React.useRef(null), initialOverflowRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!enabled) return;\n    function onWheel(e2) {\n      if (e2.ctrlKey || !el || overflowRef.current == null)\n        return;\n      const dY = e2.deltaY, isAtTop = overflowRef.current.top >= -0.5, isAtBottom = overflowRef.current.bottom >= -0.5, remainingScroll = el.scrollHeight - el.clientHeight, sign = dY < 0 ? -1 : 1, method = dY < 0 ? \"max\" : \"min\";\n      el.scrollHeight <= el.clientHeight || (!isAtTop && dY > 0 || !isAtBottom && dY < 0 ? (e2.preventDefault(), ReactDOM.flushSync(() => {\n        onChange((d2) => d2 + Math[method](dY, remainingScroll * sign));\n      })) : /firefox/i.test(getUserAgent()) && (el.scrollTop += dY));\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el)\n      return el.addEventListener(\"wheel\", onWheel), requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop, overflowRef.current != null && (initialOverflowRef.current = {\n          ...overflowRef.current\n        });\n      }), () => {\n        prevScrollTopRef.current = null, initialOverflowRef.current = null, el.removeEventListener(\"wheel\", onWheel);\n      };\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  const floating = React.useMemo(() => ({\n    onKeyDown() {\n      controlledScrollingRef.current = !0;\n    },\n    onWheel() {\n      controlledScrollingRef.current = !1;\n    },\n    onPointerMove() {\n      controlledScrollingRef.current = !1;\n    },\n    onScroll() {\n      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n      if (!(!overflowRef.current || !el || !controlledScrollingRef.current)) {\n        if (prevScrollTopRef.current !== null) {\n          const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n          (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) && ReactDOM.flushSync(() => onChange((d2) => d2 + scrollDiff));\n        }\n        requestAnimationFrame(() => {\n          prevScrollTopRef.current = el.scrollTop;\n        });\n      }\n    }\n  }), [elements.floating, onChange, overflowRef, scrollRef]);\n  return React.useMemo(() => enabled ? {\n    floating\n  } : {}, [enabled, floating]);\n}\nlet y$1 = createContext({ styles: void 0, setReference: () => {\n}, setFloating: () => {\n}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });\ny$1.displayName = \"FloatingContext\";\nlet H$2 = createContext(null);\nH$2.displayName = \"PlacementContext\";\nfunction xe(e2) {\n  return useMemo(() => e2 ? typeof e2 == \"string\" ? { to: e2 } : e2 : null, [e2]);\n}\nfunction ye() {\n  return useContext(y$1).setReference;\n}\nfunction Fe() {\n  return useContext(y$1).getReferenceProps;\n}\nfunction be() {\n  let { getFloatingProps: e2, slot: t2 } = useContext(y$1);\n  return useCallback((...n2) => Object.assign({}, e2(...n2), { \"data-anchor\": t2.anchor }), [e2, t2]);\n}\nfunction Re(e2 = null) {\n  e2 === !1 && (e2 = null), typeof e2 == \"string\" && (e2 = { to: e2 });\n  let t2 = useContext(H$2), n2 = useMemo(() => e2, [JSON.stringify(e2, (r2, o3) => {\n    var u2;\n    return (u2 = o3 == null ? void 0 : o3.outerHTML) != null ? u2 : o3;\n  })]);\n  n$3(() => {\n    t2 == null || t2(n2 ?? null);\n  }, [t2, n2]);\n  let l2 = useContext(y$1);\n  return useMemo(() => [l2.setFloating, e2 ? l2.styles : {}], [l2.setFloating, e2, l2.styles]);\n}\nlet q = 4;\nfunction Me({ children: e2, enabled: t2 = !0 }) {\n  let [n2, l2] = useState(null), [r2, o3] = useState(0), u2 = useRef(null), [f2, s2] = useState(null);\n  pe(f2);\n  let i2 = t2 && n2 !== null && f2 !== null, { to: F2 = \"bottom\", gap: E2 = 0, offset: v2 = 0, padding: c2 = 0, inner: P2 } = ce(n2, f2), [a3, p2 = \"center\"] = F2.split(\" \");\n  n$3(() => {\n    i2 && o3(0);\n  }, [i2]);\n  let { refs: b2, floatingStyles: w2, context: g2 } = useFloating({ open: i2, placement: a3 === \"selection\" ? p2 === \"center\" ? \"bottom\" : \\`bottom-\\${p2}\\` : p2 === \"center\" ? \\`\\${a3}\\` : \\`\\${a3}-\\${p2}\\`, strategy: \"absolute\", transform: !1, middleware: [offset({ mainAxis: a3 === \"selection\" ? 0 : E2, crossAxis: v2 }), shift({ padding: c2 }), a3 !== \"selection\" && flip({ padding: c2 }), a3 === \"selection\" && P2 ? inner({ ...P2, padding: c2, overflowRef: u2, offset: r2, minItemsVisible: q, referenceOverflowThreshold: c2, onFallbackChange(h2) {\n    var O2, W;\n    if (!h2) return;\n    let d2 = g2.elements.floating;\n    if (!d2) return;\n    let T2 = parseFloat(getComputedStyle(d2).scrollPaddingBottom) || 0, $2 = Math.min(q, d2.childElementCount), L2 = 0, N2 = 0;\n    for (let m2 of (W = (O2 = g2.elements.floating) == null ? void 0 : O2.childNodes) != null ? W : []) if (m2 instanceof HTMLElement) {\n      let x2 = m2.offsetTop, k2 = x2 + m2.clientHeight + T2, S2 = d2.scrollTop, U2 = S2 + d2.clientHeight;\n      if (x2 >= S2 && k2 <= U2) $2--;\n      else {\n        N2 = Math.max(0, Math.min(k2, U2) - Math.max(x2, S2)), L2 = m2.clientHeight;\n        break;\n      }\n    }\n    $2 >= 1 && o3((m2) => {\n      let x2 = L2 * $2 - N2 + T2;\n      return m2 >= x2 ? m2 : x2;\n    });\n  } }) : null, size({ padding: c2, apply({ availableWidth: h2, availableHeight: d2, elements: T2 }) {\n    Object.assign(T2.floating.style, { overflow: \"auto\", maxWidth: \\`\\${h2}px\\`, maxHeight: \\`min(var(--anchor-max-height, 100vh), \\${d2}px)\\` });\n  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [I2 = a3, B2 = p2] = g2.placement.split(\"-\");\n  a3 === \"selection\" && (I2 = \"selection\");\n  let G2 = useMemo(() => ({ anchor: [I2, B2].filter(Boolean).join(\" \") }), [I2, B2]), K2 = useInnerOffset(g2, { overflowRef: u2, onChange: o3 }), { getReferenceProps: Q, getFloatingProps: X2 } = useInteractions([K2]), Y = o$4((h2) => {\n    s2(h2), b2.setFloating(h2);\n  });\n  return React.createElement(H$2.Provider, { value: l2 }, React.createElement(y$1.Provider, { value: { setFloating: Y, setReference: b2.setReference, styles: w2, getReferenceProps: Q, getFloatingProps: X2, slot: G2 } }, e2));\n}\nfunction pe(e2) {\n  n$3(() => {\n    if (!e2) return;\n    let t2 = new MutationObserver(() => {\n      let n2 = window.getComputedStyle(e2).maxHeight, l2 = parseFloat(n2);\n      if (isNaN(l2)) return;\n      let r2 = parseInt(n2);\n      isNaN(r2) || l2 !== r2 && (e2.style.maxHeight = \\`\\${Math.ceil(l2)}px\\`);\n    });\n    return t2.observe(e2, { attributes: !0, attributeFilter: [\"style\"] }), () => {\n      t2.disconnect();\n    };\n  }, [e2]);\n}\nfunction ce(e2, t2) {\n  var o3, u2, f2;\n  let n2 = V((o3 = e2 == null ? void 0 : e2.gap) != null ? o3 : \"var(--anchor-gap, 0)\", t2), l2 = V((u2 = e2 == null ? void 0 : e2.offset) != null ? u2 : \"var(--anchor-offset, 0)\", t2), r2 = V((f2 = e2 == null ? void 0 : e2.padding) != null ? f2 : \"var(--anchor-padding, 0)\", t2);\n  return { ...e2, gap: n2, offset: l2, padding: r2 };\n}\nfunction V(e2, t2, n2 = void 0) {\n  let l2 = p$2(), r2 = o$4((s2, i2) => {\n    if (s2 == null) return [n2, null];\n    if (typeof s2 == \"number\") return [s2, null];\n    if (typeof s2 == \"string\") {\n      if (!i2) return [n2, null];\n      let F2 = J$2(s2, i2);\n      return [F2, (E2) => {\n        let v2 = D$1(s2);\n        {\n          let c2 = v2.map((P2) => window.getComputedStyle(i2).getPropertyValue(P2));\n          l2.requestAnimationFrame(function P2() {\n            l2.nextFrame(P2);\n            let a3 = !1;\n            for (let [b2, w2] of v2.entries()) {\n              let g2 = window.getComputedStyle(i2).getPropertyValue(w2);\n              if (c2[b2] !== g2) {\n                c2[b2] = g2, a3 = !0;\n                break;\n              }\n            }\n            if (!a3) return;\n            let p2 = J$2(s2, i2);\n            F2 !== p2 && (E2(p2), F2 = p2);\n          });\n        }\n        return l2.dispose;\n      }];\n    }\n    return [n2, null];\n  }), o3 = useMemo(() => r2(e2, t2)[0], [e2, t2]), [u2 = o3, f2] = useState();\n  return n$3(() => {\n    let [s2, i2] = r2(e2, t2);\n    if (f2(s2), !!i2) return i2(f2);\n  }, [e2, t2]), u2;\n}\nfunction D$1(e2) {\n  let t2 = /var\\\\((.*)\\\\)/.exec(e2);\n  if (t2) {\n    let n2 = t2[1].indexOf(\",\");\n    if (n2 === -1) return [t2[1]];\n    let l2 = t2[1].slice(0, n2).trim(), r2 = t2[1].slice(n2 + 1).trim();\n    return r2 ? [l2, ...D$1(r2)] : [l2];\n  }\n  return [];\n}\nfunction J$2(e2, t2) {\n  let n2 = document.createElement(\"div\");\n  t2.appendChild(n2), n2.style.setProperty(\"margin-top\", \"0px\", \"important\"), n2.style.setProperty(\"margin-top\", e2, \"important\");\n  let l2 = parseFloat(window.getComputedStyle(n2).marginTop) || 0;\n  return t2.removeChild(n2), l2;\n}\nlet n = createContext(null);\nn.displayName = \"OpenClosedContext\";\nvar i$2 = ((e2) => (e2[e2.Open = 1] = \"Open\", e2[e2.Closed = 2] = \"Closed\", e2[e2.Closing = 4] = \"Closing\", e2[e2.Opening = 8] = \"Opening\", e2))(i$2 || {});\nfunction u$2() {\n  return useContext(n);\n}\nfunction c$3({ value: o3, children: t2 }) {\n  return React__default.createElement(n.Provider, { value: o3 }, t2);\n}\nvar withSelector = { exports: {} }, useSyncExternalStoreWithSelector_production = {};\n/**\n * @license React\n * use-sync-external-store-with-selector.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredUseSyncExternalStoreWithSelector_production;\nfunction requireUseSyncExternalStoreWithSelector_production() {\n  if (hasRequiredUseSyncExternalStoreWithSelector_production) return useSyncExternalStoreWithSelector_production;\n  hasRequiredUseSyncExternalStoreWithSelector_production = 1;\n  var React2 = React__default;\n  function is(x2, y2) {\n    return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;\n  }\n  var objectIs = typeof Object.is == \"function\" ? Object.is : is, useSyncExternalStore2 = React2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;\n  return useSyncExternalStoreWithSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n    var instRef = useRef2(null);\n    if (instRef.current === null) {\n      var inst = { hasValue: !1, value: null };\n      instRef.current = inst;\n    } else inst = instRef.current;\n    instRef = useMemo2(\n      function() {\n        function memoizedSelector(nextSnapshot) {\n          if (!hasMemo) {\n            if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {\n              var currentSelection = inst.value;\n              if (isEqual(currentSelection, nextSnapshot))\n                return memoizedSelection = currentSelection;\n            }\n            return memoizedSelection = nextSnapshot;\n          }\n          if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;\n          var nextSelection = selector(nextSnapshot);\n          return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);\n        }\n        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n        return [\n          function() {\n            return memoizedSelector(getSnapshot());\n          },\n          maybeGetServerSnapshot === null ? void 0 : function() {\n            return memoizedSelector(maybeGetServerSnapshot());\n          }\n        ];\n      },\n      [getSnapshot, getServerSnapshot, selector, isEqual]\n    );\n    var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);\n    return useEffect2(\n      function() {\n        inst.hasValue = !0, inst.value = value;\n      },\n      [value]\n    ), useDebugValue(value), value;\n  }, useSyncExternalStoreWithSelector_production;\n}\nvar useSyncExternalStoreWithSelector_development = {}, hasRequiredUseSyncExternalStoreWithSelector_development;\nfunction requireUseSyncExternalStoreWithSelector_development() {\n  if (hasRequiredUseSyncExternalStoreWithSelector_development) return useSyncExternalStoreWithSelector_development;\n  hasRequiredUseSyncExternalStoreWithSelector_development = 1;\n  var define_process_env_default2 = {};\n  /**\n   * @license React\n   * use-sync-external-store-with-selector.development.js\n   *\n   * Copyright (c) Meta Platforms, Inc. and affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n  return define_process_env_default2.NODE_ENV !== \"production\" && function() {\n    function is(x2, y2) {\n      return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;\n    }\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());\n    var React2 = React__default, objectIs = typeof Object.is == \"function\" ? Object.is : is, useSyncExternalStore2 = React2.useSyncExternalStore, useRef2 = React2.useRef, useEffect2 = React2.useEffect, useMemo2 = React2.useMemo, useDebugValue = React2.useDebugValue;\n    useSyncExternalStoreWithSelector_development.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n      var instRef = useRef2(null);\n      if (instRef.current === null) {\n        var inst = { hasValue: !1, value: null };\n        instRef.current = inst;\n      } else inst = instRef.current;\n      instRef = useMemo2(\n        function() {\n          function memoizedSelector(nextSnapshot) {\n            if (!hasMemo) {\n              if (hasMemo = !0, memoizedSnapshot = nextSnapshot, nextSnapshot = selector(nextSnapshot), isEqual !== void 0 && inst.hasValue) {\n                var currentSelection = inst.value;\n                if (isEqual(currentSelection, nextSnapshot))\n                  return memoizedSelection = currentSelection;\n              }\n              return memoizedSelection = nextSnapshot;\n            }\n            if (currentSelection = memoizedSelection, objectIs(memoizedSnapshot, nextSnapshot))\n              return currentSelection;\n            var nextSelection = selector(nextSnapshot);\n            return isEqual !== void 0 && isEqual(currentSelection, nextSelection) ? (memoizedSnapshot = nextSnapshot, currentSelection) : (memoizedSnapshot = nextSnapshot, memoizedSelection = nextSelection);\n          }\n          var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;\n          return [\n            function() {\n              return memoizedSelector(getSnapshot());\n            },\n            maybeGetServerSnapshot === null ? void 0 : function() {\n              return memoizedSelector(maybeGetServerSnapshot());\n            }\n          ];\n        },\n        [getSnapshot, getServerSnapshot, selector, isEqual]\n      );\n      var value = useSyncExternalStore2(subscribe, instRef[0], instRef[1]);\n      return useEffect2(\n        function() {\n          inst.hasValue = !0, inst.value = value;\n        },\n        [value]\n      ), useDebugValue(value), value;\n    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());\n  }(), useSyncExternalStoreWithSelector_development;\n}\nvar hasRequiredWithSelector;\nfunction requireWithSelector() {\n  if (hasRequiredWithSelector) return withSelector.exports;\n  hasRequiredWithSelector = 1;\n  var define_process_env_default2 = {};\n  return define_process_env_default2.NODE_ENV === \"production\" ? withSelector.exports = requireUseSyncExternalStoreWithSelector_production() : withSelector.exports = requireUseSyncExternalStoreWithSelector_development(), withSelector.exports;\n}\nvar withSelectorExports = requireWithSelector(), f$1 = (t2, e2, r2) => {\n  if (!e2.has(t2)) throw TypeError(\"Cannot \" + r2);\n}, a$3 = (t2, e2, r2) => (f$1(t2, e2, \"read from private field\"), r2 ? r2.call(t2) : e2.get(t2)), l$2 = (t2, e2, r2) => {\n  if (e2.has(t2)) throw TypeError(\"Cannot add the same private member more than once\");\n  e2 instanceof WeakSet ? e2.add(t2) : e2.set(t2, r2);\n}, c$2 = (t2, e2, r2, n2) => (f$1(t2, e2, \"write to private field\"), e2.set(t2, r2), r2), i$1, s$4, o$1;\nclass m {\n  constructor(e2) {\n    l$2(this, i$1, {}), l$2(this, s$4, new a$7(() => /* @__PURE__ */ new Set())), l$2(this, o$1, /* @__PURE__ */ new Set()), c$2(this, i$1, e2);\n  }\n  get state() {\n    return a$3(this, i$1);\n  }\n  subscribe(e2, r2) {\n    let n2 = { selector: e2, callback: r2, current: e2(a$3(this, i$1)) };\n    return a$3(this, o$1).add(n2), () => {\n      a$3(this, o$1).delete(n2);\n    };\n  }\n  on(e2, r2) {\n    return a$3(this, s$4).get(e2).add(r2), () => {\n      a$3(this, s$4).get(e2).delete(r2);\n    };\n  }\n  send(e2) {\n    c$2(this, i$1, this.reduce(a$3(this, i$1), e2));\n    for (let r2 of a$3(this, o$1)) {\n      let n2 = r2.selector(a$3(this, i$1));\n      h$1(r2.current, n2) || (r2.current = n2, r2.callback(n2));\n    }\n    for (let r2 of a$3(this, s$4).get(e2.type)) r2(a$3(this, i$1), e2);\n  }\n}\ni$1 = /* @__PURE__ */ new WeakMap(), s$4 = /* @__PURE__ */ new WeakMap(), o$1 = /* @__PURE__ */ new WeakMap();\nfunction h$1(t2, e2) {\n  return Object.is(t2, e2) ? !0 : typeof t2 != \"object\" || t2 === null || typeof e2 != \"object\" || e2 === null ? !1 : Array.isArray(t2) && Array.isArray(e2) ? t2.length !== e2.length ? !1 : u$1(t2[Symbol.iterator](), e2[Symbol.iterator]()) : t2 instanceof Map && e2 instanceof Map || t2 instanceof Set && e2 instanceof Set ? t2.size !== e2.size ? !1 : u$1(t2.entries(), e2.entries()) : S$2(t2) && S$2(e2) ? u$1(Object.entries(t2)[Symbol.iterator](), Object.entries(e2)[Symbol.iterator]()) : !1;\n}\nfunction u$1(t2, e2) {\n  do {\n    let r2 = t2.next(), n2 = e2.next();\n    if (r2.done && n2.done) return !0;\n    if (r2.done || n2.done || !Object.is(r2.value, n2.value)) return !1;\n  } while (!0);\n}\nfunction S$2(t2) {\n  if (Object.prototype.toString.call(t2) !== \"[object Object]\") return !1;\n  let e2 = Object.getPrototypeOf(t2);\n  return e2 === null || Object.getPrototypeOf(e2) === null;\n}\nfunction g$2(t2) {\n  let [e2, r2] = t2(), n2 = o$5();\n  return (...b2) => {\n    e2(...b2), n2.dispose(), n2.microTask(r2);\n  };\n}\nfunction S$1(e2, n2, r2 = h$1) {\n  return withSelectorExports.useSyncExternalStoreWithSelector(o$4((i2) => e2.subscribe(s$3, i2)), o$4(() => e2.state), o$4(() => e2.state), o$4(n2), r2);\n}\nfunction s$3(e2) {\n  return e2;\n}\nfunction u(l2) {\n  throw new Error(\"Unexpected object: \" + l2);\n}\nvar c$1 = ((i2) => (i2[i2.First = 0] = \"First\", i2[i2.Previous = 1] = \"Previous\", i2[i2.Next = 2] = \"Next\", i2[i2.Last = 3] = \"Last\", i2[i2.Specific = 4] = \"Specific\", i2[i2.Nothing = 5] = \"Nothing\", i2))(c$1 || {});\nfunction f(l2, n2) {\n  let t2 = n2.resolveItems();\n  if (t2.length <= 0) return null;\n  let r2 = n2.resolveActiveIndex(), s2 = r2 ?? -1;\n  switch (l2.focus) {\n    case 0: {\n      for (let e2 = 0; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;\n      return r2;\n    }\n    case 1: {\n      s2 === -1 && (s2 = t2.length);\n      for (let e2 = s2 - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;\n      return r2;\n    }\n    case 2: {\n      for (let e2 = s2 + 1; e2 < t2.length; ++e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;\n      return r2;\n    }\n    case 3: {\n      for (let e2 = t2.length - 1; e2 >= 0; --e2) if (!n2.resolveDisabled(t2[e2], e2, t2)) return e2;\n      return r2;\n    }\n    case 4: {\n      for (let e2 = 0; e2 < t2.length; ++e2) if (n2.resolveId(t2[e2], e2, t2) === l2.id) return e2;\n      return r2;\n    }\n    case 5:\n      return null;\n    default:\n      u(l2);\n  }\n}\nfunction c(t2) {\n  let r2 = o$4(t2), e2 = useRef(!1);\n  useEffect(() => (e2.current = !1, () => {\n    e2.current = !0, t$3(() => {\n      e2.current && r2();\n    });\n  }), [r2]);\n}\nfunction s$2() {\n  let r2 = typeof document > \"u\";\n  return \"useSyncExternalStore\" in React ? ((o3) => o3.useSyncExternalStore)(React)(() => () => {\n  }, () => !1, () => !r2) : !1;\n}\nfunction l$1() {\n  let r2 = s$2(), [e2, n2] = React.useState(s$7.isHandoffComplete);\n  return e2 && s$7.isHandoffComplete === !1 && n2(!1), React.useEffect(() => {\n    e2 !== !0 && n2(!0);\n  }, [e2]), React.useEffect(() => s$7.handoff(), []), r2 ? !1 : e2;\n}\nlet e = createContext(!1);\nfunction a$2() {\n  return useContext(e);\n}\nfunction j(e2) {\n  let l2 = a$2(), o3 = useContext(H$1), [r2, u2] = useState(() => {\n    var i2;\n    if (!l2 && o3 !== null) return (i2 = o3.current) != null ? i2 : null;\n    if (s$7.isServer) return null;\n    let t2 = e2 == null ? void 0 : e2.getElementById(\"headlessui-portal-root\");\n    if (t2) return t2;\n    if (e2 === null) return null;\n    let a3 = e2.createElement(\"div\");\n    return a3.setAttribute(\"id\", \"headlessui-portal-root\"), e2.body.appendChild(a3);\n  });\n  return useEffect(() => {\n    r2 !== null && (e2 != null && e2.body.contains(r2) || e2 == null || e2.body.appendChild(r2));\n  }, [r2, e2]), useEffect(() => {\n    l2 || o3 !== null && u2(o3.current);\n  }, [o3, u2, l2]), r2;\n}\nlet M$1 = Fragment, I = K$1(function(l2, o3) {\n  let { ownerDocument: r2 = null, ...u2 } = l2, t2 = useRef(null), a3 = y$4(T$3((s2) => {\n    t2.current = s2;\n  }), o3), i2 = n$1(t2), f2 = r2 ?? i2, p2 = j(f2), [n2] = useState(() => {\n    var s2;\n    return s$7.isServer ? null : (s2 = f2 == null ? void 0 : f2.createElement(\"div\")) != null ? s2 : null;\n  }), P2 = useContext(g$1), b2 = l$1();\n  n$3(() => {\n    !p2 || !n2 || p2.contains(n2) || (n2.setAttribute(\"data-headlessui-portal\", \"\"), p2.appendChild(n2));\n  }, [p2, n2]), n$3(() => {\n    if (n2 && P2) return P2.register(n2);\n  }, [P2, n2]), c(() => {\n    var s2;\n    !p2 || !n2 || (n2 instanceof Node && p2.contains(n2) && p2.removeChild(n2), p2.childNodes.length <= 0 && ((s2 = p2.parentElement) == null || s2.removeChild(p2)));\n  });\n  let h2 = L$2();\n  return b2 ? !p2 || !n2 ? null : createPortal(h2({ ourProps: { ref: a3 }, theirProps: u2, slot: {}, defaultTag: M$1, name: \"Portal\" }), n2) : null;\n});\nfunction J$1(e2, l2) {\n  let o3 = y$4(l2), { enabled: r2 = !0, ownerDocument: u2, ...t2 } = e2, a3 = L$2();\n  return r2 ? React__default.createElement(I, { ...t2, ownerDocument: u2, ref: o3 }) : a3({ ourProps: { ref: o3 }, theirProps: t2, slot: {}, defaultTag: M$1, name: \"Portal\" });\n}\nlet X$1 = Fragment, H$1 = createContext(null);\nfunction k(e2, l2) {\n  let { target: o3, ...r2 } = e2, t2 = { ref: y$4(l2) }, a3 = L$2();\n  return React__default.createElement(H$1.Provider, { value: o3 }, a3({ ourProps: t2, theirProps: r2, defaultTag: X$1, name: \"Popover.Group\" }));\n}\nlet g$1 = createContext(null), B = K$1(J$1), D = K$1(k), oe = Object.assign(B, { Group: D });\nfunction s$1(n2, t2) {\n  let e2 = useRef({ left: 0, top: 0 });\n  if (n$3(() => {\n    if (!t2) return;\n    let r2 = t2.getBoundingClientRect();\n    r2 && (e2.current = r2);\n  }, [n2, t2]), t2 == null || !n2 || t2 === document.activeElement) return !1;\n  let o3 = t2.getBoundingClientRect();\n  return o3.top !== e2.current.top || o3.left !== e2.current.left;\n}\nlet a$1 = /([\\\\u2700-\\\\u27BF]|[\\\\uE000-\\\\uF8FF]|\\\\uD83C[\\\\uDC00-\\\\uDFFF]|\\\\uD83D[\\\\uDC00-\\\\uDFFF]|[\\\\u2011-\\\\u26FF]|\\\\uD83E[\\\\uDD10-\\\\uDDFF])/g;\nfunction o2(e2) {\n  var r2, i2;\n  let n2 = (r2 = e2.innerText) != null ? r2 : \"\", t2 = e2.cloneNode(!0);\n  if (!(t2 instanceof HTMLElement)) return n2;\n  let u2 = !1;\n  for (let f2 of t2.querySelectorAll('[hidden],[aria-hidden],[role=\"img\"]')) f2.remove(), u2 = !0;\n  let l2 = u2 ? (i2 = t2.innerText) != null ? i2 : \"\" : n2;\n  return a$1.test(l2) && (l2 = l2.replace(a$1, \"\")), l2;\n}\nfunction g(e2) {\n  let n2 = e2.getAttribute(\"aria-label\");\n  if (typeof n2 == \"string\") return n2.trim();\n  let t2 = e2.getAttribute(\"aria-labelledby\");\n  if (t2) {\n    let u2 = t2.split(\" \").map((l2) => {\n      let r2 = document.getElementById(l2);\n      if (r2) {\n        let i2 = r2.getAttribute(\"aria-label\");\n        return typeof i2 == \"string\" ? i2.trim() : o2(r2).trim();\n      }\n      return null;\n    }).filter(Boolean);\n    if (u2.length > 0) return u2.join(\", \");\n  }\n  return o2(e2).trim();\n}\nfunction s(c2) {\n  let t2 = useRef(\"\"), r2 = useRef(\"\");\n  return o$4(() => {\n    let e2 = c2.current;\n    if (!e2) return \"\";\n    let u2 = e2.innerText;\n    if (t2.current === u2) return r2.current;\n    let n2 = g(e2).trim().toLowerCase();\n    return t2.current = u2, r2.current = n2, n2;\n  });\n}\nvar h = Object.defineProperty, y = (e2, n2, t2) => n2 in e2 ? h(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, v = (e2, n2, t2) => (y(e2, typeof n2 != \"symbol\" ? n2 + \"\" : n2, t2), t2), M = ((t2) => (t2[t2.Open = 0] = \"Open\", t2[t2.Closed = 1] = \"Closed\", t2))(M || {}), T = ((t2) => (t2[t2.Pointer = 0] = \"Pointer\", t2[t2.Other = 1] = \"Other\", t2))(T || {}), b = ((i2) => (i2[i2.OpenMenu = 0] = \"OpenMenu\", i2[i2.CloseMenu = 1] = \"CloseMenu\", i2[i2.GoToItem = 2] = \"GoToItem\", i2[i2.Search = 3] = \"Search\", i2[i2.ClearSearch = 4] = \"ClearSearch\", i2[i2.RegisterItems = 5] = \"RegisterItems\", i2[i2.UnregisterItems = 6] = \"UnregisterItems\", i2[i2.SetButtonElement = 7] = \"SetButtonElement\", i2[i2.SetItemsElement = 8] = \"SetItemsElement\", i2[i2.SortItems = 9] = \"SortItems\", i2))(b || {});\nfunction S(e2, n2 = (t2) => t2) {\n  let t2 = e2.activeItemIndex !== null ? e2.items[e2.activeItemIndex] : null, r2 = _(n2(e2.items.slice()), (u2) => u2.dataRef.current.domRef.current), l2 = t2 ? r2.indexOf(t2) : null;\n  return l2 === -1 && (l2 = null), { items: r2, activeItemIndex: l2 };\n}\nlet F = { 1(e2) {\n  return e2.menuState === 1 ? e2 : { ...e2, activeItemIndex: null, pendingFocus: { focus: c$1.Nothing }, menuState: 1 };\n}, 0(e2, n2) {\n  return e2.menuState === 0 ? e2 : { ...e2, __demoMode: !1, pendingFocus: n2.focus, menuState: 0 };\n}, 2: (e2, n2) => {\n  var u2, m2, d2, a3, I2;\n  if (e2.menuState === 1) return e2;\n  let t2 = { ...e2, searchQuery: \"\", activationTrigger: (u2 = n2.trigger) != null ? u2 : 1, __demoMode: !1 };\n  if (n2.focus === c$1.Nothing) return { ...t2, activeItemIndex: null };\n  if (n2.focus === c$1.Specific) return { ...t2, activeItemIndex: e2.items.findIndex((i2) => i2.id === n2.id) };\n  if (n2.focus === c$1.Previous) {\n    let i2 = e2.activeItemIndex;\n    if (i2 !== null) {\n      let g2 = e2.items[i2].dataRef.current.domRef, o3 = f(n2, { resolveItems: () => e2.items, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (s2) => s2.id, resolveDisabled: (s2) => s2.dataRef.current.disabled });\n      if (o3 !== null) {\n        let s2 = e2.items[o3].dataRef.current.domRef;\n        if (((m2 = g2.current) == null ? void 0 : m2.previousElementSibling) === s2.current || ((d2 = s2.current) == null ? void 0 : d2.previousElementSibling) === null) return { ...t2, activeItemIndex: o3 };\n      }\n    }\n  } else if (n2.focus === c$1.Next) {\n    let i2 = e2.activeItemIndex;\n    if (i2 !== null) {\n      let g2 = e2.items[i2].dataRef.current.domRef, o3 = f(n2, { resolveItems: () => e2.items, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (s2) => s2.id, resolveDisabled: (s2) => s2.dataRef.current.disabled });\n      if (o3 !== null) {\n        let s2 = e2.items[o3].dataRef.current.domRef;\n        if (((a3 = g2.current) == null ? void 0 : a3.nextElementSibling) === s2.current || ((I2 = s2.current) == null ? void 0 : I2.nextElementSibling) === null) return { ...t2, activeItemIndex: o3 };\n      }\n    }\n  }\n  let r2 = S(e2), l2 = f(n2, { resolveItems: () => r2.items, resolveActiveIndex: () => r2.activeItemIndex, resolveId: (i2) => i2.id, resolveDisabled: (i2) => i2.dataRef.current.disabled });\n  return { ...t2, ...r2, activeItemIndex: l2 };\n}, 3: (e2, n2) => {\n  let r2 = e2.searchQuery !== \"\" ? 0 : 1, l2 = e2.searchQuery + n2.value.toLowerCase(), m2 = (e2.activeItemIndex !== null ? e2.items.slice(e2.activeItemIndex + r2).concat(e2.items.slice(0, e2.activeItemIndex + r2)) : e2.items).find((a3) => {\n    var I2;\n    return ((I2 = a3.dataRef.current.textValue) == null ? void 0 : I2.startsWith(l2)) && !a3.dataRef.current.disabled;\n  }), d2 = m2 ? e2.items.indexOf(m2) : -1;\n  return d2 === -1 || d2 === e2.activeItemIndex ? { ...e2, searchQuery: l2 } : { ...e2, searchQuery: l2, activeItemIndex: d2, activationTrigger: 1 };\n}, 4(e2) {\n  return e2.searchQuery === \"\" ? e2 : { ...e2, searchQuery: \"\", searchActiveItemIndex: null };\n}, 5: (e2, n2) => {\n  let t2 = e2.items.concat(n2.items.map((l2) => l2)), r2 = e2.activeItemIndex;\n  return e2.pendingFocus.focus !== c$1.Nothing && (r2 = f(e2.pendingFocus, { resolveItems: () => t2, resolveActiveIndex: () => e2.activeItemIndex, resolveId: (l2) => l2.id, resolveDisabled: (l2) => l2.dataRef.current.disabled })), { ...e2, items: t2, activeItemIndex: r2, pendingFocus: { focus: c$1.Nothing }, pendingShouldSort: !0 };\n}, 6: (e2, n2) => {\n  let t2 = e2.items, r2 = [], l2 = new Set(n2.items);\n  for (let [u2, m2] of t2.entries()) if (l2.has(m2.id) && (r2.push(u2), l2.delete(m2.id), l2.size === 0)) break;\n  if (r2.length > 0) {\n    t2 = t2.slice();\n    for (let u2 of r2.reverse()) t2.splice(u2, 1);\n  }\n  return { ...e2, items: t2, activationTrigger: 1 };\n}, 7: (e2, n2) => e2.buttonElement === n2.element ? e2 : { ...e2, buttonElement: n2.element }, 8: (e2, n2) => e2.itemsElement === n2.element ? e2 : { ...e2, itemsElement: n2.element }, 9: (e2) => e2.pendingShouldSort ? { ...e2, ...S(e2), pendingShouldSort: !1 } : e2 };\nclass x extends m {\n  constructor(t2) {\n    super(t2), v(this, \"actions\", { registerItem: g$2(() => {\n      let t3 = [], r2 = /* @__PURE__ */ new Set();\n      return [(l2, u2) => {\n        r2.has(u2) || (r2.add(u2), t3.push({ id: l2, dataRef: u2 }));\n      }, () => (r2.clear(), this.send({ type: 5, items: t3.splice(0) }))];\n    }), unregisterItem: g$2(() => {\n      let t3 = [];\n      return [(r2) => t3.push(r2), () => this.send({ type: 6, items: t3.splice(0) })];\n    }) }), v(this, \"selectors\", { activeDescendantId(t3) {\n      var u2;\n      let r2 = t3.activeItemIndex, l2 = t3.items;\n      return r2 === null || (u2 = l2[r2]) == null ? void 0 : u2.id;\n    }, isActive(t3, r2) {\n      var m2;\n      let l2 = t3.activeItemIndex, u2 = t3.items;\n      return l2 !== null ? ((m2 = u2[l2]) == null ? void 0 : m2.id) === r2 : !1;\n    }, shouldScrollIntoView(t3, r2) {\n      return t3.__demoMode || t3.menuState !== 0 || t3.activationTrigger === 0 ? !1 : this.isActive(t3, r2);\n    } }), this.on(5, () => {\n      requestAnimationFrame(() => {\n        this.send({ type: 9 });\n      });\n    });\n  }\n  static new({ __demoMode: t2 = !1 } = {}) {\n    return new x({ __demoMode: t2, menuState: t2 ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: \"\", activeItemIndex: null, activationTrigger: 1, pendingShouldSort: !1, pendingFocus: { focus: c$1.Nothing } });\n  }\n  reduce(t2, r2) {\n    return u$7(r2.type, F, t2, r2);\n  }\n}\nconst a2 = createContext(null);\nfunction l(e2) {\n  let n2 = useContext(a2);\n  if (n2 === null) {\n    let t2 = new Error(\\`<\\${e2} /> is missing a parent <Menu /> component.\\`);\n    throw Error.captureStackTrace && Error.captureStackTrace(t2, i), t2;\n  }\n  return n2;\n}\nfunction i({ __demoMode: e2 = !1 } = {}) {\n  return useMemo(() => x.new({ __demoMode: e2 }), []);\n}\nlet ze = Fragment;\nfunction Qe(T2, E2) {\n  let { __demoMode: i$12 = !1, ...a$12 } = T2, n2 = i({ __demoMode: i$12 }), [s2, o3, P2] = S$1(n2, (p2) => [p2.menuState, p2.itemsElement, p2.buttonElement]), c2 = y$4(E2), _2 = s2 === M.Open;\n  R$1(_2, [P2, o3], (p2, F2) => {\n    var A$12;\n    n2.send({ type: b.CloseMenu }), A(F2, h$2.Loose) || (p2.preventDefault(), (A$12 = n2.state.buttonElement) == null || A$12.focus());\n  });\n  let t2 = o$4(() => {\n    n2.send({ type: b.CloseMenu });\n  }), R2 = useMemo(() => ({ open: s2 === M.Open, close: t2 }), [s2, t2]), I2 = { ref: c2 }, g2 = L$2();\n  return React__default.createElement(Me, null, React__default.createElement(a2.Provider, { value: n2 }, React__default.createElement(c$3, { value: u$7(s2, { [M.Open]: i$2.Open, [M.Closed]: i$2.Closed }) }, g2({ ourProps: I2, theirProps: a$12, slot: R2, defaultTag: ze, name: \"Menu\" }))));\n}\nlet Ye = \"button\";\nfunction Ze(T$12, E2) {\n  let i2 = l(\"Menu.Button\"), a3 = useId$1(), { id: n2 = \\`headlessui-menu-button-\\${a3}\\`, disabled: s2 = !1, autoFocus: o3 = !1, ...P2 } = T$12, c2 = useRef(null), _2 = Fe(), t2 = y$4(E2, c2, ye(), o$4((l2) => i2.send({ type: b.SetButtonElement, element: l2 }))), R2 = o$4((l2) => {\n    switch (l2.key) {\n      case o$3.Space:\n      case o$3.Enter:\n      case o$3.ArrowDown:\n        l2.preventDefault(), l2.stopPropagation(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.First } });\n        break;\n      case o$3.ArrowUp:\n        l2.preventDefault(), l2.stopPropagation(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.Last } });\n        break;\n    }\n  }), I2 = o$4((l2) => {\n    switch (l2.key) {\n      case o$3.Space:\n        l2.preventDefault();\n        break;\n    }\n  }), [g2, p2] = S$1(i2, (l2) => [l2.menuState, l2.itemsElement]), F2 = o$4((l2) => {\n    var H2;\n    if (l2.button === 0) {\n      if (r$1(l2.currentTarget)) return l2.preventDefault();\n      s2 || (g2 === M.Open ? (flushSync(() => i2.send({ type: b.CloseMenu })), (H2 = c2.current) == null || H2.focus({ preventScroll: !0 })) : (l2.preventDefault(), i2.send({ type: b.OpenMenu, focus: { focus: c$1.Nothing }, trigger: T.Pointer })));\n    }\n  }), { isFocusVisible: A2, focusProps: f2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: o3 }), { isHovered: M$12, hoverProps: L2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: s2 }), { pressed: S2, pressProps: O2 } = w$2({ disabled: s2 }), x2 = useMemo(() => ({ open: g2 === M.Open, active: S2 || g2 === M.Open, disabled: s2, hover: M$12, focus: A2, autofocus: o3 }), [g2, M$12, A2, S2, s2, o3]), U2 = _$2(_2(), { ref: t2, id: n2, type: e$1(T$12, c2.current), \"aria-haspopup\": \"menu\", \"aria-controls\": p2 == null ? void 0 : p2.id, \"aria-expanded\": g2 === M.Open, disabled: s2 || void 0, autoFocus: o3, onKeyDown: R2, onKeyUp: I2, onMouseDown: F2 }, f2, L2, O2);\n  return L$2()({ ourProps: U2, theirProps: P2, slot: x2, defaultTag: Ye, name: \"Menu.Button\" });\n}\nlet et = \"div\", tt = O$1.RenderStrategy | O$1.Static;\nfunction ot(T2, E2) {\n  let i2 = useId$1(), { id: a3 = \\`headlessui-menu-items-\\${i2}\\`, anchor: n2, portal: s2 = !1, modal: o3 = !0, transition: P2 = !1, ...c2 } = T2, _2 = xe(n2), t2 = l(\"Menu.Items\"), [R$12, I2] = Re(_2), g2 = be(), [p2, F2] = useState(null), A2 = y$4(E2, _2 ? R$12 : null, o$4((e2) => t2.send({ type: b.SetItemsElement, element: e2 })), F2), [f2, M$12] = S$1(t2, (e2) => [e2.menuState, e2.buttonElement]), L2 = n$1(M$12), S2 = n$1(p2);\n  _2 && (s2 = !0);\n  let O2 = u$2(), [x2, U2] = x$1(P2, p2, O2 !== null ? (O2 & i$2.Open) === i$2.Open : f2 === M.Open);\n  m$2(x2, M$12, () => {\n    t2.send({ type: b.CloseMenu });\n  });\n  let G$12 = S$1(t2, (e2) => e2.__demoMode), l$12 = G$12 ? !1 : o3 && f2 === M.Open;\n  f$2(l$12, S2);\n  let H2 = G$12 ? !1 : o3 && f2 === M.Open;\n  y$3(H2, { allowed: useCallback(() => [M$12, p2], [M$12, p2]) });\n  let u2 = f2 !== M.Open, ae = s$1(u2, M$12) ? !1 : x2;\n  useEffect(() => {\n    let e2 = p2;\n    e2 && f2 === M.Open && e2 !== (S2 == null ? void 0 : S2.activeElement) && e2.focus({ preventScroll: !0 });\n  }, [f2, p2, S2]), F$1(f2 === M.Open, { container: p2, accept(e2) {\n    return e2.getAttribute(\"role\") === \"menuitem\" ? NodeFilter.FILTER_REJECT : e2.hasAttribute(\"role\") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;\n  }, walk(e2) {\n    e2.setAttribute(\"role\", \"none\");\n  } });\n  let q2 = p$2(), se = o$4((e2) => {\n    var N2, z, Q;\n    switch (q2.dispose(), e2.key) {\n      case o$3.Space:\n        if (t2.state.searchQuery !== \"\") return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.Search, value: e2.key });\n      case o$3.Enter:\n        if (e2.preventDefault(), e2.stopPropagation(), t2.state.activeItemIndex !== null) {\n          let { dataRef: de } = t2.state.items[t2.state.activeItemIndex];\n          (z = (N2 = de.current) == null ? void 0 : N2.domRef.current) == null || z.click();\n        }\n        t2.send({ type: b.CloseMenu }), G(t2.state.buttonElement);\n        break;\n      case o$3.ArrowDown:\n        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Next });\n      case o$3.ArrowUp:\n        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Previous });\n      case o$3.Home:\n      case o$3.PageUp:\n        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.First });\n      case o$3.End:\n      case o$3.PageDown:\n        return e2.preventDefault(), e2.stopPropagation(), t2.send({ type: b.GoToItem, focus: c$1.Last });\n      case o$3.Escape:\n        e2.preventDefault(), e2.stopPropagation(), flushSync(() => t2.send({ type: b.CloseMenu })), (Q = t2.state.buttonElement) == null || Q.focus({ preventScroll: !0 });\n        break;\n      case o$3.Tab:\n        e2.preventDefault(), e2.stopPropagation(), flushSync(() => t2.send({ type: b.CloseMenu })), j$2(t2.state.buttonElement, e2.shiftKey ? F$2.Previous : F$2.Next);\n        break;\n      default:\n        e2.key.length === 1 && (t2.send({ type: b.Search, value: e2.key }), q2.setTimeout(() => t2.send({ type: b.ClearSearch }), 350));\n        break;\n    }\n  }), le = o$4((e2) => {\n    switch (e2.key) {\n      case o$3.Space:\n        e2.preventDefault();\n        break;\n    }\n  }), pe2 = useMemo(() => ({ open: f2 === M.Open }), [f2]), ie = _$2(_2 ? g2() : {}, { \"aria-activedescendant\": S$1(t2, t2.selectors.activeDescendantId), \"aria-labelledby\": S$1(t2, (e2) => {\n    var N2;\n    return (N2 = e2.buttonElement) == null ? void 0 : N2.id;\n  }), id: a3, onKeyDown: se, onKeyUp: le, role: \"menu\", tabIndex: f2 === M.Open ? 0 : void 0, ref: A2, style: { ...c2.style, ...I2, \"--button-width\": d$2(M$12, !0).width }, ...R(U2) }), ue = L$2();\n  return React__default.createElement(oe, { enabled: s2 ? T2.static || x2 : !1, ownerDocument: L2 }, ue({ ourProps: ie, theirProps: c2, slot: pe2, defaultTag: et, features: tt, visible: ae, name: \"Menu.Items\" }));\n}\nlet nt = Fragment;\nfunction rt(T$12, E2) {\n  let i2 = useId$1(), { id: a3 = \\`headlessui-menu-item-\\${i2}\\`, disabled: n2 = !1, ...s$12 } = T$12, o3 = l(\"Menu.Item\"), P2 = S$1(o3, (u2) => o3.selectors.isActive(u2, a3)), c2 = useRef(null), _2 = y$4(E2, c2), t2 = S$1(o3, (u2) => o3.selectors.shouldScrollIntoView(u2, a3));\n  n$3(() => {\n    if (t2) return o$5().requestAnimationFrame(() => {\n      var u2, J2;\n      (J2 = (u2 = c2.current) == null ? void 0 : u2.scrollIntoView) == null || J2.call(u2, { block: \"nearest\" });\n    });\n  }, [t2, c2]);\n  let R2 = s(c2), I2 = useRef({ disabled: n2, domRef: c2, get textValue() {\n    return R2();\n  } });\n  n$3(() => {\n    I2.current.disabled = n2;\n  }, [I2, n2]), n$3(() => (o3.actions.registerItem(a3, I2), () => o3.actions.unregisterItem(a3)), [I2, a3]);\n  let g2 = o$4(() => {\n    o3.send({ type: b.CloseMenu });\n  }), p2 = o$4((u2) => {\n    if (n2) return u2.preventDefault();\n    o3.send({ type: b.CloseMenu }), G(o3.state.buttonElement);\n  }), F2 = o$4(() => {\n    if (n2) return o3.send({ type: b.GoToItem, focus: c$1.Nothing });\n    o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3 });\n  }), A2 = u$3(), f2 = o$4((u2) => {\n    A2.update(u2), !n2 && (P2 || o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3, trigger: T.Pointer }));\n  }), M2 = o$4((u2) => {\n    A2.wasMoved(u2) && (n2 || P2 || o3.send({ type: b.GoToItem, focus: c$1.Specific, id: a3, trigger: T.Pointer }));\n  }), L2 = o$4((u2) => {\n    A2.wasMoved(u2) && (n2 || P2 && o3.send({ type: b.GoToItem, focus: c$1.Nothing }));\n  }), [S2, O2] = K(), [x2, U2] = w$1(), G$12 = useMemo(() => ({ active: P2, focus: P2, disabled: n2, close: g2 }), [P2, n2, g2]), l$12 = { id: a3, ref: _2, role: \"menuitem\", tabIndex: n2 === !0 ? void 0 : -1, \"aria-disabled\": n2 === !0 ? !0 : void 0, \"aria-labelledby\": S2, \"aria-describedby\": x2, disabled: void 0, onClick: p2, onFocus: F2, onPointerEnter: f2, onMouseEnter: f2, onPointerMove: M2, onMouseMove: M2, onPointerLeave: L2, onMouseLeave: L2 }, H2 = L$2();\n  return React__default.createElement(O2, null, React__default.createElement(U2, null, H2({ ourProps: l$12, theirProps: s$12, slot: G$12, defaultTag: nt, name: \"Menu.Item\" })));\n}\nlet at = \"div\";\nfunction st(T2, E2) {\n  let [i2, a3] = K(), n2 = T2, s2 = { ref: E2, \"aria-labelledby\": i2, role: \"group\" }, o3 = L$2();\n  return React__default.createElement(a3, null, o3({ ourProps: s2, theirProps: n2, slot: {}, defaultTag: at, name: \"Menu.Section\" }));\n}\nlet lt = \"header\";\nfunction pt(T2, E2) {\n  let i2 = useId$1(), { id: a3 = \\`headlessui-menu-heading-\\${i2}\\`, ...n2 } = T2, s2 = P$1();\n  n$3(() => s2.register(a3), [a3, s2.register]);\n  let o3 = { id: a3, ref: E2, role: \"presentation\", ...s2.props };\n  return L$2()({ ourProps: o3, theirProps: n2, slot: {}, defaultTag: lt, name: \"Menu.Heading\" });\n}\nlet it = \"div\";\nfunction ut(T2, E2) {\n  let i2 = T2, a3 = { ref: E2, role: \"separator\" };\n  return L$2()({ ourProps: a3, theirProps: i2, slot: {}, defaultTag: it, name: \"Menu.Separator\" });\n}\nlet dt = K$1(Qe), mt = K$1(Ze), Tt = K$1(ot), ft = K$1(rt), ct = K$1(st), yt = K$1(pt), Et = K$1(ut), to = Object.assign(dt, { Button: mt, Items: Tt, Item: ft, Section: ct, Heading: yt, Separator: Et }), L = \"textarea\";\nfunction H(s2, l2) {\n  let i2 = useId$1(), d2 = u$6(), n2 = a$9(), { id: p2 = d2 || \\`headlessui-textarea-\\${i2}\\`, disabled: e2 = n2 || !1, autoFocus: r2 = !1, invalid: a3 = !1, ...T2 } = s2, f2 = I$2(), m2 = U$1(), { isFocused: o3, focusProps: u2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: r2 }), { isHovered: t2, hoverProps: b2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: e2 }), y2 = _$2({ ref: l2, id: p2, \"aria-labelledby\": f2, \"aria-describedby\": m2, \"aria-invalid\": a3 ? \"true\" : void 0, disabled: e2 || void 0, autoFocus: r2 }, u2, b2), x2 = useMemo(() => ({ disabled: e2, invalid: a3, hover: t2, focus: o3, autofocus: r2 }), [e2, a3, t2, o3, r2]);\n  return L$2()({ ourProps: y2, theirProps: T2, slot: x2, defaultTag: L, name: \"Textarea\" });\n}\nlet J = K$1(H);\nfunction ToolbarItem(props) {\n  return /* @__PURE__ */ jsxs(\"div\", { className: \"relative flex w-full shrink-0 items-center justify-center\", children: [\n    props.children,\n    props.badgeContent && /* @__PURE__ */ jsx(\n      \"div\",\n      {\n        className: cn(\n          \"bg-blue-600 text-white\",\n          props.badgeClassName,\n          \"pointer-events-none absolute right-0 bottom-0 flex h-3 w-max min-w-3 max-w-8 select-none items-center justify-center truncate rounded-full px-0.5 font-semibold text-[0.5em]\"\n        ),\n        children: props.badgeContent\n      }\n    ),\n    props.statusDot && /* @__PURE__ */ jsx(\n      \"div\",\n      {\n        className: cn(\n          \"bg-rose-600 text-white\",\n          props.statusDotClassName,\n          \"pointer-events-none absolute top-0 right-0 size-1.5 rounded-full\"\n        )\n      }\n    )\n  ] });\n}\nconst ToolbarButton = forwardRef(\n  ({\n    badgeContent,\n    badgeClassName,\n    statusDot,\n    statusDotClassName,\n    tooltipHint,\n    variant = \"default\",\n    active,\n    ...props\n  }, ref) => {\n    const button = /* @__PURE__ */ jsx(\n      H$4,\n      {\n        ref,\n        ...props,\n        className: cn(\n          \"flex cursor-pointer items-center justify-center rounded-full bg-radial from-transparent to-transparent p-1 text-current transition-all duration-150 hover:from-20% hover:from-zinc-100/40 hover:to-75% hover:to-zinc-100/0\",\n          variant === \"default\" ? \"size-8\" : \"h-8 rounded-full\",\n          active && \"from-30% from-zinc-100/60 to-75% to-zinc-100/0 fill-[var(--active)] stroke-[var(--active)] text-[var(--active)]\",\n          props.className\n        )\n      }\n    );\n    return /* @__PURE__ */ jsx(\n      ToolbarItem,\n      {\n        badgeContent,\n        badgeClassName,\n        statusDot,\n        statusDotClassName,\n        children: button\n      }\n    );\n  }\n);\nToolbarButton.displayName = \"ToolbarButton\";\nfunction ToolbarSection({ children }) {\n  return /* @__PURE__ */ jsx(\"div\", { className: \"fade-in slide-in-from-right-2 flex max-h-sm max-w-full animate-in snap-start flex-col items-center justify-between gap-1 py-0.5\", children });\n}\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase(), toCamelCase = (string) => string.replace(\n  /^([A-Z])|[\\\\s-_]+(\\\\w)/g,\n  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()\n), toPascalCase = (string) => {\n  const camelCase = toCamelCase(string);\n  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n}, mergeClasses = (...classes) => classes.filter((className, index2, array) => !!className && className.trim() !== \"\" && array.indexOf(className) === index2).join(\" \").trim(), hasA11yProp = (props) => {\n  for (const prop in props)\n    if (prop.startsWith(\"aria-\") || prop === \"role\" || prop === \"title\")\n      return !0;\n};\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nvar defaultAttributes = {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: 24,\n  height: 24,\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: \"currentColor\",\n  strokeWidth: 2,\n  strokeLinecap: \"round\",\n  strokeLinejoin: \"round\"\n};\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst Icon = forwardRef(\n  ({\n    color = \"currentColor\",\n    size: size2 = 24,\n    strokeWidth = 2,\n    absoluteStrokeWidth,\n    className = \"\",\n    children,\n    iconNode,\n    ...rest\n  }, ref) => createElement(\n    \"svg\",\n    {\n      ref,\n      ...defaultAttributes,\n      width: size2,\n      height: size2,\n      stroke: color,\n      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,\n      className: mergeClasses(\"lucide\", className),\n      ...!children && !hasA11yProp(rest) && { \"aria-hidden\": \"true\" },\n      ...rest\n    },\n    [\n      ...iconNode.map(([tag, attrs]) => createElement(tag, attrs)),\n      ...Array.isArray(children) ? children : [children]\n    ]\n  )\n);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst createLucideIcon = (iconName, iconNode) => {\n  const Component = forwardRef(\n    ({ className, ...props }, ref) => createElement(Icon, {\n      ref,\n      iconNode,\n      className: mergeClasses(\n        \\`lucide-\\${toKebabCase(toPascalCase(iconName))}\\`,\n        \\`lucide-\\${iconName}\\`,\n        className\n      ),\n      ...props\n    })\n  );\n  return Component.displayName = toPascalCase(iconName), Component;\n};\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$e = [\n  [\"path\", { d: \"m5 12 7-7 7 7\", key: \"hav0vg\" }],\n  [\"path\", { d: \"M12 19V5\", key: \"x0mq9r\" }]\n], ArrowUp = createLucideIcon(\"arrow-up\", __iconNode$e);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$d = [[\"path\", { d: \"M20 6 9 17l-5-5\", key: \"1gmf2c\" }]], Check = createLucideIcon(\"check\", __iconNode$d);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$c = [[\"path\", { d: \"m6 9 6 6 6-6\", key: \"qrunsl\" }]], ChevronDown = createLucideIcon(\"chevron-down\", __iconNode$c);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$b = [[\"path\", { d: \"m18 15-6-6-6 6\", key: \"153udz\" }]], ChevronUp = createLucideIcon(\"chevron-up\", __iconNode$b);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$a = [\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"10\", key: \"1mglay\" }],\n  [\"path\", { d: \"m15 9-6 6\", key: \"1uzhvr\" }],\n  [\"path\", { d: \"m9 9 6 6\", key: \"z0biqf\" }]\n], CircleX = createLucideIcon(\"circle-x\", __iconNode$a);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$9 = [\n  [\"path\", { d: \"M12 20a8 8 0 1 0 0-16 8 8 0 0 0 0 16Z\", key: \"sobvz5\" }],\n  [\"path\", { d: \"M12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z\", key: \"11i496\" }],\n  [\"path\", { d: \"M12 2v2\", key: \"tus03m\" }],\n  [\"path\", { d: \"M12 22v-2\", key: \"1osdcq\" }],\n  [\"path\", { d: \"m17 20.66-1-1.73\", key: \"eq3orb\" }],\n  [\"path\", { d: \"M11 10.27 7 3.34\", key: \"16pf9h\" }],\n  [\"path\", { d: \"m20.66 17-1.73-1\", key: \"sg0v6f\" }],\n  [\"path\", { d: \"m3.34 7 1.73 1\", key: \"1ulond\" }],\n  [\"path\", { d: \"M14 12h8\", key: \"4f43i9\" }],\n  [\"path\", { d: \"M2 12h2\", key: \"1t8f8n\" }],\n  [\"path\", { d: \"m20.66 7-1.73 1\", key: \"1ow05n\" }],\n  [\"path\", { d: \"m3.34 17 1.73-1\", key: \"nuk764\" }],\n  [\"path\", { d: \"m17 3.34-1 1.73\", key: \"2wel8s\" }],\n  [\"path\", { d: \"m11 13.73-4 6.93\", key: \"794ttg\" }]\n], Cog = createLucideIcon(\"cog\", __iconNode$9);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$8 = [[\"path\", { d: \"M21 12a9 9 0 1 1-6.219-8.56\", key: \"13zald\" }]], LoaderCircle = createLucideIcon(\"loader-circle\", __iconNode$8);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$7 = [\n  [\"path\", { d: \"M7.9 20A9 9 0 1 0 4 16.1L2 22Z\", key: \"vv11sd\" }],\n  [\"path\", { d: \"M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3\", key: \"1u773s\" }],\n  [\"path\", { d: \"M12 17h.01\", key: \"p32p05\" }]\n], MessageCircleQuestionMark = createLucideIcon(\"message-circle-question-mark\", __iconNode$7);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$6 = [\n  [\"path\", { d: \"M7.9 20A9 9 0 1 0 4 16.1L2 22Z\", key: \"vv11sd\" }]\n], MessageCircle = createLucideIcon(\"message-circle\", __iconNode$6);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$5 = [\n  [\n    \"path\",\n    {\n      d: \"M15.39 4.39a1 1 0 0 0 1.68-.474 2.5 2.5 0 1 1 3.014 3.015 1 1 0 0 0-.474 1.68l1.683 1.682a2.414 2.414 0 0 1 0 3.414L19.61 15.39a1 1 0 0 1-1.68-.474 2.5 2.5 0 1 0-3.014 3.015 1 1 0 0 1 .474 1.68l-1.683 1.682a2.414 2.414 0 0 1-3.414 0L8.61 19.61a1 1 0 0 0-1.68.474 2.5 2.5 0 1 1-3.014-3.015 1 1 0 0 0 .474-1.68l-1.683-1.682a2.414 2.414 0 0 1 0-3.414L4.39 8.61a1 1 0 0 1 1.68.474 2.5 2.5 0 1 0 3.014-3.015 1 1 0 0 1-.474-1.68l1.683-1.682a2.414 2.414 0 0 1 3.414 0z\",\n      key: \"w46dr5\"\n    }\n  ]\n], Puzzle = createLucideIcon(\"puzzle\", __iconNode$5);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$4 = [\n  [\"path\", { d: \"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\", key: \"v9h5vc\" }],\n  [\"path\", { d: \"M21 3v5h-5\", key: \"1q7to0\" }],\n  [\"path\", { d: \"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\", key: \"3uifl3\" }],\n  [\"path\", { d: \"M8 16H3v5\", key: \"1cv678\" }]\n], RefreshCw = createLucideIcon(\"refresh-cw\", __iconNode$4);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$3 = [\n  [\n    \"path\",\n    {\n      d: \"M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z\",\n      key: \"1qme2f\"\n    }\n  ],\n  [\"circle\", { cx: \"12\", cy: \"12\", r: \"3\", key: \"1v7zrd\" }]\n], Settings = createLucideIcon(\"settings\", __iconNode$3);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$2 = [\n  [\n    \"path\",\n    {\n      d: \"m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3\",\n      key: \"wmoenq\"\n    }\n  ],\n  [\"path\", { d: \"M12 9v4\", key: \"juzpu7\" }],\n  [\"path\", { d: \"M12 17h.01\", key: \"p32p05\" }]\n], TriangleAlert = createLucideIcon(\"triangle-alert\", __iconNode$2);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode$1 = [\n  [\"path\", { d: \"M12 20h.01\", key: \"zekei9\" }],\n  [\"path\", { d: \"M8.5 16.429a5 5 0 0 1 7 0\", key: \"1bycff\" }],\n  [\"path\", { d: \"M5 12.859a10 10 0 0 1 5.17-2.69\", key: \"1dl1wf\" }],\n  [\"path\", { d: \"M19 12.859a10 10 0 0 0-2.007-1.523\", key: \"4k23kn\" }],\n  [\"path\", { d: \"M2 8.82a15 15 0 0 1 4.177-2.643\", key: \"1grhjp\" }],\n  [\"path\", { d: \"M22 8.82a15 15 0 0 0-11.288-3.764\", key: \"z3jwby\" }],\n  [\"path\", { d: \"m2 2 20 20\", key: \"1ooewy\" }]\n], WifiOff = createLucideIcon(\"wifi-off\", __iconNode$1);\n/**\n * @license lucide-react v0.523.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */\nconst __iconNode = [\n  [\"path\", { d: \"M18 6 6 18\", key: \"1bl5f8\" }],\n  [\"path\", { d: \"m6 6 12 12\", key: \"d8bk6v\" }]\n], X = createLucideIcon(\"x\", __iconNode);\nfunction RegularContent() {\n  const {\n    isSettingsOpen,\n    openSettings,\n    closeSettings,\n    isChatOpen,\n    openChat,\n    closeChat,\n    openPluginName,\n    closePlugin,\n    openPlugin\n  } = usePanels(), { startPromptCreation } = useChatState(), pluginsWithActions = usePlugins().plugins.filter(\n    (plugin) => plugin.onActionClick\n  );\n  return /* @__PURE__ */ jsxs(Fragment$1, { children: [\n    /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(\n      ToolbarButton,\n      {\n        onClick: isSettingsOpen ? closeSettings : openSettings,\n        active: isSettingsOpen,\n        children: /* @__PURE__ */ jsx(Settings, { className: \"size-4\" })\n      }\n    ) }),\n    pluginsWithActions.length > 0 && /* @__PURE__ */ jsx(ToolbarSection, { children: pluginsWithActions.map((plugin) => /* @__PURE__ */ jsx(\n      ToolbarButton,\n      {\n        onClick: openPluginName === plugin.pluginName ? closePlugin : () => openPlugin(plugin.pluginName),\n        active: openPluginName === plugin.pluginName,\n        children: plugin.iconSvg ? /* @__PURE__ */ jsx(\"span\", { className: \"size-4 *:size-full\", children: plugin.iconSvg }) : /* @__PURE__ */ jsx(Puzzle, { className: \"size-4\" })\n      },\n      plugin.pluginName\n    )) }),\n    /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(\n      ToolbarButton,\n      {\n        onClick: isChatOpen ? closeChat : () => {\n          openChat(), startPromptCreation();\n        },\n        active: isChatOpen,\n        children: /* @__PURE__ */ jsx(MessageCircle, { className: \"size-4\" })\n      }\n    ) })\n  ] });\n}\nfunction DisconnectedContent() {\n  const { refreshAgentList, isRefreshing } = useAgents();\n  return /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(\n    ToolbarButton,\n    {\n      onClick: isRefreshing ? void 0 : () => refreshAgentList(),\n      children: /* @__PURE__ */ jsx(\n        RefreshCw,\n        {\n          className: cn(\"size-4\", isRefreshing && \"animate-spin\")\n        }\n      )\n    }\n  ) });\n}\nconst Logo = ({\n  color = \"default\",\n  loading = !1,\n  loadingSpeed = \"slow\",\n  ...props\n}) => {\n  const colorStyle = {\n    default: \"fill-stagewise-700 stroke-none\",\n    black: \"fill-zinc-950 stroke-none\",\n    white: \"fill-white stroke-none\",\n    zinc: \"fill-zinc-500/50 stroke-none\",\n    current: \"fill-current stroke-none\",\n    gradient: \"fill-white stroke-black/30 stroke-1\"\n  };\n  return /* @__PURE__ */ jsxs(\n    \"div\",\n    {\n      className: \\`relative \\${color === \"gradient\" ? \"rounded-full bg-[image:var(--gradient)] bg-cover bg-no-repeat\" : \"\"} \\${props.className || \"\"} \\${loading ? \"drop-shadow-xl\" : \"\"} aspect-square overflow-visible\\`,\n      children: [\n        /* @__PURE__ */ jsxs(\n          \"svg\",\n          {\n            className: \\`absolute overflow-visible \\${color === \"gradient\" ? \"top-[25%] left-[25%] h-[50%] w-[50%]\" : \"top-0 left-0 h-full w-full\"}\\`,\n            viewBox: \"0 0 2048 2048\",\n            children: [\n              /* @__PURE__ */ jsx(\"title\", { children: \"stagewise\" }),\n              /* @__PURE__ */ jsx(\n                \"ellipse\",\n                {\n                  className: colorStyle[color] + (loading ? \" animate-pulse\" : \"\"),\n                  id: \"path3\",\n                  ry: \"624\",\n                  rx: \"624\",\n                  cy: \"1024\",\n                  cx: \"1024\"\n                }\n              )\n            ]\n          }\n        ),\n        /* @__PURE__ */ jsx(\n          \"svg\",\n          {\n            className: \\`absolute overflow-visible \\${color === \"gradient\" ? \"top-[25%] left-[25%] h-[50%] w-[50%]\" : \"top-0 left-0 h-full w-full\"}\\`,\n            viewBox: \"0 0 2048 2048\",\n            children: /* @__PURE__ */ jsx(\n              \"path\",\n              {\n                id: \"path4\",\n                className: \"origin-center \" + colorStyle[color] + (loading ? loadingSpeed === \"fast\" ? \" animate-spin-fast\" : \" animate-spin-slow\" : \"\"),\n                d: \"M 1024 0 A 1024 1024 0 0 0 0 1024 A 1024 1024 0 0 0 1024 2048 L 1736 2048 L 1848 2048 C 1958.7998 2048 2048 1958.7998 2048 1848 L 2048 1736 L 2048 1024 A 1024 1024 0 0 0 1024 0 z M 1024.9414 200 A 824 824 0 0 1 1848.9414 1024 A 824 824 0 0 1 1024.9414 1848 A 824 824 0 0 1 200.94141 1024 A 824 824 0 0 1 1024.9414 200 z \"\n              }\n            )\n          }\n        )\n      ]\n    }\n  );\n}, AnimatedGradientBackground = ({\n  className\n}) => /* @__PURE__ */ jsxs(\n  \"svg\",\n  {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 800 800\",\n    preserveAspectRatio: \"xMidYMid slice\",\n    className,\n    children: [\n      /* @__PURE__ */ jsx(\"defs\", { children: /* @__PURE__ */ jsx(\"filter\", { id: \"blur\", x: \"-50%\", y: \"-50%\", width: \"200%\", height: \"200%\", children: /* @__PURE__ */ jsx(\"feGaussianBlur\", { in: \"SourceGraphic\", stdDeviation: \"80\" }) }) }),\n      /* @__PURE__ */ jsx(\"rect\", { width: \"800\", height: \"800\", fill: \"#000f68\" }),\n      /* @__PURE__ */ jsxs(\"g\", { filter: \"url(#blur)\", children: [\n        /* @__PURE__ */ jsxs(\"circle\", { cx: \"100\", cy: \"400\", r: \"260\", fill: \"#1e90ff\", children: [\n          /* @__PURE__ */ jsx(\n            \"animate\",\n            {\n              attributeName: \"cx\",\n              dur: \"15s\",\n              begin: \"0s\",\n              values: \"100; 700; 100\",\n              repeatCount: \"indefinite\",\n              calcMode: \"spline\",\n              keyTimes: \"0; 0.5; 1\",\n              keySplines: \"0.42 0 0.58 1; 0.42 0 0.58 1\"\n            }\n          ),\n          /* @__PURE__ */ jsx(\n            \"animate\",\n            {\n              attributeName: \"cy\",\n              dur: \"20s\",\n              begin: \"0.1s\",\n              values: \"400; 100; 400\",\n              repeatCount: \"indefinite\",\n              calcMode: \"spline\",\n              keyTimes: \"0; 0.5; 1\",\n              keySplines: \"0.42 0 0.58 1; 0.42 0 0.58 1\"\n            }\n          )\n        ] }),\n        /* @__PURE__ */ jsxs(\"circle\", { cx: \"700\", cy: \"100\", r: \"220\", fill: \"#c300ff\", children: [\n          /* @__PURE__ */ jsx(\n            \"animate\",\n            {\n              attributeName: \"cx\",\n              dur: \"12s\",\n              begin: \"0.2s\",\n              values: \"700; 100; 700\",\n              repeatCount: \"indefinite\",\n              calcMode: \"spline\",\n              keyTimes: \"0; 0.5; 1\",\n              keySplines: \"0.42 0 0.58 1; 0.42 0 0.58 1\"\n            }\n          ),\n          /* @__PURE__ */ jsx(\n            \"animate\",\n            {\n              attributeName: \"cy\",\n              dur: \"10s\",\n              begin: \"0.3s\",\n              values: \"100; 700; 100\",\n              repeatCount: \"indefinite\",\n              calcMode: \"spline\",\n              keyTimes: \"0; 0.5; 1\",\n              keySplines: \"0.42 0 0.58 1; 0.42 0 0.58 1\"\n            }\n          )\n        ] }),\n        /* @__PURE__ */ jsxs(\"circle\", { cx: \"400\", cy: \"700\", r: \"240\", fill: \"#0055ff\", children: [\n          /* @__PURE__ */ jsx(\n            \"animate\",\n            {\n              attributeName: \"cx\",\n              dur: \"18s\",\n              begin: \"0.4s\",\n              values: \"400; 500; 200; 400\",\n              repeatCount: \"indefinite\",\n              calcMode: \"spline\",\n              keyTimes: \"0; 0.33; 0.67; 1\",\n              keySplines: \"0.42 0 0.58 1; 0.42 0 0.58 1; 0.42 0 0.58 1\"\n            }\n          ),\n          /* @__PURE__ */ jsx(\n            \"animate\",\n            {\n              attributeName: \"cy\",\n              dur: \"22s\",\n              begin: \"0.5s\",\n              values: \"700; 400; 700\",\n              repeatCount: \"indefinite\",\n              calcMode: \"spline\",\n              keyTimes: \"0; 0.5; 1\",\n              keySplines: \"0.42 0 0.58 1; 0.42 0 0.58 1\"\n            }\n          )\n        ] })\n      ] })\n    ]\n  }\n);\nfunction Toolbar({\n  draggableHandleRef,\n  position,\n  isDragged\n}) {\n  const { minimized, minimize, expand } = useAppState(), { requiresUserAttention, isInitialLoad } = useAgents(), { isAvailable } = useAgentAvailability();\n  return /* @__PURE__ */ jsxs(\n    Glassy,\n    {\n      as: \"div\",\n      className: cn(\n        \"pointer-events-auto absolute z-10 origin-center rounded-full p-0.5 shadow-md transition-transform duration-500 ease-spring\",\n        minimized || isInitialLoad ? \"size-10 bg-blue-950/80\" : \"size-auto\",\n        isDragged && \"scale-110 bg-sky-100/60 shadow-lg shadow-sky-500/10 blur-[0.2px]\",\n        !requiresUserAttention && isAvailable ? \"[--active-secondary:var(--color-blue-100)] [--active:var(--color-blue-600)] [--primary:var(--color-zinc-950)] [--secondary:var(--color-zinc-400)]\" : \"bg-orange-200/50 [--active-secondary:var(--color-orange-100)] [--active:var(--color-orange-600)] [--primary:var(--color-orange-900)] [--secondary:var(--color-orange-100)]\",\n        \"stroke-[var(--primary)] text-[var(--primary)]\"\n      ),\n      ref: draggableHandleRef,\n      children: [\n        /* @__PURE__ */ jsxs(\n          H$4,\n          {\n            onClick: () => expand(),\n            className: cn(\n              \"absolute left-0 z-50 flex size-10 origin-center cursor-pointer items-center justify-center overflow-hidden rounded-full border border-zinc-500/20 transition-all duration-500 ease-spring hover:opacity-90\",\n              minimized || isInitialLoad ? \"pointer-events-auto scale-100 opacity-100 blur-none\" : \"pointer-events-none scale-25 opacity-0 blur-md\",\n              position.isTopHalf ? \"top-0\" : \"bottom-0\",\n              (requiresUserAttention || !isAvailable) && \"bg-orange-500\"\n            ),\n            children: [\n              !requiresUserAttention && isAvailable && /* @__PURE__ */ jsxs(Fragment$1, { children: [\n                /* @__PURE__ */ jsx(AnimatedGradientBackground, { className: \"-z-10 absolute inset-0 size-full\" }),\n                /* @__PURE__ */ jsx(Logo, { color: \"white\", className: \"mr-px mb-px size-1/2 shadow-2xs\" })\n              ] }),\n              requiresUserAttention && /* @__PURE__ */ jsx(WifiOff, { className: \"size-5 stroke-white\" }),\n              !requiresUserAttention && !isAvailable && /* @__PURE__ */ jsx(TriangleAlert, { className: \"size-5 stroke-white\" })\n            ]\n          }\n        ),\n        /* @__PURE__ */ jsxs(\n          \"div\",\n          {\n            className: cn(\n              \"flex h-[calc-size(auto,size)] scale-100 items-center justify-center divide-y divide-border/20 transition-all duration-500 ease-spring\",\n              position.isTopHalf ? \"origin-top flex-col-reverse divide-y-reverse\" : \"origin-bottom flex-col\",\n              minimized && \"pointer-events-none h-0 scale-50 opacity-0 blur-md\"\n            ),\n            children: [\n              !requiresUserAttention && isAvailable ? /* @__PURE__ */ jsx(RegularContent, {}) : /* @__PURE__ */ jsx(DisconnectedContent, {}),\n              /* @__PURE__ */ jsx(ToolbarSection, { children: /* @__PURE__ */ jsx(\n                ToolbarButton,\n                {\n                  onClick: minimize,\n                  className: cn(\n                    \"h-5\",\n                    position.isTopHalf ? \"rounded-t-3xl rounded-b-lg\" : \"rounded-t-lg rounded-b-3xl\"\n                  ),\n                  children: position.isTopHalf ? /* @__PURE__ */ jsx(ChevronUp, { className: \"size-4\" }) : /* @__PURE__ */ jsx(ChevronDown, { className: \"size-4\" })\n                }\n              ) })\n            ]\n          }\n        )\n      ]\n    }\n  );\n}\nfunction AgentSelection({\n  showConnectedDetails = !1\n}) {\n  const {\n    connected,\n    refreshAgentList,\n    isRefreshing,\n    availableAgents,\n    connectAgent\n  } = useAgents(), handleAgentChange = (e2) => {\n    const port = Number.parseInt(e2.target.value);\n    port && connectAgent(port);\n  }, placeholderText = availableAgents.length > 0 ? \"Select an agent...\" : \"No agents available\";\n  return isRefreshing ? availableAgents.length > 0 ? \"Scanning for additional agents...\" : \"Scanning for available agents...\" : availableAgents.length === 0 ? \"No agents found. Make sure the stagewise extension is installed and running.\" : null, /* @__PURE__ */ jsxs(\"div\", { className: \"space-y-3\", children: [\n    /* @__PURE__ */ jsxs(\"div\", { children: [\n      /* @__PURE__ */ jsxs(\n        \"label\",\n        {\n          htmlFor: \"agent-select\",\n          className: \"mb-2 block font-medium text-foreground text-sm\",\n          children: [\n            \"Agent\",\n            isRefreshing && /* @__PURE__ */ jsx(RefreshCw, { className: \"ml-2 inline size-3 animate-spin text-muted-foreground\" })\n          ]\n        }\n      ),\n      /* @__PURE__ */ jsx(\"div\", { className: \"flex w-full items-center space-x-2\", children: /* @__PURE__ */ jsxs(\n        \"select\",\n        {\n          id: \"agent-select\",\n          value: (connected == null ? void 0 : connected.port) || \"\",\n          onChange: handleAgentChange,\n          className: \"h-8 min-w-0 flex-1 rounded-lg border border-zinc-950/10 bg-zinc-500/10 px-3 text-sm ring-1 ring-white/20 focus:border-zinc-500 focus:outline-none\",\n          children: [\n            /* @__PURE__ */ jsx(\"option\", { value: \"\", disabled: !0, children: placeholderText }),\n            availableAgents.map((agent) => /* @__PURE__ */ jsxs(\"option\", { value: agent.port, children: [\n              agent.name,\n              \" - \",\n              agent.description,\n              \" - Port \",\n              agent.port\n            ] }, agent.port))\n          ]\n        }\n      ) })\n    ] }),\n    connected && showConnectedDetails && /* @__PURE__ */ jsxs(\"div\", { className: \"rounded-lg bg-zinc-950/5 p-3\", children: [\n      /* @__PURE__ */ jsx(\"p\", { className: \"font-medium text-foreground text-sm\", children: \"Active Agent\" }),\n      /* @__PURE__ */ jsx(\"p\", { className: \"mt-2 font-semibold text-base text-foreground\", children: connected.name }),\n      /* @__PURE__ */ jsx(\"p\", { className: \"text-muted-foreground text-xs\", children: connected.description }),\n      /* @__PURE__ */ jsxs(\"p\", { className: \"text-muted-foreground text-xs\", children: [\n        \"Port \",\n        connected.port\n      ] })\n    ] })\n  ] });\n}\nconst DropdownMenu = to, DropdownMenuButton = forwardRef(\n  (props, ref) => /* @__PURE__ */ jsx(mt, { as: Fragment, ref, ...props })\n), DropdownMenuContent = forwardRef(\n  (props, ref) => /* @__PURE__ */ jsx(\n    Tt,\n    {\n      ref,\n      anchor: \"bottom\",\n      transition: !0,\n      portal: !0,\n      ...props,\n      className: cn(\n        glassyBoxClassName,\n        \"z-50 flex w-fit min-w-24 max-w-90 flex-col items-stretch justify-start gap-1 rounded-xl p-1 shadow-black/50 shadow-lg outline-none data-focus:outline-none\",\n        props.className\n      )\n    }\n  )\n), DropdownMenuItemStyles = \"w-full flex flex-row select-none items-center justify-start gap-2 py-1.5 pl-2 pr-6 truncate overflow-hidden rounded-lg hover:bg-zinc-950/10 focus:text-zinc-900 cursor-pointer transition-color duration-150 text-sm font-normal text-foreground\";\nforwardRef(\n  (props, ref) => {\n    const { className, ...buttonProps } = props;\n    return /* @__PURE__ */ jsx(ft, { ref, children: /* @__PURE__ */ jsx(\n      H$4,\n      {\n        as: \"button\",\n        ...buttonProps,\n        className: cn(DropdownMenuItemStyles, className)\n      }\n    ) });\n  }\n);\nconst DropdownMenuLinkItem = forwardRef(\n  (props, ref) => /* @__PURE__ */ jsx(ft, { ref, children: /* @__PURE__ */ jsx(\"a\", { ...props, className: cn(DropdownMenuItemStyles, props.className) }) })\n);\nfunction SettingsPanel() {\n  return /* @__PURE__ */ jsxs(Panel, { children: [\n    /* @__PURE__ */ jsx(PanelHeader, { title: \"Settings\" }),\n    /* @__PURE__ */ jsx(PanelContent, { children: /* @__PURE__ */ jsx(AgentSelection, { showConnectedDetails: !0 }) }),\n    /* @__PURE__ */ jsx(PanelFooter, { children: /* @__PURE__ */ jsxs(DropdownMenu, { children: [\n      /* @__PURE__ */ jsx(DropdownMenuButton, { children: /* @__PURE__ */ jsxs(Button, { glassy: !0, size: \"sm\", variant: \"secondary\", children: [\n        /* @__PURE__ */ jsx(MessageCircleQuestionMark, { className: \"mr-2 size-4\" }),\n        \"Need help?\"\n      ] }) }),\n      /* @__PURE__ */ jsxs(DropdownMenuContent, { children: [\n        /* @__PURE__ */ jsx(\n          DropdownMenuLinkItem,\n          {\n            href: \"https://stagewise.io/docs\",\n            target: \"_blank\",\n            children: \"Read the docs\"\n          }\n        ),\n        /* @__PURE__ */ jsx(\n          DropdownMenuLinkItem,\n          {\n            href: \"https://discord.gg/y8gdNb4D\",\n            target: \"_blank\",\n            children: \"Join the community\"\n          }\n        )\n      ] })\n    ] }) })\n  ] });\n}\nfunction ContextElementsChips() {\n  const { domContextElements, removeChatDomContext } = useChatState(), { setHoveredElement } = useContextChipHover();\n  return domContextElements.length === 0 ? null : /* @__PURE__ */ jsx(\"div\", { className: \"mb-1.5\", children: /* @__PURE__ */ jsx(\"div\", { className: \"scrollbar-thin flex gap-2 overflow-x-auto pb-1\", children: domContextElements.map((contextElement, index2) => /* @__PURE__ */ jsx(\n    ContextElementChip,\n    {\n      element: contextElement.element,\n      pluginContext: contextElement.pluginContext,\n      onDelete: () => removeChatDomContext(contextElement.element),\n      onHover: setHoveredElement,\n      onUnhover: () => setHoveredElement(null)\n    },\n    \\`\\${contextElement.element.tagName}-\\${index2}\\`\n  )) }) });\n}\nfunction ContextElementChip({\n  element,\n  pluginContext,\n  onDelete,\n  onHover,\n  onUnhover\n}) {\n  const chipLabel = useMemo(() => {\n    var _a, _b;\n    const firstAnnotation = (_b = (_a = pluginContext.find(\n      (plugin) => {\n        var _a2;\n        return (_a2 = plugin.context) == null ? void 0 : _a2.annotation;\n      }\n    )) == null ? void 0 : _a.context) == null ? void 0 : _b.annotation;\n    if (firstAnnotation)\n      return firstAnnotation;\n    const tagName = element.tagName.toLowerCase(), id = element.id ? \\`#\\${element.id}\\` : \"\";\n    return \\`\\${tagName}\\${id}\\`;\n  }, [element, pluginContext]);\n  return /* @__PURE__ */ jsxs(\n    \"div\",\n    {\n      className: cn(\n        \"flex min-w-fit shrink-0 items-center gap-1 rounded-lg border border-border/20 bg-white/10 px-2 py-1 text-xs transition-all hover:border-border/40 hover:bg-white/20\"\n      ),\n      onMouseEnter: () => onHover(element),\n      onMouseLeave: () => onUnhover(),\n      children: [\n        /* @__PURE__ */ jsx(\"span\", { className: \"max-w-24 truncate font-medium text-foreground/80\", children: chipLabel }),\n        /* @__PURE__ */ jsx(\n          \"button\",\n          {\n            type: \"button\",\n            onClick: (e2) => {\n              e2.stopPropagation(), onDelete();\n            },\n            className: \"text-muted-foreground transition-colors hover:text-red-500\",\n            children: /* @__PURE__ */ jsx(X, { className: \"size-3\" })\n          }\n        )\n      ]\n    }\n  );\n}\nfunction AgentMessageDisplay() {\n  var _a, _b, _c, _d, _e;\n  const messaging = useAgentMessaging(), agentState = useAgentState(), scrollContainerRef = useRef(null), wasAtBottomRef = useRef(!0), scrollToBottom = () => {\n    const container = scrollContainerRef.current;\n    container && setTimeout(() => {\n      container.scrollTop = container.scrollHeight;\n    }, 0);\n  }, checkIfAtBottom = () => {\n    const container = scrollContainerRef.current;\n    return container ? container.scrollTop + container.clientHeight >= container.scrollHeight - 10 : !0;\n  }, handleScroll = () => {\n    const isAtBottom = checkIfAtBottom();\n    wasAtBottomRef.current = isAtBottom;\n  };\n  return useEffect(() => {\n    scrollContainerRef.current && wasAtBottomRef.current && scrollToBottom();\n  }, [(_a = messaging.agentMessage) == null ? void 0 : _a.contentItems, agentState.state]), useEffect(() => {\n    const container = scrollContainerRef.current;\n    if (container)\n      return container.addEventListener(\"scroll\", handleScroll), scrollToBottom(), wasAtBottomRef.current = !0, () => {\n        container.removeEventListener(\"scroll\", handleScroll);\n      };\n  }, []), ((_c = (_b = messaging.agentMessage) == null ? void 0 : _b.contentItems) == null ? void 0 : _c.length) > 0 || agentState.state === AgentStateType.IDLE ? /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      ref: scrollContainerRef,\n      className: \"scrollbar-thin pointer-events-auto space-y-2 overflow-y-scroll overscroll-contain px-3 py-4 text-foreground text-sm focus-within:outline-none hover:bg-white/0 focus:outline-none\",\n      onScroll: handleScroll,\n      onMouseEnter: () => {\n        var _a2;\n        (_a2 = scrollContainerRef.current) == null || _a2.focus();\n      },\n      children: (_e = (_d = messaging.agentMessage) == null ? void 0 : _d.contentItems) == null ? void 0 : _e.map((item, index2) => item.type === \"text\" ? /* @__PURE__ */ jsx(\"p\", { className: \"whitespace-pre-wrap\", children: item.text }, \\`item_\\${index2 + 1}\\`) : item.type === \"image\" ? /* @__PURE__ */ jsx(\"div\", { className: \"text-sm\", children: /* @__PURE__ */ jsx(\n        \"img\",\n        {\n          src: item.data,\n          alt: \"Agent message attachment\",\n          className: \"max-w-full rounded-lg border border-black/15 ring-1 ring-white/20\"\n        }\n      ) }, \\`item_\\${index2 + 1}\\`) : null)\n    }\n  ) : null;\n}\nconst DEFAULT_VARIANTS = {\n  blue: {\n    activeSpeed: \"slow\",\n    backgroundColor: \"#0d253f\",\n    colors: [\"#1e40af\", \"#2563eb\", \"#3b82f6\", \"#60a5fa\"]\n  },\n  green: {\n    activeSpeed: \"fast\",\n    backgroundColor: \"#062a22\",\n    colors: [\"#059669\", \"#10b981\", \"#34d399\", \"#6ee7b7\"]\n  },\n  transparent: {\n    activeSpeed: \"slow\",\n    backgroundColor: \"transparent\",\n    colors: [\"transparent\", \"transparent\", \"transparent\", \"transparent\"]\n  }\n}, SHAPE_DEFAULTS = [\n  // This is now just a template for generating shapes for each speed group\n  { type: \"circle\", cx: \"15%\", cy: \"20%\", r: \"30%\", color: 1 },\n  {\n    type: \"rect\",\n    x: \"50%\",\n    y: \"0%\",\n    width: \"40%\",\n    height: \"40%\",\n    color: 2\n  },\n  { type: \"circle\", cx: \"75%\", cy: \"60%\", r: \"25%\", color: 3 },\n  {\n    type: \"rect\",\n    x: \"10%\",\n    y: \"55%\",\n    width: \"35%\",\n    height: \"35%\",\n    color: 4\n  },\n  { type: \"circle\", cx: \"40%\", cy: \"80%\", r: \"20%\", color: 1 }\n], random = (min2, max2) => Math.random() * (max2 - min2) + min2, ShapeGroup = ({\n  shapes,\n  speed,\n  speedClass\n}) => {\n  const animationMultipliers = useMemo(() => shapes.map((_2, i2) => ({\n    duration: random(0.8, 1.2),\n    delay: random(0, -1),\n    direction: i2 % 2 === 0 ? \"alternate\" : \"alternate-reverse\"\n  })), [shapes]), shapesWithColorVar = shapes.map((shape, i2) => ({\n    ...shape,\n    colorVar: \\`--chat-grad-bg-c\\${shape.color}\\`,\n    id: \\`\\${shape.type}-\\${shape.color}-\\${i2}\\`,\n    // Better key for React\n    animationMultipliers: animationMultipliers[i2]\n  }));\n  return /* @__PURE__ */ jsx(\"g\", { className: speedClass, children: shapesWithColorVar.map((shape) => {\n    const multipliers = shape.animationMultipliers, animationProps = {\n      animationDuration: \\`calc(\\${speed}s * \\${multipliers.duration})\\`,\n      animationDelay: \\`calc(\\${speed}s * \\${multipliers.delay})\\`,\n      animationDirection: multipliers.direction\n    };\n    return shape.type === \"circle\" ? /* @__PURE__ */ jsx(\n      \"circle\",\n      {\n        cx: shape.cx,\n        cy: shape.cy,\n        r: shape.r,\n        fill: \\`var(\\${shape.colorVar})\\`,\n        className: \"shape-anim\",\n        style: animationProps\n      },\n      shape.id\n    ) : /* @__PURE__ */ jsx(\n      \"rect\",\n      {\n        x: shape.x,\n        y: shape.y,\n        width: shape.width,\n        height: shape.height,\n        fill: \\`var(\\${shape.colorVar})\\`,\n        className: \"shape-anim\",\n        style: animationProps\n      },\n      shape.id\n    );\n  }) });\n}, GradientBackgroundChat = ({\n  currentVariant,\n  variants = DEFAULT_VARIANTS,\n  className,\n  blurAmount = 80,\n  shapes = SHAPE_DEFAULTS,\n  transparent = !1\n}) => {\n  const [style, setStyle] = useState({});\n  return useEffect(() => {\n    const activeVariant = variants[currentVariant];\n    if (!activeVariant) {\n      console.warn(\n        \\`Variant \"\\${currentVariant}\" not found, falling back to default\\`\n      );\n      return;\n    }\n    const shouldBeTransparent = transparent || currentVariant === \"transparent\";\n    setStyle({\n      \"--chat-grad-bg-bg-color\": activeVariant.backgroundColor,\n      backgroundColor: \"var(--chat-grad-bg-bg-color)\",\n      \"--chat-grad-bg-c1\": activeVariant.colors[0],\n      \"--chat-grad-bg-c2\": activeVariant.colors[1],\n      \"--chat-grad-bg-c3\": activeVariant.colors[2],\n      \"--chat-grad-bg-c4\": activeVariant.colors[3],\n      \"--chat-grad-bg-opacity-slow\": activeVariant.activeSpeed === \"slow\" ? 1 : 0,\n      \"--chat-grad-bg-opacity-medium\": activeVariant.activeSpeed === \"medium\" ? 1 : 0,\n      \"--chat-grad-bg-opacity-fast\": activeVariant.activeSpeed === \"fast\" ? 1 : 0,\n      \"--chat-grad-bg-overall-opacity\": shouldBeTransparent ? 0 : 1,\n      opacity: \"var(--chat-grad-bg-overall-opacity)\"\n    });\n  }, [currentVariant, variants, transparent]), /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      className: \\`absolute inset-0 overflow-hidden transition-all duration-1000 \\${className}\\`,\n      style,\n      children: /* @__PURE__ */ jsxs(\n        \"svg\",\n        {\n          className: \"-inset-[25%] absolute h-[150%] w-[150%]\",\n          xmlns: \"http://www.w3.org/2000/svg\",\n          \"aria-hidden\": \"true\",\n          role: \"presentation\",\n          children: [\n            /* @__PURE__ */ jsx(\"defs\", { children: /* @__PURE__ */ jsx(\"filter\", { id: \"blur-filter\", children: /* @__PURE__ */ jsx(\"feGaussianBlur\", { stdDeviation: blurAmount }) }) }),\n            /* @__PURE__ */ jsxs(\"g\", { filter: \"url(#blur-filter)\", children: [\n              /* @__PURE__ */ jsx(ShapeGroup, { shapes, speed: 40, speedClass: \"g-slow\" }),\n              /* @__PURE__ */ jsx(ShapeGroup, { shapes, speed: 20, speedClass: \"g-medium\" }),\n              /* @__PURE__ */ jsx(ShapeGroup, { shapes, speed: 5, speedClass: \"g-fast\" })\n            ] })\n          ]\n        }\n      )\n    }\n  );\n}, textSlideshowVariants = cva(\n  \"relative block h-[1.2em] h-full overflow-hidden\"\n);\nfunction TextSlideshow({\n  className,\n  texts,\n  changeEveryMs = 3e3,\n  ...props\n}) {\n  const [currentIndex, setCurrentIndex] = React.useState(0), [isAnimating, setIsAnimating] = React.useState(!1);\n  return React.useEffect(() => {\n    if (texts.length <= 1) return;\n    const interval = setInterval(() => {\n      setIsAnimating(!0), setTimeout(() => {\n        setCurrentIndex((prevIndex) => (prevIndex + 1) % texts.length), setIsAnimating(!1);\n      }, 300);\n    }, changeEveryMs);\n    return () => clearInterval(interval);\n  }, [texts.length, changeEveryMs]), texts.length === 0 ? null : /* @__PURE__ */ jsxs(\n    \"span\",\n    {\n      \"data-slot\": \"text-slideshow\",\n      className: cn(textSlideshowVariants(), className),\n      ...props,\n      children: [\n        /* @__PURE__ */ jsx(\n          \"span\",\n          {\n            className: cn(\n              \"absolute inset-0 transition-all duration-300 ease-in-out\",\n              isAnimating ? \"-translate-y-2 transform opacity-0 blur-sm\" : \"translate-y-0 transform opacity-100\"\n            ),\n            children: texts[currentIndex]\n          },\n          \\`current-\\${currentIndex}\\`\n        ),\n        /* @__PURE__ */ jsx(\n          \"span\",\n          {\n            className: cn(\n              \"absolute inset-0 transition-all duration-300 ease-in-out\",\n              isAnimating ? \"translate-y-0 opacity-100\" : \"translate-y-2 opacity-0 blur-sm\"\n            ),\n            children: texts[(currentIndex + 1) % texts.length]\n          },\n          \\`next-\\${(currentIndex + 1) % texts.length}\\`\n        )\n      ]\n    }\n  );\n}\nconst agentStateToText = {\n  [AgentStateType.WAITING_FOR_USER_RESPONSE]: \"Waiting for user response\",\n  [AgentStateType.IDLE]: \"\",\n  [AgentStateType.THINKING]: \"Thinking\",\n  [AgentStateType.FAILED]: \"Failed\",\n  [AgentStateType.COMPLETED]: \"Completed\",\n  [AgentStateType.WORKING]: \"Working\",\n  [AgentStateType.CALLING_TOOL]: \"Calling tool\"\n}, agentStateToIcon = {\n  [AgentStateType.WAITING_FOR_USER_RESPONSE]: /* @__PURE__ */ jsx(MessageCircleQuestionMark, { className: \"size-6\" }),\n  [AgentStateType.IDLE]: /* @__PURE__ */ jsx(Fragment$1, {}),\n  [AgentStateType.THINKING]: /* @__PURE__ */ jsx(LoaderCircle, { className: \"size-6 animate-spin stroke-violet-600\" }),\n  [AgentStateType.FAILED]: /* @__PURE__ */ jsx(CircleX, { className: \"size-6 stroke-rose-600\" }),\n  [AgentStateType.COMPLETED]: /* @__PURE__ */ jsx(Check, { className: \"size-6 stroke-green-600\" }),\n  [AgentStateType.WORKING]: /* @__PURE__ */ jsx(LoaderCircle, { className: \"size-6 animate-spin stroke-blue-600\" }),\n  [AgentStateType.CALLING_TOOL]: /* @__PURE__ */ jsx(Cog, { className: \"size-6 animate-spin stroke-fuchsia-700\" })\n};\nfunction ChatPanel() {\n  var _a;\n  const agentState = useAgentState(), chatState = useChatState(), chatMessaging = useAgentMessaging(), [isComposing, setIsComposing] = useState(!1), enableInputField = useMemo(() => agentState.state === AgentStateType.WAITING_FOR_USER_RESPONSE || agentState.state === AgentStateType.IDLE, [agentState.state]), canSendMessage = useMemo(() => enableInputField && chatState.chatInput.trim().length > 2 && chatState.isPromptCreationActive, [enableInputField, chatState]), anyMessageInChat = useMemo(() => {\n    var _a2, _b;\n    return ((_b = (_a2 = chatMessaging.agentMessage) == null ? void 0 : _a2.contentItems) == null ? void 0 : _b.length) > 0;\n  }, [(_a = chatMessaging.agentMessage) == null ? void 0 : _a.contentItems]), handleSubmit = useCallback(() => {\n    chatState.sendMessage(), chatState.stopPromptCreation();\n  }, [chatState]), handleKeyDown = useCallback(\n    (e2) => {\n      e2.key === \"Enter\" && !e2.shiftKey && !isComposing && (e2.preventDefault(), handleSubmit());\n    },\n    [handleSubmit, isComposing]\n  ), handleCompositionStart = useCallback(() => {\n    setIsComposing(!0);\n  }, []), handleCompositionEnd = useCallback(() => {\n    setIsComposing(!1);\n  }, []), inputRef = useRef(null), isIntentionallyStoppingRef = useRef(!1);\n  return useEffect(() => {\n    var _a2, _b, _c;\n    const blurHandler = () => {\n      var _a3;\n      if (isIntentionallyStoppingRef.current) {\n        isIntentionallyStoppingRef.current = !1;\n        return;\n      }\n      (_a3 = inputRef.current) == null || _a3.focus();\n    };\n    return chatState.isPromptCreationActive && enableInputField ? ((_a2 = inputRef.current) == null || _a2.focus(), (_b = inputRef.current) == null || _b.addEventListener(\"blur\", blurHandler), isIntentionallyStoppingRef.current = !1) : (inputRef.current === document.activeElement && (isIntentionallyStoppingRef.current = !0), (_c = inputRef.current) == null || _c.blur()), () => {\n      var _a3;\n      (_a3 = inputRef.current) == null || _a3.removeEventListener(\"blur\", blurHandler);\n    };\n  }, [chatState.isPromptCreationActive, enableInputField]), /* @__PURE__ */ jsxs(\n    Panel,\n    {\n      className: cn(\n        anyMessageInChat ? \"h-[35vh] max-h-[50vh] min-h-[20vh]\" : \"!h-[calc-size(auto,size)] h-auto min-h-0\"\n      ),\n      children: [\n        /* @__PURE__ */ jsx(\n          PanelHeader,\n          {\n            className: cn(\n              \"mb-0 origin-bottom transition-all duration-300 ease-out\",\n              agentState.state !== AgentStateType.IDLE ? \"!h-[calc-size(auto,size)] h-auto\" : \"h-0 scale-x-75 scale-y-0 p-0 opacity-0 blur-md\"\n            ),\n            title: /* @__PURE__ */ jsx(\"span\", { className: \"text-base\", children: agentStateToText[agentState.state] }),\n            description: agentState.description && /* @__PURE__ */ jsx(\"span\", { className: \"text-sm\", children: agentState.description }),\n            iconArea: /* @__PURE__ */ jsx(\"div\", { className: \"flex size-8 items-center justify-center\", children: Object.values(AgentStateType).map((state) => /* @__PURE__ */ jsx(StateIcon, { shouldRender: agentState.state === state, children: agentStateToIcon[state] }, state)) }),\n            actionArea: /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(\"div\", { className: \"-z-10 pointer-events-none absolute inset-0 overflow-hidden rounded-[inherit] opacity-50\", children: /* @__PURE__ */ jsx(\n              GradientBackgroundChat,\n              {\n                className: \"size-full\",\n                currentVariant: agentState.state,\n                variants: GradientBackgroundVariants,\n                transparent: agentState.state === AgentStateType.IDLE\n              }\n            ) }) })\n          }\n        ),\n        /* @__PURE__ */ jsx(\n          PanelContent,\n          {\n            className: cn(\n              \"flex basis-[initial] flex-col gap-0 px-1 py-0\",\n              anyMessageInChat ? \"!h-[calc-size(auto,size)] h-auto flex-1\" : \"h-0\",\n              agentState.state === AgentStateType.IDLE ? \"rounded-t-[inherit]\" : \"rounded-t-none\",\n              \"mask-alpha mask-[linear-gradient(to_bottom,transparent_0%,black_5%,black_95%,transparent_100%)]\",\n              \"overflow-hidden\"\n            ),\n            children: /* @__PURE__ */ jsx(AgentMessageDisplay, {})\n          }\n        ),\n        /* @__PURE__ */ jsxs(\n          PanelFooter,\n          {\n            className: cn(\n              \"mt-0 flex origin-top flex-col items-stretch gap-0 px-2 pt-1 pb-2 duration-150 ease-out\",\n              !enableInputField && \"pointer-events-none opacity-80 brightness-75\",\n              chatState.isPromptCreationActive && \"bg-blue-400/10\",\n              anyMessageInChat ? \"h-24\" : \"h-36\",\n              !anyMessageInChat && agentState.state === AgentStateType.IDLE && \"rounded-t-[inherit] border-transparent border-t-none pt-3 pl-3\"\n            ),\n            children: [\n              /* @__PURE__ */ jsx(ContextElementsChips, {}),\n              /* @__PURE__ */ jsxs(\"div\", { className: \"flex flex-1 flex-row items-end justify-between gap-2\", children: [\n                /* @__PURE__ */ jsxs(\"div\", { className: \"h-full flex-1\", children: [\n                  /* @__PURE__ */ jsx(\n                    J,\n                    {\n                      ref: inputRef,\n                      value: chatState.chatInput,\n                      onChange: (e2) => {\n                        chatState.setChatInput(e2.target.value);\n                      },\n                      onFocus: () => {\n                        chatState.startPromptCreation();\n                      },\n                      onKeyDown: handleKeyDown,\n                      onCompositionStart: handleCompositionStart,\n                      onCompositionEnd: handleCompositionEnd,\n                      disabled: !enableInputField,\n                      className: \"m-1 h-full w-full resize-none focus:outline-none\"\n                    }\n                  ),\n                  /* @__PURE__ */ jsx(\"div\", { className: \"pointer-events-none absolute inset-0 z-10 p-1\", children: /* @__PURE__ */ jsx(\n                    TextSlideshow,\n                    {\n                      className: cn(\n                        \"text-foreground/40 text-sm\",\n                        chatState.chatInput.length !== 0 && \"opacity-0\"\n                      ),\n                      texts: [\n                        \"Try: Add a new button into the top right corner\",\n                        \"Try: Convert these cards into accordions\",\n                        \"Try: Add a gradient to the background\"\n                      ]\n                    }\n                  ) })\n                ] }),\n                /* @__PURE__ */ jsx(\n                  Button,\n                  {\n                    disabled: !canSendMessage,\n                    onClick: handleSubmit,\n                    glassy: !0,\n                    variant: \"primary\",\n                    className: \"size-8 cursor-pointer rounded-full p-1\",\n                    children: /* @__PURE__ */ jsx(ArrowUp, { className: \"size-4 stroke-3\" })\n                  }\n                )\n              ] })\n            ]\n          }\n        )\n      ]\n    }\n  );\n}\nconst StateIcon = ({\n  children,\n  shouldRender\n}) => /* @__PURE__ */ jsx(\n  \"div\",\n  {\n    className: cn(\n      \"absolute origin-center transition-all duration-500 ease-spring-soft\",\n      shouldRender ? \"scale-100\" : \"scale-0 opacity-0 blur-md\"\n    ),\n    children\n  }\n), GradientBackgroundVariants = {\n  [AgentStateType.WAITING_FOR_USER_RESPONSE]: {\n    activeSpeed: \"slow\",\n    backgroundColor: \"var(--color-blue-200)\",\n    colors: [\n      \"var(--color-blue-200)\",\n      \"var(--color-indigo-400)\",\n      \"var(--color-sky-100)\",\n      \"var(--color-cyan-200)\"\n    ]\n  },\n  [AgentStateType.IDLE]: {\n    activeSpeed: \"slow\",\n    backgroundColor: \"var(--color-white/0)\",\n    colors: [\n      \"var(--color-white/0)\",\n      \"var(--color-white/0)\",\n      \"var(--color-white/0)\",\n      \"var(--color-white/0)\"\n    ]\n  },\n  [AgentStateType.THINKING]: {\n    activeSpeed: \"medium\",\n    backgroundColor: \"var(--color-blue-400)\",\n    colors: [\n      \"var(--color-orange-300)\",\n      \"var(--color-teal-300)\",\n      \"var(--color-fuchsia-400)\",\n      \"var(--color-indigo-200)\"\n    ]\n  },\n  [AgentStateType.WORKING]: {\n    activeSpeed: \"medium\",\n    backgroundColor: \"var(--color-indigo-400)\",\n    colors: [\n      \"var(--color-sky-300)\",\n      \"var(--color-teal-500)\",\n      \"var(--color-violet-400)\",\n      \"var(--color-indigo-200)\"\n    ]\n  },\n  [AgentStateType.CALLING_TOOL]: {\n    activeSpeed: \"fast\",\n    backgroundColor: \"var(--color-fuchsia-400)\",\n    colors: [\n      \"var(--color-fuchsia-400)\",\n      \"var(--color-violet-400)\",\n      \"var(--color-indigo-500)\",\n      \"var(--color-purple-200)\"\n    ]\n  },\n  [AgentStateType.FAILED]: {\n    activeSpeed: \"slow\",\n    backgroundColor: \"var(--color-red-200)\",\n    colors: [\n      \"var(--color-red-100)\",\n      \"var(--color-rose-300)\",\n      \"var(--color-fuchsia-400)\",\n      \"var(--color-indigo-300)\"\n    ]\n  },\n  [AgentStateType.COMPLETED]: {\n    activeSpeed: \"slow\",\n    backgroundColor: \"var(--color-green-400)\",\n    colors: [\n      \"var(--color-green-300)\",\n      \"var(--color-teal-400)\",\n      \"var(--color-emerald-500)\",\n      \"var(--color-lime-200)\"\n    ]\n  }\n};\nfunction SelectAgent() {\n  return /* @__PURE__ */ jsx(AgentSelection, {});\n}\nfunction NoAgentFound() {\n  return /* @__PURE__ */ jsxs(\"div\", { className: \"space-y-2 text-foreground text-sm\", children: [\n    /* @__PURE__ */ jsx(\"p\", { className: \"font-medium\", children: \"To connect:\" }),\n    /* @__PURE__ */ jsxs(\"ol\", { className: \"list-inside list-decimal space-y-1 pl-2 text-sm\", children: [\n      /* @__PURE__ */ jsx(\"li\", { children: \"Open your IDE (Cursor, Windsurf, etc.)\" }),\n      /* @__PURE__ */ jsx(\"li\", { children: \"Install the stagewise extension\" }),\n      /* @__PURE__ */ jsx(\"li\", { children: \"Make sure the extension is active\" }),\n      /* @__PURE__ */ jsx(\"li\", { children: \"Click refresh in the toolbar\" })\n    ] })\n  ] });\n}\nfunction AgentDisconnected() {\n  return /* @__PURE__ */ jsxs(Fragment$1, { children: [\n    /* @__PURE__ */ jsxs(\"span\", { className: \"text-foreground text-sm\", children: [\n      \"The previously connected agent is not available anymore.\",\n      /* @__PURE__ */ jsx(\"br\", {}),\n      /* @__PURE__ */ jsx(\"br\", {}),\n      \"Try to wait a second or restart the agent.\"\n    ] }),\n    /* @__PURE__ */ jsx(AgentSelection, {})\n  ] });\n}\nconst availabilityErrorMessages = {\n  [AgentAvailabilityError.NO_CONNECTION]: \"The agent has no connection to it's service.\",\n  [AgentAvailabilityError.INCOMPATIBLE_VERSION]: \"The agent is running an incompatible version.\",\n  [AgentAvailabilityError.NO_AUTHENTICATION]: \"You're not authenticated to the agent.\",\n  [AgentAvailabilityError.OTHER]: \"\"\n};\nfunction BadAgentAvailability() {\n  const availabilityStatus = useAgentAvailability();\n  return availabilityStatus.isAvailable ? null : /* @__PURE__ */ jsxs(Fragment$1, { children: [\n    /* @__PURE__ */ jsxs(\"span\", { className: \"text-foreground text-sm\", children: [\n      \"The agent is connected to the toolbar, but not ready to use.\",\n      /* @__PURE__ */ jsx(\"br\", {}),\n      /* @__PURE__ */ jsx(\"br\", {}),\n      \"error\" in availabilityStatus && availabilityErrorMessages[availabilityStatus.error].length > 0 && /* @__PURE__ */ jsxs(Fragment$1, { children: [\n        /* @__PURE__ */ jsx(\"span\", { className: \"font-medium text-foreground\", children: \"Reason\" }),\n        /* @__PURE__ */ jsx(\"br\", {}),\n        /* @__PURE__ */ jsx(\"span\", { className: \"text-foreground/80\", children: availabilityStatus.errorMessage || availabilityErrorMessages[availabilityStatus.error] }),\n        /* @__PURE__ */ jsx(\"br\", {})\n      ] })\n    ] }),\n    /* @__PURE__ */ jsx(AgentSelection, {})\n  ] });\n}\nfunction AgentConnectivityPanel() {\n  const { availableAgents, connectedUnavailable, connected } = useAgents(), availabilityStatus = useAgentAvailability(), shouldRenderAsWarning = useMemo(() => availableAgents.length === 0 || connectedUnavailable || !availabilityStatus.isAvailable, [availableAgents, connectedUnavailable, availabilityStatus]), title = useMemo(() => availableAgents.length === 0 ? \"No agents available\" : connectedUnavailable ? \"Agent disconnected\" : connected && !availabilityStatus.isAvailable ? \"Agent not ready to use\" : \"Select an agent to connect to\", [availableAgents, connectedUnavailable, availabilityStatus]), renderedIcon = useMemo(() => shouldRenderAsWarning ? connectedUnavailable || connected && \"error\" in availabilityStatus && availabilityStatus.error === AgentAvailabilityError.NO_CONNECTION ? /* @__PURE__ */ jsx(WifiOff, { className: \"size-6\" }) : /* @__PURE__ */ jsx(TriangleAlert, { className: \"size-6\" }) : null, [connectedUnavailable, connected, availabilityStatus]);\n  return /* @__PURE__ */ jsxs(\n    Panel,\n    {\n      className: cn(\n        shouldRenderAsWarning && \"[--color-foreground:var(--color-orange-700)] [--color-muted-foreground:var(--color-orange-600)] before:bg-orange-50/80\"\n      ),\n      children: [\n        /* @__PURE__ */ jsx(\n          PanelHeader,\n          {\n            title,\n            actionArea: shouldRenderAsWarning && renderedIcon\n          }\n        ),\n        /* @__PURE__ */ jsxs(PanelContent, { children: [\n          availableAgents.length > 0 && !connectedUnavailable && !connected && /* @__PURE__ */ jsx(SelectAgent, {}),\n          connectedUnavailable && /* @__PURE__ */ jsx(AgentDisconnected, {}),\n          availableAgents.length === 0 && !connectedUnavailable && /* @__PURE__ */ jsx(NoAgentFound, {}),\n          !connectedUnavailable && connected && !availabilityStatus.isAvailable && /* @__PURE__ */ jsx(BadAgentAvailability, {})\n        ] }),\n        /* @__PURE__ */ jsx(PanelFooter, { children: /* @__PURE__ */ jsxs(DropdownMenu, { children: [\n          /* @__PURE__ */ jsx(DropdownMenuButton, { children: /* @__PURE__ */ jsxs(Button, { glassy: !0, size: \"sm\", variant: \"secondary\", children: [\n            /* @__PURE__ */ jsx(MessageCircleQuestionMark, { className: \"mr-2 size-4\" }),\n            \"Need help?\"\n          ] }) }),\n          /* @__PURE__ */ jsxs(DropdownMenuContent, { children: [\n            /* @__PURE__ */ jsx(\n              DropdownMenuLinkItem,\n              {\n                href: \"https://stagewise.io/docs\",\n                target: \"_blank\",\n                children: \"Read the docs\"\n              }\n            ),\n            /* @__PURE__ */ jsx(\n              DropdownMenuLinkItem,\n              {\n                href: \"https://discord.gg/y8gdNb4D\",\n                target: \"_blank\",\n                children: \"Join the community\"\n              }\n            )\n          ] })\n        ] }) })\n      ]\n    }\n  );\n}\nconst TOOLBAR_POSITION_KEY = \"stagewise_toolbar_toolbar_position\";\nfunction getStoredToolbarPosition() {\n  try {\n    const stored = localStorage.getItem(TOOLBAR_POSITION_KEY);\n    if (stored)\n      return stored;\n  } catch (error2) {\n    console.warn(\"Failed to load toolbar position from localStorage:\", error2);\n  }\n  return null;\n}\nfunction saveToolbarPosition(position) {\n  try {\n    position && localStorage.setItem(TOOLBAR_POSITION_KEY, position);\n  } catch (error2) {\n    console.warn(\"Failed to save toolbar position to localStorage:\", error2);\n  }\n}\nfunction DefaultLayout() {\n  return /* @__PURE__ */ jsx(ContextChipHoverProvider, { children: /* @__PURE__ */ jsxs(\"div\", { className: cn(\"fixed inset-0 h-screen w-screen\"), children: [\n    /* @__PURE__ */ jsx(DOMContextSelector, {}),\n    /* @__PURE__ */ jsx(DraggingArea, {})\n  ] }) });\n}\nfunction DraggingArea() {\n  const containerRef = useRef(null);\n  return /* @__PURE__ */ jsx(\"div\", { className: \"absolute z-50 size-full\", children: /* @__PURE__ */ jsx(\"div\", { className: \"absolute inset-4\", ref: containerRef, children: /* @__PURE__ */ jsx(\n    DraggableProvider,\n    {\n      containerRef,\n      snapAreas: {\n        topLeft: !0,\n        topRight: !0,\n        bottomLeft: !0,\n        bottomRight: !0,\n        topCenter: !1,\n        bottomCenter: !1\n      },\n      children: /* @__PURE__ */ jsx(ToolbarAndPanelArea, {})\n    }\n  ) }) });\n}\nfunction ToolbarAndPanelArea() {\n  const onNewSnapArea = useCallback(\n    (snapArea) => {\n      saveToolbarPosition(snapArea);\n    },\n    []\n  ), initialSnapArea = useMemo(() => getStoredToolbarPosition() || \"bottomRight\", []), draggable = useDraggable({\n    startThreshold: 5,\n    initialSnapArea,\n    onDragEnd: onNewSnapArea\n  }), clickHandleRef = useRef(null);\n  return useEffect(() => {\n    const listener = (e2) => {\n      if (draggable.wasDragged) {\n        e2.preventDefault(), e2.stopPropagation();\n        return;\n      }\n    };\n    return window.addEventListener(\"click\", listener, { capture: !0 }), () => {\n      window.removeEventListener(\"click\", listener, { capture: !0 });\n    };\n  }, [draggable]), /* @__PURE__ */ jsxs(\"div\", { className: \"absolute inset-0 z-50 size-full\", children: [\n    /* @__PURE__ */ jsx(\n      Toolbar,\n      {\n        draggableHandleRef: (ref) => {\n          draggable.handleRef(ref), draggable.draggableRef(ref), clickHandleRef.current = ref;\n        },\n        isDragged: draggable.isDragging,\n        position: draggable.position\n      }\n    ),\n    /* @__PURE__ */ jsx(\n      PanelsArea,\n      {\n        position: draggable.position,\n        isToolbarDragged: draggable.isDragging\n      }\n    )\n  ] });\n}\nfunction PanelsArea({\n  position,\n  isToolbarDragged\n}) {\n  const {\n    isChatOpen,\n    isSettingsOpen,\n    isAgentConnectivityOpen,\n    openPluginName\n  } = usePanels(), plugins = usePlugins(), pluginPanel = useMemo(() => {\n    if (!openPluginName)\n      return null;\n    const plugin = plugins.plugins.find(\n      (plugin2) => plugin2.pluginName === openPluginName\n    );\n    if (!plugin)\n      return null;\n    const panelResult = plugin.onActionClick();\n    return panelResult || null;\n  }, [openPluginName, plugins]);\n  return /* @__PURE__ */ jsxs(\n    \"div\",\n    {\n      className: cn(\n        \"absolute z-0 flex h-full w-96 max-w-[calc(100%-48px)] transition-all duration-500 ease-spring\",\n        position.isLeftHalf ? \"left-12\" : \"right-12\",\n        position.isTopHalf ? \"top-0 flex-col\" : \"bottom-0 flex-col-reverse\",\n        isToolbarDragged ? \"scale-95 opacity-50 blur-md brightness-90\" : \"opacity-100\"\n      ),\n      children: [\n        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: isChatOpen, children: /* @__PURE__ */ jsx(ChatPanel, {}) }),\n        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: isSettingsOpen, children: /* @__PURE__ */ jsx(SettingsPanel, {}) }),\n        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: isAgentConnectivityOpen, children: /* @__PURE__ */ jsx(AgentConnectivityPanel, {}) }),\n        /* @__PURE__ */ jsx(PanelWrapper, { position, isOpen: !!pluginPanel, children: pluginPanel })\n      ]\n    }\n  );\n}\nfunction PanelWrapper({\n  children,\n  position,\n  isOpen\n}) {\n  const [shouldRender, setShouldRender] = useState(isOpen), stopRenderTimeoutRef = useRef(null), isAgentPanel = children && typeof children == \"object\" && \"type\" in children && typeof children.type == \"function\" && children.type.name === \"AgentConnectivityPanel\";\n  return useEffect(() => {\n    isAgentPanel && console.debug(\"[PanelWrapper] AgentConnectivityPanel isOpen changed:\", {\n      isOpen,\n      shouldRender,\n      hasTimeout: !!stopRenderTimeoutRef.current\n    }), isOpen ? (isAgentPanel && console.debug(\n      \"[PanelWrapper] AgentConnectivityPanel setting shouldRender to true immediately\"\n    ), setShouldRender(!0), stopRenderTimeoutRef.current && (clearTimeout(stopRenderTimeoutRef.current), stopRenderTimeoutRef.current = null)) : stopRenderTimeoutRef.current = setTimeout(() => {\n      isAgentPanel && console.debug(\n        \"[PanelWrapper] AgentConnectivityPanel setting shouldRender to false after timeout\"\n      ), setShouldRender(!1);\n    }, 500);\n  }, [isOpen, isAgentPanel]), useEffect(() => () => {\n    stopRenderTimeoutRef.current && clearTimeout(stopRenderTimeoutRef.current);\n  }, []), /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      className: cn(\n        \"h-[calc-size(auto,size)] transition-all duration-150 ease-out\",\n        position.isTopHalf ? \"mb-3\" : \"mt-3\",\n        position.isLeftHalf ? \"origin-left\" : \"origin-right\",\n        isOpen ? \"\" : \"mt-0 mb-0 h-0 scale-0 opacity-0 blur-md\"\n      ),\n      children: shouldRender && children\n    }\n  );\n}\nfunction MainAppBlocker() {\n  const { isMainAppBlocked } = useAppState();\n  return /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      className: cn(\n        \"fixed inset-0 h-screen w-screen\",\n        isMainAppBlocked ? \"pointer-events-auto\" : \"pointer-events-none\"\n      ),\n      role: \"button\",\n      tabIndex: 0\n    }\n  );\n}\nfunction App(config2) {\n  return /* @__PURE__ */ jsxs(AppStateProvider, { children: [\n    /* @__PURE__ */ jsx(MainAppBlocker, {}),\n    /* @__PURE__ */ jsxs(ContextProviders, { config: config2, children: [\n      /* @__PURE__ */ jsx(HotkeyListener, {}),\n      /* @__PURE__ */ jsx(DefaultLayout, {})\n    ] })\n  ] });\n}\nconst styleNode = document.createElement(\"style\");\nstyleNode.textContent = appStyle;\ndocument.head.appendChild(styleNode);\ncreateRoot(document.body).render(\n  createElement(StrictMode, null, createElement(App, config))\n);\n`, \"plugin-ui.js\": `import { m as cn, w as cva, b as usePlugins } from \"index-DsC5zpes.js\";\nimport { B, r, t, v, s } from \"index-DsC5zpes.js\";\nimport { jsx } from \"react/jsx-runtime\";\nconst badgeVariants = cva(\"rounded-md p-2\", {\n  variants: {\n    color: {\n      blue: \"\",\n      green: \"\",\n      red: \"\",\n      yellow: \"\",\n      purple: \"\",\n      orange: \"\",\n      pink: \"\"\n    },\n    style: {\n      default: \"text-white\",\n      outline: \"border text-zinc-950\"\n    }\n  },\n  compoundVariants: [\n    {\n      style: \"default\",\n      color: \"blue\",\n      className: \"bg-blue-500\"\n    },\n    {\n      style: \"default\",\n      color: \"green\",\n      className: \"bg-green-500\"\n    },\n    {\n      style: \"default\",\n      color: \"red\",\n      className: \"bg-red-500\"\n    },\n    {\n      style: \"default\",\n      color: \"yellow\",\n      className: \"bg-yellow-500\"\n    },\n    {\n      style: \"default\",\n      color: \"purple\",\n      className: \"bg-purple-500\"\n    },\n    {\n      style: \"default\",\n      color: \"orange\",\n      className: \"bg-orange-500\"\n    },\n    {\n      style: \"default\",\n      color: \"pink\",\n      className: \"bg-pink-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"blue\",\n      className: \"border-blue-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"green\",\n      className: \"border-green-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"red\",\n      className: \"border-red-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"yellow\",\n      className: \"border-yellow-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"purple\",\n      className: \"border-purple-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"orange\",\n      className: \"border-orange-500\"\n    },\n    {\n      style: \"outline\",\n      color: \"pink\",\n      className: \"border-pink-500\"\n    }\n  ],\n  defaultVariants: {\n    color: \"blue\",\n    style: \"default\"\n  }\n});\nfunction Badge({ children, color, style, className }) {\n  return /* @__PURE__ */ jsx(\"span\", { className: cn(badgeVariants({ color, style }), className), children });\n}\nconst useToolbar = () => usePlugins().toolbarContext;\nexport {\n  Badge,\n  B as Button,\n  r as Panel,\n  t as PanelContent,\n  v as PanelFooter,\n  s as PanelHeader,\n  useToolbar\n};\n` };\nfunction initToolbar(config = {}) {\n  if (!(typeof window < \"u\")) {\n    console.warn(\n      \"Stagewise Toolbar is not supported in non-browser environments.\"\n    );\n    return;\n  }\n  if (document.querySelector(\"stagewise-toolbar\")) {\n    console.warn(\"Stagewise Toolbar is already loaded - aborting init.\");\n    return;\n  }\n  const wrapper = document.createElement(\"stagewise-toolbar\");\n  wrapper.style.display = \"block\", wrapper.style.position = \"fixed\", wrapper.style.top = \"0\", wrapper.style.left = \"0\", wrapper.style.right = \"0\", wrapper.style.bottom = \"0\", wrapper.style.width = \"100vw\", wrapper.style.height = \"100vh\", wrapper.style.zIndex = \"2147483647\", wrapper.style.pointerEvents = \"none\";\n  const iframe = document.createElement(\"iframe\");\n  iframe.style.display = \"block\", iframe.style.border = \"none\", iframe.style.overflow = \"hidden\", iframe.style.margin = \"0\", iframe.style.padding = \"0\", iframe.style.width = \"100vw\", iframe.style.height = \"100vh\", iframe.style.backgroundColor = \"transparent\", iframe.style.pointerEvents = \"none\", iframe.style.colorScheme = \"normal\", iframe.sandbox.add(\"allow-same-origin\"), iframe.sandbox.add(\"allow-scripts\"), iframe.sandbox.add(\"allow-presentation\"), iframe.sandbox.add(\"allow-pointer-lock\"), iframe.sandbox.add(\"allow-popups\"), iframe.setAttribute(\"allowtransparency\", \"true\"), iframe.srcdoc = '<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><link rel=\"preconnect\" href=\"https://rsms.me/\"><link rel=\"stylesheet\" href=\"https://rsms.me/inter/inter.css\"></head><body style=\"pointer-events: none;\"></body></html>', iframe.addEventListener(\"load\", () => {\n    let lastMouseOverInteractiveAreaState = !1;\n    const handleMouseMove = (e) => {\n      const elementAtPoint = iframe.contentDocument.elementFromPoint(\n        e.clientX,\n        e.clientY\n      ), isInteractive = elementAtPoint && elementAtPoint !== document.body && elementAtPoint.tagName !== \"HTML\";\n      isInteractive !== lastMouseOverInteractiveAreaState && (iframe.style.pointerEvents = isInteractive ? \"auto\" : \"none\", lastMouseOverInteractiveAreaState = isInteractive);\n    };\n    window.addEventListener(\"mousemove\", handleMouseMove, { capture: !0 }), iframe.contentWindow.addEventListener(\"mousemove\", handleMouseMove, {\n      capture: !0\n    });\n    const devSuffix = \"\", main_modules = Object.fromEntries(\n      Object.entries(define_MAIN_MODULES_default).map(([key, value]) => [\n        key,\n        URL.createObjectURL(new Blob([value], { type: \"text/javascript\" }))\n      ])\n    );\n    if (main_modules[\"@stagewise/toolbar/plugin-ui\"] = URL.createObjectURL(\n      new Blob([\"export * from 'plugin-ui.js'\"], { type: \"text/javascript\" })\n    ), config.plugins)\n      for (const [index, plugin] of config.plugins.entries()) {\n        const plugin_module = URL.createObjectURL(\n          new Blob([plugin.mainPlugin], { type: \"text/javascript\" })\n        );\n        main_modules[`plugin-entry-${index}`] = plugin_module;\n      }\n    const config_module = URL.createObjectURL(\n      new Blob([getConfigModuleContent(config)], { type: \"text/javascript\" })\n    );\n    main_modules[\"@stagewise/toolbar/config\"] = config_module;\n    const imports = {\n      react: `https://esm.sh/react@19.1.0${devSuffix}`,\n      \"react-dom\": `https://esm.sh/react-dom@19.1.0${devSuffix}`,\n      \"react-dom/client\": `https://esm.sh/react-dom@19.1.0/client${devSuffix}`,\n      \"react/jsx-runtime\": `https://esm.sh/react@19.1.0/jsx-runtime${devSuffix}`,\n      ...main_modules\n    }, importmapScript = iframe.contentDocument.createElement(\"script\");\n    importmapScript.type = \"importmap\", importmapScript.textContent = `{\"imports\":${JSON.stringify(imports)}}`, iframe.contentDocument.head.appendChild(importmapScript);\n    const script = iframe.contentDocument.createElement(\"script\");\n    script.type = \"module\", script.textContent = \"import('index.js');\", iframe.contentDocument.head.appendChild(script);\n  }), wrapper.appendChild(iframe), document.body.appendChild(wrapper);\n}\nfunction getConfigModuleContent(config) {\n  var _a, _b;\n  const pluginImports = ((_a = config.plugins) == null ? void 0 : _a.map((_, index) => `import plugin${index} from 'plugin-entry-${index}'`).join(`\n`)) ?? \"\", convertedPluginArray = `[${((_b = config.plugins) == null ? void 0 : _b.map((_, index) => `plugin${index}`).join(\",\")) ?? \"\"}]`, convertedConfig = {\n    ...config,\n    plugins: \"__PLUGIN_PLACEHOLDER__\"\n  };\n  let configString = JSON.stringify(convertedConfig);\n  return configString = configString.replace(\n    '\"__PLUGIN_PLACEHOLDER__\"',\n    convertedPluginArray\n  ), `${pluginImports}\n\nconst config = ${configString};\n\nexport default config;\n`;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3RhZ2V3aXNlL3Rvb2xiYXIvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsb0NBQW9DLCtCQUErQixZQUFZO0FBQy9FLFNBQVMsMEZBQTBGO0FBQ25HO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsdURBQXVELGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUUsQ0FBQztBQUNELDRJQUE0SSxPQUFPO0FBQ25KO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsdUdBQXVHO0FBQ3hHO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRywwQ0FBMEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw0Q0FBNEM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw2Q0FBNkM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsNENBQTRDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNU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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQ0FBZ0M7QUFDOUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFlBQVksY0FBYyxxQ0FBcUMseUJBQXlCO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw2QkFBNkI7QUFDNUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELHFCQUFxQjtBQUNyQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkJBQTZCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtB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QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQix1Q0FBdUMsNkNBQTZDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxSUFBcUksMENBQTBDO0FBQy9LLFFBQVE7QUFDUiw4Q0FBOEMsNkNBQTZDLG1KQUFtSiwwQ0FBMEM7QUFDeFI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixRQUFRO0FBQ1IsOENBQThDLDZDQUE2QztBQUMzRjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksY0FBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1RkFBdUYsa0JBQWtCO0FBQ3pHLGtDQUFrQyxhQUFhO0FBQy9DO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBMEM7QUFDbkU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLHNEQUFzRDtBQUN2RDtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DLENBQUM7QUFDRCxzQ0FBc0Msb0JBQW9CO0FBQzFELHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNDQUFzQyxvQkFBb0I7QUFDMUQsa0NBQWtDLG9CQUFvQjtBQUN0RCxDQUFDLDJYQUEyWDtBQUM1WDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpWkFBaVo7QUFDalo7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCwyQkFBMkI7QUFDeko7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDBCQUEwQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCwwQ0FBMEM7QUFDNUosR0FBRztBQUNIO0FBQ0E7QUFDQSxxRkFBcUYsbUJBQW1CO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHNCQUFzQjtBQUMxRixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0EsU0FBUyxxREFBcUQ7QUFDOUQ7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZ0JBQWdCLGdFQUFnRSx5QkFBeUI7QUFDbko7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQSw0TUFBNE07QUFDNU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsZ0NBQWdDO0FBQzlHLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyTUFBMk07QUFDcE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsUUFBUSxzRUFBc0U7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBK0Q7QUFDdkU7QUFDQSxHQUFHLEtBQUssOENBQThDO0FBQ3REO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLHVHQUF1RztBQUMzRyxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHdPQUF3TztBQUN4TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBbUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQTJEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUErRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUE0RDtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0ZBQWtGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQyxhQUFhO0FBQ2I7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsd0VBQXdFLGFBQWE7QUFDckY7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixhQUFhO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsZUFBZTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBMEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxxREFBcUQsVUFBVTtBQUMvRCxtRUFBbUUsVUFBVTtBQUM3RSxxRUFBcUUsVUFBVTtBQUMvRTtBQUNBLEtBQUs7QUFDTCx3RUFBd0UsWUFBWSx5QkFBeUI7QUFDN0c7QUFDQSxxRUFBcUU7QUFDckUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxPQUFPLHFCQUFxQixNQUFNO0FBQ3pJLHNDQUFzQyx3RUFBd0UsTUFBTSxvQkFBb0I7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9kYXVyZW56aHVudXNzb3YvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdGFnZXdpc2UvdG9vbGJhci9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkZWZpbmVfTUFJTl9NT0RVTEVTX2RlZmF1bHQgPSB7IFwiaW5kZXgtRHNDNXpwZXMuanNcIjogYGltcG9ydCB7IGpzeCwganN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlTWVtbywgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgY3JlYXRlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBDb25maWdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gIGNvbmZpZzogdm9pZCAwXG59KTtcbmZ1bmN0aW9uIENvbmZpZ1Byb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGNvbmZpZ1xufSkge1xuICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjb25maWdcbiAgfSksIFtjb25maWddKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZSwgY2hpbGRyZW4gfSk7XG59XG5mdW5jdGlvbiB1c2VDb25maWcoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KENvbmZpZ0NvbnRleHQpO1xufVxudmFyIF9fY3JlYXRlJDEgPSBPYmplY3QuY3JlYXRlLCBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19nZXRPd25Qcm9wRGVzYyQxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgX19nZXRPd25Qcm9wTmFtZXMkMSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLCBfX2dldFByb3RvT2YkMSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgX19oYXNPd25Qcm9wJDEgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBfX2NvbW1vbkpTJDEgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzJDEoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59LCBfX2NvcHlQcm9wcyQxID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PSBcImZ1bmN0aW9uXCIpIGZvciAodmFyIGtleXMgPSBfX2dldE93blByb3BOYW1lcyQxKGZyb20pLCBpID0gMCwgbiA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBuOyBpKyspXG4gICAga2V5ID0ga2V5c1tpXSwgIV9faGFzT3duUHJvcCQxLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQgJiYgX19kZWZQcm9wJDIodG8sIGtleSwge1xuICAgICAgZ2V0OiAoKGspID0+IGZyb21ba10pLmJpbmQobnVsbCwga2V5KSxcbiAgICAgIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MkMShmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGVcbiAgICB9KTtcbiAgcmV0dXJuIHRvO1xufSwgX190b0VTTSQxID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZSQxKF9fZ2V0UHJvdG9PZiQxKG1vZCkpIDoge30sIF9fY29weVByb3BzJDEoX19kZWZQcm9wJDIodGFyZ2V0LCBcImRlZmF1bHRcIiwge1xuICB2YWx1ZTogbW9kLFxuICBlbnVtZXJhYmxlOiAhMFxufSksIG1vZCkpLCByZXF1aXJlX3R5cGVvZiQxID0gX19jb21tb25KUyQxKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90eXBlb2YuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgZnVuY3Rpb24gX3R5cGVvZiQyKG8pIHtcbiAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiQyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obyQxKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG8kMTtcbiAgICB9IDogZnVuY3Rpb24obyQxKSB7XG4gICAgICByZXR1cm4gbyQxICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mJDIobyk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mJDIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xufSB9KSwgcmVxdWlyZV90b1ByaW1pdGl2ZSQxID0gX19jb21tb25KUyQxKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90b1ByaW1pdGl2ZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICB2YXIgX3R5cGVvZiQxID0gcmVxdWlyZV90eXBlb2YkMSgpLmRlZmF1bHQ7XG4gIGZ1bmN0aW9uIHRvUHJpbWl0aXZlJDEodCwgcjIpIHtcbiAgICBpZiAoX3R5cGVvZiQxKHQpICE9IFwib2JqZWN0XCIgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIyIHx8IFwiZGVmYXVsdFwiKTtcbiAgICAgIGlmIChfdHlwZW9mJDEoaSkgIT0gXCJvYmplY3RcIikgcmV0dXJuIGk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiAocjIgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gdG9QcmltaXRpdmUkMSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pLCByZXF1aXJlX3RvUHJvcGVydHlLZXkkMSA9IF9fY29tbW9uSlMkMSh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICB2YXIgX3R5cGVvZiA9IHJlcXVpcmVfdHlwZW9mJDEoKS5kZWZhdWx0LCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmVfdG9QcmltaXRpdmUkMSgpO1xuICBmdW5jdGlvbiB0b1Byb3BlcnR5S2V5JDEodCkge1xuICAgIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gICAgcmV0dXJuIF90eXBlb2YoaSkgPT0gXCJzeW1ib2xcIiA/IGkgOiBpICsgXCJcIjtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IHRvUHJvcGVydHlLZXkkMSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pLCByZXF1aXJlX2RlZmluZVByb3BlcnR5JDEgPSBfX2NvbW1vbkpTJDEoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZV90b1Byb3BlcnR5S2V5JDEoKTtcbiAgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KGUsIHIyLCB0KSB7XG4gICAgcmV0dXJuIChyMiA9IHRvUHJvcGVydHlLZXkocjIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIyLCB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pIDogZVtyMl0gPSB0LCBlO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gX2RlZmluZVByb3BlcnR5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gITAsIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbn0gfSksIHJlcXVpcmVfb2JqZWN0U3ByZWFkMiQxID0gX19jb21tb25KUyQxKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lUHJvcGVydHkkMSgpO1xuICBmdW5jdGlvbiBvd25LZXlzKGUsIHIyKSB7XG4gICAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgICAgcjIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbihyJDEpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgciQxKS5lbnVtZXJhYmxlO1xuICAgICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgICBmb3IgKHZhciByMiA9IDE7IHIyIDwgYXJndW1lbnRzLmxlbmd0aDsgcjIrKykge1xuICAgICAgdmFyIHQgPSBhcmd1bWVudHNbcjJdICE9IG51bGwgPyBhcmd1bWVudHNbcjJdIDoge307XG4gICAgICByMiAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KGUsIHIkMSwgdFtyJDFdKTtcbiAgICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIkMSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByJDEpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IF9vYmplY3RTcHJlYWQyLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gITAsIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5mdW5jdGlvbiBvYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICBjb25zdCBzZWxmID0ge1xuICAgIHN1YnNjcmliZShvYnNlcnZlcikge1xuICAgICAgbGV0IHRlYXJkb3duUmVmID0gbnVsbCwgaXNEb25lID0gITEsIHVuc3Vic2NyaWJlZCA9ICExLCB0ZWFyZG93bkltbWVkaWF0ZWx5ID0gITE7XG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKHRlYXJkb3duUmVmID09PSBudWxsKSB7XG4gICAgICAgICAgdGVhcmRvd25JbW1lZGlhdGVseSA9ICEwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bnN1YnNjcmliZWQgfHwgKHVuc3Vic2NyaWJlZCA9ICEwLCB0eXBlb2YgdGVhcmRvd25SZWYgPT0gXCJmdW5jdGlvblwiID8gdGVhcmRvd25SZWYoKSA6IHRlYXJkb3duUmVmICYmIHRlYXJkb3duUmVmLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlYXJkb3duUmVmID0gc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dCh2YWx1ZSkge1xuICAgICAgICAgIHZhciBfb2JzZXJ2ZXIkbmV4dDtcbiAgICAgICAgICBpc0RvbmUgfHwgKF9vYnNlcnZlciRuZXh0ID0gb2JzZXJ2ZXIubmV4dCkgPT09IG51bGwgfHwgX29ic2VydmVyJG5leHQgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkbmV4dC5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKGVycikge1xuICAgICAgICAgIHZhciBfb2JzZXJ2ZXIkZXJyb3I7XG4gICAgICAgICAgaXNEb25lIHx8IChpc0RvbmUgPSAhMCwgKF9vYnNlcnZlciRlcnJvciA9IG9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkZXJyb3IgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkZXJyb3IuY2FsbChvYnNlcnZlciwgZXJyKSwgdW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICAgIHZhciBfb2JzZXJ2ZXIkY29tcGxldGU7XG4gICAgICAgICAgaXNEb25lIHx8IChpc0RvbmUgPSAhMCwgKF9vYnNlcnZlciRjb21wbGV0ZSA9IG9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkY29tcGxldGUgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkY29tcGxldGUuY2FsbChvYnNlcnZlciksIHVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9XG4gICAgICB9KSwgdGVhcmRvd25JbW1lZGlhdGVseSAmJiB1bnN1YnNjcmliZSgpLCB7IHVuc3Vic2NyaWJlIH07XG4gICAgfSxcbiAgICBwaXBlKC4uLm9wZXJhdGlvbnMpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25zLnJlZHVjZShwaXBlUmVkdWNlciwgc2VsZik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIHBpcGVSZWR1Y2VyKHByZXYsIGZuKSB7XG4gIHJldHVybiBmbihwcmV2KTtcbn1cbmZ1bmN0aW9uIG9ic2VydmFibGVUb1Byb21pc2Uob2JzZXJ2YWJsZSQxKSB7XG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBpc0RvbmUgPSAhMTtcbiAgICBmdW5jdGlvbiBvbkRvbmUoKSB7XG4gICAgICBpc0RvbmUgfHwgKGlzRG9uZSA9ICEwLCBvYnMkLnVuc3Vic2NyaWJlKCkpO1xuICAgIH1cbiAgICBhYy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgIHJlamVjdChhYy5zaWduYWwucmVhc29uKTtcbiAgICB9KTtcbiAgICBjb25zdCBvYnMkID0gb2JzZXJ2YWJsZSQxLnN1YnNjcmliZSh7XG4gICAgICBuZXh0KGRhdGEpIHtcbiAgICAgICAgaXNEb25lID0gITAsIHJlc29sdmUoZGF0YSksIG9uRG9uZSgpO1xuICAgICAgfSxcbiAgICAgIGVycm9yKGRhdGEpIHtcbiAgICAgICAgcmVqZWN0KGRhdGEpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBhYy5hYm9ydCgpLCBvbkRvbmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaGFyZShfb3B0cykge1xuICByZXR1cm4gKHNvdXJjZSkgPT4ge1xuICAgIGxldCByZWZDb3VudCA9IDAsIHN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gW107XG4gICAgZnVuY3Rpb24gc3RhcnRJZk5lZWRlZCgpIHtcbiAgICAgIHN1YnNjcmlwdGlvbiB8fCAoc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQodmFsdWUpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycykge1xuICAgICAgICAgICAgdmFyIF9vYnNlcnZlciRuZXh0O1xuICAgICAgICAgICAgKF9vYnNlcnZlciRuZXh0ID0gb2JzZXJ2ZXIubmV4dCkgPT09IG51bGwgfHwgX29ic2VydmVyJG5leHQgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkbmV4dC5jYWxsKG9ic2VydmVyLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBlcnJvcihlcnJvcikge1xuICAgICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJzKSB7XG4gICAgICAgICAgICB2YXIgX29ic2VydmVyJGVycm9yO1xuICAgICAgICAgICAgKF9vYnNlcnZlciRlcnJvciA9IG9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkZXJyb3IgPT09IHZvaWQgMCB8fCBfb2JzZXJ2ZXIkZXJyb3IuY2FsbChvYnNlcnZlciwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcGxldGUoKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIHZhciBfb2JzZXJ2ZXIkY29tcGxldGU7XG4gICAgICAgICAgICAoX29ic2VydmVyJGNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGUpID09PSBudWxsIHx8IF9vYnNlcnZlciRjb21wbGV0ZSA9PT0gdm9pZCAwIHx8IF9vYnNlcnZlciRjb21wbGV0ZS5jYWxsKG9ic2VydmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRJZk5lZWRlZCgpIHtcbiAgICAgIGlmIChyZWZDb3VudCA9PT0gMCAmJiBzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgX3N1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gbnVsbCwgX3N1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JzZXJ2YWJsZSgoc3Vic2NyaWJlcikgPT4gKHJlZkNvdW50KyssIG9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpLCBzdGFydElmTmVlZGVkKCksIHsgdW5zdWJzY3JpYmUoKSB7XG4gICAgICByZWZDb3VudC0tLCByZXNldElmTmVlZGVkKCk7XG4gICAgICBjb25zdCBpbmRleCA9IG9ic2VydmVycy5maW5kSW5kZXgoKHYpID0+IHYgPT09IHN1YnNjcmliZXIpO1xuICAgICAgaW5kZXggPiAtMSAmJiBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9IH0pKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGJlaGF2aW9yU3ViamVjdChpbml0aWFsVmFsdWUpIHtcbiAgbGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBjb25zdCBvYnNlcnZlckxpc3QgPSBbXSwgYWRkT2JzZXJ2ZXIgPSAob2JzZXJ2ZXIpID0+IHtcbiAgICB2YWx1ZSAhPT0gdm9pZCAwICYmIG9ic2VydmVyLm5leHQodmFsdWUpLCBvYnNlcnZlckxpc3QucHVzaChvYnNlcnZlcik7XG4gIH0sIHJlbW92ZU9ic2VydmVyID0gKG9ic2VydmVyKSA9PiB7XG4gICAgb2JzZXJ2ZXJMaXN0LnNwbGljZShvYnNlcnZlckxpc3QuaW5kZXhPZihvYnNlcnZlciksIDEpO1xuICB9LCBvYnMgPSBvYnNlcnZhYmxlKChvYnNlcnZlcikgPT4gKGFkZE9ic2VydmVyKG9ic2VydmVyKSwgKCkgPT4ge1xuICAgIHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgfSkpO1xuICByZXR1cm4gb2JzLm5leHQgPSAobmV4dFZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlICE9PSBuZXh0VmFsdWUpIHtcbiAgICAgIHZhbHVlID0gbmV4dFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlckxpc3QpIG9ic2VydmVyLm5leHQobmV4dFZhbHVlKTtcbiAgICB9XG4gIH0sIG9icy5nZXQgPSAoKSA9PiB2YWx1ZSwgb2JzO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2hhaW4ob3B0cykge1xuICByZXR1cm4gb2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBmdW5jdGlvbiBleGVjdXRlKGluZGV4ID0gMCwgb3AgPSBvcHRzLm9wKSB7XG4gICAgICBjb25zdCBuZXh0ID0gb3B0cy5saW5rc1tpbmRleF07XG4gICAgICBpZiAoIW5leHQpIHRocm93IG5ldyBFcnJvcihcIk5vIG1vcmUgbGlua3MgdG8gZXhlY3V0ZSAtIGRpZCB5b3UgZm9yZ2V0IHRvIGFkZCBhbiBlbmRpbmcgbGluaz9cIik7XG4gICAgICByZXR1cm4gbmV4dCh7XG4gICAgICAgIG9wLFxuICAgICAgICBuZXh0KG5leHRPcCkge1xuICAgICAgICAgIHJldHVybiBleGVjdXRlKGluZGV4ICsgMSwgbmV4dE9wKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBleGVjdXRlKCkuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCI7XG59XG5jb25zdCBydW4gPSAoZm4pID0+IGZuKCk7XG5mdW5jdGlvbiBzbGVlcChtcyA9IDApIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xufVxudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZSwgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLCBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufSwgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIga2V5cyA9IF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pLCBpID0gMCwgbiA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBuOyBpKyspXG4gICAga2V5ID0ga2V5c1tpXSwgIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0ICYmIF9fZGVmUHJvcCQxKHRvLCBrZXksIHtcbiAgICAgIGdldDogKChrKSA9PiBmcm9tW2tdKS5iaW5kKG51bGwsIGtleSksXG4gICAgICBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZVxuICAgIH0pO1xuICByZXR1cm4gdG87XG59LCBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoX19kZWZQcm9wJDEodGFyZ2V0LCBcImRlZmF1bHRcIiwge1xuICB2YWx1ZTogbW9kLFxuICBlbnVtZXJhYmxlOiAhMFxufSksIG1vZCkpO1xuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn0sIGZyZWV6ZUlmQXZhaWxhYmxlID0gKG9iaikgPT4ge1xuICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUob2JqKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBwYXRoLCBtZW1vKSB7XG4gIHZhciBfbWVtbyRjYWNoZUtleTtcbiAgY29uc3QgY2FjaGVLZXkgPSBwYXRoLmpvaW4oXCIuXCIpO1xuICByZXR1cm4gKF9tZW1vJGNhY2hlS2V5ID0gbWVtb1tjYWNoZUtleV0pICE9PSBudWxsICYmIF9tZW1vJGNhY2hlS2V5ICE9PSB2b2lkIDAgfHwgKG1lbW9bY2FjaGVLZXldID0gbmV3IFByb3h5KG5vb3AsIHtcbiAgICBnZXQoX29iaiwga2V5KSB7XG4gICAgICBpZiAoISh0eXBlb2Yga2V5ICE9IFwic3RyaW5nXCIgfHwga2V5ID09PSBcInRoZW5cIikpXG4gICAgICAgIHJldHVybiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBbLi4ucGF0aCwga2V5XSwgbWVtbyk7XG4gICAgfSxcbiAgICBhcHBseShfMSwgXzIsIGFyZ3MpIHtcbiAgICAgIGNvbnN0IGxhc3RPZlBhdGggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgcGF0aFxuICAgICAgfTtcbiAgICAgIHJldHVybiBsYXN0T2ZQYXRoID09PSBcImNhbGxcIiA/IG9wdHMgPSB7XG4gICAgICAgIGFyZ3M6IGFyZ3MubGVuZ3RoID49IDIgPyBbYXJnc1sxXV0gOiBbXSxcbiAgICAgICAgcGF0aDogcGF0aC5zbGljZSgwLCAtMSlcbiAgICAgIH0gOiBsYXN0T2ZQYXRoID09PSBcImFwcGx5XCIgJiYgKG9wdHMgPSB7XG4gICAgICAgIGFyZ3M6IGFyZ3MubGVuZ3RoID49IDIgPyBhcmdzWzFdIDogW10sXG4gICAgICAgIHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpXG4gICAgICB9KSwgZnJlZXplSWZBdmFpbGFibGUob3B0cy5hcmdzKSwgZnJlZXplSWZBdmFpbGFibGUob3B0cy5wYXRoKSwgY2FsbGJhY2sob3B0cyk7XG4gICAgfVxuICB9KSksIG1lbW9bY2FjaGVLZXldO1xufVxuY29uc3QgY3JlYXRlUmVjdXJzaXZlUHJveHkgPSAoY2FsbGJhY2spID0+IGNyZWF0ZUlubmVyUHJveHkoY2FsbGJhY2ssIFtdLCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSksIGNyZWF0ZUZsYXRQcm94eSA9IChjYWxsYmFjaykgPT4gbmV3IFByb3h5KG5vb3AsIHsgZ2V0KF9vYmosIG5hbWUpIHtcbiAgaWYgKG5hbWUgIT09IFwidGhlblwiKVxuICAgIHJldHVybiBjYWxsYmFjayhuYW1lKTtcbn0gfSk7XG52YXIgcmVxdWlyZV90eXBlb2YgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90eXBlb2YuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgZnVuY3Rpb24gX3R5cGVvZiQyKG8pIHtcbiAgICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG4gICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiQyID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSBcInN5bWJvbFwiID8gZnVuY3Rpb24obyQxKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG8kMTtcbiAgICB9IDogZnVuY3Rpb24obyQxKSB7XG4gICAgICByZXR1cm4gbyQxICYmIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIG8kMS5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8kMSAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbyQxO1xuICAgIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzLCBfdHlwZW9mJDIobyk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mJDIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xufSB9KSwgcmVxdWlyZV90b1ByaW1pdGl2ZSA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJpbWl0aXZlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciBfdHlwZW9mJDEgPSByZXF1aXJlX3R5cGVvZigpLmRlZmF1bHQ7XG4gIGZ1bmN0aW9uIHRvUHJpbWl0aXZlJDEodCwgcjIpIHtcbiAgICBpZiAoX3R5cGVvZiQxKHQpICE9IFwib2JqZWN0XCIgfHwgIXQpIHJldHVybiB0O1xuICAgIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICAgIGlmIChlICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBpID0gZS5jYWxsKHQsIHIyIHx8IFwiZGVmYXVsdFwiKTtcbiAgICAgIGlmIChfdHlwZW9mJDEoaSkgIT0gXCJvYmplY3RcIikgcmV0dXJuIGk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gICAgfVxuICAgIHJldHVybiAocjIgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gdG9QcmltaXRpdmUkMSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pLCByZXF1aXJlX3RvUHJvcGVydHlLZXkgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciBfdHlwZW9mID0gcmVxdWlyZV90eXBlb2YoKS5kZWZhdWx0LCB0b1ByaW1pdGl2ZSA9IHJlcXVpcmVfdG9QcmltaXRpdmUoKTtcbiAgZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSQxKHQpIHtcbiAgICB2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICAgIHJldHVybiBfdHlwZW9mKGkpID09IFwic3ltYm9sXCIgPyBpIDogaSArIFwiXCI7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5JDEsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xufSB9KSwgcmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZV90b1Byb3BlcnR5S2V5KCk7XG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByMiwgdCkge1xuICAgIHJldHVybiAocjIgPSB0b1Byb3BlcnR5S2V5KHIyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByMiwge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITBcbiAgICB9KSA6IGVbcjJdID0gdCwgZTtcbiAgfVxuICBtb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pLCByZXF1aXJlX29iamVjdFNwcmVhZDIgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKTtcbiAgZnVuY3Rpb24gb3duS2V5cyhlLCByMikge1xuICAgIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICAgIHIyICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24ociQxKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIkMSkuZW51bWVyYWJsZTtcbiAgICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBmdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gICAgZm9yICh2YXIgcjIgPSAxOyByMiA8IGFyZ3VtZW50cy5sZW5ndGg7IHIyKyspIHtcbiAgICAgIHZhciB0ID0gYXJndW1lbnRzW3IyXSAhPSBudWxsID8gYXJndW1lbnRzW3IyXSA6IHt9O1xuICAgICAgcjIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShlLCByJDEsIHRbciQxXSk7XG4gICAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ociQxKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByJDEsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgciQxKSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0U3ByZWFkMiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSk7XG5fX3RvRVNNKHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSk7XG52YXIgaW1wb3J0X29iamVjdFNwcmVhZDIkMSQxID0gX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSk7XG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHRJbm5lcihyZXNwb25zZSwgdHJhbnNmb3JtZXIyKSB7XG4gIGlmIChcImVycm9yXCIgaW4gcmVzcG9uc2UpIHtcbiAgICBjb25zdCBlcnJvciA9IHRyYW5zZm9ybWVyMi5kZXNlcmlhbGl6ZShyZXNwb25zZS5lcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9rOiAhMSxcbiAgICAgIGVycm9yOiAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMSQxLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxJDEuZGVmYXVsdCkoe30sIHJlc3BvbnNlKSwge30sIHsgZXJyb3IgfSlcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgb2s6ICEwLFxuICAgIHJlc3VsdDogKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEkMS5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMSQxLmRlZmF1bHQpKHt9LCByZXNwb25zZS5yZXN1bHQpLCAoIXJlc3BvbnNlLnJlc3VsdC50eXBlIHx8IHJlc3BvbnNlLnJlc3VsdC50eXBlID09PSBcImRhdGFcIikgJiYge1xuICAgICAgdHlwZTogXCJkYXRhXCIsXG4gICAgICBkYXRhOiB0cmFuc2Zvcm1lcjIuZGVzZXJpYWxpemUocmVzcG9uc2UucmVzdWx0LmRhdGEpXG4gICAgfSlcbiAgfTtcbn1cbnZhciBUcmFuc2Zvcm1SZXN1bHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlVuYWJsZSB0byB0cmFuc2Zvcm0gcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIik7XG4gIH1cbn07XG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHQocmVzcG9uc2UsIHRyYW5zZm9ybWVyMikge1xuICBsZXQgcmVzdWx0O1xuICB0cnkge1xuICAgIHJlc3VsdCA9IHRyYW5zZm9ybVJlc3VsdElubmVyKHJlc3BvbnNlLCB0cmFuc2Zvcm1lcjIpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcbiAgfVxuICBpZiAoIXJlc3VsdC5vayAmJiAoIWlzT2JqZWN0KHJlc3VsdC5lcnJvci5lcnJvcikgfHwgdHlwZW9mIHJlc3VsdC5lcnJvci5lcnJvci5jb2RlICE9IFwibnVtYmVyXCIpKSB0aHJvdyBuZXcgVHJhbnNmb3JtUmVzdWx0RXJyb3IoKTtcbiAgaWYgKHJlc3VsdC5vayAmJiAhaXNPYmplY3QocmVzdWx0LnJlc3VsdCkpIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSk7XG52YXIgaW1wb3J0X2RlZmluZVByb3BlcnR5JDUgPSBfX3RvRVNNJDEocmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSQxKCkpLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxID0gX190b0VTTSQxKHJlcXVpcmVfb2JqZWN0U3ByZWFkMiQxKCkpO1xuZnVuY3Rpb24gaXNUUlBDQ2xpZW50RXJyb3IoY2F1c2UpIHtcbiAgcmV0dXJuIGNhdXNlIGluc3RhbmNlb2YgVFJQQ0NsaWVudEVycm9yO1xufVxuZnVuY3Rpb24gaXNUUlBDRXJyb3JSZXNwb25zZShvYmopIHtcbiAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgaXNPYmplY3Qob2JqLmVycm9yKSAmJiB0eXBlb2Ygb2JqLmVycm9yLmNvZGUgPT0gXCJudW1iZXJcIiAmJiB0eXBlb2Ygb2JqLmVycm9yLm1lc3NhZ2UgPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tVW5rbm93bkVycm9yKGVyciwgZmFsbGJhY2spIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnIgPT0gXCJzdHJpbmdcIiA/IGVyciA6IGlzT2JqZWN0KGVycikgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09IFwic3RyaW5nXCIgPyBlcnIubWVzc2FnZSA6IGZhbGxiYWNrO1xufVxudmFyIFRSUENDbGllbnRFcnJvciA9IGNsYXNzIFRSUENDbGllbnRFcnJvcjIgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdHMpIHtcbiAgICB2YXIgX29wdHMkcmVzdWx0LCBfb3B0cyRyZXN1bHQyO1xuICAgIGNvbnN0IGNhdXNlID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5jYXVzZTtcbiAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlIH0pLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDUuZGVmYXVsdCkodGhpcywgXCJjYXVzZVwiLCB2b2lkIDApLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDUuZGVmYXVsdCkodGhpcywgXCJzaGFwZVwiLCB2b2lkIDApLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDUuZGVmYXVsdCkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCksICgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkkNS5kZWZhdWx0KSh0aGlzLCBcIm1ldGFcIiwgdm9pZCAwKSwgdGhpcy5tZXRhID0gb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5tZXRhLCB0aGlzLmNhdXNlID0gY2F1c2UsIHRoaXMuc2hhcGUgPSBvcHRzID09IG51bGwgfHwgKF9vcHRzJHJlc3VsdCA9IG9wdHMucmVzdWx0KSA9PT0gbnVsbCB8fCBfb3B0cyRyZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHJlc3VsdC5lcnJvciwgdGhpcy5kYXRhID0gb3B0cyA9PSBudWxsIHx8IChfb3B0cyRyZXN1bHQyID0gb3B0cy5yZXN1bHQpID09PSBudWxsIHx8IF9vcHRzJHJlc3VsdDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHJlc3VsdDIuZXJyb3IuZGF0YSwgdGhpcy5uYW1lID0gXCJUUlBDQ2xpZW50RXJyb3JcIiwgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRSUENDbGllbnRFcnJvcjIucHJvdG90eXBlKTtcbiAgfVxuICBzdGF0aWMgZnJvbShfY2F1c2UsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGNhdXNlID0gX2NhdXNlO1xuICAgIHJldHVybiBpc1RSUENDbGllbnRFcnJvcihjYXVzZSkgPyAob3B0cy5tZXRhICYmIChjYXVzZS5tZXRhID0gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoe30sIGNhdXNlLm1ldGEpLCBvcHRzLm1ldGEpKSwgY2F1c2UpIDogaXNUUlBDRXJyb3JSZXNwb25zZShjYXVzZSkgPyBuZXcgVFJQQ0NsaWVudEVycm9yMihjYXVzZS5lcnJvci5tZXNzYWdlLCAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSh7fSwgb3B0cyksIHt9LCB7IHJlc3VsdDogY2F1c2UgfSkpIDogbmV3IFRSUENDbGllbnRFcnJvcjIoZ2V0TWVzc2FnZUZyb21Vbmtub3duRXJyb3IoY2F1c2UsIFwiVW5rbm93biBlcnJvclwiKSwgKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoe30sIG9wdHMpLCB7fSwgeyBjYXVzZSB9KSk7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRUcmFuc2Zvcm1lcih0cmFuc2Zvcm1lcjIpIHtcbiAgY29uc3QgX3RyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXIyO1xuICByZXR1cm4gX3RyYW5zZm9ybWVyID8gXCJpbnB1dFwiIGluIF90cmFuc2Zvcm1lciA/IF90cmFuc2Zvcm1lciA6IHtcbiAgICBpbnB1dDogX3RyYW5zZm9ybWVyLFxuICAgIG91dHB1dDogX3RyYW5zZm9ybWVyXG4gIH0gOiB7XG4gICAgaW5wdXQ6IHtcbiAgICAgIHNlcmlhbGl6ZTogKGRhdGEpID0+IGRhdGEsXG4gICAgICBkZXNlcmlhbGl6ZTogKGRhdGEpID0+IGRhdGFcbiAgICB9LFxuICAgIG91dHB1dDoge1xuICAgICAgc2VyaWFsaXplOiAoZGF0YSkgPT4gZGF0YSxcbiAgICAgIGRlc2VyaWFsaXplOiAoZGF0YSkgPT4gZGF0YVxuICAgIH1cbiAgfTtcbn1cbl9fdG9FU00kMShyZXF1aXJlX29iamVjdFNwcmVhZDIkMSgpKTtcbl9fdG9FU00kMShyZXF1aXJlX29iamVjdFNwcmVhZDIkMSgpKTtcbl9fdG9FU00kMShyZXF1aXJlX29iamVjdFNwcmVhZDIkMSgpKTtcbl9fdG9FU00kMShyZXF1aXJlX29iamVjdFNwcmVhZDIkMSgpKTtcbmNvbnN0IGxhenlEZWZhdWx0cyA9IHtcbiAgZW5hYmxlZDogITEsXG4gIGNsb3NlTXM6IDBcbn0sIGtlZXBBbGl2ZURlZmF1bHRzID0ge1xuICBlbmFibGVkOiAhMSxcbiAgcG9uZ1RpbWVvdXRNczogMWUzLFxuICBpbnRlcnZhbE1zOiA1ZTNcbn0sIGV4cG9uZW50aWFsQmFja29mZiA9IChhdHRlbXB0SW5kZXgpID0+IGF0dGVtcHRJbmRleCA9PT0gMCA/IDAgOiBNYXRoLm1pbigxZTMgKiAyICoqIGF0dGVtcHRJbmRleCwgM2U0KSwgcmVzdWx0T2YgPSAodmFsdWUsIC4uLmFyZ3MpID0+IHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZSguLi5hcmdzKSA6IHZhbHVlO1xudmFyIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQzID0gX190b0VTTSQxKHJlcXVpcmVfZGVmaW5lUHJvcGVydHkkMSgpKSwgVFJQQ1dlYlNvY2tldENsb3NlZEVycm9yID0gY2xhc3MgVFJQQ1dlYlNvY2tldENsb3NlZEVycm9yMiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMubWVzc2FnZSwgeyBjYXVzZTogb3B0cy5jYXVzZSB9KSwgdGhpcy5uYW1lID0gXCJUUlBDV2ViU29ja2V0Q2xvc2VkRXJyb3JcIiwgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRSUENXZWJTb2NrZXRDbG9zZWRFcnJvcjIucHJvdG90eXBlKTtcbiAgfVxufSwgUmVzZXR0YWJsZVRpbWVvdXQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9uVGltZW91dCwgdGltZW91dE1zKSB7XG4gICAgdGhpcy5vblRpbWVvdXQgPSBvblRpbWVvdXQsIHRoaXMudGltZW91dE1zID0gdGltZW91dE1zLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDMuZGVmYXVsdCkodGhpcywgXCJ0aW1lb3V0XCIsIHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICogUmVzZXRzIHRoZSBjdXJyZW50IHRpbWVvdXQsIHJlc3RhcnRpbmcgaXQgd2l0aCB0aGUgc2FtZSBkdXJhdGlvbi5cbiAgKiBEb2VzIG5vdGhpbmcgaWYgbm8gdGltZW91dCBpcyBhY3RpdmUuXG4gICovXG4gIHJlc2V0KCkge1xuICAgIHRoaXMudGltZW91dCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCksIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5vblRpbWVvdXQsIHRoaXMudGltZW91dE1zKSk7XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCksIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5vblRpbWVvdXQsIHRoaXMudGltZW91dE1zKTtcbiAgfVxuICBzdG9wKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLCB0aGlzLnRpbWVvdXQgPSB2b2lkIDA7XG4gIH1cbn07XG5mdW5jdGlvbiB3aXRoUmVzb2x2ZXJzKCkge1xuICBsZXQgcmVzb2x2ZSwgcmVqZWN0O1xuICByZXR1cm4ge1xuICAgIHByb21pc2U6IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgcmVzb2x2ZSA9IHJlcywgcmVqZWN0ID0gcmVqO1xuICAgIH0pLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlVXJsKHVybE9wdGlvbnMpIHtcbiAgY29uc3QgdXJsID0gYXdhaXQgcmVzdWx0T2YodXJsT3B0aW9ucy51cmwpO1xuICBpZiAoIXVybE9wdGlvbnMuY29ubmVjdGlvblBhcmFtcykgcmV0dXJuIHVybDtcbiAgY29uc3QgY29ubmVjdGlvblBhcmFtcyA9IFxcYFxcJHt1cmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIn1jb25uZWN0aW9uUGFyYW1zPTFcXGA7XG4gIHJldHVybiB1cmwgKyBjb25uZWN0aW9uUGFyYW1zO1xufVxuYXN5bmMgZnVuY3Rpb24gYnVpbGRDb25uZWN0aW9uTWVzc2FnZShjb25uZWN0aW9uUGFyYW1zKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgbWV0aG9kOiBcImNvbm5lY3Rpb25QYXJhbXNcIixcbiAgICBkYXRhOiBhd2FpdCByZXN1bHRPZihjb25uZWN0aW9uUGFyYW1zKVxuICB9O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWVzc2FnZSk7XG59XG52YXIgaW1wb3J0X2RlZmluZVByb3BlcnR5JDIgPSBfX3RvRVNNJDEocmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSQxKCkpLCBSZXF1ZXN0TWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQyLmRlZmF1bHQpKHRoaXMsIFwib3V0Z29pbmdSZXF1ZXN0c1wiLCBuZXcgQXJyYXkoKSksICgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkkMi5kZWZhdWx0KSh0aGlzLCBcInBlbmRpbmdSZXF1ZXN0c1wiLCB7fSk7XG4gIH1cbiAgLyoqXG4gICogUmVnaXN0ZXJzIGEgbmV3IHJlcXVlc3QgYnkgYWRkaW5nIGl0IHRvIHRoZSBvdXRnb2luZyBxdWV1ZSBhbmQgc2V0dGluZyB1cFxuICAqIGNhbGxiYWNrcyBmb3IgbGlmZWN5Y2xlIGV2ZW50cyBzdWNoIGFzIGNvbXBsZXRpb24gb3IgZXJyb3IuXG4gICpcbiAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBvdXRnb2luZyBtZXNzYWdlIHRvIGJlIHNlbnQuXG4gICogQHBhcmFtIGNhbGxiYWNrcyAtIENhbGxiYWNrIGZ1bmN0aW9ucyB0byBvYnNlcnZlIHRoZSByZXF1ZXN0J3Mgc3RhdGUuXG4gICogQHJldHVybnMgQSBjbGVhbnVwIGZ1bmN0aW9uIHRvIG1hbnVhbGx5IHJlbW92ZSB0aGUgcmVxdWVzdC5cbiAgKi9cbiAgcmVnaXN0ZXIobWVzc2FnZSwgY2FsbGJhY2tzKSB7XG4gICAgY29uc3QgeyBwcm9taXNlOiBlbmQsIHJlc29sdmUgfSA9IHdpdGhSZXNvbHZlcnMoKTtcbiAgICByZXR1cm4gdGhpcy5vdXRnb2luZ1JlcXVlc3RzLnB1c2goe1xuICAgICAgaWQ6IFN0cmluZyhtZXNzYWdlLmlkKSxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBlbmQsXG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgbmV4dDogY2FsbGJhY2tzLm5leHQsXG4gICAgICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2tzLmNvbXBsZXRlKCksIHJlc29sdmUoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IChlKSA9PiB7XG4gICAgICAgICAgY2FsbGJhY2tzLmVycm9yKGUpLCByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgKCkgPT4ge1xuICAgICAgdGhpcy5kZWxldGUobWVzc2FnZS5pZCksIGNhbGxiYWNrcy5jb21wbGV0ZSgpLCByZXNvbHZlKCk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBEZWxldGVzIGEgcmVxdWVzdCBmcm9tIGJvdGggdGhlIG91dGdvaW5nIGFuZCBwZW5kaW5nIGNvbGxlY3Rpb25zLCBpZiBpdCBleGlzdHMuXG4gICovXG4gIGRlbGV0ZShtZXNzYWdlSWQpIHtcbiAgICBtZXNzYWdlSWQgIT09IG51bGwgJiYgKHRoaXMub3V0Z29pbmdSZXF1ZXN0cyA9IHRoaXMub3V0Z29pbmdSZXF1ZXN0cy5maWx0ZXIoKHsgaWQgfSkgPT4gaWQgIT09IFN0cmluZyhtZXNzYWdlSWQpKSwgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW1N0cmluZyhtZXNzYWdlSWQpXSk7XG4gIH1cbiAgLyoqXG4gICogTW92ZXMgYWxsIG91dGdvaW5nIHJlcXVlc3RzIHRvIHRoZSBwZW5kaW5nIHN0YXRlIGFuZCBjbGVhcnMgdGhlIG91dGdvaW5nIHF1ZXVlLlxuICAqXG4gICogVGhlIGNhbGxlciBpcyBleHBlY3RlZCB0byBoYW5kbGUgdGhlIGFjdHVhbCBzZW5kaW5nIG9mIHRoZSByZXF1ZXN0c1xuICAqIChlLmcuLCBzZW5kaW5nIHRoZW0gb3ZlciB0aGUgbmV0d29yaykgYWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICAqXG4gICogQHJldHVybnMgVGhlIGxpc3Qgb2YgcmVxdWVzdHMgdGhhdCB3ZXJlIHRyYW5zaXRpb25lZCB0byB0aGUgcGVuZGluZyBzdGF0ZS5cbiAgKi9cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgcmVxdWVzdHMgPSB0aGlzLm91dGdvaW5nUmVxdWVzdHM7XG4gICAgdGhpcy5vdXRnb2luZ1JlcXVlc3RzID0gW107XG4gICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1tyZXF1ZXN0LmlkXSA9IHJlcXVlc3Q7XG4gICAgcmV0dXJuIHJlcXVlc3RzO1xuICB9XG4gIC8qKlxuICAqIFJldHJpZXZlcyBhbGwgY3VycmVudGx5IHBlbmRpbmcgcmVxdWVzdHMsIHdoaWNoIGFyZSBpbiBmbGlnaHQgYXdhaXRpbmcgcmVzcG9uc2VzXG4gICogb3IgaGFuZGxpbmcgb25nb2luZyBzdWJzY3JpcHRpb25zLlxuICAqL1xuICBnZXRQZW5kaW5nUmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5wZW5kaW5nUmVxdWVzdHMpO1xuICB9XG4gIC8qKlxuICAqIFJldHJpZXZlcyBhIHNwZWNpZmljIHBlbmRpbmcgcmVxdWVzdCBieSBpdHMgbWVzc2FnZSBJRC5cbiAgKi9cbiAgZ2V0UGVuZGluZ1JlcXVlc3QobWVzc2FnZUlkKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2VJZCA9PT0gbnVsbCA/IG51bGwgOiB0aGlzLnBlbmRpbmdSZXF1ZXN0c1tTdHJpbmcobWVzc2FnZUlkKV07XG4gIH1cbiAgLyoqXG4gICogUmV0cmlldmVzIGFsbCBvdXRnb2luZyByZXF1ZXN0cywgd2hpY2ggYXJlIHdhaXRpbmcgdG8gYmUgc2VudC5cbiAgKi9cbiAgZ2V0T3V0Z29pbmdSZXF1ZXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRnb2luZ1JlcXVlc3RzO1xuICB9XG4gIC8qKlxuICAqIFJldHJpZXZlcyBhbGwgcmVxdWVzdHMsIGJvdGggb3V0Z29pbmcgYW5kIHBlbmRpbmcsIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBzdGF0ZXMuXG4gICpcbiAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgcmVxdWVzdHMgd2l0aCB0aGVpciBzdGF0ZSAoXCJvdXRnb2luZ1wiIG9yIFwicGVuZGluZ1wiKS5cbiAgKi9cbiAgZ2V0UmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmdldE91dGdvaW5nUmVxdWVzdHMoKS5tYXAoKHJlcXVlc3QpID0+ICh7XG4gICAgICBzdGF0ZTogXCJvdXRnb2luZ1wiLFxuICAgICAgbWVzc2FnZTogcmVxdWVzdC5tZXNzYWdlLFxuICAgICAgZW5kOiByZXF1ZXN0LmVuZCxcbiAgICAgIGNhbGxiYWNrczogcmVxdWVzdC5jYWxsYmFja3NcbiAgICB9KSksIC4uLnRoaXMuZ2V0UGVuZGluZ1JlcXVlc3RzKCkubWFwKChyZXF1ZXN0KSA9PiAoe1xuICAgICAgc3RhdGU6IFwicGVuZGluZ1wiLFxuICAgICAgbWVzc2FnZTogcmVxdWVzdC5tZXNzYWdlLFxuICAgICAgZW5kOiByZXF1ZXN0LmVuZCxcbiAgICAgIGNhbGxiYWNrczogcmVxdWVzdC5jYWxsYmFja3NcbiAgICB9KSldO1xuICB9XG4gIC8qKlxuICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgcmVxdWVzdHMsIGluY2x1ZGluZyBvbmdvaW5nIHN1YnNjcmlwdGlvbnMuXG4gICovXG4gIGhhc1BlbmRpbmdSZXF1ZXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQZW5kaW5nUmVxdWVzdHMoKS5sZW5ndGggPiAwO1xuICB9XG4gIC8qKlxuICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IHBlbmRpbmcgc3Vic2NyaXB0aW9uc1xuICAqL1xuICBoYXNQZW5kaW5nU3Vic2NyaXB0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQZW5kaW5nUmVxdWVzdHMoKS5zb21lKChyZXF1ZXN0KSA9PiByZXF1ZXN0Lm1lc3NhZ2UubWV0aG9kID09PSBcInN1YnNjcmlwdGlvblwiKTtcbiAgfVxuICAvKipcbiAgKiBDaGVja3MgaWYgdGhlcmUgYXJlIGFueSBvdXRnb2luZyByZXF1ZXN0cyB3YWl0aW5nIHRvIGJlIHNlbnQuXG4gICovXG4gIGhhc091dGdvaW5nUmVxdWVzdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0Z29pbmdSZXF1ZXN0cy5sZW5ndGggPiAwO1xuICB9XG59LCBpbXBvcnRfZGVmaW5lUHJvcGVydHkkMSA9IF9fdG9FU00kMShyZXF1aXJlX2RlZmluZVByb3BlcnR5JDEoKSk7XG5mdW5jdGlvbiBhc3luY1dzT3Blbih3cykge1xuICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gd2l0aFJlc29sdmVycygpO1xuICByZXR1cm4gd3MuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgIHdzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZWplY3QpLCByZXNvbHZlKCk7XG4gIH0pLCB3cy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVqZWN0KSwgcHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHNldHVwUGluZ0ludGVydmFsKHdzLCB7IGludGVydmFsTXMsIHBvbmdUaW1lb3V0TXMgfSkge1xuICBsZXQgcGluZ1RpbWVvdXQsIHBvbmdUaW1lb3V0O1xuICBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBwaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd3Muc2VuZChcIlBJTkdcIiksIHBvbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICB9LCBwb25nVGltZW91dE1zKTtcbiAgICB9LCBpbnRlcnZhbE1zKTtcbiAgfVxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQocGluZ1RpbWVvdXQpLCBzdGFydCgpO1xuICB9XG4gIGZ1bmN0aW9uIHBvbmcoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHBvbmdUaW1lb3V0KSwgcmVzZXQoKTtcbiAgfVxuICB3cy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCBzdGFydCksIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7IGRhdGEgfSkgPT4ge1xuICAgIGNsZWFyVGltZW91dChwaW5nVGltZW91dCksIHN0YXJ0KCksIGRhdGEgPT09IFwiUE9OR1wiICYmIHBvbmcoKTtcbiAgfSksIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHBpbmdUaW1lb3V0KSwgY2xlYXJUaW1lb3V0KHBvbmdUaW1lb3V0KTtcbiAgfSk7XG59XG52YXIgV3NDb25uZWN0aW9uID0gY2xhc3MgV3NDb25uZWN0aW9uMiB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB2YXIgX29wdHMkV2ViU29ja2V0UG9ueWZpO1xuICAgIGlmICgoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDEuZGVmYXVsdCkodGhpcywgXCJpZFwiLCArK1dzQ29ubmVjdGlvbjIuY29ubmVjdENvdW50KSwgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQxLmRlZmF1bHQpKHRoaXMsIFwiV2ViU29ja2V0UG9ueWZpbGxcIiwgdm9pZCAwKSwgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQxLmRlZmF1bHQpKHRoaXMsIFwidXJsT3B0aW9uc1wiLCB2b2lkIDApLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDEuZGVmYXVsdCkodGhpcywgXCJrZWVwQWxpdmVPcHRzXCIsIHZvaWQgMCksICgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkkMS5kZWZhdWx0KSh0aGlzLCBcIndzT2JzZXJ2YWJsZVwiLCBiZWhhdmlvclN1YmplY3QobnVsbCkpLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDEuZGVmYXVsdCkodGhpcywgXCJvcGVuUHJvbWlzZVwiLCBudWxsKSwgdGhpcy5XZWJTb2NrZXRQb255ZmlsbCA9IChfb3B0cyRXZWJTb2NrZXRQb255ZmkgPSBvcHRzLldlYlNvY2tldFBvbnlmaWxsKSAhPT0gbnVsbCAmJiBfb3B0cyRXZWJTb2NrZXRQb255ZmkgIT09IHZvaWQgMCA/IF9vcHRzJFdlYlNvY2tldFBvbnlmaSA6IFdlYlNvY2tldCwgIXRoaXMuV2ViU29ja2V0UG9ueWZpbGwpIHRocm93IG5ldyBFcnJvcihcIk5vIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiBmb3VuZCAtIHlvdSBwcm9iYWJseSBkb24ndCB3YW50IHRvIHVzZSB0aGlzIG9uIHRoZSBzZXJ2ZXIsIGJ1dCBpZiB5b3UgZG8geW91IG5lZWQgdG8gcGFzcyBhIFxcYFdlYlNvY2tldFxcYC1wb255ZmlsbFwiKTtcbiAgICB0aGlzLnVybE9wdGlvbnMgPSBvcHRzLnVybE9wdGlvbnMsIHRoaXMua2VlcEFsaXZlT3B0cyA9IG9wdHMua2VlcEFsaXZlO1xuICB9XG4gIGdldCB3cygpIHtcbiAgICByZXR1cm4gdGhpcy53c09ic2VydmFibGUuZ2V0KCk7XG4gIH1cbiAgc2V0IHdzKHdzKSB7XG4gICAgdGhpcy53c09ic2VydmFibGUubmV4dCh3cyk7XG4gIH1cbiAgLyoqXG4gICogQ2hlY2tzIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBvcGVuIGFuZCByZWFkeSB0byBjb21tdW5pY2F0ZS5cbiAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiAhIXRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSB0aGlzLldlYlNvY2tldFBvbnlmaWxsLk9QRU4gJiYgIXRoaXMub3BlblByb21pc2U7XG4gIH1cbiAgLyoqXG4gICogQ2hlY2tzIGlmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBjbG9zZWQgb3IgaW4gdGhlIHByb2Nlc3Mgb2YgY2xvc2luZy5cbiAgKi9cbiAgaXNDbG9zZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy53cyAmJiAodGhpcy53cy5yZWFkeVN0YXRlID09PSB0aGlzLldlYlNvY2tldFBvbnlmaWxsLkNMT1NJTkcgfHwgdGhpcy53cy5yZWFkeVN0YXRlID09PSB0aGlzLldlYlNvY2tldFBvbnlmaWxsLkNMT1NFRCk7XG4gIH1cbiAgYXN5bmMgb3BlbigpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChfdGhpcy5vcGVuUHJvbWlzZSkgcmV0dXJuIF90aGlzLm9wZW5Qcm9taXNlO1xuICAgIF90aGlzLmlkID0gKytXc0Nvbm5lY3Rpb24yLmNvbm5lY3RDb3VudDtcbiAgICBjb25zdCB3c1Byb21pc2UgPSBwcmVwYXJlVXJsKF90aGlzLnVybE9wdGlvbnMpLnRoZW4oKHVybCkgPT4gbmV3IF90aGlzLldlYlNvY2tldFBvbnlmaWxsKHVybCkpO1xuICAgIF90aGlzLm9wZW5Qcm9taXNlID0gd3NQcm9taXNlLnRoZW4oYXN5bmMgKHdzKSA9PiB7XG4gICAgICBfdGhpcy53cyA9IHdzLCB3cy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbih7IGRhdGEgfSkge1xuICAgICAgICBkYXRhID09PSBcIlBJTkdcIiAmJiB0aGlzLnNlbmQoXCJQT05HXCIpO1xuICAgICAgfSksIF90aGlzLmtlZXBBbGl2ZU9wdHMuZW5hYmxlZCAmJiBzZXR1cFBpbmdJbnRlcnZhbCh3cywgX3RoaXMua2VlcEFsaXZlT3B0cyksIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIF90aGlzLndzID09PSB3cyAmJiAoX3RoaXMud3MgPSBudWxsKTtcbiAgICAgIH0pLCBhd2FpdCBhc3luY1dzT3Blbih3cyksIF90aGlzLnVybE9wdGlvbnMuY29ubmVjdGlvblBhcmFtcyAmJiB3cy5zZW5kKGF3YWl0IGJ1aWxkQ29ubmVjdGlvbk1lc3NhZ2UoX3RoaXMudXJsT3B0aW9ucy5jb25uZWN0aW9uUGFyYW1zKSk7XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IF90aGlzLm9wZW5Qcm9taXNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfdGhpcy5vcGVuUHJvbWlzZSA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIENsb3NlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ3JhY2VmdWxseS5cbiAgKiBXYWl0cyBmb3IgYW55IG9uZ29pbmcgb3BlbiBvcGVyYXRpb24gdG8gY29tcGxldGUgYmVmb3JlIGNsb3NpbmcuXG4gICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfdGhpczIub3BlblByb21pc2U7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBfdGhpcyR3cztcbiAgICAgIChfdGhpcyR3cyA9IF90aGlzMi53cykgPT09IG51bGwgfHwgX3RoaXMkd3MgPT09IHZvaWQgMCB8fCBfdGhpcyR3cy5jbG9zZSgpO1xuICAgIH1cbiAgfVxufTtcbigwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkkMS5kZWZhdWx0KShXc0Nvbm5lY3Rpb24sIFwiY29ubmVjdENvdW50XCIsIDApO1xuZnVuY3Rpb24gYmFja3dhcmRDb21wYXRpYmlsaXR5KGNvbm5lY3Rpb24pIHtcbiAgcmV0dXJuIGNvbm5lY3Rpb24uaXNPcGVuKCkgPyB7XG4gICAgaWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgc3RhdGU6IFwib3BlblwiLFxuICAgIHdzOiBjb25uZWN0aW9uLndzXG4gIH0gOiBjb25uZWN0aW9uLmlzQ2xvc2VkKCkgPyB7XG4gICAgaWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgc3RhdGU6IFwiY2xvc2VkXCIsXG4gICAgd3M6IGNvbm5lY3Rpb24ud3NcbiAgfSA6IGNvbm5lY3Rpb24ud3MgPyB7XG4gICAgaWQ6IGNvbm5lY3Rpb24uaWQsXG4gICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgIHdzOiBjb25uZWN0aW9uLndzXG4gIH0gOiBudWxsO1xufVxudmFyIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQ0ID0gX190b0VTTSQxKHJlcXVpcmVfZGVmaW5lUHJvcGVydHkkMSgpKSwgaW1wb3J0X29iamVjdFNwcmVhZDIgPSBfX3RvRVNNJDEocmVxdWlyZV9vYmplY3RTcHJlYWQyJDEoKSksIFdzQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdmFyIF9vcHRzJHJldHJ5RGVsYXlNcztcbiAgICAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDQuZGVmYXVsdCkodGhpcywgXCJjb25uZWN0aW9uU3RhdGVcIiwgdm9pZCAwKSwgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQ0LmRlZmF1bHQpKHRoaXMsIFwiYWxsb3dSZWNvbm5lY3RcIiwgITEpLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDQuZGVmYXVsdCkodGhpcywgXCJyZXF1ZXN0TWFuYWdlclwiLCBuZXcgUmVxdWVzdE1hbmFnZXIoKSksICgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkkNC5kZWZhdWx0KSh0aGlzLCBcImFjdGl2ZUNvbm5lY3Rpb25cIiwgdm9pZCAwKSwgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQ0LmRlZmF1bHQpKHRoaXMsIFwicmVjb25uZWN0UmV0cnlEZWxheVwiLCB2b2lkIDApLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDQuZGVmYXVsdCkodGhpcywgXCJpbmFjdGl2aXR5VGltZW91dFwiLCB2b2lkIDApLCAoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5JDQuZGVmYXVsdCkodGhpcywgXCJjYWxsYmFja3NcIiwgdm9pZCAwKSwgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQ0LmRlZmF1bHQpKHRoaXMsIFwibGF6eU1vZGVcIiwgdm9pZCAwKSwgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSQ0LmRlZmF1bHQpKHRoaXMsIFwicmVjb25uZWN0aW5nXCIsIG51bGwpLCB0aGlzLmNhbGxiYWNrcyA9IHtcbiAgICAgIG9uT3Blbjogb3B0cy5vbk9wZW4sXG4gICAgICBvbkNsb3NlOiBvcHRzLm9uQ2xvc2UsXG4gICAgICBvbkVycm9yOiBvcHRzLm9uRXJyb3JcbiAgICB9O1xuICAgIGNvbnN0IGxhenlPcHRpb25zID0gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgbGF6eURlZmF1bHRzKSwgb3B0cy5sYXp5KTtcbiAgICB0aGlzLmluYWN0aXZpdHlUaW1lb3V0ID0gbmV3IFJlc2V0dGFibGVUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc091dGdvaW5nUmVxdWVzdHMoKSB8fCB0aGlzLnJlcXVlc3RNYW5hZ2VyLmhhc1BlbmRpbmdSZXF1ZXN0cygpKSB7XG4gICAgICAgIHRoaXMuaW5hY3Rpdml0eVRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5jbG9zZSgpLmNhdGNoKCgpID0+IG51bGwpO1xuICAgIH0sIGxhenlPcHRpb25zLmNsb3NlTXMpLCB0aGlzLmFjdGl2ZUNvbm5lY3Rpb24gPSBuZXcgV3NDb25uZWN0aW9uKHtcbiAgICAgIFdlYlNvY2tldFBvbnlmaWxsOiBvcHRzLldlYlNvY2tldCxcbiAgICAgIHVybE9wdGlvbnM6IG9wdHMsXG4gICAgICBrZWVwQWxpdmU6ICgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIGtlZXBBbGl2ZURlZmF1bHRzKSwgb3B0cy5rZWVwQWxpdmUpXG4gICAgfSksIHRoaXMuYWN0aXZlQ29ubmVjdGlvbi53c09ic2VydmFibGUuc3Vic2NyaWJlKHsgbmV4dDogKHdzKSA9PiB7XG4gICAgICB3cyAmJiB0aGlzLnNldHVwV2ViU29ja2V0TGlzdGVuZXJzKHdzKTtcbiAgICB9IH0pLCB0aGlzLnJlY29ubmVjdFJldHJ5RGVsYXkgPSAoX29wdHMkcmV0cnlEZWxheU1zID0gb3B0cy5yZXRyeURlbGF5TXMpICE9PSBudWxsICYmIF9vcHRzJHJldHJ5RGVsYXlNcyAhPT0gdm9pZCAwID8gX29wdHMkcmV0cnlEZWxheU1zIDogZXhwb25lbnRpYWxCYWNrb2ZmLCB0aGlzLmxhenlNb2RlID0gbGF6eU9wdGlvbnMuZW5hYmxlZCwgdGhpcy5jb25uZWN0aW9uU3RhdGUgPSBiZWhhdmlvclN1YmplY3Qoe1xuICAgICAgdHlwZTogXCJzdGF0ZVwiLFxuICAgICAgc3RhdGU6IGxhenlPcHRpb25zLmVuYWJsZWQgPyBcImlkbGVcIiA6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KSwgdGhpcy5sYXp5TW9kZSB8fCB0aGlzLm9wZW4oKS5jYXRjaCgoKSA9PiBudWxsKTtcbiAgfVxuICAvKipcbiAgKiBPcGVucyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uIEhhbmRsZXMgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGFuZCB1cGRhdGVzXG4gICogdGhlIGNvbm5lY3Rpb24gc3RhdGUgYWNjb3JkaW5nbHkuXG4gICovXG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfdGhpcy5hbGxvd1JlY29ubmVjdCA9ICEwLCBfdGhpcy5jb25uZWN0aW9uU3RhdGUuZ2V0KCkuc3RhdGUgIT09IFwiY29ubmVjdGluZ1wiICYmIF90aGlzLmNvbm5lY3Rpb25TdGF0ZS5uZXh0KHtcbiAgICAgIHR5cGU6IFwic3RhdGVcIixcbiAgICAgIHN0YXRlOiBcImNvbm5lY3RpbmdcIixcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IF90aGlzLmFjdGl2ZUNvbm5lY3Rpb24ub3BlbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gX3RoaXMucmVjb25uZWN0KG5ldyBUUlBDV2ViU29ja2V0Q2xvc2VkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkluaXRpYWxpemF0aW9uIGVycm9yXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvclxuICAgICAgfSkpLCBfdGhpcy5yZWNvbm5lY3Rpbmc7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIENsb3NlcyB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYW5kIHN0b3BzIG1hbmFnaW5nIHJlcXVlc3RzLlxuICAqIEVuc3VyZXMgYWxsIG91dGdvaW5nIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGFyZSBwcm9wZXJseSBmaW5hbGl6ZWQuXG4gICovXG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIF90aGlzMi5hbGxvd1JlY29ubmVjdCA9ICExLCBfdGhpczIuaW5hY3Rpdml0eVRpbWVvdXQuc3RvcCgpO1xuICAgIGNvbnN0IHJlcXVlc3RzVG9Bd2FpdCA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiBfdGhpczIucmVxdWVzdE1hbmFnZXIuZ2V0UmVxdWVzdHMoKSkgcmVxdWVzdC5tZXNzYWdlLm1ldGhvZCA9PT0gXCJzdWJzY3JpcHRpb25cIiA/IHJlcXVlc3QuY2FsbGJhY2tzLmNvbXBsZXRlKCkgOiByZXF1ZXN0LnN0YXRlID09PSBcIm91dGdvaW5nXCIgPyByZXF1ZXN0LmNhbGxiYWNrcy5lcnJvcihUUlBDQ2xpZW50RXJyb3IuZnJvbShuZXcgVFJQQ1dlYlNvY2tldENsb3NlZEVycm9yKHsgbWVzc2FnZTogXCJDbG9zZWQgYmVmb3JlIGNvbm5lY3Rpb24gd2FzIGVzdGFibGlzaGVkXCIgfSkpKSA6IHJlcXVlc3RzVG9Bd2FpdC5wdXNoKHJlcXVlc3QuZW5kKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChyZXF1ZXN0c1RvQXdhaXQpLmNhdGNoKCgpID0+IG51bGwpLCBhd2FpdCBfdGhpczIuYWN0aXZlQ29ubmVjdGlvbi5jbG9zZSgpLmNhdGNoKCgpID0+IG51bGwpLCBfdGhpczIuY29ubmVjdGlvblN0YXRlLm5leHQoe1xuICAgICAgdHlwZTogXCJzdGF0ZVwiLFxuICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBNZXRob2QgdG8gcmVxdWVzdCB0aGUgc2VydmVyLlxuICAqIEhhbmRsZXMgZGF0YSB0cmFuc2Zvcm1hdGlvbiwgYmF0Y2hpbmcgb2YgcmVxdWVzdHMsIGFuZCBzdWJzY3JpcHRpb24gbGlmZWN5Y2xlLlxuICAqXG4gICogQHBhcmFtIG9wIC0gVGhlIG9wZXJhdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBpZCwgdHlwZSwgcGF0aCwgaW5wdXQgYW5kIHNpZ25hbFxuICAqIEBwYXJhbSB0cmFuc2Zvcm1lciAtIERhdGEgdHJhbnNmb3JtZXIgZm9yIHNlcmlhbGl6aW5nIHJlcXVlc3RzIGFuZCBkZXNlcmlhbGl6aW5nIHJlc3BvbnNlc1xuICAqIEBwYXJhbSBsYXN0RXZlbnRJZCAtIE9wdGlvbmFsIElEIG9mIHRoZSBsYXN0IHJlY2VpdmVkIGV2ZW50IGZvciBzdWJzY3JpcHRpb25zXG4gICpcbiAgKiBAcmV0dXJucyBBbiBvYnNlcnZhYmxlIHRoYXQgZW1pdHMgb3BlcmF0aW9uIHJlc3VsdHMgYW5kIGhhbmRsZXMgY2xlYW51cFxuICAqL1xuICByZXF1ZXN0KHsgb3A6IHsgaWQsIHR5cGUsIHBhdGgsIGlucHV0LCBzaWduYWwgfSwgdHJhbnNmb3JtZXI6IHRyYW5zZm9ybWVyMiwgbGFzdEV2ZW50SWQgfSkge1xuICAgIHJldHVybiBvYnNlcnZhYmxlKChvYnNlcnZlcikgPT4ge1xuICAgICAgY29uc3QgYWJvcnQgPSB0aGlzLmJhdGNoU2VuZCh7XG4gICAgICAgIGlkLFxuICAgICAgICBtZXRob2Q6IHR5cGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGlucHV0OiB0cmFuc2Zvcm1lcjIuaW5wdXQuc2VyaWFsaXplKGlucHV0KSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIGxhc3RFdmVudElkXG4gICAgICAgIH1cbiAgICAgIH0sICgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIuZGVmYXVsdCkoe30sIG9ic2VydmVyKSwge30sIHsgbmV4dChldmVudCkge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IHRyYW5zZm9ybVJlc3VsdChldmVudCwgdHJhbnNmb3JtZXIyLm91dHB1dCk7XG4gICAgICAgIGlmICghdHJhbnNmb3JtZWQub2spIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihUUlBDQ2xpZW50RXJyb3IuZnJvbSh0cmFuc2Zvcm1lZC5lcnJvcikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvYnNlcnZlci5uZXh0KHsgcmVzdWx0OiB0cmFuc2Zvcm1lZC5yZXN1bHQgfSk7XG4gICAgICB9IH0pKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGFib3J0KCksIHR5cGUgPT09IFwic3Vic2NyaXB0aW9uXCIgJiYgdGhpcy5hY3RpdmVDb25uZWN0aW9uLmlzT3BlbigpICYmIHRoaXMuc2VuZCh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbWV0aG9kOiBcInN1YnNjcmlwdGlvbi5zdG9wXCJcbiAgICAgICAgfSksIHNpZ25hbCA9PSBudWxsIHx8IHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnQpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICBnZXQgY29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gYmFja3dhcmRDb21wYXRpYmlsaXR5KHRoaXMuYWN0aXZlQ29ubmVjdGlvbik7XG4gIH1cbiAgcmVjb25uZWN0KGNsb3NlZEVycm9yKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblN0YXRlLm5leHQoe1xuICAgICAgdHlwZTogXCJzdGF0ZVwiLFxuICAgICAgc3RhdGU6IFwiY29ubmVjdGluZ1wiLFxuICAgICAgZXJyb3I6IFRSUENDbGllbnRFcnJvci5mcm9tKGNsb3NlZEVycm9yKVxuICAgIH0pLCB0aGlzLnJlY29ubmVjdGluZykgcmV0dXJuO1xuICAgIGNvbnN0IHRyeVJlY29ubmVjdCA9IGFzeW5jIChhdHRlbXB0SW5kZXgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKF90aGlzMy5yZWNvbm5lY3RSZXRyeURlbGF5KGF0dGVtcHRJbmRleCkpLCBfdGhpczMuYWxsb3dSZWNvbm5lY3QgJiYgKGF3YWl0IF90aGlzMy5hY3RpdmVDb25uZWN0aW9uLmNsb3NlKCksIGF3YWl0IF90aGlzMy5hY3RpdmVDb25uZWN0aW9uLm9wZW4oKSwgX3RoaXMzLnJlcXVlc3RNYW5hZ2VyLmhhc1BlbmRpbmdSZXF1ZXN0cygpICYmIF90aGlzMy5zZW5kKF90aGlzMy5yZXF1ZXN0TWFuYWdlci5nZXRQZW5kaW5nUmVxdWVzdHMoKS5tYXAoKHsgbWVzc2FnZSB9KSA9PiBtZXNzYWdlKSkpLCBfdGhpczMucmVjb25uZWN0aW5nID0gbnVsbDtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICBhd2FpdCB0cnlSZWNvbm5lY3QoYXR0ZW1wdEluZGV4ICsgMSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRyeVJlY29ubmVjdCgwKTtcbiAgfVxuICBzZXR1cFdlYlNvY2tldExpc3RlbmVycyh3cykge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgIGNvbnN0IGhhbmRsZUNsb3NlT3JFcnJvciA9IChjYXVzZSkgPT4ge1xuICAgICAgY29uc3QgcmVxcyA9IHRoaXMucmVxdWVzdE1hbmFnZXIuZ2V0UGVuZGluZ1JlcXVlc3RzKCk7XG4gICAgICBmb3IgKGNvbnN0IHsgbWVzc2FnZSwgY2FsbGJhY2tzIH0gb2YgcmVxcylcbiAgICAgICAgbWVzc2FnZS5tZXRob2QgIT09IFwic3Vic2NyaXB0aW9uXCIgJiYgKGNhbGxiYWNrcy5lcnJvcihUUlBDQ2xpZW50RXJyb3IuZnJvbShjYXVzZSA/PyBuZXcgVFJQQ1dlYlNvY2tldENsb3NlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIldlYlNvY2tldCBjbG9zZWRcIixcbiAgICAgICAgICBjYXVzZVxuICAgICAgICB9KSkpLCB0aGlzLnJlcXVlc3RNYW5hZ2VyLmRlbGV0ZShtZXNzYWdlLmlkKSk7XG4gICAgfTtcbiAgICB3cy5hZGRFdmVudExpc3RlbmVyKFwib3BlblwiLCAoKSA9PiB7XG4gICAgICBydW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzJG9uT3BlLCBfdGhpcyRjYWxsYmFja3M7XG4gICAgICAgIF90aGlzNC5sYXp5TW9kZSAmJiBfdGhpczQuaW5hY3Rpdml0eVRpbWVvdXQuc3RhcnQoKSwgKF90aGlzJGNhbGxiYWNrcyRvbk9wZSA9IChfdGhpcyRjYWxsYmFja3MgPSBfdGhpczQuY2FsbGJhY2tzKS5vbk9wZW4pID09PSBudWxsIHx8IF90aGlzJGNhbGxiYWNrcyRvbk9wZSA9PT0gdm9pZCAwIHx8IF90aGlzJGNhbGxiYWNrcyRvbk9wZS5jYWxsKF90aGlzJGNhbGxiYWNrcyksIF90aGlzNC5jb25uZWN0aW9uU3RhdGUubmV4dCh7XG4gICAgICAgICAgdHlwZTogXCJzdGF0ZVwiLFxuICAgICAgICAgIHN0YXRlOiBcInBlbmRpbmdcIixcbiAgICAgICAgICBlcnJvcjogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICB3cy5jbG9zZSgzZTMpLCBoYW5kbGVDbG9zZU9yRXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgfSksIHdzLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7IGRhdGEgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuaW5hY3Rpdml0eVRpbWVvdXQucmVzZXQoKSwgdHlwZW9mIGRhdGEgIT0gXCJzdHJpbmdcIiB8fCBbXCJQSU5HXCIsIFwiUE9OR1wiXS5pbmNsdWRlcyhkYXRhKSkgcmV0dXJuO1xuICAgICAgY29uc3QgaW5jb21pbmdNZXNzYWdlID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIGlmIChcIm1ldGhvZFwiIGluIGluY29taW5nTWVzc2FnZSkge1xuICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUmVxdWVzdChpbmNvbWluZ01lc3NhZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlTWVzc2FnZShpbmNvbWluZ01lc3NhZ2UpO1xuICAgIH0pLCB3cy5hZGRFdmVudExpc3RlbmVyKFwiY2xvc2VcIiwgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX3RoaXMkY2FsbGJhY2tzJG9uQ2xvLCBfdGhpcyRjYWxsYmFja3MyO1xuICAgICAgaGFuZGxlQ2xvc2VPckVycm9yKGV2ZW50KSwgKF90aGlzJGNhbGxiYWNrcyRvbkNsbyA9IChfdGhpcyRjYWxsYmFja3MyID0gdGhpcy5jYWxsYmFja3MpLm9uQ2xvc2UpID09PSBudWxsIHx8IF90aGlzJGNhbGxiYWNrcyRvbkNsbyA9PT0gdm9pZCAwIHx8IF90aGlzJGNhbGxiYWNrcyRvbkNsby5jYWxsKF90aGlzJGNhbGxiYWNrczIsIGV2ZW50KSwgKCF0aGlzLmxhenlNb2RlIHx8IHRoaXMucmVxdWVzdE1hbmFnZXIuaGFzUGVuZGluZ1N1YnNjcmlwdGlvbnMoKSkgJiYgdGhpcy5yZWNvbm5lY3QobmV3IFRSUENXZWJTb2NrZXRDbG9zZWRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiV2ViU29ja2V0IGNsb3NlZFwiLFxuICAgICAgICBjYXVzZTogZXZlbnRcbiAgICAgIH0pKTtcbiAgICB9KSwgd3MuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChldmVudCkgPT4ge1xuICAgICAgdmFyIF90aGlzJGNhbGxiYWNrcyRvbkVyciwgX3RoaXMkY2FsbGJhY2tzMztcbiAgICAgIGhhbmRsZUNsb3NlT3JFcnJvcihldmVudCksIChfdGhpcyRjYWxsYmFja3Mkb25FcnIgPSAoX3RoaXMkY2FsbGJhY2tzMyA9IHRoaXMuY2FsbGJhY2tzKS5vbkVycm9yKSA9PT0gbnVsbCB8fCBfdGhpcyRjYWxsYmFja3Mkb25FcnIgPT09IHZvaWQgMCB8fCBfdGhpcyRjYWxsYmFja3Mkb25FcnIuY2FsbChfdGhpcyRjYWxsYmFja3MzLCBldmVudCksIHRoaXMucmVjb25uZWN0KG5ldyBUUlBDV2ViU29ja2V0Q2xvc2VkRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIldlYlNvY2tldCBjbG9zZWRcIixcbiAgICAgICAgY2F1c2U6IGV2ZW50XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlUmVzcG9uc2VNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0TWFuYWdlci5nZXRQZW5kaW5nUmVxdWVzdChtZXNzYWdlLmlkKTtcbiAgICBpZiAoIXJlcXVlc3QpIHJldHVybjtcbiAgICByZXF1ZXN0LmNhbGxiYWNrcy5uZXh0KG1lc3NhZ2UpO1xuICAgIGxldCBjb21wbGV0ZWQgPSAhMDtcbiAgICBcInJlc3VsdFwiIGluIG1lc3NhZ2UgJiYgcmVxdWVzdC5tZXNzYWdlLm1ldGhvZCA9PT0gXCJzdWJzY3JpcHRpb25cIiAmJiAobWVzc2FnZS5yZXN1bHQudHlwZSA9PT0gXCJkYXRhXCIgJiYgKHJlcXVlc3QubWVzc2FnZS5wYXJhbXMubGFzdEV2ZW50SWQgPSBtZXNzYWdlLnJlc3VsdC5pZCksIG1lc3NhZ2UucmVzdWx0LnR5cGUgIT09IFwic3RvcHBlZFwiICYmIChjb21wbGV0ZWQgPSAhMSkpLCBjb21wbGV0ZWQgJiYgKHJlcXVlc3QuY2FsbGJhY2tzLmNvbXBsZXRlKCksIHRoaXMucmVxdWVzdE1hbmFnZXIuZGVsZXRlKG1lc3NhZ2UuaWQpKTtcbiAgfVxuICBoYW5kbGVJbmNvbWluZ1JlcXVlc3QobWVzc2FnZSkge1xuICAgIG1lc3NhZ2UubWV0aG9kID09PSBcInJlY29ubmVjdFwiICYmIHRoaXMucmVjb25uZWN0KG5ldyBUUlBDV2ViU29ja2V0Q2xvc2VkRXJyb3IoeyBtZXNzYWdlOiBcIlNlcnZlciByZXF1ZXN0ZWQgcmVjb25uZWN0XCIgfSkpO1xuICB9XG4gIC8qKlxuICAqIFNlbmRzIGEgbWVzc2FnZSBvciBiYXRjaCBvZiBtZXNzYWdlcyBkaXJlY3RseSB0byB0aGUgc2VydmVyLlxuICAqL1xuICBzZW5kKG1lc3NhZ2VPck1lc3NhZ2VzKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZUNvbm5lY3Rpb24uaXNPcGVuKCkpIHRocm93IG5ldyBFcnJvcihcIkFjdGl2ZSBjb25uZWN0aW9uIGlzIG5vdCBvcGVuXCIpO1xuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZU9yTWVzc2FnZXMgaW5zdGFuY2VvZiBBcnJheSA/IG1lc3NhZ2VPck1lc3NhZ2VzIDogW21lc3NhZ2VPck1lc3NhZ2VzXTtcbiAgICB0aGlzLmFjdGl2ZUNvbm5lY3Rpb24ud3Muc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlcy5sZW5ndGggPT09IDEgPyBtZXNzYWdlc1swXSA6IG1lc3NhZ2VzKSk7XG4gIH1cbiAgLyoqXG4gICogR3JvdXBzIHJlcXVlc3RzIGZvciBiYXRjaCBzZW5kaW5nLlxuICAqXG4gICogQHJldHVybnMgQSBmdW5jdGlvbiB0byBhYm9ydCB0aGUgYmF0Y2hlZCByZXF1ZXN0LlxuICAqL1xuICBiYXRjaFNlbmQobWVzc2FnZSwgY2FsbGJhY2tzKSB7XG4gICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuaW5hY3Rpdml0eVRpbWVvdXQucmVzZXQoKSwgcnVuKGFzeW5jICgpID0+IHtcbiAgICAgIF90aGlzNS5hY3RpdmVDb25uZWN0aW9uLmlzT3BlbigpIHx8IGF3YWl0IF90aGlzNS5vcGVuKCksIGF3YWl0IHNsZWVwKDApLCBfdGhpczUucmVxdWVzdE1hbmFnZXIuaGFzT3V0Z29pbmdSZXF1ZXN0cygpICYmIF90aGlzNS5zZW5kKF90aGlzNS5yZXF1ZXN0TWFuYWdlci5mbHVzaCgpLm1hcCgoeyBtZXNzYWdlOiBtZXNzYWdlJDEgfSkgPT4gbWVzc2FnZSQxKSk7XG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5kZWxldGUobWVzc2FnZS5pZCksIGNhbGxiYWNrcy5lcnJvcihUUlBDQ2xpZW50RXJyb3IuZnJvbShlcnIpKTtcbiAgICB9KSwgdGhpcy5yZXF1ZXN0TWFuYWdlci5yZWdpc3RlcihtZXNzYWdlLCBjYWxsYmFja3MpO1xuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlV1NDbGllbnQob3B0cykge1xuICByZXR1cm4gbmV3IFdzQ2xpZW50KG9wdHMpO1xufVxuZnVuY3Rpb24gd3NMaW5rKG9wdHMpIHtcbiAgY29uc3QgeyBjbGllbnQgfSA9IG9wdHMsIHRyYW5zZm9ybWVyMiA9IGdldFRyYW5zZm9ybWVyKG9wdHMudHJhbnNmb3JtZXIpO1xuICByZXR1cm4gKCkgPT4gKHsgb3AgfSkgPT4gb2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBjb25zdCBjb25uU3RhdGVTdWJzY3JpcHRpb24gPSBvcC50eXBlID09PSBcInN1YnNjcmlwdGlvblwiID8gY2xpZW50LmNvbm5lY3Rpb25TdGF0ZS5zdWJzY3JpYmUoeyBuZXh0KHJlc3VsdCkge1xuICAgICAgb2JzZXJ2ZXIubmV4dCh7XG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgY29udGV4dDogb3AuY29udGV4dFxuICAgICAgfSk7XG4gICAgfSB9KSA6IG51bGwsIHJlcXVlc3RTdWJzY3JpcHRpb24gPSBjbGllbnQucmVxdWVzdCh7XG4gICAgICBvcCxcbiAgICAgIHRyYW5zZm9ybWVyOiB0cmFuc2Zvcm1lcjJcbiAgICB9KS5zdWJzY3JpYmUob2JzZXJ2ZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXF1ZXN0U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCksIGNvbm5TdGF0ZVN1YnNjcmlwdGlvbiA9PSBudWxsIHx8IGNvbm5TdGF0ZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0pO1xufVxudmFyIGltcG9ydF9kZWZpbmVQcm9wZXJ0eSA9IF9fdG9FU00kMShyZXF1aXJlX2RlZmluZVByb3BlcnR5JDEoKSksIGltcG9ydF9vYmplY3RTcHJlYWQyJDQgPSBfX3RvRVNNJDEocmVxdWlyZV9vYmplY3RTcHJlYWQyJDEoKSksIFRSUENVbnR5cGVkQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgKDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eS5kZWZhdWx0KSh0aGlzLCBcImxpbmtzXCIsIHZvaWQgMCksICgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgXCJydW50aW1lXCIsIHZvaWQgMCksICgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgXCJyZXF1ZXN0SWRcIiwgdm9pZCAwKSwgdGhpcy5yZXF1ZXN0SWQgPSAwLCB0aGlzLnJ1bnRpbWUgPSB7fSwgdGhpcy5saW5rcyA9IG9wdHMubGlua3MubWFwKChsaW5rKSA9PiBsaW5rKHRoaXMucnVudGltZSkpO1xuICB9XG4gICRyZXF1ZXN0KG9wdHMpIHtcbiAgICB2YXIgX29wdHMkY29udGV4dDtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW4oe1xuICAgICAgbGlua3M6IHRoaXMubGlua3MsXG4gICAgICBvcDogKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDQuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDQuZGVmYXVsdCkoe30sIG9wdHMpLCB7fSwge1xuICAgICAgICBjb250ZXh0OiAoX29wdHMkY29udGV4dCA9IG9wdHMuY29udGV4dCkgIT09IG51bGwgJiYgX29wdHMkY29udGV4dCAhPT0gdm9pZCAwID8gX29wdHMkY29udGV4dCA6IHt9LFxuICAgICAgICBpZDogKyt0aGlzLnJlcXVlc3RJZFxuICAgICAgfSlcbiAgICB9KS5waXBlKHNoYXJlKCkpO1xuICB9XG4gIGFzeW5jIHJlcXVlc3RBc1Byb21pc2Uob3B0cykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcSQgPSBfdGhpcy4kcmVxdWVzdChvcHRzKTtcbiAgICAgIHJldHVybiAoYXdhaXQgb2JzZXJ2YWJsZVRvUHJvbWlzZShyZXEkKSkucmVzdWx0LmRhdGE7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBUUlBDQ2xpZW50RXJyb3IuZnJvbShlcnIpO1xuICAgIH1cbiAgfVxuICBxdWVyeShwYXRoLCBpbnB1dCwgb3B0cykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RBc1Byb21pc2Uoe1xuICAgICAgdHlwZTogXCJxdWVyeVwiLFxuICAgICAgcGF0aCxcbiAgICAgIGlucHV0LFxuICAgICAgY29udGV4dDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5jb250ZXh0LFxuICAgICAgc2lnbmFsOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnNpZ25hbFxuICAgIH0pO1xuICB9XG4gIG11dGF0aW9uKHBhdGgsIGlucHV0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdEFzUHJvbWlzZSh7XG4gICAgICB0eXBlOiBcIm11dGF0aW9uXCIsXG4gICAgICBwYXRoLFxuICAgICAgaW5wdXQsXG4gICAgICBjb250ZXh0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmNvbnRleHQsXG4gICAgICBzaWduYWw6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuc2lnbmFsXG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaXB0aW9uKHBhdGgsIGlucHV0LCBvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMuJHJlcXVlc3Qoe1xuICAgICAgdHlwZTogXCJzdWJzY3JpcHRpb25cIixcbiAgICAgIHBhdGgsXG4gICAgICBpbnB1dCxcbiAgICAgIGNvbnRleHQ6IG9wdHMuY29udGV4dCxcbiAgICAgIHNpZ25hbDogb3B0cy5zaWduYWxcbiAgICB9KS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dChlbnZlbG9wZSkge1xuICAgICAgICBzd2l0Y2ggKGVudmVsb3BlLnJlc3VsdC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInN0YXRlXCI6IHtcbiAgICAgICAgICAgIHZhciBfb3B0cyRvbkNvbm5lY3Rpb25TdGE7XG4gICAgICAgICAgICAoX29wdHMkb25Db25uZWN0aW9uU3RhID0gb3B0cy5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSkgPT09IG51bGwgfHwgX29wdHMkb25Db25uZWN0aW9uU3RhID09PSB2b2lkIDAgfHwgX29wdHMkb25Db25uZWN0aW9uU3RhLmNhbGwob3B0cywgZW52ZWxvcGUucmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3RhcnRlZFwiOiB7XG4gICAgICAgICAgICB2YXIgX29wdHMkb25TdGFydGVkO1xuICAgICAgICAgICAgKF9vcHRzJG9uU3RhcnRlZCA9IG9wdHMub25TdGFydGVkKSA9PT0gbnVsbCB8fCBfb3B0cyRvblN0YXJ0ZWQgPT09IHZvaWQgMCB8fCBfb3B0cyRvblN0YXJ0ZWQuY2FsbChvcHRzLCB7IGNvbnRleHQ6IGVudmVsb3BlLmNvbnRleHQgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInN0b3BwZWRcIjoge1xuICAgICAgICAgICAgdmFyIF9vcHRzJG9uU3RvcHBlZDtcbiAgICAgICAgICAgIChfb3B0cyRvblN0b3BwZWQgPSBvcHRzLm9uU3RvcHBlZCkgPT09IG51bGwgfHwgX29wdHMkb25TdG9wcGVkID09PSB2b2lkIDAgfHwgX29wdHMkb25TdG9wcGVkLmNhbGwob3B0cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgICAgICAgdmFyIF9vcHRzJG9uRGF0YTtcbiAgICAgICAgICAgIChfb3B0cyRvbkRhdGEgPSBvcHRzLm9uRGF0YSkgPT09IG51bGwgfHwgX29wdHMkb25EYXRhID09PSB2b2lkIDAgfHwgX29wdHMkb25EYXRhLmNhbGwob3B0cywgZW52ZWxvcGUucmVzdWx0LmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXJyb3IoZXJyKSB7XG4gICAgICAgIHZhciBfb3B0cyRvbkVycm9yO1xuICAgICAgICAoX29wdHMkb25FcnJvciA9IG9wdHMub25FcnJvcikgPT09IG51bGwgfHwgX29wdHMkb25FcnJvciA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3IuY2FsbChvcHRzLCBlcnIpO1xuICAgICAgfSxcbiAgICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB2YXIgX29wdHMkb25Db21wbGV0ZTtcbiAgICAgICAgKF9vcHRzJG9uQ29tcGxldGUgPSBvcHRzLm9uQ29tcGxldGUpID09PSBudWxsIHx8IF9vcHRzJG9uQ29tcGxldGUgPT09IHZvaWQgMCB8fCBfb3B0cyRvbkNvbXBsZXRlLmNhbGwob3B0cyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5jb25zdCB1bnR5cGVkQ2xpZW50U3ltYm9sID0gU3ltYm9sLmZvcihcInRycGNfdW50eXBlZENsaWVudFwiKSwgY2xpZW50Q2FsbFR5cGVNYXAgPSB7XG4gIHF1ZXJ5OiBcInF1ZXJ5XCIsXG4gIG11dGF0ZTogXCJtdXRhdGlvblwiLFxuICBzdWJzY3JpYmU6IFwic3Vic2NyaXB0aW9uXCJcbn0sIGNsaWVudENhbGxUeXBlVG9Qcm9jZWR1cmVUeXBlID0gKGNsaWVudENhbGxUeXBlKSA9PiBjbGllbnRDYWxsVHlwZU1hcFtjbGllbnRDYWxsVHlwZV07XG5mdW5jdGlvbiBjcmVhdGVUUlBDQ2xpZW50UHJveHkoY2xpZW50KSB7XG4gIGNvbnN0IHByb3h5ID0gY3JlYXRlUmVjdXJzaXZlUHJveHkoKHsgcGF0aCwgYXJncyB9KSA9PiB7XG4gICAgY29uc3QgcGF0aENvcHkgPSBbLi4ucGF0aF0sIHByb2NlZHVyZVR5cGUgPSBjbGllbnRDYWxsVHlwZVRvUHJvY2VkdXJlVHlwZShwYXRoQ29weS5wb3AoKSksIGZ1bGxQYXRoID0gcGF0aENvcHkuam9pbihcIi5cIik7XG4gICAgcmV0dXJuIGNsaWVudFtwcm9jZWR1cmVUeXBlXShmdWxsUGF0aCwgLi4uYXJncyk7XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlRmxhdFByb3h5KChrZXkpID0+IGtleSA9PT0gdW50eXBlZENsaWVudFN5bWJvbCA/IGNsaWVudCA6IHByb3h5W2tleV0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVFJQQ0NsaWVudChvcHRzKSB7XG4gIGNvbnN0IGNsaWVudCA9IG5ldyBUUlBDVW50eXBlZENsaWVudChvcHRzKTtcbiAgcmV0dXJuIGNyZWF0ZVRSUENDbGllbnRQcm94eShjbGllbnQpO1xufVxuX190b0VTTSQxKHJlcXVpcmVfb2JqZWN0U3ByZWFkMiQxKCkpO1xuX190b0VTTSQxKHJlcXVpcmVfb2JqZWN0U3ByZWFkMiQxKCkpO1xudmFyIHJlcXVpcmVfYXN5bmNJdGVyYXRvciA9IF9fY29tbW9uSlMkMSh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvYXN5bmNJdGVyYXRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICBmdW5jdGlvbiBfYXN5bmNJdGVyYXRvciQxKHIyKSB7XG4gICAgdmFyIG4sIHQsIG8sIGUgPSAyO1xuICAgIGZvciAodHlwZW9mIFN5bWJvbCA8IFwidVwiICYmICh0ID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IsIG8gPSBTeW1ib2wuaXRlcmF0b3IpOyBlLS07ICkge1xuICAgICAgaWYgKHQgJiYgKG4gPSByMlt0XSkgIT0gbnVsbCkgcmV0dXJuIG4uY2FsbChyMik7XG4gICAgICBpZiAobyAmJiAobiA9IHIyW29dKSAhPSBudWxsKSByZXR1cm4gbmV3IEFzeW5jRnJvbVN5bmNJdGVyYXRvcihuLmNhbGwocjIpKTtcbiAgICAgIHQgPSBcIkBAYXN5bmNJdGVyYXRvclwiLCBvID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGFzeW5jIGl0ZXJhYmxlXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvcihyMikge1xuICAgIGZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvckNvbnRpbnVhdGlvbihyJDEpIHtcbiAgICAgIGlmIChPYmplY3QociQxKSAhPT0gciQxKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihyJDEgKyBcIiBpcyBub3QgYW4gb2JqZWN0LlwiKSk7XG4gICAgICB2YXIgbiA9IHIkMS5kb25lO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyJDEudmFsdWUpLnRoZW4oZnVuY3Rpb24ociQyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHIkMixcbiAgICAgICAgICBkb25lOiBuXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEFzeW5jRnJvbVN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uKHIkMSkge1xuICAgICAgdGhpcy5zID0gciQxLCB0aGlzLm4gPSByJDEubmV4dDtcbiAgICB9LCBBc3luY0Zyb21TeW5jSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgczogbnVsbCxcbiAgICAgIG46IG51bGwsXG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFzeW5jRnJvbVN5bmNJdGVyYXRvckNvbnRpbnVhdGlvbih0aGlzLm4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcbiAgICAgIH0sXG4gICAgICByZXR1cm46IGZ1bmN0aW9uKHIkMSkge1xuICAgICAgICB2YXIgbiA9IHRoaXMucy5yZXR1cm47XG4gICAgICAgIHJldHVybiBuID09PSB2b2lkIDAgPyBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiByJDEsXG4gICAgICAgICAgZG9uZTogITBcbiAgICAgICAgfSkgOiBBc3luY0Zyb21TeW5jSXRlcmF0b3JDb250aW51YXRpb24obi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuICAgICAgfSxcbiAgICAgIHRocm93OiBmdW5jdGlvbihyJDEpIHtcbiAgICAgICAgdmFyIG4gPSB0aGlzLnMucmV0dXJuO1xuICAgICAgICByZXR1cm4gbiA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZWplY3QociQxKSA6IEFzeW5jRnJvbVN5bmNJdGVyYXRvckNvbnRpbnVhdGlvbihuLmFwcGx5KHRoaXMucywgYXJndW1lbnRzKSk7XG4gICAgICB9XG4gICAgfSwgbmV3IEFzeW5jRnJvbVN5bmNJdGVyYXRvcihyMik7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNJdGVyYXRvciQxLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gITAsIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5fX3RvRVNNJDEocmVxdWlyZV9hc3luY0l0ZXJhdG9yKCkpO1xuX190b0VTTSQxKHJlcXVpcmVfb2JqZWN0U3ByZWFkMiQxKCkpO1xudmFyIHJlcXVpcmVfdXNpbmdDdHggPSBfX2NvbW1vbkpTJDEoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3VzaW5nQ3R4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIGZ1bmN0aW9uIF91c2luZ0N0eCgpIHtcbiAgICB2YXIgcjIgPSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uKHIkMSwgZSQxKSB7XG4gICAgICB2YXIgbiQxID0gRXJyb3IoKTtcbiAgICAgIHJldHVybiBuJDEubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIG4kMS5lcnJvciA9IHIkMSwgbiQxLnN1cHByZXNzZWQgPSBlJDEsIG4kMTtcbiAgICB9LCBlID0ge30sIG4gPSBbXTtcbiAgICBmdW5jdGlvbiB1c2luZyhyJDEsIGUkMSkge1xuICAgICAgaWYgKGUkMSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChPYmplY3QoZSQxKSAhPT0gZSQxKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwidXNpbmcgZGVjbGFyYXRpb25zIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBvYmplY3RzLCBmdW5jdGlvbnMsIG51bGwsIG9yIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIGlmIChyJDEpIHZhciBvID0gZSQxW1N5bWJvbC5hc3luY0Rpc3Bvc2UgfHwgU3ltYm9sLmZvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2VcIildO1xuICAgICAgICBpZiAobyA9PT0gdm9pZCAwICYmIChvID0gZSQxW1N5bWJvbC5kaXNwb3NlIHx8IFN5bWJvbC5mb3IoXCJTeW1ib2wuZGlzcG9zZVwiKV0sIHIkMSkpIHZhciB0ID0gbztcbiAgICAgICAgaWYgKHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgICAgIHQgJiYgKG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdC5jYWxsKGUkMSk7XG4gICAgICAgICAgfSBjYXRjaCAociQyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QociQyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBuLnB1c2goe1xuICAgICAgICAgIHY6IGUkMSxcbiAgICAgICAgICBkOiBvLFxuICAgICAgICAgIGE6IHIkMVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSByJDEgJiYgbi5wdXNoKHtcbiAgICAgICAgZDogZSQxLFxuICAgICAgICBhOiByJDFcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGUkMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGUsXG4gICAgICB1OiB1c2luZy5iaW5kKG51bGwsICExKSxcbiAgICAgIGE6IHVzaW5nLmJpbmQobnVsbCwgITApLFxuICAgICAgZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvLCB0ID0gdGhpcy5lLCBzID0gMDtcbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICBmb3IgKDsgbyA9IG4ucG9wKCk7ICkgdHJ5IHtcbiAgICAgICAgICAgIGlmICghby5hICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgbi5wdXNoKG8pLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKG5leHQpO1xuICAgICAgICAgICAgaWYgKG8uZCkge1xuICAgICAgICAgICAgICB2YXIgciQxID0gby5kLmNhbGwoby52KTtcbiAgICAgICAgICAgICAgaWYgKG8uYSkgcmV0dXJuIHMgfD0gMiwgUHJvbWlzZS5yZXNvbHZlKHIkMSkudGhlbihuZXh0LCBlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHMgfD0gMTtcbiAgICAgICAgICB9IGNhdGNoIChyJDIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIociQyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMgPT09IDEpIHJldHVybiB0ICE9PSBlID8gUHJvbWlzZS5yZWplY3QodCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICBpZiAodCAhPT0gZSkgdGhyb3cgdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlcnIobiQxKSB7XG4gICAgICAgICAgcmV0dXJuIHQgPSB0ICE9PSBlID8gbmV3IHIyKG4kMSwgdCkgOiBuJDEsIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfdXNpbmdDdHgsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xufSB9KSwgcmVxdWlyZV9PdmVybG9hZFlpZWxkID0gX19jb21tb25KUyQxKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9PdmVybG9hZFlpZWxkLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIGZ1bmN0aW9uIF9PdmVybG9hZFlpZWxkKGUsIGQpIHtcbiAgICB0aGlzLnYgPSBlLCB0aGlzLmsgPSBkO1xuICB9XG4gIG1vZHVsZS5leHBvcnRzID0gX092ZXJsb2FkWWllbGQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSAhMCwgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xufSB9KSwgcmVxdWlyZV9hd2FpdEFzeW5jR2VuZXJhdG9yID0gX19jb21tb25KUyQxKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG4gIHZhciBPdmVybG9hZFlpZWxkJDEgPSByZXF1aXJlX092ZXJsb2FkWWllbGQoKTtcbiAgZnVuY3Rpb24gX2F3YWl0QXN5bmNHZW5lcmF0b3IkMShlKSB7XG4gICAgcmV0dXJuIG5ldyBPdmVybG9hZFlpZWxkJDEoZSwgMCk7XG4gIH1cbiAgbW9kdWxlLmV4cG9ydHMgPSBfYXdhaXRBc3luY0dlbmVyYXRvciQxLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gITAsIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcbn0gfSksIHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yID0gX19jb21tb25KUyQxKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3IuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgdmFyIE92ZXJsb2FkWWllbGQgPSByZXF1aXJlX092ZXJsb2FkWWllbGQoKTtcbiAgZnVuY3Rpb24gX3dyYXBBc3luY0dlbmVyYXRvciQxKGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IEFzeW5jR2VuZXJhdG9yKGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBBc3luY0dlbmVyYXRvcihlKSB7XG4gICAgdmFyIHIyLCB0O1xuICAgIGZ1bmN0aW9uIHJlc3VtZShyJDEsIHQkMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG4gPSBlW3IkMV0odCQxKSwgbyA9IG4udmFsdWUsIHUgPSBvIGluc3RhbmNlb2YgT3ZlcmxvYWRZaWVsZDtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHUgPyBvLnYgOiBvKS50aGVuKGZ1bmN0aW9uKHQkMikge1xuICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHIkMSA9PT0gXCJyZXR1cm5cIiA/IFwicmV0dXJuXCIgOiBcIm5leHRcIjtcbiAgICAgICAgICAgIGlmICghby5rIHx8IHQkMi5kb25lKSByZXR1cm4gcmVzdW1lKGksIHQkMik7XG4gICAgICAgICAgICB0JDIgPSBlW2ldKHQkMikudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldHRsZShuLmRvbmUgPyBcInJldHVyblwiIDogXCJub3JtYWxcIiwgdCQyKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZSQxKSB7XG4gICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgZSQxKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlJDEpIHtcbiAgICAgICAgc2V0dGxlKFwidGhyb3dcIiwgZSQxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGUkMSwgbikge1xuICAgICAgc3dpdGNoIChlJDEpIHtcbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgIHIyLnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgICBkb25lOiAhMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICByMi5yZWplY3Qobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcjIucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogbixcbiAgICAgICAgICAgIGRvbmU6ICExXG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAocjIgPSByMi5uZXh0KSA/IHJlc3VtZShyMi5rZXksIHIyLmFyZykgOiB0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5faW52b2tlID0gZnVuY3Rpb24oZSQxLCBuKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obywgdSkge1xuICAgICAgICB2YXIgaSA9IHtcbiAgICAgICAgICBrZXk6IGUkMSxcbiAgICAgICAgICBhcmc6IG4sXG4gICAgICAgICAgcmVzb2x2ZTogbyxcbiAgICAgICAgICByZWplY3Q6IHUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0ID8gdCA9IHQubmV4dCA9IGkgOiAocjIgPSB0ID0gaSwgcmVzdW1lKGUkMSwgbikpO1xuICAgICAgfSk7XG4gICAgfSwgdHlwZW9mIGUucmV0dXJuICE9IFwiZnVuY3Rpb25cIiAmJiAodGhpcy5yZXR1cm4gPSB2b2lkIDApO1xuICB9XG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVt0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFwibmV4dFwiLCBlKTtcbiAgfSwgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJ0aHJvd1wiLCBlKTtcbiAgfSwgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFwicmV0dXJuXCIsIGUpO1xuICB9LCBtb2R1bGUuZXhwb3J0cyA9IF93cmFwQXN5bmNHZW5lcmF0b3IkMSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9ICEwLCBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuX190b0VTTSQxKHJlcXVpcmVfdXNpbmdDdHgoKSk7XG5fX3RvRVNNJDEocmVxdWlyZV9hd2FpdEFzeW5jR2VuZXJhdG9yKCkpO1xuX190b0VTTSQxKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCkpO1xuX190b0VTTSQxKHJlcXVpcmVfb2JqZWN0U3ByZWFkMiQxKCkpO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogITAgfSk7XG59LCBleHRlcm5hbF9leHBvcnRzID0ge307XG5fX2V4cG9ydChleHRlcm5hbF9leHBvcnRzLCB7XG4gIEJSQU5EOiAoKSA9PiBCUkFORCxcbiAgRElSVFk6ICgpID0+IERJUlRZLFxuICBFTVBUWV9QQVRIOiAoKSA9PiBFTVBUWV9QQVRILFxuICBJTlZBTElEOiAoKSA9PiBJTlZBTElELFxuICBORVZFUjogKCkgPT4gTkVWRVIsXG4gIE9LOiAoKSA9PiBPSyxcbiAgUGFyc2VTdGF0dXM6ICgpID0+IFBhcnNlU3RhdHVzLFxuICBTY2hlbWE6ICgpID0+IFpvZFR5cGUsXG4gIFpvZEFueTogKCkgPT4gWm9kQW55LFxuICBab2RBcnJheTogKCkgPT4gWm9kQXJyYXksXG4gIFpvZEJpZ0ludDogKCkgPT4gWm9kQmlnSW50LFxuICBab2RCb29sZWFuOiAoKSA9PiBab2RCb29sZWFuLFxuICBab2RCcmFuZGVkOiAoKSA9PiBab2RCcmFuZGVkLFxuICBab2RDYXRjaDogKCkgPT4gWm9kQ2F0Y2gsXG4gIFpvZERhdGU6ICgpID0+IFpvZERhdGUsXG4gIFpvZERlZmF1bHQ6ICgpID0+IFpvZERlZmF1bHQsXG4gIFpvZERpc2NyaW1pbmF0ZWRVbmlvbjogKCkgPT4gWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICBab2RFZmZlY3RzOiAoKSA9PiBab2RFZmZlY3RzLFxuICBab2RFbnVtOiAoKSA9PiBab2RFbnVtLFxuICBab2RFcnJvcjogKCkgPT4gWm9kRXJyb3IsXG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDogKCkgPT4gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLFxuICBab2RGdW5jdGlvbjogKCkgPT4gWm9kRnVuY3Rpb24sXG4gIFpvZEludGVyc2VjdGlvbjogKCkgPT4gWm9kSW50ZXJzZWN0aW9uLFxuICBab2RJc3N1ZUNvZGU6ICgpID0+IFpvZElzc3VlQ29kZSxcbiAgWm9kTGF6eTogKCkgPT4gWm9kTGF6eSxcbiAgWm9kTGl0ZXJhbDogKCkgPT4gWm9kTGl0ZXJhbCxcbiAgWm9kTWFwOiAoKSA9PiBab2RNYXAsXG4gIFpvZE5hTjogKCkgPT4gWm9kTmFOLFxuICBab2ROYXRpdmVFbnVtOiAoKSA9PiBab2ROYXRpdmVFbnVtLFxuICBab2ROZXZlcjogKCkgPT4gWm9kTmV2ZXIsXG4gIFpvZE51bGw6ICgpID0+IFpvZE51bGwsXG4gIFpvZE51bGxhYmxlOiAoKSA9PiBab2ROdWxsYWJsZSxcbiAgWm9kTnVtYmVyOiAoKSA9PiBab2ROdW1iZXIsXG4gIFpvZE9iamVjdDogKCkgPT4gWm9kT2JqZWN0LFxuICBab2RPcHRpb25hbDogKCkgPT4gWm9kT3B0aW9uYWwsXG4gIFpvZFBhcnNlZFR5cGU6ICgpID0+IFpvZFBhcnNlZFR5cGUsXG4gIFpvZFBpcGVsaW5lOiAoKSA9PiBab2RQaXBlbGluZSxcbiAgWm9kUHJvbWlzZTogKCkgPT4gWm9kUHJvbWlzZSxcbiAgWm9kUmVhZG9ubHk6ICgpID0+IFpvZFJlYWRvbmx5LFxuICBab2RSZWNvcmQ6ICgpID0+IFpvZFJlY29yZCxcbiAgWm9kU2NoZW1hOiAoKSA9PiBab2RUeXBlLFxuICBab2RTZXQ6ICgpID0+IFpvZFNldCxcbiAgWm9kU3RyaW5nOiAoKSA9PiBab2RTdHJpbmcsXG4gIFpvZFN5bWJvbDogKCkgPT4gWm9kU3ltYm9sLFxuICBab2RUcmFuc2Zvcm1lcjogKCkgPT4gWm9kRWZmZWN0cyxcbiAgWm9kVHVwbGU6ICgpID0+IFpvZFR1cGxlLFxuICBab2RUeXBlOiAoKSA9PiBab2RUeXBlLFxuICBab2RVbmRlZmluZWQ6ICgpID0+IFpvZFVuZGVmaW5lZCxcbiAgWm9kVW5pb246ICgpID0+IFpvZFVuaW9uLFxuICBab2RVbmtub3duOiAoKSA9PiBab2RVbmtub3duLFxuICBab2RWb2lkOiAoKSA9PiBab2RWb2lkLFxuICBhZGRJc3N1ZVRvQ29udGV4dDogKCkgPT4gYWRkSXNzdWVUb0NvbnRleHQsXG4gIGFueTogKCkgPT4gYW55VHlwZSxcbiAgYXJyYXk6ICgpID0+IGFycmF5VHlwZSxcbiAgYmlnaW50OiAoKSA9PiBiaWdJbnRUeXBlLFxuICBib29sZWFuOiAoKSA9PiBib29sZWFuVHlwZSxcbiAgY29lcmNlOiAoKSA9PiBjb2VyY2UsXG4gIGN1c3RvbTogKCkgPT4gY3VzdG9tLFxuICBkYXRlOiAoKSA9PiBkYXRlVHlwZSxcbiAgZGF0ZXRpbWVSZWdleDogKCkgPT4gZGF0ZXRpbWVSZWdleCxcbiAgZGVmYXVsdEVycm9yTWFwOiAoKSA9PiBlbl9kZWZhdWx0LFxuICBkaXNjcmltaW5hdGVkVW5pb246ICgpID0+IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUsXG4gIGVmZmVjdDogKCkgPT4gZWZmZWN0c1R5cGUsXG4gIGVudW06ICgpID0+IGVudW1UeXBlLFxuICBmdW5jdGlvbjogKCkgPT4gZnVuY3Rpb25UeXBlLFxuICBnZXRFcnJvck1hcDogKCkgPT4gZ2V0RXJyb3JNYXAsXG4gIGdldFBhcnNlZFR5cGU6ICgpID0+IGdldFBhcnNlZFR5cGUsXG4gIGluc3RhbmNlb2Y6ICgpID0+IGluc3RhbmNlT2ZUeXBlLFxuICBpbnRlcnNlY3Rpb246ICgpID0+IGludGVyc2VjdGlvblR5cGUsXG4gIGlzQWJvcnRlZDogKCkgPT4gaXNBYm9ydGVkLFxuICBpc0FzeW5jOiAoKSA9PiBpc0FzeW5jLFxuICBpc0RpcnR5OiAoKSA9PiBpc0RpcnR5LFxuICBpc1ZhbGlkOiAoKSA9PiBpc1ZhbGlkLFxuICBsYXRlOiAoKSA9PiBsYXRlLFxuICBsYXp5OiAoKSA9PiBsYXp5VHlwZSxcbiAgbGl0ZXJhbDogKCkgPT4gbGl0ZXJhbFR5cGUsXG4gIG1ha2VJc3N1ZTogKCkgPT4gbWFrZUlzc3VlLFxuICBtYXA6ICgpID0+IG1hcFR5cGUsXG4gIG5hbjogKCkgPT4gbmFuVHlwZSxcbiAgbmF0aXZlRW51bTogKCkgPT4gbmF0aXZlRW51bVR5cGUsXG4gIG5ldmVyOiAoKSA9PiBuZXZlclR5cGUsXG4gIG51bGw6ICgpID0+IG51bGxUeXBlLFxuICBudWxsYWJsZTogKCkgPT4gbnVsbGFibGVUeXBlLFxuICBudW1iZXI6ICgpID0+IG51bWJlclR5cGUsXG4gIG9iamVjdDogKCkgPT4gb2JqZWN0VHlwZSxcbiAgb2JqZWN0VXRpbDogKCkgPT4gb2JqZWN0VXRpbCxcbiAgb2Jvb2xlYW46ICgpID0+IG9ib29sZWFuLFxuICBvbnVtYmVyOiAoKSA9PiBvbnVtYmVyLFxuICBvcHRpb25hbDogKCkgPT4gb3B0aW9uYWxUeXBlLFxuICBvc3RyaW5nOiAoKSA9PiBvc3RyaW5nLFxuICBwaXBlbGluZTogKCkgPT4gcGlwZWxpbmVUeXBlLFxuICBwcmVwcm9jZXNzOiAoKSA9PiBwcmVwcm9jZXNzVHlwZSxcbiAgcHJvbWlzZTogKCkgPT4gcHJvbWlzZVR5cGUsXG4gIHF1b3RlbGVzc0pzb246ICgpID0+IHF1b3RlbGVzc0pzb24sXG4gIHJlY29yZDogKCkgPT4gcmVjb3JkVHlwZSxcbiAgc2V0OiAoKSA9PiBzZXRUeXBlLFxuICBzZXRFcnJvck1hcDogKCkgPT4gc2V0RXJyb3JNYXAsXG4gIHN0cmljdE9iamVjdDogKCkgPT4gc3RyaWN0T2JqZWN0VHlwZSxcbiAgc3RyaW5nOiAoKSA9PiBzdHJpbmdUeXBlLFxuICBzeW1ib2w6ICgpID0+IHN5bWJvbFR5cGUsXG4gIHRyYW5zZm9ybWVyOiAoKSA9PiBlZmZlY3RzVHlwZSxcbiAgdHVwbGU6ICgpID0+IHR1cGxlVHlwZSxcbiAgdW5kZWZpbmVkOiAoKSA9PiB1bmRlZmluZWRUeXBlLFxuICB1bmlvbjogKCkgPT4gdW5pb25UeXBlLFxuICB1bmtub3duOiAoKSA9PiB1bmtub3duVHlwZSxcbiAgdXRpbDogKCkgPT4gdXRpbCxcbiAgdm9pZDogKCkgPT4gdm9pZFR5cGVcbn0pO1xudmFyIHV0aWw7XG4oZnVuY3Rpb24odXRpbDIpIHtcbiAgdXRpbDIuYXNzZXJ0RXF1YWwgPSAoXykgPT4ge1xuICB9O1xuICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7XG4gIH1cbiAgdXRpbDIuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICB1dGlsMi5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyLCB1dGlsMi5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcylcbiAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgcmV0dXJuIG9iajtcbiAgfSwgdXRpbDIuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwyLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPSBcIm51bWJlclwiKSwgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKVxuICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgcmV0dXJuIHV0aWwyLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gIH0sIHV0aWwyLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHV0aWwyLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBvYmpbZV07XG4gIH0pLCB1dGlsMi5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09IFwiZnVuY3Rpb25cIiA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgOiAob2JqZWN0KSA9PiB7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdClcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5cy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH0sIHV0aWwyLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycilcbiAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgfSwgdXRpbDIuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT0gXCJmdW5jdGlvblwiID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiB0eXBlb2YgdmFsID09IFwic3RyaW5nXCIgPyBcXGAnXFwke3ZhbH0nXFxgIDogdmFsKS5qb2luKHNlcGFyYXRvcik7XG4gIH1cbiAgdXRpbDIuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXMsIHV0aWwyLmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09IFwiYmlnaW50XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWU7XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbnZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uKG9iamVjdFV0aWwyKSB7XG4gIG9iamVjdFV0aWwyLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+ICh7XG4gICAgLi4uZmlyc3QsXG4gICAgLi4uc2Vjb25kXG4gICAgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgfSk7XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbnZhciBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwic3RyaW5nXCIsXG4gIFwibmFuXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwiaW50ZWdlclwiLFxuICBcImZsb2F0XCIsXG4gIFwiYm9vbGVhblwiLFxuICBcImRhdGVcIixcbiAgXCJiaWdpbnRcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcInVuZGVmaW5lZFwiLFxuICBcIm51bGxcIixcbiAgXCJhcnJheVwiLFxuICBcIm9iamVjdFwiLFxuICBcInVua25vd25cIixcbiAgXCJwcm9taXNlXCIsXG4gIFwidm9pZFwiLFxuICBcIm5ldmVyXCIsXG4gIFwibWFwXCIsXG4gIFwic2V0XCJcbl0pLCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgc3dpdGNoICh0eXBlb2YgZGF0YSkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGRhdGEpID8gWm9kUGFyc2VkVHlwZS5hcnJheSA6IGRhdGEgPT09IG51bGwgPyBab2RQYXJzZWRUeXBlLm51bGwgOiBkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PSBcImZ1bmN0aW9uXCIgPyBab2RQYXJzZWRUeXBlLnByb21pc2UgOiB0eXBlb2YgTWFwIDwgXCJ1XCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCA/IFpvZFBhcnNlZFR5cGUubWFwIDogdHlwZW9mIFNldCA8IFwidVwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQgPyBab2RQYXJzZWRUeXBlLnNldCA6IHR5cGVvZiBEYXRlIDwgXCJ1XCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUgPyBab2RQYXJzZWRUeXBlLmRhdGUgOiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgfVxufSwgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwiaW52YWxpZF90eXBlXCIsXG4gIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW52YWxpZF91bmlvblwiLFxuICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gIFwiaW52YWxpZF9kYXRlXCIsXG4gIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgXCJ0b29fc21hbGxcIixcbiAgXCJ0b29fYmlnXCIsXG4gIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgXCJub3RfZmluaXRlXCJcbl0pLCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKS5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpLCBab2RFcnJvciA9IGNsYXNzIF9ab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgZ2V0IGVycm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gIH1cbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5pc3N1ZXMgPSBbXSwgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgIH0sIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgIH07XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pIDogdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bywgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiLCB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgfVxuICBmb3JtYXQoX21hcHBlcikge1xuICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHwgZnVuY3Rpb24oaXNzdWUpIHtcbiAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgIH0sIGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9LCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKVxuICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpXG4gICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKVxuICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpXG4gICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzLCBpID0gMDtcbiAgICAgICAgICBmb3IgKDsgaSA8IGlzc3VlLnBhdGgubGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgIGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMSA/IChjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfSwgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpKSA6IGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9LCBjdXJyID0gY3VycltlbF0sIGkrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBwcm9jZXNzRXJyb3IodGhpcyksIGZpZWxkRXJyb3JzO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9ab2RFcnJvcikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxgTm90IGEgWm9kRXJyb3I6IFxcJHt2YWx1ZX1cXGApO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge30sIGZvcm1FcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3VlcylcbiAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RWwgPSBzdWIucGF0aFswXTtcbiAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0gPSBmaWVsZEVycm9yc1tmaXJzdEVsXSB8fCBbXSwgZmllbGRFcnJvcnNbZmlyc3RFbF0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICB9XG4gIGdldCBmb3JtRXJyb3JzKCkge1xuICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgfVxufTtcblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xudmFyIGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gIGxldCBtZXNzYWdlO1xuICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICBpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQgPyBtZXNzYWdlID0gXCJSZXF1aXJlZFwiIDogbWVzc2FnZSA9IFxcYEV4cGVjdGVkIFxcJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkIFxcJHtpc3N1ZS5yZWNlaXZlZH1cXGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICBtZXNzYWdlID0gXFxgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCBcXCR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1cXGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgIG1lc3NhZ2UgPSBcXGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogXFwke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfVxcYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICBtZXNzYWdlID0gXFxgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCBcXCR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfVxcYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgIG1lc3NhZ2UgPSBcXGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkIFxcJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnXFwke2lzc3VlLnJlY2VpdmVkfSdcXGA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBkYXRlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgIHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09IFwib2JqZWN0XCIgPyBcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbiA/IChtZXNzYWdlID0gXFxgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiXFwke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJcXGAsIHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09IFwibnVtYmVyXCIgJiYgKG1lc3NhZ2UgPSBcXGBcXCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBcXCR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1cXGApKSA6IFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24gPyBtZXNzYWdlID0gXFxgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiXFwke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cIlxcYCA6IFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uID8gbWVzc2FnZSA9IFxcYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCJcXCR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cIlxcYCA6IHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbikgOiBpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIgPyBtZXNzYWdlID0gXFxgSW52YWxpZCBcXCR7aXNzdWUudmFsaWRhdGlvbn1cXGAgOiBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICBpc3N1ZS50eXBlID09PSBcImFycmF5XCIgPyBtZXNzYWdlID0gXFxgQXJyYXkgbXVzdCBjb250YWluIFxcJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJtb3JlIHRoYW5cIn0gXFwke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylcXGAgOiBpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA9IFxcYFN0cmluZyBtdXN0IGNvbnRhaW4gXFwke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBcImF0IGxlYXN0XCIgOiBcIm92ZXJcIn0gXFwke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKVxcYCA6IGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIgPyBtZXNzYWdlID0gXFxgTnVtYmVyIG11c3QgYmUgXFwke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5IGVxdWFsIHRvIFwiIDogaXNzdWUuaW5jbHVzaXZlID8gXCJncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gXCIgOiBcImdyZWF0ZXIgdGhhbiBcIn1cXCR7aXNzdWUubWluaW11bX1cXGAgOiBpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiID8gbWVzc2FnZSA9IFxcYE51bWJlciBtdXN0IGJlIFxcJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseSBlcXVhbCB0byBcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiIDogXCJncmVhdGVyIHRoYW4gXCJ9XFwke2lzc3VlLm1pbmltdW19XFxgIDogaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIgPyBtZXNzYWdlID0gXFxgRGF0ZSBtdXN0IGJlIFxcJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseSBlcXVhbCB0byBcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiIDogXCJncmVhdGVyIHRoYW4gXCJ9XFwke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9XFxgIDogbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgIGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIiA/IG1lc3NhZ2UgPSBcXGBBcnJheSBtdXN0IGNvbnRhaW4gXFwke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBcImF0IG1vc3RcIiA6IFwibGVzcyB0aGFuXCJ9IFxcJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpXFxgIDogaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgPSBcXGBTdHJpbmcgbXVzdCBjb250YWluIFxcJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcInVuZGVyXCJ9IFxcJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylcXGAgOiBpc3N1ZS50eXBlID09PSBcIm51bWJlclwiID8gbWVzc2FnZSA9IFxcYE51bWJlciBtdXN0IGJlIFxcJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwibGVzcyB0aGFuXCJ9IFxcJHtpc3N1ZS5tYXhpbXVtfVxcYCA6IGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIgPyBtZXNzYWdlID0gXFxgQmlnSW50IG11c3QgYmUgXFwke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBcImxlc3MgdGhhbiBvciBlcXVhbCB0b1wiIDogXCJsZXNzIHRoYW5cIn0gXFwke2lzc3VlLm1heGltdW19XFxgIDogaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIgPyBtZXNzYWdlID0gXFxgRGF0ZSBtdXN0IGJlIFxcJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gXCJzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwic21hbGxlciB0aGFuXCJ9IFxcJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfVxcYCA6IG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcbiAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgbWVzc2FnZSA9IFwiSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgbWVzc2FnZSA9IFxcYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgXFwke2lzc3VlLm11bHRpcGxlT2Z9XFxgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1lc3NhZ2UgPSBfY3R4LmRlZmF1bHRFcnJvciwgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gIH1cbiAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufSwgZW5fZGVmYXVsdCA9IGVycm9yTWFwLCBvdmVycmlkZUVycm9yTWFwID0gZW5fZGVmYXVsdDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxudmFyIG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zLCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi5pc3N1ZURhdGEucGF0aCB8fCBbXV0sIGZ1bGxJc3N1ZSA9IHtcbiAgICAuLi5pc3N1ZURhdGEsXG4gICAgcGF0aDogZnVsbFBhdGhcbiAgfTtcbiAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2VcbiAgICB9O1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgY29uc3QgbWFwcyA9IGVycm9yTWFwcy5maWx0ZXIoKG0pID0+ICEhbSkuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpXG4gICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICByZXR1cm4ge1xuICAgIC4uLmlzc3VlRGF0YSxcbiAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2VcbiAgfTtcbn0sIEVNUFRZX1BBVEggPSBbXTtcbmZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKSwgaXNzdWUgPSBtYWtlSXNzdWUoe1xuICAgIGlzc3VlRGF0YSxcbiAgICBkYXRhOiBjdHguZGF0YSxcbiAgICBwYXRoOiBjdHgucGF0aCxcbiAgICBlcnJvck1hcHM6IFtcbiAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgLy8gY29udGV4dHVhbCBlcnJvciBtYXAgaXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgIG92ZXJyaWRlTWFwLFxuICAgICAgLy8gdGhlbiBnbG9iYWwgb3ZlcnJpZGUgbWFwXG4gICAgICBvdmVycmlkZU1hcCA9PT0gZW5fZGVmYXVsdCA/IHZvaWQgMCA6IGVuX2RlZmF1bHRcbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKHgpID0+ICEheClcbiAgfSk7XG4gIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxudmFyIFBhcnNlU3RhdHVzID0gY2xhc3MgX1BhcnNlU3RhdHVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgfVxuICBkaXJ0eSgpIHtcbiAgICB0aGlzLnZhbHVlID09PSBcInZhbGlkXCIgJiYgKHRoaXMudmFsdWUgPSBcImRpcnR5XCIpO1xuICB9XG4gIGFib3J0KCkge1xuICAgIHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiICYmICh0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCIpO1xuICB9XG4gIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHN0YXR1cy5kaXJ0eSgpLCBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5LCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX1BhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gIH1cbiAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiBzdGF0dXMuZGlydHkoKSwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgc3RhdHVzLmRpcnR5KCksIGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIHZhbHVlLnZhbHVlIDwgXCJ1XCIgfHwgcGFpci5hbHdheXNTZXQpICYmIChmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gIH1cbn0sIElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSksIERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSksIE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSksIGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIsIGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIiwgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiLCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2UsIGVycm9yVXRpbDtcbihmdW5jdGlvbihlcnJvclV0aWwyKSB7XG4gIGVycm9yVXRpbDIuZXJyVG9PYmogPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fSwgZXJyb3JVdGlsMi50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2UubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcbnZhciBQYXJzZUlucHV0TGF6eVBhdGggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXSwgdGhpcy5wYXJlbnQgPSBwYXJlbnQsIHRoaXMuZGF0YSA9IHZhbHVlLCB0aGlzLl9wYXRoID0gcGF0aCwgdGhpcy5fa2V5ID0ga2V5O1xuICB9XG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCB8fCAoQXJyYXkuaXNBcnJheSh0aGlzLl9rZXkpID8gdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSkgOiB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KSksIHRoaXMuX2NhY2hlZFBhdGg7XG4gIH1cbn0sIGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICBpZiAoaXNWYWxpZChyZXN1bHQpKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6ICEwLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogITEsXG4gICAgZ2V0IGVycm9yKCkge1xuICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IgPSBlcnJvciwgdGhpcy5fZXJyb3I7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBlcnJvck1hcDogZXJyb3JNYXAyLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICBpZiAoZXJyb3JNYXAyICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKVxuICAgIHRocm93IG5ldyBFcnJvcihcXGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLlxcYCk7XG4gIHJldHVybiBlcnJvck1hcDIgPyB7IGVycm9yTWFwOiBlcnJvck1hcDIsIGRlc2NyaXB0aW9uIH0gOiB7IGVycm9yTWFwOiAoaXNzLCBjdHgpID0+IHtcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvciB9IDogdHlwZW9mIGN0eC5kYXRhID4gXCJ1XCIgPyB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gcmVxdWlyZWRfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9IDogaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIgPyB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfSA6IHsgbWVzc2FnZTogbWVzc2FnZSA/PyBpbnZhbGlkX3R5cGVfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICB9LCBkZXNjcmlwdGlvbiB9O1xufVxudmFyIFpvZFR5cGUgPSBjbGFzcyB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICB9XG4gIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gIH1cbiAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICByZXR1cm4gY3R4IHx8IHtcbiAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudFxuICAgIH07XG4gIH1cbiAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgY3R4OiB7XG4gICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnRcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgaWYgKGlzQXN5bmMocmVzdWx0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICB9XG4gIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgfVxuICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpID8/ICExLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLmVycm9yTWFwXG4gICAgICB9LFxuICAgICAgcGF0aDogKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfSwgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICB9XG4gIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmNcbiAgICAgIH0sXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBkYXRhLFxuICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKVxuICAgIH07XG4gICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpID8ge1xuICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzXG4gICAgICAgIH07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgKF9iID0gKF9hID0gZXJyID09IG51bGwgPyB2b2lkIDAgOiBlcnIubWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvTG93ZXJDYXNlKCkpICE9IG51bGwgJiYgX2IuaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSAmJiAodGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9ICEwKSwgY3R4LmNvbW1vbiA9IHtcbiAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgIGFzeW5jOiAhMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIHJldHVybiB0aGlzLl9wYXJzZUFzeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pLnRoZW4oKHJlc3VsdCkgPT4gaXNWYWxpZChyZXN1bHQpID8ge1xuICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZVxuICAgIH0gOiB7XG4gICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgcGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgfVxuICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICBjb21tb246IHtcbiAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgYXN5bmM6ICEwXG4gICAgICB9LFxuICAgICAgcGF0aDogKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfSwgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLCByZXN1bHQgPSBhd2FpdCAoaXNBc3luYyhtYXliZUFzeW5jUmVzdWx0KSA/IG1heWJlQXN5bmNSZXN1bHQgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICB9XG4gIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHR5cGVvZiBtZXNzYWdlID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPiBcInVcIiA/IHsgbWVzc2FnZSB9IDogdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZSh2YWwpIDogbWVzc2FnZTtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCksIHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBkYXRhID8gITAgOiAoc2V0RXJyb3IoKSwgITEpKSA6IHJlc3VsdCA/ICEwIDogKHNldEVycm9yKCksICExKTtcbiAgICB9KTtcbiAgfVxuICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4gY2hlY2sodmFsKSA/ICEwIDogKGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT0gXCJmdW5jdGlvblwiID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpIDogcmVmaW5lbWVudERhdGEpLCAhMSkpO1xuICB9XG4gIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gIH1cbiAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLCB0aGlzLl9kZWYgPSBkZWYsIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyksIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKSwgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyksIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyksIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKSwgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpLCB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKSwgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKSwgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKSwgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKSwgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyksIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyksIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpLCB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpLCB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyksIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKSwgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKSwgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyksIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyksIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyksIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpLCB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpLCB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKSwgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyksIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICB2ZXJzaW9uOiAxLFxuICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpXG4gICAgfTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgbnVsbGFibGUoKSB7XG4gICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxpc2goKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICB9XG4gIGFycmF5KCkge1xuICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gIH1cbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihvcHRpb24pIHtcbiAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICB9XG4gIGFuZChpbmNvbWluZykge1xuICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICB9XG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdFxuICAgIH0pO1xuICB9XG4gIGJyYW5kKCkge1xuICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICB0eXBlOiB0aGlzLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpXG4gICAgfSk7XG4gIH1cbiAgY2F0Y2goZGVmKSB7XG4gICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaFxuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGRlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbiAgcGlwZSh0YXJnZXQpIHtcbiAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gIH1cbiAgcmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh2b2lkIDApLnN1Y2Nlc3M7XG4gIH1cbiAgaXNOdWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgfVxufSwgY3VpZFJlZ2V4ID0gL15jW15cXFxccy1dezgsfSQvaSwgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC8sIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaSwgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcXFxiLVswLTlhLWZBLUZdezR9XFxcXGItWzAtOWEtZkEtRl17NH1cXFxcYi1bMC05YS1mQS1GXXs0fVxcXFxiLVswLTlhLWZBLUZdezEyfSQvaSwgbmFub2lkUmVnZXggPSAvXlthLXowLTlfLV17MjF9JC9pLCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXFxcLltBLVphLXowLTktX10rXFxcXC5bQS1aYS16MC05LV9dKiQvLCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxcXGQrWSl8KD86Wy0rXT9cXFxcZCtbLixdXFxcXGQrWSQpKT8oPzooPzpbLStdP1xcXFxkK00pfCg/OlstK10/XFxcXGQrWy4sXVxcXFxkK00kKSk/KD86KD86Wy0rXT9cXFxcZCtXKXwoPzpbLStdP1xcXFxkK1suLF1cXFxcZCtXJCkpPyg/Oig/OlstK10/XFxcXGQrRCl8KD86Wy0rXT9cXFxcZCtbLixdXFxcXGQrRCQpKT8oPzpUKD89W1xcXFxkKy1dKSg/Oig/OlstK10/XFxcXGQrSCl8KD86Wy0rXT9cXFxcZCtbLixdXFxcXGQrSCQpKT8oPzooPzpbLStdP1xcXFxkK00pfCg/OlstK10/XFxcXGQrWy4sXVxcXFxkK00kKSk/KD86Wy0rXT9cXFxcZCsoPzpbLixdXFxcXGQrKT9TKT8pPz8kLywgZW1haWxSZWdleCA9IC9eKD8hXFxcXC4pKD8hLipcXFxcLlxcXFwuKShbQS1aMC05XycrXFxcXC1cXFxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXFxcLV0qXFxcXC4pK1tBLVpdezIsfSQvaSwgX2Vtb2ppUmVnZXggPSBcIl4oXFxcXFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRcIiwgZW1vamlSZWdleCwgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFxcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvLCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFxcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvLCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXFxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC8sIGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXFxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFxcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvLCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLywgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC8sIGRhdGVSZWdleFNvdXJjZSA9IFwiKChcXFxcXFxcXGRcXFxcXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcXFxcXGRcXFxcXFxcXGRbMTM1NzldWzI2XXxcXFxcXFxcXGRcXFxcXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcXFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXFxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXFxcXFxkfDJbMC04XSkpKVwiLCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKFxcYF5cXCR7ZGF0ZVJlZ2V4U291cmNlfSRcXGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IFwiWzAtNV1cXFxcXFxcXGRcIjtcbiAgYXJncy5wcmVjaXNpb24gPyBzZWNvbmRzUmVnZXhTb3VyY2UgPSBcXGBcXCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFxcXFxcLlxcXFxcXFxcZHtcXCR7YXJncy5wcmVjaXNpb259fVxcYCA6IGFyZ3MucHJlY2lzaW9uID09IG51bGwgJiYgKHNlY29uZHNSZWdleFNvdXJjZSA9IFxcYFxcJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFxcXFxcLlxcXFxcXFxcZCspP1xcYCk7XG4gIGNvbnN0IHNlY29uZHNRdWFudGlmaWVyID0gYXJncy5wcmVjaXNpb24gPyBcIitcIiA6IFwiP1wiO1xuICByZXR1cm4gXFxgKFswMV1cXFxcXFxcXGR8MlswLTNdKTpbMC01XVxcXFxcXFxcZCg6XFwke3NlY29uZHNSZWdleFNvdXJjZX0pXFwke3NlY29uZHNRdWFudGlmaWVyfVxcYDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFxcYF5cXCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRcXGApO1xufVxuZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gIGxldCByZWdleCA9IFxcYFxcJHtkYXRlUmVnZXhTb3VyY2V9VFxcJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9XFxgO1xuICBjb25zdCBvcHRzID0gW107XG4gIHJldHVybiBvcHRzLnB1c2goYXJncy5sb2NhbCA/IFwiWj9cIiA6IFwiWlwiKSwgYXJncy5vZmZzZXQgJiYgb3B0cy5wdXNoKFwiKFsrLV1cXFxcXFxcXGR7Mn06P1xcXFxcXFxcZHsyfSlcIiksIHJlZ2V4ID0gXFxgXFwke3JlZ2V4fShcXCR7b3B0cy5qb2luKFwifFwiKX0pXFxgLCBuZXcgUmVnRXhwKFxcYF5cXCR7cmVnZXh9JFxcYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgcmV0dXJuICEhKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSB8fCAodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xuICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICByZXR1cm4gITE7XG4gIHRyeSB7XG4gICAgY29uc3QgW2hlYWRlcl0gPSBqd3Quc3BsaXQoXCIuXCIpO1xuICAgIGlmICghaGVhZGVyKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlci5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKS5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICg0IC0gaGVhZGVyLmxlbmd0aCAlIDQpICUgNCwgXCI9XCIpLCBkZWNvZGVkID0gSlNPTi5wYXJzZShhdG9iKGJhc2U2NCkpO1xuICAgIHJldHVybiAhKHR5cGVvZiBkZWNvZGVkICE9IFwib2JqZWN0XCIgfHwgZGVjb2RlZCA9PT0gbnVsbCB8fCBcInR5cFwiIGluIGRlY29kZWQgJiYgKGRlY29kZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGRlY29kZWQudHlwKSAhPT0gXCJKV1RcIiB8fCAhZGVjb2RlZC5hbGcgfHwgYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gIHJldHVybiAhISgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApIHx8ICh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZDaWRyUmVnZXgudGVzdChpcCkpO1xufVxudmFyIFpvZFN0cmluZyA9IGNsYXNzIF9ab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UgJiYgKGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSkpLCB0aGlzLl9nZXRUeXBlKGlucHV0KSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICBsZXQgY3R4O1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKVxuICAgICAgICBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlICYmIChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpXG4gICAgICAgIGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUgJiYgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSwgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAodG9vQmlnIHx8IHRvb1NtYWxsKSAmJiAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIHRvb0JpZyA/IGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITAsXG4gICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICB9KSA6IHRvb1NtYWxsICYmIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICAgIGV4YWN0OiAhMCxcbiAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSk7XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIilcbiAgICAgICAgZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpXG4gICAgICAgIGVtb2ppUmVnZXggfHwgKGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIikpLCBlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKVxuICAgICAgICB1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSB8fCAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKVxuICAgICAgICBuYW5vaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpXG4gICAgICAgIGN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIilcbiAgICAgICAgY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIilcbiAgICAgICAgdWxpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIilcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pLCBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgZWxzZSBjaGVjay5raW5kID09PSBcInJlZ2V4XCIgPyAoY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMCwgY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKSB8fCAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSkgOiBjaGVjay5raW5kID09PSBcInRyaW1cIiA/IGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKSA6IGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIiA/IGlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSB8fCAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIiA/IGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCkgOiBjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIgPyBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpIDogY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIgPyBpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpIDogY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiID8gaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpIDogY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiID8gZGF0ZXRpbWVSZWdleChjaGVjaykudGVzdChpbnB1dC5kYXRhKSB8fCAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwiZGF0ZVwiID8gZGF0ZVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwidGltZVwiID8gdGltZVJlZ2V4KGNoZWNrKS50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiBjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIgPyBkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiBjaGVjay5raW5kID09PSBcImlwXCIgPyBpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiBjaGVjay5raW5kID09PSBcImp3dFwiID8gaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwiY2lkclwiID8gaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIgPyBiYXNlNjRSZWdleC50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIgPyBiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpIHx8IChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgIHZhbGlkYXRpb24sXG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgZW1haWwobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHVybChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGVtb2ppKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1dWlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGN1aWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgY3VpZDIobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHVsaWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgYmFzZTY0KG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGp3dChvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICB9XG4gIGlwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgfVxuICBjaWRyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICB9XG4gIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgIG9mZnNldDogITEsXG4gICAgICBsb2NhbDogITEsXG4gICAgICBtZXNzYWdlOiBvcHRpb25zXG4gICAgfSkgOiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID4gXCJ1XCIgPyBudWxsIDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICBvZmZzZXQ6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkgPz8gITEsXG4gICAgICBsb2NhbDogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubG9jYWwpID8/ICExLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBkYXRlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcbiAgfVxuICB0aW1lKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgbWVzc2FnZTogb3B0aW9uc1xuICAgIH0pIDogdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IHR5cGVvZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID4gXCJ1XCIgPyBudWxsIDogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICByZWdleCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgIHZhbHVlLFxuICAgICAgcG9zaXRpb246IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucG9zaXRpb24sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgIHZhbHVlLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICB2YWx1ZTogbGVuLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gXFxgLm1pbigxKVxcYFxuICAgKi9cbiAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICB9XG4gIGdldCBpc0RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICB9XG4gIGdldCBpc1RpbWUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gIH1cbiAgZ2V0IGlzRW1haWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgfVxuICBnZXQgaXNVUkwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgfVxuICBnZXQgaXNVVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgfVxuICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgfVxuICBnZXQgaXNVTElEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICB9XG4gIGdldCBpc0NJRFIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICB9XG4gIGdldCBpc0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgfVxuICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gIH1cbiAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICBsZXQgbWluID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBjaC5raW5kID09PSBcIm1pblwiICYmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pICYmIChtaW4gPSBjaC52YWx1ZSk7XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGNoLmtpbmQgPT09IFwibWF4XCIgJiYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heCkgJiYgKG1heCA9IGNoLnZhbHVlKTtcbiAgICByZXR1cm4gbWF4O1xuICB9XG59O1xuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IG5ldyBab2RTdHJpbmcoe1xuICBjaGVja3M6IFtdLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgY29lcmNlOiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSA/PyAhMSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoLCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQsIHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpLCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gdmFsSW50ICUgc3RlcEludCAvIDEwICoqIGRlY0NvdW50O1xufVxudmFyIFpvZE51bWJlciA9IGNsYXNzIF9ab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5taW4gPSB0aGlzLmd0ZSwgdGhpcy5tYXggPSB0aGlzLmx0ZSwgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpKSwgdGhpcy5fZ2V0VHlwZShpbnB1dCkgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICB9XG4gICAgbGV0IGN0eDtcbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBjaGVjay5raW5kID09PSBcImludFwiID8gdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkgfHwgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpIDogY2hlY2sua2luZCA9PT0gXCJtaW5cIiA/IChjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlKSAmJiAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgIGV4YWN0OiAhMSxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IGNoZWNrLmtpbmQgPT09IFwibWF4XCIgPyAoY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZSkgJiYgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpIDogY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgPyBmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwICYmIChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpIDogY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIiA/IE51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSB8fCAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKSA6IHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCAhMCwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCAhMSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgITAsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gIH1cbiAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgITEsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gIH1cbiAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZE51bWJlcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFtcbiAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAge1xuICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kTnVtYmVyKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIGludChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITEsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITEsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgdmFsdWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBmaW5pdGUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgc2FmZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSkuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGNoLmtpbmQgPT09IFwibWluXCIgJiYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbikgJiYgKG1pbiA9IGNoLnZhbHVlKTtcbiAgICByZXR1cm4gbWluO1xuICB9XG4gIGdldCBtYXhWYWx1ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBjaC5raW5kID09PSBcIm1heFwiICYmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpICYmIChtYXggPSBjaC52YWx1ZSk7XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBnZXQgaXNJbnQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpO1xuICB9XG4gIGdldCBpc0Zpbml0ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbCwgbWluID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGNoLmtpbmQgPT09IFwibWluXCIgPyAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKSAmJiAobWluID0gY2gudmFsdWUpIDogY2gua2luZCA9PT0gXCJtYXhcIiAmJiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KSAmJiAobWF4ID0gY2gudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XG4gIH1cbn07XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZE51bWJlcih7XG4gIGNoZWNrczogW10sXG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICBjb2VyY2U6IChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8ICExLFxuICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbn0pO1xudmFyIFpvZEJpZ0ludCA9IGNsYXNzIF9ab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5taW4gPSB0aGlzLmd0ZSwgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSlcbiAgICAgIHRyeSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICB9XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoaW5wdXQpICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludClcbiAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgIGxldCBjdHg7XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgY2hlY2sua2luZCA9PT0gXCJtaW5cIiA/IChjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlKSAmJiAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiBjaGVjay5raW5kID09PSBcIm1heFwiID8gKGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWUpICYmIChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiBjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIiA/IGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApICYmIChjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSwgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICB9KSwgc3RhdHVzLmRpcnR5KCkpIDogdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gIH1cbiAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgfSksIElOVkFMSUQ7XG4gIH1cbiAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsICEwLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsICExLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCAhMCwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCAhMSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQmlnSW50KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITEsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiAhMSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgdmFsdWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBnZXQgbWluVmFsdWUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgY2gua2luZCA9PT0gXCJtaW5cIiAmJiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKSAmJiAobWluID0gY2gudmFsdWUpO1xuICAgIHJldHVybiBtaW47XG4gIH1cbiAgZ2V0IG1heFZhbHVlKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGNoLmtpbmQgPT09IFwibWF4XCIgJiYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heCkgJiYgKG1heCA9IGNoLnZhbHVlKTtcbiAgICByZXR1cm4gbWF4O1xuICB9XG59O1xuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IG5ldyBab2RCaWdJbnQoe1xuICBjaGVja3M6IFtdLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgY29lcmNlOiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSA/PyAhMSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbnZhciBab2RCb29sZWFuID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UgJiYgKGlucHV0LmRhdGEgPSAhIWlucHV0LmRhdGEpLCB0aGlzLl9nZXRUeXBlKGlucHV0KSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZEJvb2xlYW4oe1xuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gIGNvZXJjZTogKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLmNvZXJjZSkgfHwgITEsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kRGF0ZSA9IGNsYXNzIF9ab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSkpLCB0aGlzLl9nZXRUeXBlKGlucHV0KSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGxldCBjdHg7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgY2hlY2sua2luZCA9PT0gXCJtaW5cIiA/IGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUgJiYgKGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpLCBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiBjaGVjay5raW5kID09PSBcIm1heFwiID8gaW5wdXQuZGF0YS5nZXRUaW1lKCkgPiBjaGVjay52YWx1ZSAmJiAoY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCksIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSkgOiB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpXG4gICAgfTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2REYXRlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgY2gua2luZCA9PT0gXCJtaW5cIiAmJiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKSAmJiAobWluID0gY2gudmFsdWUpO1xuICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICB9XG4gIGdldCBtYXhEYXRlKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGNoLmtpbmQgPT09IFwibWF4XCIgJiYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heCkgJiYgKG1heCA9IGNoLnZhbHVlKTtcbiAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgfVxufTtcblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZERhdGUoe1xuICBjaGVja3M6IFtdLFxuICBjb2VyY2U6IChwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8ICExLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kU3ltYm9sID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoaW5wdXQpICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiBuZXcgWm9kU3ltYm9sKHtcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kVW5kZWZpbmVkID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoaW5wdXQpICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kTnVsbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9nZXRUeXBlKGlucHV0KSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZE51bGwoe1xuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kQW55ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fYW55ID0gITA7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IG5ldyBab2RBbnkoe1xuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbnZhciBab2RVbmtub3duID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fdW5rbm93biA9ICEwO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZFVua25vd24oe1xuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kTmV2ZXIgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgfSksIElOVkFMSUQ7XG4gIH1cbn07XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiBuZXcgWm9kTmV2ZXIoe1xuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbn0pO1xudmFyIFpvZFZvaWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShpbnB1dCkgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZFZvaWQoe1xuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kQXJyYXkgPSBjbGFzcyBfWm9kQXJyYXkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSwgZGVmID0gdGhpcy5fZGVmO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSlcbiAgICAgIHJldHVybiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlLCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICh0b29CaWcgfHwgdG9vU21hbGwpICYmIChhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiB0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgbWF4aW11bTogdG9vQmlnID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgIGV4YWN0OiAhMCxcbiAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2VcbiAgICAgIH0pLCBzdGF0dXMuZGlydHkoKSk7XG4gICAgfVxuICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsICYmIGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUgJiYgKGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgZXhhY3Q6ICExLFxuICAgICAgbWVzc2FnZTogZGVmLm1pbkxlbmd0aC5tZXNzYWdlXG4gICAgfSksIHN0YXR1cy5kaXJ0eSgpKSwgZGVmLm1heExlbmd0aCAhPT0gbnVsbCAmJiBjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlICYmIChhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICB9KSwgc3RhdHVzLmRpcnR5KCkpLCBjdHguY29tbW9uLmFzeW5jKVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSkpLnRoZW4oKHJlc3VsdDIpID0+IFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQyKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZEFycmF5KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiBuZXcgWm9kQXJyYXkoe1xuICB0eXBlOiBzY2hlbWEsXG4gIG1pbkxlbmd0aDogbnVsbCxcbiAgbWF4TGVuZ3RoOiBudWxsLFxuICBleGFjdExlbmd0aDogbnVsbCxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH0gZWxzZSByZXR1cm4gc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkgPyBuZXcgWm9kQXJyYXkoe1xuICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgIHR5cGU6IGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS5lbGVtZW50KVxuICB9KSA6IHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsID8gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpIDogc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUgPyBab2ROdWxsYWJsZS5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSkgOiBzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSA/IFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpIDogc2NoZW1hO1xufVxudmFyIFpvZE9iamVjdCA9IGNsYXNzIF9ab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fY2FjaGVkID0gbnVsbCwgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoLCB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgfVxuICBfZ2V0Q2FjaGVkKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCksIGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH0sIHRoaXMuX2NhY2hlZDtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShpbnB1dCkgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSwgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKSwgZXh0cmFLZXlzID0gW107XG4gICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiYgdGhpcy5fZGVmLnVua25vd25LZXlzID09PSBcInN0cmlwXCIpKVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpXG4gICAgICAgIHNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpIHx8IGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV0sIHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgdmFsdWU6IGtleVZhbGlkYXRvci5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpXG4gICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9XG4gICAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIilcbiAgICAgICAgZXh0cmFLZXlzLmxlbmd0aCA+IDAgJiYgKGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICBrZXlzOiBleHRyYUtleXNcbiAgICAgICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzICE9PSBcInN0cmlwXCIpIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNhdGNoYWxsID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgdmFsdWU6IGNhdGNoYWxsLl9wYXJzZShcbiAgICAgICAgICAgIG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSlcbiAgICAgICAgICAgIC8vLCBjdHguY2hpbGQoa2V5KSwgdmFsdWUsIGdldFBhcnNlZFR5cGUodmFsdWUpXG4gICAgICAgICAgKSxcbiAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jb21tb24uYXN5bmMgPyBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5LCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgfSkudGhlbigoc3luY1BhaXJzKSA9PiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpKSA6IFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgfVxuICBnZXQgc2hhcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICB9XG4gIHN0cmljdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGVycm9yVXRpbC5lcnJUb09iaiwgbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAuLi5tZXNzYWdlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gKChfYiA9IChfYSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBpc3N1ZSwgY3R4KS5tZXNzYWdlKSA/PyBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgIHJldHVybiBpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIgPyB7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSA/PyBkZWZhdWx0RXJyb3JcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSA6IHt9XG4gICAgfSk7XG4gIH1cbiAgc3RyaXAoKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCJcbiAgICB9KTtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIlxuICAgIH0pO1xuICB9XG4gIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgLy8gICApOiBab2RPYmplY3Q8XG4gIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgLy8gICA+ID0+IHtcbiAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgICAgLi4uZGVmLFxuICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gIC8vICAgICAgIH0pLFxuICAvLyAgICAgfSkgYXMgYW55O1xuICAvLyAgIH07XG4gIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5hdWdtZW50YXRpb25cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAqL1xuICBtZXJnZShtZXJnaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgICAgfSksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdFxuICAgIH0pO1xuICB9XG4gIC8vIG1lcmdlPFxuICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xuICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gIC8vICAgICAgID8gT3V0cHV0W2tdXG4gIC8vICAgICAgIDogbmV2ZXI7XG4gIC8vICAgfSxcbiAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAvLyAgICAgICA/IElucHV0W2tdXG4gIC8vICAgICAgIDogbmV2ZXI7XG4gIC8vICAgfVxuICAvLyA+KFxuICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gIC8vICk6IFpvZE9iamVjdDxcbiAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gIC8vICAgTmV3T3V0cHV0LFxuICAvLyAgIE5ld0lucHV0XG4gIC8vID4ge1xuICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgLy8gICB9KSBhcyBhbnk7XG4gIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgLy8gfVxuICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgfVxuICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgLy8gWm9kT2JqZWN0PFxuICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAvLyA+IHtcbiAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gIC8vICAgLy8gKTtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2F0Y2hhbGw6IGluZGV4XG4gICAgfSk7XG4gIH1cbiAgcGljayhtYXNrKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXMobWFzaykpXG4gICAgICBtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldICYmIChzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldKTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXG4gICAgfSk7XG4gIH1cbiAgb21pdChtYXNrKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpXG4gICAgICBtYXNrW2tleV0gfHwgKHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gc2hhcGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgfVxuICBwYXJ0aWFsKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICBtYXNrICYmICFtYXNrW2tleV0gPyBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEgOiBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZVxuICAgIH0pO1xuICB9XG4gIHJlcXVpcmVkKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSlcbiAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pXG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5ld0ZpZWxkID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICBmb3IgKDsgbmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbDsgKVxuICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgIH1cbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH1cbiAga2V5b2YoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgfVxufTtcblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4gbmV3IFpvZE9iamVjdCh7XG4gIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4gbmV3IFpvZE9iamVjdCh7XG4gIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiBuZXcgWm9kT2JqZWN0KHtcbiAgc2hhcGUsXG4gIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kVW5pb24gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSwgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cylcbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKVxuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICByZXR1cm4gY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpLCByZXN1bHQucmVzdWx0O1xuICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICB1bmlvbkVycm9yc1xuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgIGlzc3VlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3R4OiBjaGlsZEN0eFxuICAgICAgICB9O1xuICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAge1xuICAgICAgbGV0IGRpcnR5O1xuICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgfSwgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY2hpbGRDdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgcmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSAmJiAoZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9KSwgY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGggJiYgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICB9XG4gICAgICBpZiAoZGlydHkpXG4gICAgICAgIHJldHVybiBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKSwgZGlydHkucmVzdWx0O1xuICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMyKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzMikpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnNcbiAgICAgIH0pLCBJTlZBTElEO1xuICAgIH1cbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbn07XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4gbmV3IFpvZFVuaW9uKHtcbiAgb3B0aW9uczogdHlwZXMsXG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSA/IGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpIDogdHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMgPyBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpIDogdHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwgPyBbdHlwZS52YWx1ZV0gOiB0eXBlIGluc3RhbmNlb2YgWm9kRW51bSA/IHR5cGUub3B0aW9ucyA6IHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtID8gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKSA6IHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0ID8gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKSA6IHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQgPyBbdm9pZCAwXSA6IHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsID8gW251bGxdIDogdHlwZSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsID8gW3ZvaWQgMCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV0gOiB0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUgPyBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV0gOiB0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCB8fCB0eXBlIGluc3RhbmNlb2YgWm9kUmVhZG9ubHkgPyBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpIDogdHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoID8gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKSA6IFtdLCBab2REaXNjcmltaW5hdGVkVW5pb24gPSBjbGFzcyBfWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpXG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yLCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXSwgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgIHJldHVybiBvcHRpb24gPyBjdHguY29tbW9uLmFzeW5jID8gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IGN0eFxuICAgIH0pIDogb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgIHBhcmVudDogY3R4XG4gICAgfSkgOiAoYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxuICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXVxuICAgIH0pLCBJTlZBTElEKTtcbiAgfVxuICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICB9XG4gIGdldCBvcHRpb25zTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXFxcXFxgXFwke2Rpc2NyaW1pbmF0b3J9XFxcXFxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zXFxgKTtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICBpZiAob3B0aW9uc01hcC5oYXModmFsdWUpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXGBEaXNjcmltaW5hdG9yIHByb3BlcnR5IFxcJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgXFwke1N0cmluZyh2YWx1ZSl9XFxgKTtcbiAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IF9ab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpLCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gIGlmIChhID09PSBiKVxuICAgIHJldHVybiB7IHZhbGlkOiAhMCwgZGF0YTogYSB9O1xuICBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpLCBzaGFyZWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKSwgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKVxuICAgICAgICByZXR1cm4geyB2YWxpZDogITEgfTtcbiAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6ICEwLCBkYXRhOiBuZXdPYmogfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICByZXR1cm4geyB2YWxpZDogITEgfTtcbiAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XSwgaXRlbUIgPSBiW2luZGV4XSwgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZClcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6ICExIH07XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogITAsIGRhdGE6IG5ld0FycmF5IH07XG4gIH0gZWxzZSByZXR1cm4gYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09ICtiID8geyB2YWxpZDogITAsIGRhdGE6IGEgfSA6IHsgdmFsaWQ6ICExIH07XG59XG52YXIgWm9kSW50ZXJzZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSwgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgcmV0dXJuIG1lcmdlZC52YWxpZCA/ICgoaXNEaXJ0eShwYXJzZWRMZWZ0KSB8fCBpc0RpcnR5KHBhcnNlZFJpZ2h0KSkgJiYgc3RhdHVzLmRpcnR5KCksIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9KSA6IChhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXG4gICAgICB9KSwgSU5WQUxJRCk7XG4gICAgfTtcbiAgICByZXR1cm4gY3R4LmNvbW1vbi5hc3luYyA/IFByb21pc2UuYWxsKFtcbiAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSksXG4gICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIHBhcmVudDogY3R4XG4gICAgICB9KVxuICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpIDogaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgIHBhcmVudDogY3R4XG4gICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IGN0eFxuICAgIH0pKTtcbiAgfVxufTtcblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gIGxlZnQsXG4gIHJpZ2h0LFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbnZhciBab2RUdXBsZSA9IGNsYXNzIF9ab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSlcbiAgICAgIHJldHVybiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpXG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgIGV4YWN0OiAhMSxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICAhdGhpcy5fZGVmLnJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCAmJiAoYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgZXhhY3Q6ICExLFxuICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICBjb25zdCBpdGVtcyA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgcmV0dXJuIHNjaGVtYSA/IHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKSA6IG51bGw7XG4gICAgfSkuZmlsdGVyKCh4KSA9PiAhIXgpO1xuICAgIHJldHVybiBjdHguY29tbW9uLmFzeW5jID8gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSkgOiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICB9XG4gIGdldCBpdGVtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICB9XG4gIHJlc3QocmVzdCkge1xuICAgIHJldHVybiBuZXcgX1pvZFR1cGxlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHJlc3RcbiAgICB9KTtcbiAgfVxufTtcblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICBpdGVtczogc2NoZW1hcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgIHJlc3Q6IG51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RSZWNvcmQgPSBjbGFzcyBfWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICB9XG4gIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpXG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICBjb25zdCBwYWlycyA9IFtdLCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGUsIHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpXG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICB9KTtcbiAgICByZXR1cm4gY3R4LmNvbW1vbi5hc3luYyA/IFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykgOiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIHJldHVybiBzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlID8gbmV3IF9ab2RSZWNvcmQoe1xuICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZClcbiAgICB9KSA6IG5ldyBfWm9kUmVjb3JkKHtcbiAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKVxuICAgIH0pO1xuICB9XG59LCBab2RNYXAgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKVxuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlLCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlLCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4gKHtcbiAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcbiAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpXG4gICAgfSkpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICBjb25zdCBmaW5hbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5LCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSAmJiBzdGF0dXMuZGlydHkoKSwgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmaW5hbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXksIHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpICYmIHN0YXR1cy5kaXJ0eSgpLCBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgfVxuICB9XG59O1xuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4gbmV3IFpvZE1hcCh7XG4gIHZhbHVlVHlwZSxcbiAga2V5VHlwZSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kU2V0ID0gY2xhc3MgX1pvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpXG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgZGVmLm1pblNpemUgIT09IG51bGwgJiYgY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlICYmIChhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICBtaW5pbXVtOiBkZWYubWluU2l6ZS52YWx1ZSxcbiAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgZXhhY3Q6ICExLFxuICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZVxuICAgIH0pLCBzdGF0dXMuZGlydHkoKSksIGRlZi5tYXhTaXplICE9PSBudWxsICYmIGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSAmJiAoYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlXG4gICAgfSksIHN0YXR1cy5kaXJ0eSgpKTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzMikge1xuICAgICAgY29uc3QgcGFyc2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50czIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiBzdGF0dXMuZGlydHkoKSwgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgIHJldHVybiBjdHguY29tbW9uLmFzeW5jID8gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzMikgPT4gZmluYWxpemVTZXQoZWxlbWVudHMyKSkgOiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gIH1cbiAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTZXQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZFNldCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gIH1cbiAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgfVxufTtcblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IG5ldyBab2RTZXQoe1xuICB2YWx1ZVR5cGUsXG4gIG1pblNpemU6IG51bGwsXG4gIG1heFNpemU6IG51bGwsXG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbn0pO1xudmFyIFpvZEZ1bmN0aW9uID0gY2xhc3MgX1pvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pXG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pLCBJTlZBTElEO1xuICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZW5fZGVmYXVsdF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGVuX2RlZmF1bHRdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfSwgZm4gPSBjdHguZGF0YTtcbiAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSksIHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSksIGVycm9yO1xuICAgICAgICB9KSwgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgIHJldHVybiBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgdGhyb3cgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKSwgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgIHJldHVybiBPSyhmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpLCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKVxuICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIHBhcnNlZFJldHVybnMuZXJyb3IpXSk7XG4gICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGFyYW1ldGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmFyZ3M7XG4gIH1cbiAgcmV0dXJuVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gIH1cbiAgYXJncyguLi5pdGVtcykge1xuICAgIHJldHVybiBuZXcgX1pvZEZ1bmN0aW9uKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGFyZ3M6IFpvZFR1cGxlLmNyZWF0ZShpdGVtcykucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKVxuICAgIH0pO1xuICB9XG4gIHJldHVybnMocmV0dXJuVHlwZSkge1xuICAgIHJldHVybiBuZXcgX1pvZEZ1bmN0aW9uKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHJldHVybnM6IHJldHVyblR5cGVcbiAgICB9KTtcbiAgfVxuICBpbXBsZW1lbnQoZnVuYykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKGZ1bmMpO1xuICB9XG4gIHN0cmljdEltcGxlbWVudChmdW5jKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2UoZnVuYyk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShhcmdzLCByZXR1cm5zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICBhcmdzOiBhcmdzIHx8IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSxcbiAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgICB9KTtcbiAgfVxufSwgWm9kTGF6eSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gIH1cbn07XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4gbmV3IFpvZExhenkoe1xuICBnZXR0ZXIsXG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbnZhciBab2RMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWVcbiAgICAgIH0pLCBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgfVxufTtcblpvZExpdGVyYWwuY3JlYXRlID0gKHZhbHVlLCBwYXJhbXMpID0+IG5ldyBab2RMaXRlcmFsKHtcbiAgdmFsdWUsXG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbmZ1bmN0aW9uIGNyZWF0ZVpvZEVudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICB2YWx1ZXMsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn1cbnZhciBab2RFbnVtID0gY2xhc3MgX1pvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KSwgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlIHx8ICh0aGlzLl9jYWNoZSA9IG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcykpLCAhdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCksIGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgIHJldHVybiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSksIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgfVxuICBnZXQgZW51bSgpIHtcbiAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcylcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgfVxuICBnZXQgVmFsdWVzKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKVxuICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGdldCBFbnVtKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKVxuICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICByZXR1cm4gX1pvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgLi4ubmV3RGVmXG4gICAgfSk7XG4gIH1cbiAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiBfWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5uZXdEZWZcbiAgICB9KTtcbiAgfVxufTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbnZhciBab2ROYXRpdmVFbnVtID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpLCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJiBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pLCBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGUgfHwgKHRoaXMuX2NhY2hlID0gbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSkpLCAhdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgcmV0dXJuIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG59O1xuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgdmFsdWVzLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kUHJvbWlzZSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiYgY3R4LmNvbW1vbi5hc3luYyA9PT0gITEpXG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSksIElOVkFMSUQ7XG4gICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlID8gY3R4LmRhdGEgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwXG4gICAgfSkpKTtcbiAgfVxufTtcblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiBuZXcgWm9kUHJvbWlzZSh7XG4gIHR5cGU6IHNjaGVtYSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbn0pO1xudmFyIFpvZEVmZmVjdHMgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBpbm5lclR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gIH1cbiAgc291cmNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpLCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGwsIGNoZWNrQ3R4ID0ge1xuICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpLCBhcmcuZmF0YWwgPyBzdGF0dXMuYWJvcnQoKSA6IHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfSxcbiAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KSwgZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYylcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZDIpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkMixcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBJTlZBTElEIDogcmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiID8gRElSVFkocmVzdWx0LnZhbHVlKSA6IHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgICB7XG4gICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gSU5WQUxJRCA6IHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCBzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIiA/IERJUlRZKHJlc3VsdC52YWx1ZSkgOiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH07XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gITEpIHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IElOVkFMSUQgOiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgc3RhdHVzLmRpcnR5KCksIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKSwgeyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChpbm5lcikgPT4gaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IElOVkFMSUQgOiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgc3RhdHVzLmRpcnR5KCksIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+ICh7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfSkpKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIilcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSAhMSkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGJhc2UpID0+IGlzVmFsaWQoYmFzZSkgPyBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgIH0pKSA6IElOVkFMSUQpO1xuICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgfVxufTtcblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IG5ldyBab2RFZmZlY3RzKHtcbiAgc2NoZW1hLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gIGVmZmVjdCxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IG5ldyBab2RFZmZlY3RzKHtcbiAgc2NoZW1hLFxuICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kT3B0aW9uYWwgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VHlwZShpbnB1dCkgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkID8gT0sodm9pZCAwKSA6IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiBuZXcgWm9kT3B0aW9uYWwoe1xuICBpbm5lclR5cGU6IHR5cGUsXG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxufSk7XG52YXIgWm9kTnVsbGFibGUgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0VHlwZShpbnB1dCkgPT09IFpvZFBhcnNlZFR5cGUubnVsbCA/IE9LKG51bGwpIDogdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IG5ldyBab2ROdWxsYWJsZSh7XG4gIGlubmVyVHlwZTogdHlwZSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbnZhciBab2REZWZhdWx0ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICByZXR1cm4gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkICYmIChkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpKSwgdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YSxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgcGFyZW50OiBjdHhcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiBuZXcgWm9kRGVmYXVsdCh7XG4gIGlubmVyVHlwZTogdHlwZSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuZGVmYXVsdCA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbn0pO1xudmFyIFpvZENhdGNoID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCksIG5ld0N0eCA9IHtcbiAgICAgIC4uLmN0eCxcbiAgICAgIGNvbW1vbjoge1xuICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICB9XG4gICAgfSwgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YTogbmV3Q3R4LmRhdGEsXG4gICAgICBwYXRoOiBuZXdDdHgucGF0aCxcbiAgICAgIHBhcmVudDoge1xuICAgICAgICAuLi5uZXdDdHhcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpID8gcmVzdWx0LnRoZW4oKHJlc3VsdDIpID0+ICh7XG4gICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgIHZhbHVlOiByZXN1bHQyLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0Mi52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB9LFxuICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGFcbiAgICAgIH0pXG4gICAgfSkpIDoge1xuICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0LnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGlucHV0OiBuZXdDdHguZGF0YVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHJlbW92ZUNhdGNoKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kQ2F0Y2guY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4gbmV3IFpvZENhdGNoKHtcbiAgaW5uZXJUeXBlOiB0eXBlLFxuICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5jYXRjaCA6ICgpID0+IHBhcmFtcy5jYXRjaCxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbnZhciBab2ROYU4gPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShpbnB1dCkgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICByZXR1cm4gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KSwgSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gIH1cbn07XG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4gbmV3IFpvZE5hTih7XG4gIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbn0pO1xudmFyIEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpLCBab2RCcmFuZGVkID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCksIGRhdGEgPSBjdHguZGF0YTtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgIHBhcmVudDogY3R4XG4gICAgfSk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxufSwgWm9kUGlwZWxpbmUgPSBjbGFzcyBfWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYylcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBpblJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5pbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gSU5WQUxJRCA6IGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiID8gKHN0YXR1cy5kaXJ0eSgpLCBESVJUWShpblJlc3VsdC52YWx1ZSkpIDogdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIHtcbiAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIHBhcmVudDogY3R4XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gSU5WQUxJRCA6IGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiID8gKHN0YXR1cy5kaXJ0eSgpLCB7XG4gICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWVcbiAgICAgIH0pIDogdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgIHJldHVybiBuZXcgX1pvZFBpcGVsaW5lKHtcbiAgICAgIGluOiBhLFxuICAgICAgb3V0OiBiLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZVxuICAgIH0pO1xuICB9XG59LCBab2RSZWFkb25seSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KSwgZnJlZXplID0gKGRhdGEpID0+IChpc1ZhbGlkKGRhdGEpICYmIChkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKSksIGRhdGEpO1xuICAgIHJldHVybiBpc0FzeW5jKHJlc3VsdCkgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKSA6IGZyZWV6ZShyZXN1bHQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IG5ldyBab2RSZWFkb25seSh7XG4gIGlubmVyVHlwZTogdHlwZSxcbiAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG59KTtcbmZ1bmN0aW9uIGNsZWFuUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoZGF0YSkgOiB0eXBlb2YgcGFyYW1zID09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICByZXR1cm4gdHlwZW9mIHAgPT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbn1cbmZ1bmN0aW9uIGN1c3RvbShjaGVjaywgX3BhcmFtcyA9IHt9LCBmYXRhbCkge1xuICByZXR1cm4gY2hlY2sgPyBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgIGNvbnN0IHIyID0gY2hlY2soZGF0YSk7XG4gICAgaWYgKHIyIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgIHJldHVybiByMi50aGVuKChyMjIpID0+IHtcbiAgICAgICAgaWYgKCFyMjIpIHtcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKSwgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/ICEwO1xuICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgaWYgKCFyMikge1xuICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSksIF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyAhMDtcbiAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICB9XG4gIH0pIDogWm9kQW55LmNyZWF0ZSgpO1xufVxudmFyIGxhdGUgPSB7XG4gIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGVcbn0sIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbihab2RGaXJzdFBhcnR5VHlwZUtpbmQyKSB7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kU3RyaW5nID0gXCJab2RTdHJpbmdcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2ROdW1iZXIgPSBcIlpvZE51bWJlclwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZE5hTiA9IFwiWm9kTmFOXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kQmlnSW50ID0gXCJab2RCaWdJbnRcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RCb29sZWFuID0gXCJab2RCb29sZWFuXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kRGF0ZSA9IFwiWm9kRGF0ZVwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZFN5bWJvbCA9IFwiWm9kU3ltYm9sXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kVW5kZWZpbmVkID0gXCJab2RVbmRlZmluZWRcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2ROdWxsID0gXCJab2ROdWxsXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kQW55ID0gXCJab2RBbnlcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RVbmtub3duID0gXCJab2RVbmtub3duXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kTmV2ZXIgPSBcIlpvZE5ldmVyXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kVm9pZCA9IFwiWm9kVm9pZFwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZEFycmF5ID0gXCJab2RBcnJheVwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZE9iamVjdCA9IFwiWm9kT2JqZWN0XCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kVW5pb24gPSBcIlpvZFVuaW9uXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RJbnRlcnNlY3Rpb24gPSBcIlpvZEludGVyc2VjdGlvblwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZFR1cGxlID0gXCJab2RUdXBsZVwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZFJlY29yZCA9IFwiWm9kUmVjb3JkXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kTWFwID0gXCJab2RNYXBcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RTZXQgPSBcIlpvZFNldFwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZEZ1bmN0aW9uID0gXCJab2RGdW5jdGlvblwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZExhenkgPSBcIlpvZExhenlcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RMaXRlcmFsID0gXCJab2RMaXRlcmFsXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kRW51bSA9IFwiWm9kRW51bVwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZEVmZmVjdHMgPSBcIlpvZEVmZmVjdHNcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2ROYXRpdmVFbnVtID0gXCJab2ROYXRpdmVFbnVtXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kT3B0aW9uYWwgPSBcIlpvZE9wdGlvbmFsXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kTnVsbGFibGUgPSBcIlpvZE51bGxhYmxlXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kRGVmYXVsdCA9IFwiWm9kRGVmYXVsdFwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZENhdGNoID0gXCJab2RDYXRjaFwiLCBab2RGaXJzdFBhcnR5VHlwZUtpbmQyLlpvZFByb21pc2UgPSBcIlpvZFByb21pc2VcIiwgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMi5ab2RCcmFuZGVkID0gXCJab2RCcmFuZGVkXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kUGlwZWxpbmUgPSBcIlpvZFBpcGVsaW5lXCIsIFpvZEZpcnN0UGFydHlUeXBlS2luZDIuWm9kUmVhZG9ubHkgPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG52YXIgaW5zdGFuY2VPZlR5cGUgPSAoY2xzLCBwYXJhbXMgPSB7XG4gIG1lc3NhZ2U6IFxcYElucHV0IG5vdCBpbnN0YW5jZSBvZiBcXCR7Y2xzLm5hbWV9XFxgXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyksIHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlLCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZSwgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGUsIGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlLCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlLCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlLCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZSwgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGUsIG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGUsIGFueVR5cGUgPSBab2RBbnkuY3JlYXRlLCB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlLCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGUsIHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGUsIGFycmF5VHlwZSA9IFpvZEFycmF5LmNyZWF0ZSwgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGUsIHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlLCB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGUsIGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlLCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSwgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlLCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZSwgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGUsIHNldFR5cGUgPSBab2RTZXQuY3JlYXRlLCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGUsIGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGUsIGxpdGVyYWxUeXBlID0gWm9kTGl0ZXJhbC5jcmVhdGUsIGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGUsIG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGUsIHByb21pc2VUeXBlID0gWm9kUHJvbWlzZS5jcmVhdGUsIGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGUsIG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZSwgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlLCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MsIHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZSwgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpLCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCksIG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpLCBjb2VyY2UgPSB7XG4gIHN0cmluZzogKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiAhMCB9KSxcbiAgbnVtYmVyOiAoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6ICEwIH0pLFxuICBib29sZWFuOiAoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgLi4uYXJnLFxuICAgIGNvZXJjZTogITBcbiAgfSksXG4gIGJpZ2ludDogKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiAhMCB9KSxcbiAgZGF0ZTogKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogITAgfSlcbn0sIE5FVkVSID0gSU5WQUxJRCwgQWdlbnRBdmFpbGFiaWxpdHlFcnJvciA9IC8qIEBfX1BVUkVfXyAqLyAoKEFnZW50QXZhaWxhYmlsaXR5RXJyb3IyKSA9PiAoQWdlbnRBdmFpbGFiaWxpdHlFcnJvcjIuTk9fQ09OTkVDVElPTiA9IFwibm9fY29ubmVjdGlvblwiLCBBZ2VudEF2YWlsYWJpbGl0eUVycm9yMi5OT19BVVRIRU5USUNBVElPTiA9IFwibm9fYXV0aGVudGljYXRpb25cIiwgQWdlbnRBdmFpbGFiaWxpdHlFcnJvcjIuSU5DT01QQVRJQkxFX1ZFUlNJT04gPSBcImluY29tcGF0aWJsZV92ZXJzaW9uXCIsIEFnZW50QXZhaWxhYmlsaXR5RXJyb3IyLk9USEVSID0gXCJvdGhlclwiLCBBZ2VudEF2YWlsYWJpbGl0eUVycm9yMikpKEFnZW50QXZhaWxhYmlsaXR5RXJyb3IgfHwge30pO1xuZXh0ZXJuYWxfZXhwb3J0cy5kaXNjcmltaW5hdGVkVW5pb24oXCJpc0F2YWlsYWJsZVwiLCBbXG4gIGV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgICBpc0F2YWlsYWJsZTogZXh0ZXJuYWxfZXhwb3J0cy5saXRlcmFsKCEwKVxuICB9KSxcbiAgZXh0ZXJuYWxfZXhwb3J0cy5vYmplY3Qoe1xuICAgIGlzQXZhaWxhYmxlOiBleHRlcm5hbF9leHBvcnRzLmxpdGVyYWwoITEpLFxuICAgIGVycm9yOiBleHRlcm5hbF9leHBvcnRzLm5hdGl2ZUVudW0oQWdlbnRBdmFpbGFiaWxpdHlFcnJvciksXG4gICAgZXJyb3JNZXNzYWdlOiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLm9wdGlvbmFsKClcbiAgfSlcbl0pO1xudmFyIEFnZW50U3RhdGVUeXBlID0gLyogQF9fUFVSRV9fICovICgoQWdlbnRTdGF0ZVR5cGUyKSA9PiAoQWdlbnRTdGF0ZVR5cGUyLklETEUgPSBcImlkbGVcIiwgQWdlbnRTdGF0ZVR5cGUyLlRISU5LSU5HID0gXCJ0aGlua2luZ1wiLCBBZ2VudFN0YXRlVHlwZTIuV09SS0lORyA9IFwid29ya2luZ1wiLCBBZ2VudFN0YXRlVHlwZTIuQ0FMTElOR19UT09MID0gXCJjYWxsaW5nX3Rvb2xcIiwgQWdlbnRTdGF0ZVR5cGUyLldBSVRJTkdfRk9SX1VTRVJfUkVTUE9OU0UgPSBcIndhaXRpbmdfZm9yX3VzZXJfcmVzcG9uc2VcIiwgQWdlbnRTdGF0ZVR5cGUyLkZBSUxFRCA9IFwiZmFpbGVkXCIsIEFnZW50U3RhdGVUeXBlMi5DT01QTEVURUQgPSBcImNvbXBsZXRlZFwiLCBBZ2VudFN0YXRlVHlwZTIpKShBZ2VudFN0YXRlVHlwZSB8fCB7fSk7XG5leHRlcm5hbF9leHBvcnRzLm9iamVjdCh7XG4gIHN0YXRlOiBleHRlcm5hbF9leHBvcnRzLm5hdGl2ZUVudW0oQWdlbnRTdGF0ZVR5cGUpLFxuICBkZXNjcmlwdGlvbjogZXh0ZXJuYWxfZXhwb3J0cy5zdHJpbmcoKS5taW4oMykubWF4KDEyOCkub3B0aW9uYWwoKVxufSk7XG52YXIgYmFzZVNlbGVjdGVkRWxlbWVudFNjaGVtYSA9IGV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgbm9kZVR5cGU6IGV4dGVybmFsX2V4cG9ydHMuc3RyaW5nKCkubWluKDEpLm1heCg5NikuZGVzY3JpYmUoXCJUaGUgbm9kZSB0eXBlIG9mIHRoZSBlbGVtZW50LlwiKSxcbiAgeHBhdGg6IGV4dGVybmFsX2V4cG9ydHMuc3RyaW5nKCkubWluKDEpLm1heCgxMDI0KS5kZXNjcmliZShcIlRoZSBYUGF0aCBvZiB0aGUgZWxlbWVudC5cIiksXG4gIGF0dHJpYnV0ZXM6IGV4dGVybmFsX2V4cG9ydHMucmVjb3JkKGV4dGVybmFsX2V4cG9ydHMudW5pb24oW2V4dGVybmFsX2V4cG9ydHMuc3RyaW5nKCksIGV4dGVybmFsX2V4cG9ydHMuYm9vbGVhbigpLCBleHRlcm5hbF9leHBvcnRzLm51bWJlcigpXSkpLnRyYW5zZm9ybSgob2JqKSA9PiB7XG4gICAgY29uc3QgaW1wb3J0YW50QXR0cmlidXRlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgIFwiY2xhc3NcIixcbiAgICAgIFwiaWRcIixcbiAgICAgIFwic3R5bGVcIixcbiAgICAgIFwibmFtZVwiLFxuICAgICAgXCJyb2xlXCIsXG4gICAgICBcImhyZWZcIixcbiAgICAgIFwiZm9yXCIsXG4gICAgICBcInBsYWNlaG9sZGVyXCIsXG4gICAgICBcImFsdFwiLFxuICAgICAgXCJ0aXRsZVwiLFxuICAgICAgXCJhcmlhTGFiZWxcIixcbiAgICAgIFwiYXJpYVJvbGVcIixcbiAgICAgIFwiYXJpYURlc2NyaXB0aW9uXCIsXG4gICAgICBcImFyaWFIaWRkZW5cIixcbiAgICAgIFwiYXJpYURpc2FibGVkXCIsXG4gICAgICBcImFyaWFFeHBhbmRlZFwiLFxuICAgICAgXCJhcmlhU2VsZWN0ZWRcIlxuICAgIF0pLCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMob2JqKSwgaW1wb3J0YW50RW50cmllcyA9IFtdLCBvdGhlckVudHJpZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICBjb25zdCBzdHJpbmdWYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiID8gdmFsdWUgOiBTdHJpbmcodmFsdWUpLCB0cnVuY2F0ZWRWYWx1ZSA9IHN0cmluZ1ZhbHVlLmxlbmd0aCA+IDQwOTYgPyBcXGBcXCR7c3RyaW5nVmFsdWUuc2xpY2UoMCwgNDA5Nil9Li4uW3RydW5jYXRlZF1cXGAgOiBzdHJpbmdWYWx1ZTtcbiAgICAgIGlmIChpbXBvcnRhbnRBdHRyaWJ1dGVzLmhhcyhrZXkpKVxuICAgICAgICBpbXBvcnRhbnRFbnRyaWVzLnB1c2goW2tleSwgdHJ1bmNhdGVkVmFsdWVdKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwcm9jZXNzZWRWYWx1ZSA9IHN0cmluZ1ZhbHVlLmxlbmd0aCA+IDI1NiA/IFxcYFxcJHtzdHJpbmdWYWx1ZS5zbGljZSgwLCAyNTYpfS4uLlt0cnVuY2F0ZWRdXFxgIDogc3RyaW5nVmFsdWU7XG4gICAgICAgIG90aGVyRW50cmllcy5wdXNoKFtrZXksIHByb2Nlc3NlZFZhbHVlXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1heE90aGVyQXR0cmlidXRlcyA9IDEwMCAtIGltcG9ydGFudEVudHJpZXMubGVuZ3RoLCB0cnVuY2F0ZWRPdGhlckVudHJpZXMgPSBvdGhlckVudHJpZXMuc2xpY2UoXG4gICAgICAwLFxuICAgICAgTWF0aC5tYXgoMCwgbWF4T3RoZXJBdHRyaWJ1dGVzKVxuICAgICksIHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyhbXG4gICAgICAuLi5pbXBvcnRhbnRFbnRyaWVzLFxuICAgICAgLi4udHJ1bmNhdGVkT3RoZXJFbnRyaWVzXG4gICAgXSk7XG4gICAgcmV0dXJuIG90aGVyRW50cmllcy5sZW5ndGggPiBtYXhPdGhlckF0dHJpYnV0ZXMgJiYgbWF4T3RoZXJBdHRyaWJ1dGVzID4gMCAmJiAocmVzdWx0Ll9fdHJ1bmNhdGVkX18gPSBcXGAuLi5bXFwke290aGVyRW50cmllcy5sZW5ndGggLSBtYXhPdGhlckF0dHJpYnV0ZXN9IG1vcmUgZW50cmllcyB0cnVuY2F0ZWRdXFxgKSwgcmVzdWx0O1xuICB9KS5kZXNjcmliZShcbiAgICBcIkEgcmVjb3JkIG9mIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQuIEltcG9ydGFudCBhdHRyaWJ1dGVzIChjbGFzcywgaWQsIHN0eWxlLCBldGMuKSBhcmUgbmV2ZXIgdHJ1bmNhdGVkIGF3YXkuIE90aGVyIGF0dHJpYnV0ZXMgbWF5IGJlIHRydW5jYXRlZCBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgdG90YWwgYXR0cmlidXRlcy5cIlxuICApLFxuICB0ZXh0Q29udGVudDogZXh0ZXJuYWxfZXhwb3J0cy5zdHJpbmcoKS50cmFuc2Zvcm0oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDIwNDggPyBcXGBcXCR7dmFsLnNsaWNlKDAsIDIwNDgpfS4uLlt0cnVuY2F0ZWRdXFxgIDogdmFsKS5kZXNjcmliZShcbiAgICBcIlRleHQgY29udGVudCBvZiB0aGUgZWxlbWVudC4gV2lsbCBiZSB0cnVuY2F0ZWQgYWZ0ZXIgMjA0OCBjaGFyYWN0ZXJzLlwiXG4gICksXG4gIG93blByb3BlcnRpZXM6IGV4dGVybmFsX2V4cG9ydHMucmVjb3JkKGV4dGVybmFsX2V4cG9ydHMuYW55KCkpLnRyYW5zZm9ybSgob2JqKSA9PiB7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKG9iaiksIHRydW5jYXRlZEVudHJpZXMgPSBlbnRyaWVzLnNsaWNlKDAsIDUwMCksIHJlc3VsdCA9IE9iamVjdC5mcm9tRW50cmllcyh0cnVuY2F0ZWRFbnRyaWVzKTtcbiAgICByZXR1cm4gZW50cmllcy5sZW5ndGggPiA1MDAgJiYgKHJlc3VsdC5fX3RydW5jYXRlZF9fID0gXFxgLi4uW1xcJHtlbnRyaWVzLmxlbmd0aCAtIDUwMH0gbW9yZSBlbnRyaWVzIHRydW5jYXRlZF1cXGApLCByZXN1bHQ7XG4gIH0pLmRlc2NyaWJlKFxuICAgIFwiQ3VzdG9tIHByb3BlcnRpZXMgdGhhdCB0aGUgdW5kZXJseWluZyBvYmplY3QgbWF5IGhhdmUuIFdpbGwgYmUgdHJ1bmNhdGVkIGFmdGVyIDUwMCBlbnRyaWVzLiBPYmplY3QgYXJlIG9ubHkgY29waWVkIHVwIHRvIDMgbGV2ZWxzIGRlZXAsIGFsbCBjaGlsZHJlbiBhbmQgbGV2ZWxzIHdpbGwgYmUgdHJ1bmNhdGVkIGVxdWFsbHkuIE9ubHkgZWxlbWVudHMgdGhhdCBhcmUgc2VyaWFsaXphYmxlIHdpbGwgYmUgc2VudCBvdmVyXCJcbiAgKSxcbiAgYm91bmRpbmdDbGllbnRSZWN0OiBleHRlcm5hbF9leHBvcnRzLm9iamVjdCh7XG4gICAgdG9wOiBleHRlcm5hbF9leHBvcnRzLm51bWJlcigpLFxuICAgIGxlZnQ6IGV4dGVybmFsX2V4cG9ydHMubnVtYmVyKCksXG4gICAgaGVpZ2h0OiBleHRlcm5hbF9leHBvcnRzLm51bWJlcigpLFxuICAgIHdpZHRoOiBleHRlcm5hbF9leHBvcnRzLm51bWJlcigpXG4gIH0pLnN0cmljdCgpLFxuICBwbHVnaW5JbmZvOiBleHRlcm5hbF9leHBvcnRzLmFycmF5KFxuICAgIGV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgICAgIHBsdWdpbk5hbWU6IGV4dGVybmFsX2V4cG9ydHMuc3RyaW5nKCkubWF4KDEyOCksXG4gICAgICBjb250ZW50OiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLm1heCg0MDk2KVxuICAgIH0pXG4gIClcbn0pLCBzZWxlY3RlZEVsZW1lbnRTY2hlbWEgPSBiYXNlU2VsZWN0ZWRFbGVtZW50U2NoZW1hLmV4dGVuZCh7XG4gIHBhcmVudDogYmFzZVNlbGVjdGVkRWxlbWVudFNjaGVtYS5vcHRpb25hbCgpXG59KSwgdXNlck1lc3NhZ2VNZXRhZGF0YVNjaGVtYSA9IGV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgY3VycmVudFVybDogZXh0ZXJuYWxfZXhwb3J0cy5zdHJpbmcoKS5tYXgoMTAyNCkudXJsKCkubnVsbGFibGUoKSxcbiAgY3VycmVudFRpdGxlOiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLm1heCgyNTYpLm51bGxhYmxlKCksXG4gIGN1cnJlbnRab29tTGV2ZWw6IGV4dGVybmFsX2V4cG9ydHMubnVtYmVyKCksXG4gIHZpZXdwb3J0TWluU2NhbGU6IGV4dGVybmFsX2V4cG9ydHMubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgdmlld3BvcnRNYXhTY2FsZTogZXh0ZXJuYWxfZXhwb3J0cy5udW1iZXIoKS5vcHRpb25hbCgpLFxuICB2aWV3cG9ydFJlc29sdXRpb246IGV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgICB3aWR0aDogZXh0ZXJuYWxfZXhwb3J0cy5udW1iZXIoKS5taW4oMCksXG4gICAgaGVpZ2h0OiBleHRlcm5hbF9leHBvcnRzLm51bWJlcigpLm1pbigwKVxuICB9KSxcbiAgZGV2aWNlUGl4ZWxSYXRpbzogZXh0ZXJuYWxfZXhwb3J0cy5udW1iZXIoKSxcbiAgdXNlckFnZW50OiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLm1heCgxMDI0KSxcbiAgbG9jYWxlOiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLm1heCg2NCksXG4gIHNlbGVjdGVkRWxlbWVudHM6IGV4dGVybmFsX2V4cG9ydHMuYXJyYXkoc2VsZWN0ZWRFbGVtZW50U2NoZW1hKVxufSksIHVzZXJNZXNzYWdlQ29udGVudEl0ZW1TY2hlbWEgPSBleHRlcm5hbF9leHBvcnRzLmRpc2NyaW1pbmF0ZWRVbmlvbihcInR5cGVcIiwgW1xuICBleHRlcm5hbF9leHBvcnRzLm9iamVjdCh7XG4gICAgdHlwZTogZXh0ZXJuYWxfZXhwb3J0cy5saXRlcmFsKFwidGV4dFwiKSxcbiAgICB0ZXh0OiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpXG4gIH0pLFxuICBleHRlcm5hbF9leHBvcnRzLm9iamVjdCh7XG4gICAgdHlwZTogZXh0ZXJuYWxfZXhwb3J0cy5saXRlcmFsKFwiaW1hZ2VcIiksXG4gICAgbWltZVR5cGU6IGV4dGVybmFsX2V4cG9ydHMuc3RyaW5nKCkubWF4KDMyKSxcbiAgICBkYXRhOiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLmJhc2U2NCgpXG4gIH0pXG5dKTtcbmV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgaWQ6IGV4dGVybmFsX2V4cG9ydHMuc3RyaW5nKCksXG4gIGNvbnRlbnRJdGVtczogZXh0ZXJuYWxfZXhwb3J0cy5hcnJheSh1c2VyTWVzc2FnZUNvbnRlbnRJdGVtU2NoZW1hKSxcbiAgY3JlYXRlZEF0OiBleHRlcm5hbF9leHBvcnRzLmRhdGUoKSxcbiAgbWV0YWRhdGE6IHVzZXJNZXNzYWdlTWV0YWRhdGFTY2hlbWEsXG4gIHBsdWdpbkNvbnRlbnQ6IGV4dGVybmFsX2V4cG9ydHMucmVjb3JkKGV4dGVybmFsX2V4cG9ydHMucmVjb3JkKHVzZXJNZXNzYWdlQ29udGVudEl0ZW1TY2hlbWEpKSxcbiAgc2VudEJ5UGx1Z2luOiBleHRlcm5hbF9leHBvcnRzLmJvb2xlYW4oKVxufSk7XG52YXIgYWdlbnRNZXNzYWdlQ29udGVudEl0ZW1QYXJ0U2NoZW1hID0gZXh0ZXJuYWxfZXhwb3J0cy5kaXNjcmltaW5hdGVkVW5pb24oXCJ0eXBlXCIsIFtcbiAgZXh0ZXJuYWxfZXhwb3J0cy5vYmplY3Qoe1xuICAgIHR5cGU6IGV4dGVybmFsX2V4cG9ydHMubGl0ZXJhbChcInRleHRcIiksXG4gICAgdGV4dDogZXh0ZXJuYWxfZXhwb3J0cy5zdHJpbmcoKVxuICB9KSxcbiAgZXh0ZXJuYWxfZXhwb3J0cy5vYmplY3Qoe1xuICAgIHR5cGU6IGV4dGVybmFsX2V4cG9ydHMubGl0ZXJhbChcImltYWdlXCIpLFxuICAgIG1pbWVUeXBlOiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLm1heCgzMiksXG4gICAgZGF0YTogZXh0ZXJuYWxfZXhwb3J0cy5zdHJpbmcoKS5iYXNlNjQoKSxcbiAgICByZXBsYWNpbmc6IGV4dGVybmFsX2V4cG9ydHMuYm9vbGVhbigpXG4gIH0pXG5dKTtcbmV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgbWVzc2FnZUlkOiBleHRlcm5hbF9leHBvcnRzLnN0cmluZygpLmRlc2NyaWJlKFxuICAgIFwiTWFrZSBzdXJlIHRoaXMgc3RheXMgY29uc2lzdGVudCBhY3Jvc3MgYWxsIG1lc3NhZ2UgcGFydHMgZm9yIHRoaXMgbWVzc2FnZSBpbiBvcmRlciB0byBwcm9wZXJseSBjb25jYXRlbmF0ZSB0aGUgbWVzc2FnZSBwYXJ0c1wiXG4gICksXG4gIHVwZGF0ZVBhcnRzOiBleHRlcm5hbF9leHBvcnRzLmFycmF5KFxuICAgIGV4dGVybmFsX2V4cG9ydHMub2JqZWN0KHtcbiAgICAgIGNvbnRlbnRJbmRleDogZXh0ZXJuYWxfZXhwb3J0cy5udW1iZXIoKS5taW4oMCkuZGVzY3JpYmUoXG4gICAgICAgIFwiVGhlIGluZGV4IG9mIHRoZSBjb250ZW50IGl0ZW0gaW4gdGhlIG1lc3NhZ2UuIFRoaXMgaXMgdXNlZCB0byBjb25jYXRlbmF0ZSB0aGUgbWVzc2FnZSBwYXJ0cyBwcm9wZXJseS4gTWFrZSBzdXJlIHRoYXQgdGhlIHBhcnQgdHlwZSBpcyBjb25zaXN0ZW50IGFjcm9zcyBhbGwgcGFydHMuXCJcbiAgICAgICksXG4gICAgICBwYXJ0OiBhZ2VudE1lc3NhZ2VDb250ZW50SXRlbVBhcnRTY2hlbWEuZGVzY3JpYmUoXG4gICAgICAgIFwiUGFydCB0aGF0IHdpbGwgYmUgY29uY2F0ZW5hdGVkIHRvIHRoZSBwcmV2aW91c2x5IGV4aXN0aW5nIGNvbnRlbnQuXCJcbiAgICAgIClcbiAgICB9KVxuICApLFxuICBjcmVhdGVkQXQ6IGV4dGVybmFsX2V4cG9ydHMuZGF0ZSgpLFxuICByZXN5bmM6IGV4dGVybmFsX2V4cG9ydHMuYm9vbGVhbigpLmRlc2NyaWJlKFxuICAgIFwiSWYgdHJ1ZSwgdGhlIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgbGlrZSBhIGZ1bGwgcmVzeW5jIG9mIHRoZSBjb21wbGV0ZSBtZXNzYWdlLiBJdCB3aWxsIHRodXMgcmVwbGFjZSB0aGUgY29tcGxldGUgcHJldmlvdXMgbWVzc2FnZS5cIlxuICApXG59KS5zdHJpY3QoKS5kZXNjcmliZShcbiAgXCJVcGRhdGUgZm9yIHRoZSBleGlzdGluZyBtZXNzYWdlIHdpdGggdGhlIHVzZXIuIFRvIGNsZWFyIGEgbWVzc2FnZSwganVzdCBzZW5kIGEgZW1wdHkgbWVzc2FnZSB3aXRoIGEgbmV3IElELlwiXG4pO1xudmFyIERFRkFVTFRfU1RBUlRJTkdfUE9SVCA9IDU3NDYsIERvdWJsZUluZGV4ZWRLViA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5rZXlUb1ZhbHVlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy52YWx1ZVRvS2V5ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5VG9WYWx1ZS5zZXQoa2V5LCB2YWx1ZSksIHRoaXMudmFsdWVUb0tleS5zZXQodmFsdWUsIGtleSk7XG4gIH1cbiAgZ2V0QnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5VG9WYWx1ZS5nZXQoa2V5KTtcbiAgfVxuICBnZXRCeVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVUb0tleS5nZXQodmFsdWUpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMua2V5VG9WYWx1ZS5jbGVhcigpLCB0aGlzLnZhbHVlVG9LZXkuY2xlYXIoKTtcbiAgfVxufSwgUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRlSWRlbnRpZmllcikge1xuICAgIHRoaXMuZ2VuZXJhdGVJZGVudGlmaWVyID0gZ2VuZXJhdGVJZGVudGlmaWVyLCB0aGlzLmt2ID0gbmV3IERvdWJsZUluZGV4ZWRLVigpO1xuICB9XG4gIHJlZ2lzdGVyKHZhbHVlLCBpZGVudGlmaWVyKSB7XG4gICAgdGhpcy5rdi5nZXRCeVZhbHVlKHZhbHVlKSB8fCAoaWRlbnRpZmllciB8fCAoaWRlbnRpZmllciA9IHRoaXMuZ2VuZXJhdGVJZGVudGlmaWVyKHZhbHVlKSksIHRoaXMua3Yuc2V0KGlkZW50aWZpZXIsIHZhbHVlKSk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5rdi5jbGVhcigpO1xuICB9XG4gIGdldElkZW50aWZpZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5rdi5nZXRCeVZhbHVlKHZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZShpZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMua3YuZ2V0QnlLZXkoaWRlbnRpZmllcik7XG4gIH1cbn0sIENsYXNzUmVnaXN0cnkgPSBjbGFzcyBleHRlbmRzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKGMpID0+IGMubmFtZSksIHRoaXMuY2xhc3NUb0FsbG93ZWRQcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgcmVnaXN0ZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0eXBlb2Ygb3B0aW9ucyA9PSBcIm9iamVjdFwiID8gKG9wdGlvbnMuYWxsb3dQcm9wcyAmJiB0aGlzLmNsYXNzVG9BbGxvd2VkUHJvcHMuc2V0KHZhbHVlLCBvcHRpb25zLmFsbG93UHJvcHMpLCBzdXBlci5yZWdpc3Rlcih2YWx1ZSwgb3B0aW9ucy5pZGVudGlmaWVyKSkgOiBzdXBlci5yZWdpc3Rlcih2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgZ2V0QWxsb3dlZFByb3BzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xhc3NUb0FsbG93ZWRQcm9wcy5nZXQodmFsdWUpO1xuICB9XG59O1xuZnVuY3Rpb24gdmFsdWVzT2ZPYmoocmVjb3JkKSB7XG4gIGlmIChcInZhbHVlc1wiIGluIE9iamVjdClcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhyZWNvcmQpO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgaW4gcmVjb3JkKVxuICAgIHJlY29yZC5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIHZhbHVlcy5wdXNoKHJlY29yZFtrZXldKTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGZpbmQocmVjb3JkLCBwcmVkaWNhdGUpIHtcbiAgY29uc3QgdmFsdWVzID0gdmFsdWVzT2ZPYmoocmVjb3JkKTtcbiAgaWYgKFwiZmluZFwiIGluIHZhbHVlcylcbiAgICByZXR1cm4gdmFsdWVzLmZpbmQocHJlZGljYXRlKTtcbiAgY29uc3QgdmFsdWVzTm90TmV2ZXIgPSB2YWx1ZXM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzTm90TmV2ZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc05vdE5ldmVyW2ldO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5mdW5jdGlvbiBmb3JFYWNoKHJlY29yZCwgcnVuMikge1xuICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4gcnVuMih2YWx1ZSwga2V5KSk7XG59XG5mdW5jdGlvbiBpbmNsdWRlcyhhcnIsIHZhbHVlKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih2YWx1ZSkgIT09IC0xO1xufVxuZnVuY3Rpb24gZmluZEFycihyZWNvcmQsIHByZWRpY2F0ZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gcmVjb3JkW2ldO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUpKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG52YXIgQ3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50cmFuc2ZvbWVycyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyKHRyYW5zZm9ybWVyMikge1xuICAgIHRoaXMudHJhbnNmb21lcnNbdHJhbnNmb3JtZXIyLm5hbWVdID0gdHJhbnNmb3JtZXIyO1xuICB9XG4gIGZpbmRBcHBsaWNhYmxlKHYpIHtcbiAgICByZXR1cm4gZmluZCh0aGlzLnRyYW5zZm9tZXJzLCAodHJhbnNmb3JtZXIyKSA9PiB0cmFuc2Zvcm1lcjIuaXNBcHBsaWNhYmxlKHYpKTtcbiAgfVxuICBmaW5kQnlOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2ZvbWVyc1tuYW1lXTtcbiAgfVxufSwgZ2V0VHlwZSA9IChwYXlsb2FkKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF5bG9hZCkuc2xpY2UoOCwgLTEpLCBpc1VuZGVmaW5lZCA9IChwYXlsb2FkKSA9PiB0eXBlb2YgcGF5bG9hZCA+IFwidVwiLCBpc051bGwgPSAocGF5bG9hZCkgPT4gcGF5bG9hZCA9PT0gbnVsbCwgaXNQbGFpbk9iamVjdCA9IChwYXlsb2FkKSA9PiB0eXBlb2YgcGF5bG9hZCAhPSBcIm9iamVjdFwiIHx8IHBheWxvYWQgPT09IG51bGwgfHwgcGF5bG9hZCA9PT0gT2JqZWN0LnByb3RvdHlwZSA/ICExIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKHBheWxvYWQpID09PSBudWxsID8gITAgOiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGF5bG9hZCkgPT09IE9iamVjdC5wcm90b3R5cGUsIGlzRW1wdHlPYmplY3QgPSAocGF5bG9hZCkgPT4gaXNQbGFpbk9iamVjdChwYXlsb2FkKSAmJiBPYmplY3Qua2V5cyhwYXlsb2FkKS5sZW5ndGggPT09IDAsIGlzQXJyYXkgPSAocGF5bG9hZCkgPT4gQXJyYXkuaXNBcnJheShwYXlsb2FkKSwgaXNTdHJpbmcgPSAocGF5bG9hZCkgPT4gdHlwZW9mIHBheWxvYWQgPT0gXCJzdHJpbmdcIiwgaXNOdW1iZXIkMSA9IChwYXlsb2FkKSA9PiB0eXBlb2YgcGF5bG9hZCA9PSBcIm51bWJlclwiICYmICFpc05hTihwYXlsb2FkKSwgaXNCb29sZWFuID0gKHBheWxvYWQpID0+IHR5cGVvZiBwYXlsb2FkID09IFwiYm9vbGVhblwiLCBpc1JlZ0V4cCA9IChwYXlsb2FkKSA9PiBwYXlsb2FkIGluc3RhbmNlb2YgUmVnRXhwLCBpc01hcCA9IChwYXlsb2FkKSA9PiBwYXlsb2FkIGluc3RhbmNlb2YgTWFwLCBpc1NldCA9IChwYXlsb2FkKSA9PiBwYXlsb2FkIGluc3RhbmNlb2YgU2V0LCBpc1N5bWJvbCA9IChwYXlsb2FkKSA9PiBnZXRUeXBlKHBheWxvYWQpID09PSBcIlN5bWJvbFwiLCBpc0RhdGUgPSAocGF5bG9hZCkgPT4gcGF5bG9hZCBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHBheWxvYWQudmFsdWVPZigpKSwgaXNFcnJvciA9IChwYXlsb2FkKSA9PiBwYXlsb2FkIGluc3RhbmNlb2YgRXJyb3IsIGlzTmFOVmFsdWUgPSAocGF5bG9hZCkgPT4gdHlwZW9mIHBheWxvYWQgPT0gXCJudW1iZXJcIiAmJiBpc05hTihwYXlsb2FkKSwgaXNQcmltaXRpdmUgPSAocGF5bG9hZCkgPT4gaXNCb29sZWFuKHBheWxvYWQpIHx8IGlzTnVsbChwYXlsb2FkKSB8fCBpc1VuZGVmaW5lZChwYXlsb2FkKSB8fCBpc051bWJlciQxKHBheWxvYWQpIHx8IGlzU3RyaW5nKHBheWxvYWQpIHx8IGlzU3ltYm9sKHBheWxvYWQpLCBpc0JpZ2ludCA9IChwYXlsb2FkKSA9PiB0eXBlb2YgcGF5bG9hZCA9PSBcImJpZ2ludFwiLCBpc0luZmluaXRlID0gKHBheWxvYWQpID0+IHBheWxvYWQgPT09IDEgLyAwIHx8IHBheWxvYWQgPT09IC0xIC8gMCwgaXNUeXBlZEFycmF5ID0gKHBheWxvYWQpID0+IEFycmF5QnVmZmVyLmlzVmlldyhwYXlsb2FkKSAmJiAhKHBheWxvYWQgaW5zdGFuY2VvZiBEYXRhVmlldyksIGlzVVJMID0gKHBheWxvYWQpID0+IHBheWxvYWQgaW5zdGFuY2VvZiBVUkwsIGVzY2FwZUtleSA9IChrZXkpID0+IGtleS5yZXBsYWNlKC9cXFxcLi9nLCBcIlxcXFxcXFxcLlwiKSwgc3RyaW5naWZ5UGF0aCA9IChwYXRoKSA9PiBwYXRoLm1hcChTdHJpbmcpLm1hcChlc2NhcGVLZXkpLmpvaW4oXCIuXCIpLCBwYXJzZVBhdGggPSAoc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNoYXIgPSBzdHJpbmcuY2hhckF0KGkpO1xuICAgIGlmIChjaGFyID09PSBcIlxcXFxcXFxcXCIgJiYgc3RyaW5nLmNoYXJBdChpICsgMSkgPT09IFwiLlwiKSB7XG4gICAgICBzZWdtZW50ICs9IFwiLlwiLCBpKys7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IFwiLlwiKSB7XG4gICAgICByZXN1bHQucHVzaChzZWdtZW50KSwgc2VnbWVudCA9IFwiXCI7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc2VnbWVudCArPSBjaGFyO1xuICB9XG4gIGNvbnN0IGxhc3RTZWdtZW50ID0gc2VnbWVudDtcbiAgcmV0dXJuIHJlc3VsdC5wdXNoKGxhc3RTZWdtZW50KSwgcmVzdWx0O1xufTtcbmZ1bmN0aW9uIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzQXBwbGljYWJsZSwgYW5ub3RhdGlvbiwgdHJhbnNmb3JtLCB1bnRyYW5zZm9ybSkge1xuICByZXR1cm4ge1xuICAgIGlzQXBwbGljYWJsZSxcbiAgICBhbm5vdGF0aW9uLFxuICAgIHRyYW5zZm9ybSxcbiAgICB1bnRyYW5zZm9ybVxuICB9O1xufVxudmFyIHNpbXBsZVJ1bGVzID0gW1xuICBzaW1wbGVUcmFuc2Zvcm1hdGlvbihpc1VuZGVmaW5lZCwgXCJ1bmRlZmluZWRcIiwgKCkgPT4gbnVsbCwgKCkgPT4ge1xuICB9KSxcbiAgc2ltcGxlVHJhbnNmb3JtYXRpb24oaXNCaWdpbnQsIFwiYmlnaW50XCIsICh2KSA9PiB2LnRvU3RyaW5nKCksICh2KSA9PiB0eXBlb2YgQmlnSW50IDwgXCJ1XCIgPyBCaWdJbnQodikgOiAoY29uc29sZS5lcnJvcihcIlBsZWFzZSBhZGQgYSBCaWdJbnQgcG9seWZpbGwuXCIpLCB2KSksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzRGF0ZSwgXCJEYXRlXCIsICh2KSA9PiB2LnRvSVNPU3RyaW5nKCksICh2KSA9PiBuZXcgRGF0ZSh2KSksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzRXJyb3IsIFwiRXJyb3JcIiwgKHYsIHN1cGVySnNvbikgPT4ge1xuICAgIGNvbnN0IGJhc2VFcnJvciA9IHtcbiAgICAgIG5hbWU6IHYubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHYubWVzc2FnZVxuICAgIH07XG4gICAgcmV0dXJuIHN1cGVySnNvbi5hbGxvd2VkRXJyb3JQcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBiYXNlRXJyb3JbcHJvcF0gPSB2W3Byb3BdO1xuICAgIH0pLCBiYXNlRXJyb3I7XG4gIH0sICh2LCBzdXBlckpzb24pID0+IHtcbiAgICBjb25zdCBlID0gbmV3IEVycm9yKHYubWVzc2FnZSk7XG4gICAgcmV0dXJuIGUubmFtZSA9IHYubmFtZSwgZS5zdGFjayA9IHYuc3RhY2ssIHN1cGVySnNvbi5hbGxvd2VkRXJyb3JQcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBlW3Byb3BdID0gdltwcm9wXTtcbiAgICB9KSwgZTtcbiAgfSksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzUmVnRXhwLCBcInJlZ2V4cFwiLCAodikgPT4gXCJcIiArIHYsIChyZWdleCkgPT4ge1xuICAgIGNvbnN0IGJvZHkgPSByZWdleC5zbGljZSgxLCByZWdleC5sYXN0SW5kZXhPZihcIi9cIikpLCBmbGFncyA9IHJlZ2V4LnNsaWNlKHJlZ2V4Lmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGJvZHksIGZsYWdzKTtcbiAgfSksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKFxuICAgIGlzU2V0LFxuICAgIFwic2V0XCIsXG4gICAgLy8gKHNldHMgb25seSBleGlzdCBpbiBlczYrKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlczUvbm8tZXM2LW1ldGhvZHNcbiAgICAodikgPT4gWy4uLnYudmFsdWVzKCldLFxuICAgICh2KSA9PiBuZXcgU2V0KHYpXG4gICksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKGlzTWFwLCBcIm1hcFwiLCAodikgPT4gWy4uLnYuZW50cmllcygpXSwgKHYpID0+IG5ldyBNYXAodikpLFxuICBzaW1wbGVUcmFuc2Zvcm1hdGlvbigodikgPT4gaXNOYU5WYWx1ZSh2KSB8fCBpc0luZmluaXRlKHYpLCBcIm51bWJlclwiLCAodikgPT4gaXNOYU5WYWx1ZSh2KSA/IFwiTmFOXCIgOiB2ID4gMCA/IFwiSW5maW5pdHlcIiA6IFwiLUluZmluaXR5XCIsIE51bWJlciksXG4gIHNpbXBsZVRyYW5zZm9ybWF0aW9uKCh2KSA9PiB2ID09PSAwICYmIDEgLyB2ID09PSAtMSAvIDAsIFwibnVtYmVyXCIsICgpID0+IFwiLTBcIiwgTnVtYmVyKSxcbiAgc2ltcGxlVHJhbnNmb3JtYXRpb24oaXNVUkwsIFwiVVJMXCIsICh2KSA9PiB2LnRvU3RyaW5nKCksICh2KSA9PiBuZXcgVVJMKHYpKVxuXTtcbmZ1bmN0aW9uIGNvbXBvc2l0ZVRyYW5zZm9ybWF0aW9uKGlzQXBwbGljYWJsZSwgYW5ub3RhdGlvbiwgdHJhbnNmb3JtLCB1bnRyYW5zZm9ybSkge1xuICByZXR1cm4ge1xuICAgIGlzQXBwbGljYWJsZSxcbiAgICBhbm5vdGF0aW9uLFxuICAgIHRyYW5zZm9ybSxcbiAgICB1bnRyYW5zZm9ybVxuICB9O1xufVxudmFyIHN5bWJvbFJ1bGUgPSBjb21wb3NpdGVUcmFuc2Zvcm1hdGlvbigocywgc3VwZXJKc29uKSA9PiBpc1N5bWJvbChzKSA/ICEhc3VwZXJKc29uLnN5bWJvbFJlZ2lzdHJ5LmdldElkZW50aWZpZXIocykgOiAhMSwgKHMsIHN1cGVySnNvbikgPT4gW1wic3ltYm9sXCIsIHN1cGVySnNvbi5zeW1ib2xSZWdpc3RyeS5nZXRJZGVudGlmaWVyKHMpXSwgKHYpID0+IHYuZGVzY3JpcHRpb24sIChfLCBhLCBzdXBlckpzb24pID0+IHtcbiAgY29uc3QgdmFsdWUgPSBzdXBlckpzb24uc3ltYm9sUmVnaXN0cnkuZ2V0VmFsdWUoYVsxXSk7XG4gIGlmICghdmFsdWUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gc3ltYm9sXCIpO1xuICByZXR1cm4gdmFsdWU7XG59KSwgY29uc3RydWN0b3JUb05hbWUgPSBbXG4gIEludDhBcnJheSxcbiAgVWludDhBcnJheSxcbiAgSW50MTZBcnJheSxcbiAgVWludDE2QXJyYXksXG4gIEludDMyQXJyYXksXG4gIFVpbnQzMkFycmF5LFxuICBGbG9hdDMyQXJyYXksXG4gIEZsb2F0NjRBcnJheSxcbiAgVWludDhDbGFtcGVkQXJyYXlcbl0ucmVkdWNlKChvYmosIGN0b3IpID0+IChvYmpbY3Rvci5uYW1lXSA9IGN0b3IsIG9iaiksIHt9KSwgdHlwZWRBcnJheVJ1bGUgPSBjb21wb3NpdGVUcmFuc2Zvcm1hdGlvbihpc1R5cGVkQXJyYXksICh2KSA9PiBbXCJ0eXBlZC1hcnJheVwiLCB2LmNvbnN0cnVjdG9yLm5hbWVdLCAodikgPT4gWy4uLnZdLCAodiwgYSkgPT4ge1xuICBjb25zdCBjdG9yID0gY29uc3RydWN0b3JUb05hbWVbYVsxXV07XG4gIGlmICghY3RvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gZGVzZXJpYWxpemUgdW5rbm93biB0eXBlZCBhcnJheVwiKTtcbiAgcmV0dXJuIG5ldyBjdG9yKHYpO1xufSk7XG5mdW5jdGlvbiBpc0luc3RhbmNlT2ZSZWdpc3RlcmVkQ2xhc3MocG90ZW50aWFsQ2xhc3MsIHN1cGVySnNvbikge1xuICByZXR1cm4gcG90ZW50aWFsQ2xhc3MgIT0gbnVsbCAmJiBwb3RlbnRpYWxDbGFzcy5jb25zdHJ1Y3RvciA/ICEhc3VwZXJKc29uLmNsYXNzUmVnaXN0cnkuZ2V0SWRlbnRpZmllcihwb3RlbnRpYWxDbGFzcy5jb25zdHJ1Y3RvcikgOiAhMTtcbn1cbnZhciBjbGFzc1J1bGUgPSBjb21wb3NpdGVUcmFuc2Zvcm1hdGlvbihpc0luc3RhbmNlT2ZSZWdpc3RlcmVkQ2xhc3MsIChjbGF6eiwgc3VwZXJKc29uKSA9PiBbXCJjbGFzc1wiLCBzdXBlckpzb24uY2xhc3NSZWdpc3RyeS5nZXRJZGVudGlmaWVyKGNsYXp6LmNvbnN0cnVjdG9yKV0sIChjbGF6eiwgc3VwZXJKc29uKSA9PiB7XG4gIGNvbnN0IGFsbG93ZWRQcm9wcyA9IHN1cGVySnNvbi5jbGFzc1JlZ2lzdHJ5LmdldEFsbG93ZWRQcm9wcyhjbGF6ei5jb25zdHJ1Y3Rvcik7XG4gIGlmICghYWxsb3dlZFByb3BzKVxuICAgIHJldHVybiB7IC4uLmNsYXp6IH07XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICByZXR1cm4gYWxsb3dlZFByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICByZXN1bHRbcHJvcF0gPSBjbGF6eltwcm9wXTtcbiAgfSksIHJlc3VsdDtcbn0sICh2LCBhLCBzdXBlckpzb24pID0+IHtcbiAgY29uc3QgY2xhenogPSBzdXBlckpzb24uY2xhc3NSZWdpc3RyeS5nZXRWYWx1ZShhWzFdKTtcbiAgaWYgKCFjbGF6eilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXFxgVHJ5aW5nIHRvIGRlc2VyaWFsaXplIHVua25vd24gY2xhc3MgJ1xcJHthWzFdfScgLSBjaGVjayBodHRwczovL2dpdGh1Yi5jb20vYmxpdHotanMvc3VwZXJqc29uL2lzc3Vlcy8xMTYjaXNzdWVjb21tZW50LTc3Mzk5NjU2NFxcYCk7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoY2xhenoucHJvdG90eXBlKSwgdik7XG59KSwgY3VzdG9tUnVsZSA9IGNvbXBvc2l0ZVRyYW5zZm9ybWF0aW9uKCh2YWx1ZSwgc3VwZXJKc29uKSA9PiAhIXN1cGVySnNvbi5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5LmZpbmRBcHBsaWNhYmxlKHZhbHVlKSwgKHZhbHVlLCBzdXBlckpzb24pID0+IFtcImN1c3RvbVwiLCBzdXBlckpzb24uY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeS5maW5kQXBwbGljYWJsZSh2YWx1ZSkubmFtZV0sICh2YWx1ZSwgc3VwZXJKc29uKSA9PiBzdXBlckpzb24uY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeS5maW5kQXBwbGljYWJsZSh2YWx1ZSkuc2VyaWFsaXplKHZhbHVlKSwgKHYsIGEsIHN1cGVySnNvbikgPT4ge1xuICBjb25zdCB0cmFuc2Zvcm1lcjIgPSBzdXBlckpzb24uY3VzdG9tVHJhbnNmb3JtZXJSZWdpc3RyeS5maW5kQnlOYW1lKGFbMV0pO1xuICBpZiAoIXRyYW5zZm9ybWVyMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gZGVzZXJpYWxpemUgdW5rbm93biBjdXN0b20gdmFsdWVcIik7XG4gIHJldHVybiB0cmFuc2Zvcm1lcjIuZGVzZXJpYWxpemUodik7XG59KSwgY29tcG9zaXRlUnVsZXMgPSBbY2xhc3NSdWxlLCBzeW1ib2xSdWxlLCBjdXN0b21SdWxlLCB0eXBlZEFycmF5UnVsZV0sIHRyYW5zZm9ybVZhbHVlID0gKHZhbHVlLCBzdXBlckpzb24pID0+IHtcbiAgY29uc3QgYXBwbGljYWJsZUNvbXBvc2l0ZVJ1bGUgPSBmaW5kQXJyKGNvbXBvc2l0ZVJ1bGVzLCAocnVsZSkgPT4gcnVsZS5pc0FwcGxpY2FibGUodmFsdWUsIHN1cGVySnNvbikpO1xuICBpZiAoYXBwbGljYWJsZUNvbXBvc2l0ZVJ1bGUpXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcHBsaWNhYmxlQ29tcG9zaXRlUnVsZS50cmFuc2Zvcm0odmFsdWUsIHN1cGVySnNvbiksXG4gICAgICB0eXBlOiBhcHBsaWNhYmxlQ29tcG9zaXRlUnVsZS5hbm5vdGF0aW9uKHZhbHVlLCBzdXBlckpzb24pXG4gICAgfTtcbiAgY29uc3QgYXBwbGljYWJsZVNpbXBsZVJ1bGUgPSBmaW5kQXJyKHNpbXBsZVJ1bGVzLCAocnVsZSkgPT4gcnVsZS5pc0FwcGxpY2FibGUodmFsdWUsIHN1cGVySnNvbikpO1xuICBpZiAoYXBwbGljYWJsZVNpbXBsZVJ1bGUpXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcHBsaWNhYmxlU2ltcGxlUnVsZS50cmFuc2Zvcm0odmFsdWUsIHN1cGVySnNvbiksXG4gICAgICB0eXBlOiBhcHBsaWNhYmxlU2ltcGxlUnVsZS5hbm5vdGF0aW9uXG4gICAgfTtcbn0sIHNpbXBsZVJ1bGVzQnlBbm5vdGF0aW9uID0ge307XG5zaW1wbGVSdWxlcy5mb3JFYWNoKChydWxlKSA9PiB7XG4gIHNpbXBsZVJ1bGVzQnlBbm5vdGF0aW9uW3J1bGUuYW5ub3RhdGlvbl0gPSBydWxlO1xufSk7XG52YXIgdW50cmFuc2Zvcm1WYWx1ZSA9IChqc29uLCB0eXBlLCBzdXBlckpzb24pID0+IHtcbiAgaWYgKGlzQXJyYXkodHlwZSkpXG4gICAgc3dpdGNoICh0eXBlWzBdKSB7XG4gICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgIHJldHVybiBzeW1ib2xSdWxlLnVudHJhbnNmb3JtKGpzb24sIHR5cGUsIHN1cGVySnNvbik7XG4gICAgICBjYXNlIFwiY2xhc3NcIjpcbiAgICAgICAgcmV0dXJuIGNsYXNzUnVsZS51bnRyYW5zZm9ybShqc29uLCB0eXBlLCBzdXBlckpzb24pO1xuICAgICAgY2FzZSBcImN1c3RvbVwiOlxuICAgICAgICByZXR1cm4gY3VzdG9tUnVsZS51bnRyYW5zZm9ybShqc29uLCB0eXBlLCBzdXBlckpzb24pO1xuICAgICAgY2FzZSBcInR5cGVkLWFycmF5XCI6XG4gICAgICAgIHJldHVybiB0eXBlZEFycmF5UnVsZS51bnRyYW5zZm9ybShqc29uLCB0eXBlLCBzdXBlckpzb24pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0cmFuc2Zvcm1hdGlvbjogXCIgKyB0eXBlKTtcbiAgICB9XG4gIGVsc2Uge1xuICAgIGNvbnN0IHRyYW5zZm9ybWF0aW9uID0gc2ltcGxlUnVsZXNCeUFubm90YXRpb25bdHlwZV07XG4gICAgaWYgKCF0cmFuc2Zvcm1hdGlvbilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHJhbnNmb3JtYXRpb246IFwiICsgdHlwZSk7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWF0aW9uLnVudHJhbnNmb3JtKGpzb24sIHN1cGVySnNvbik7XG4gIH1cbn0sIGdldE50aEtleSA9ICh2YWx1ZSwgbikgPT4ge1xuICBpZiAobiA+IHZhbHVlLnNpemUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggb3V0IG9mIGJvdW5kc1wiKTtcbiAgY29uc3Qga2V5cyA9IHZhbHVlLmtleXMoKTtcbiAgZm9yICg7IG4gPiAwOyApXG4gICAga2V5cy5uZXh0KCksIG4tLTtcbiAgcmV0dXJuIGtleXMubmV4dCgpLnZhbHVlO1xufTtcbmZ1bmN0aW9uIHZhbGlkYXRlUGF0aChwYXRoKSB7XG4gIGlmIChpbmNsdWRlcyhwYXRoLCBcIl9fcHJvdG9fX1wiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJfX3Byb3RvX18gaXMgbm90IGFsbG93ZWQgYXMgYSBwcm9wZXJ0eVwiKTtcbiAgaWYgKGluY2x1ZGVzKHBhdGgsIFwicHJvdG90eXBlXCIpKVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb3RvdHlwZSBpcyBub3QgYWxsb3dlZCBhcyBhIHByb3BlcnR5XCIpO1xuICBpZiAoaW5jbHVkZXMocGF0aCwgXCJjb25zdHJ1Y3RvclwiKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZCBhcyBhIHByb3BlcnR5XCIpO1xufVxudmFyIGdldERlZXAgPSAob2JqZWN0LCBwYXRoKSA9PiB7XG4gIHZhbGlkYXRlUGF0aChwYXRoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0gcGF0aFtpXTtcbiAgICBpZiAoaXNTZXQob2JqZWN0KSlcbiAgICAgIG9iamVjdCA9IGdldE50aEtleShvYmplY3QsICtrZXkpO1xuICAgIGVsc2UgaWYgKGlzTWFwKG9iamVjdCkpIHtcbiAgICAgIGNvbnN0IHJvdyA9ICtrZXksIHR5cGUgPSArcGF0aFsrK2ldID09IDAgPyBcImtleVwiIDogXCJ2YWx1ZVwiLCBrZXlPZlJvdyA9IGdldE50aEtleShvYmplY3QsIHJvdyk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImtleVwiOlxuICAgICAgICAgIG9iamVjdCA9IGtleU9mUm93O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuZ2V0KGtleU9mUm93KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59LCBzZXREZWVwID0gKG9iamVjdCwgcGF0aCwgbWFwcGVyKSA9PiB7XG4gIGlmICh2YWxpZGF0ZVBhdGgocGF0aCksIHBhdGgubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBtYXBwZXIob2JqZWN0KTtcbiAgbGV0IHBhcmVudCA9IG9iamVjdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IHBhdGhbaV07XG4gICAgaWYgKGlzQXJyYXkocGFyZW50KSkge1xuICAgICAgY29uc3QgaW5kZXggPSAra2V5O1xuICAgICAgcGFyZW50ID0gcGFyZW50W2luZGV4XTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocGFyZW50KSlcbiAgICAgIHBhcmVudCA9IHBhcmVudFtrZXldO1xuICAgIGVsc2UgaWYgKGlzU2V0KHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IHJvdyA9ICtrZXk7XG4gICAgICBwYXJlbnQgPSBnZXROdGhLZXkocGFyZW50LCByb3cpO1xuICAgIH0gZWxzZSBpZiAoaXNNYXAocGFyZW50KSkge1xuICAgICAgaWYgKGkgPT09IHBhdGgubGVuZ3RoIC0gMilcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCByb3cgPSAra2V5LCB0eXBlID0gK3BhdGhbKytpXSA9PSAwID8gXCJrZXlcIiA6IFwidmFsdWVcIiwga2V5T2ZSb3cgPSBnZXROdGhLZXkocGFyZW50LCByb3cpO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgICBwYXJlbnQgPSBrZXlPZlJvdztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldChrZXlPZlJvdyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGxhc3RLZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gIGlmIChpc0FycmF5KHBhcmVudCkgPyBwYXJlbnRbK2xhc3RLZXldID0gbWFwcGVyKHBhcmVudFsrbGFzdEtleV0pIDogaXNQbGFpbk9iamVjdChwYXJlbnQpICYmIChwYXJlbnRbbGFzdEtleV0gPSBtYXBwZXIocGFyZW50W2xhc3RLZXldKSksIGlzU2V0KHBhcmVudCkpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IGdldE50aEtleShwYXJlbnQsICtsYXN0S2V5KSwgbmV3VmFsdWUgPSBtYXBwZXIob2xkVmFsdWUpO1xuICAgIG9sZFZhbHVlICE9PSBuZXdWYWx1ZSAmJiAocGFyZW50LmRlbGV0ZShvbGRWYWx1ZSksIHBhcmVudC5hZGQobmV3VmFsdWUpKTtcbiAgfVxuICBpZiAoaXNNYXAocGFyZW50KSkge1xuICAgIGNvbnN0IHJvdyA9ICtwYXRoW3BhdGgubGVuZ3RoIC0gMl0sIGtleVRvUm93ID0gZ2V0TnRoS2V5KHBhcmVudCwgcm93KTtcbiAgICBzd2l0Y2ggKCtsYXN0S2V5ID09IDAgPyBcImtleVwiIDogXCJ2YWx1ZVwiKSB7XG4gICAgICBjYXNlIFwia2V5XCI6IHtcbiAgICAgICAgY29uc3QgbmV3S2V5ID0gbWFwcGVyKGtleVRvUm93KTtcbiAgICAgICAgcGFyZW50LnNldChuZXdLZXksIHBhcmVudC5nZXQoa2V5VG9Sb3cpKSwgbmV3S2V5ICE9PSBrZXlUb1JvdyAmJiBwYXJlbnQuZGVsZXRlKGtleVRvUm93KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidmFsdWVcIjoge1xuICAgICAgICBwYXJlbnQuc2V0KGtleVRvUm93LCBtYXBwZXIocGFyZW50LmdldChrZXlUb1JvdykpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59O1xuZnVuY3Rpb24gdHJhdmVyc2UodHJlZSwgd2Fsa2VyMiwgb3JpZ2luID0gW10pIHtcbiAgaWYgKCF0cmVlKVxuICAgIHJldHVybjtcbiAgaWYgKCFpc0FycmF5KHRyZWUpKSB7XG4gICAgZm9yRWFjaCh0cmVlLCAoc3VidHJlZSwga2V5KSA9PiB0cmF2ZXJzZShzdWJ0cmVlLCB3YWxrZXIyLCBbLi4ub3JpZ2luLCAuLi5wYXJzZVBhdGgoa2V5KV0pKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW25vZGVWYWx1ZSwgY2hpbGRyZW5dID0gdHJlZTtcbiAgY2hpbGRyZW4gJiYgZm9yRWFjaChjaGlsZHJlbiwgKGNoaWxkLCBrZXkpID0+IHtcbiAgICB0cmF2ZXJzZShjaGlsZCwgd2Fsa2VyMiwgWy4uLm9yaWdpbiwgLi4ucGFyc2VQYXRoKGtleSldKTtcbiAgfSksIHdhbGtlcjIobm9kZVZhbHVlLCBvcmlnaW4pO1xufVxuZnVuY3Rpb24gYXBwbHlWYWx1ZUFubm90YXRpb25zKHBsYWluLCBhbm5vdGF0aW9ucywgc3VwZXJKc29uKSB7XG4gIHJldHVybiB0cmF2ZXJzZShhbm5vdGF0aW9ucywgKHR5cGUsIHBhdGgpID0+IHtcbiAgICBwbGFpbiA9IHNldERlZXAocGxhaW4sIHBhdGgsICh2KSA9PiB1bnRyYW5zZm9ybVZhbHVlKHYsIHR5cGUsIHN1cGVySnNvbikpO1xuICB9KSwgcGxhaW47XG59XG5mdW5jdGlvbiBhcHBseVJlZmVyZW50aWFsRXF1YWxpdHlBbm5vdGF0aW9ucyhwbGFpbiwgYW5ub3RhdGlvbnMpIHtcbiAgZnVuY3Rpb24gYXBwbHkoaWRlbnRpY2FsUGF0aHMsIHBhdGgpIHtcbiAgICBjb25zdCBvYmplY3QgPSBnZXREZWVwKHBsYWluLCBwYXJzZVBhdGgocGF0aCkpO1xuICAgIGlkZW50aWNhbFBhdGhzLm1hcChwYXJzZVBhdGgpLmZvckVhY2goKGlkZW50aWNhbE9iamVjdFBhdGgpID0+IHtcbiAgICAgIHBsYWluID0gc2V0RGVlcChwbGFpbiwgaWRlbnRpY2FsT2JqZWN0UGF0aCwgKCkgPT4gb2JqZWN0KTtcbiAgICB9KTtcbiAgfVxuICBpZiAoaXNBcnJheShhbm5vdGF0aW9ucykpIHtcbiAgICBjb25zdCBbcm9vdCwgb3RoZXJdID0gYW5ub3RhdGlvbnM7XG4gICAgcm9vdC5mb3JFYWNoKChpZGVudGljYWxQYXRoKSA9PiB7XG4gICAgICBwbGFpbiA9IHNldERlZXAocGxhaW4sIHBhcnNlUGF0aChpZGVudGljYWxQYXRoKSwgKCkgPT4gcGxhaW4pO1xuICAgIH0pLCBvdGhlciAmJiBmb3JFYWNoKG90aGVyLCBhcHBseSk7XG4gIH0gZWxzZVxuICAgIGZvckVhY2goYW5ub3RhdGlvbnMsIGFwcGx5KTtcbiAgcmV0dXJuIHBsYWluO1xufVxudmFyIGlzRGVlcCA9IChvYmplY3QsIHN1cGVySnNvbikgPT4gaXNQbGFpbk9iamVjdChvYmplY3QpIHx8IGlzQXJyYXkob2JqZWN0KSB8fCBpc01hcChvYmplY3QpIHx8IGlzU2V0KG9iamVjdCkgfHwgaXNJbnN0YW5jZU9mUmVnaXN0ZXJlZENsYXNzKG9iamVjdCwgc3VwZXJKc29uKTtcbmZ1bmN0aW9uIGFkZElkZW50aXR5KG9iamVjdCwgcGF0aCwgaWRlbnRpdGllcykge1xuICBjb25zdCBleGlzdGluZ1NldCA9IGlkZW50aXRpZXMuZ2V0KG9iamVjdCk7XG4gIGV4aXN0aW5nU2V0ID8gZXhpc3RpbmdTZXQucHVzaChwYXRoKSA6IGlkZW50aXRpZXMuc2V0KG9iamVjdCwgW3BhdGhdKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlUmVmZXJlbnRpYWxFcXVhbGl0eUFubm90YXRpb25zKGlkZW50aXRpdGVzLCBkZWR1cGUpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGxldCByb290RXF1YWxpdHlQYXRocztcbiAgcmV0dXJuIGlkZW50aXRpdGVzLmZvckVhY2goKHBhdGhzKSA9PiB7XG4gICAgaWYgKHBhdGhzLmxlbmd0aCA8PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGRlZHVwZSB8fCAocGF0aHMgPSBwYXRocy5tYXAoKHBhdGgpID0+IHBhdGgubWFwKFN0cmluZykpLnNvcnQoKGEsIGIpID0+IGEubGVuZ3RoIC0gYi5sZW5ndGgpKTtcbiAgICBjb25zdCBbcmVwcmVzZW50YXRpdmVQYXRoLCAuLi5pZGVudGljYWxQYXRoc10gPSBwYXRocztcbiAgICByZXByZXNlbnRhdGl2ZVBhdGgubGVuZ3RoID09PSAwID8gcm9vdEVxdWFsaXR5UGF0aHMgPSBpZGVudGljYWxQYXRocy5tYXAoc3RyaW5naWZ5UGF0aCkgOiByZXN1bHRbc3RyaW5naWZ5UGF0aChyZXByZXNlbnRhdGl2ZVBhdGgpXSA9IGlkZW50aWNhbFBhdGhzLm1hcChzdHJpbmdpZnlQYXRoKTtcbiAgfSksIHJvb3RFcXVhbGl0eVBhdGhzID8gaXNFbXB0eU9iamVjdChyZXN1bHQpID8gW3Jvb3RFcXVhbGl0eVBhdGhzXSA6IFtyb290RXF1YWxpdHlQYXRocywgcmVzdWx0XSA6IGlzRW1wdHlPYmplY3QocmVzdWx0KSA/IHZvaWQgMCA6IHJlc3VsdDtcbn1cbnZhciB3YWxrZXIgPSAob2JqZWN0LCBpZGVudGl0aWVzLCBzdXBlckpzb24sIGRlZHVwZSwgcGF0aCA9IFtdLCBvYmplY3RzSW5UaGlzUGF0aCA9IFtdLCBzZWVuT2JqZWN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpID0+IHtcbiAgY29uc3QgcHJpbWl0aXZlID0gaXNQcmltaXRpdmUob2JqZWN0KTtcbiAgaWYgKCFwcmltaXRpdmUpIHtcbiAgICBhZGRJZGVudGl0eShvYmplY3QsIHBhdGgsIGlkZW50aXRpZXMpO1xuICAgIGNvbnN0IHNlZW4gPSBzZWVuT2JqZWN0cy5nZXQob2JqZWN0KTtcbiAgICBpZiAoc2VlbilcbiAgICAgIHJldHVybiBkZWR1cGUgPyB7XG4gICAgICAgIHRyYW5zZm9ybWVkVmFsdWU6IG51bGxcbiAgICAgIH0gOiBzZWVuO1xuICB9XG4gIGlmICghaXNEZWVwKG9iamVjdCwgc3VwZXJKc29uKSkge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkMiA9IHRyYW5zZm9ybVZhbHVlKG9iamVjdCwgc3VwZXJKc29uKSwgcmVzdWx0MiA9IHRyYW5zZm9ybWVkMiA/IHtcbiAgICAgIHRyYW5zZm9ybWVkVmFsdWU6IHRyYW5zZm9ybWVkMi52YWx1ZSxcbiAgICAgIGFubm90YXRpb25zOiBbdHJhbnNmb3JtZWQyLnR5cGVdXG4gICAgfSA6IHtcbiAgICAgIHRyYW5zZm9ybWVkVmFsdWU6IG9iamVjdFxuICAgIH07XG4gICAgcmV0dXJuIHByaW1pdGl2ZSB8fCBzZWVuT2JqZWN0cy5zZXQob2JqZWN0LCByZXN1bHQyKSwgcmVzdWx0MjtcbiAgfVxuICBpZiAoaW5jbHVkZXMob2JqZWN0c0luVGhpc1BhdGgsIG9iamVjdCkpXG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zZm9ybWVkVmFsdWU6IG51bGxcbiAgICB9O1xuICBjb25zdCB0cmFuc2Zvcm1hdGlvblJlc3VsdCA9IHRyYW5zZm9ybVZhbHVlKG9iamVjdCwgc3VwZXJKc29uKSwgdHJhbnNmb3JtZWQgPSAodHJhbnNmb3JtYXRpb25SZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRyYW5zZm9ybWF0aW9uUmVzdWx0LnZhbHVlKSA/PyBvYmplY3QsIHRyYW5zZm9ybWVkVmFsdWUgPSBpc0FycmF5KHRyYW5zZm9ybWVkKSA/IFtdIDoge30sIGlubmVyQW5ub3RhdGlvbnMgPSB7fTtcbiAgZm9yRWFjaCh0cmFuc2Zvcm1lZCwgKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCA9PT0gXCJfX3Byb3RvX19cIiB8fCBpbmRleCA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGluZGV4ID09PSBcInByb3RvdHlwZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxcYERldGVjdGVkIHByb3BlcnR5IFxcJHtpbmRleH0uIFRoaXMgaXMgYSBwcm90b3R5cGUgcG9sbHV0aW9uIHJpc2ssIHBsZWFzZSByZW1vdmUgaXQgZnJvbSB5b3VyIG9iamVjdC5cXGApO1xuICAgIGNvbnN0IHJlY3Vyc2l2ZVJlc3VsdCA9IHdhbGtlcih2YWx1ZSwgaWRlbnRpdGllcywgc3VwZXJKc29uLCBkZWR1cGUsIFsuLi5wYXRoLCBpbmRleF0sIFsuLi5vYmplY3RzSW5UaGlzUGF0aCwgb2JqZWN0XSwgc2Vlbk9iamVjdHMpO1xuICAgIHRyYW5zZm9ybWVkVmFsdWVbaW5kZXhdID0gcmVjdXJzaXZlUmVzdWx0LnRyYW5zZm9ybWVkVmFsdWUsIGlzQXJyYXkocmVjdXJzaXZlUmVzdWx0LmFubm90YXRpb25zKSA/IGlubmVyQW5ub3RhdGlvbnNbaW5kZXhdID0gcmVjdXJzaXZlUmVzdWx0LmFubm90YXRpb25zIDogaXNQbGFpbk9iamVjdChyZWN1cnNpdmVSZXN1bHQuYW5ub3RhdGlvbnMpICYmIGZvckVhY2gocmVjdXJzaXZlUmVzdWx0LmFubm90YXRpb25zLCAodHJlZSwga2V5KSA9PiB7XG4gICAgICBpbm5lckFubm90YXRpb25zW2VzY2FwZUtleShpbmRleCkgKyBcIi5cIiArIGtleV0gPSB0cmVlO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0gaXNFbXB0eU9iamVjdChpbm5lckFubm90YXRpb25zKSA/IHtcbiAgICB0cmFuc2Zvcm1lZFZhbHVlLFxuICAgIGFubm90YXRpb25zOiB0cmFuc2Zvcm1hdGlvblJlc3VsdCA/IFt0cmFuc2Zvcm1hdGlvblJlc3VsdC50eXBlXSA6IHZvaWQgMFxuICB9IDoge1xuICAgIHRyYW5zZm9ybWVkVmFsdWUsXG4gICAgYW5ub3RhdGlvbnM6IHRyYW5zZm9ybWF0aW9uUmVzdWx0ID8gW3RyYW5zZm9ybWF0aW9uUmVzdWx0LnR5cGUsIGlubmVyQW5ub3RhdGlvbnNdIDogaW5uZXJBbm5vdGF0aW9uc1xuICB9O1xuICByZXR1cm4gcHJpbWl0aXZlIHx8IHNlZW5PYmplY3RzLnNldChvYmplY3QsIHJlc3VsdCksIHJlc3VsdDtcbn07XG5mdW5jdGlvbiBnZXRUeXBlMihwYXlsb2FkKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocGF5bG9hZCkuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gaXNBcnJheTIocGF5bG9hZCkge1xuICByZXR1cm4gZ2V0VHlwZTIocGF5bG9hZCkgPT09IFwiQXJyYXlcIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QyKHBheWxvYWQpIHtcbiAgaWYgKGdldFR5cGUyKHBheWxvYWQpICE9PSBcIk9iamVjdFwiKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBheWxvYWQpO1xuICByZXR1cm4gISFwcm90b3R5cGUgJiYgcHJvdG90eXBlLmNvbnN0cnVjdG9yID09PSBPYmplY3QgJiYgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gYXNzaWduUHJvcChjYXJyeSwga2V5LCBuZXdWYWwsIG9yaWdpbmFsT2JqZWN0LCBpbmNsdWRlTm9uZW51bWVyYWJsZSkge1xuICBjb25zdCBwcm9wVHlwZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob3JpZ2luYWxPYmplY3QsIGtleSkgPyBcImVudW1lcmFibGVcIiA6IFwibm9uZW51bWVyYWJsZVwiO1xuICBwcm9wVHlwZSA9PT0gXCJlbnVtZXJhYmxlXCIgJiYgKGNhcnJ5W2tleV0gPSBuZXdWYWwpLCBpbmNsdWRlTm9uZW51bWVyYWJsZSAmJiBwcm9wVHlwZSA9PT0gXCJub25lbnVtZXJhYmxlXCIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhcnJ5LCBrZXksIHtcbiAgICB2YWx1ZTogbmV3VmFsLFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHdyaXRhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwXG4gIH0pO1xufVxuZnVuY3Rpb24gY29weSh0YXJnZXQsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoaXNBcnJheTIodGFyZ2V0KSlcbiAgICByZXR1cm4gdGFyZ2V0Lm1hcCgoaXRlbSkgPT4gY29weShpdGVtLCBvcHRpb25zKSk7XG4gIGlmICghaXNQbGFpbk9iamVjdDIodGFyZ2V0KSlcbiAgICByZXR1cm4gdGFyZ2V0O1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCksIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCk7XG4gIHJldHVybiBbLi4ucHJvcHMsIC4uLnN5bWJvbHNdLnJlZHVjZSgoY2FycnksIGtleSkgPT4ge1xuICAgIGlmIChpc0FycmF5MihvcHRpb25zLnByb3BzKSAmJiAhb3B0aW9ucy5wcm9wcy5pbmNsdWRlcyhrZXkpKVxuICAgICAgcmV0dXJuIGNhcnJ5O1xuICAgIGNvbnN0IHZhbCA9IHRhcmdldFtrZXldLCBuZXdWYWwgPSBjb3B5KHZhbCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGFzc2lnblByb3AoY2FycnksIGtleSwgbmV3VmFsLCB0YXJnZXQsIG9wdGlvbnMubm9uZW51bWVyYWJsZSksIGNhcnJ5O1xuICB9LCB7fSk7XG59XG52YXIgU3VwZXJKU09OID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIGRlZHVwZVJlZmVyZW50aWFsRXF1YWxpdGllcyAgSWYgdHJ1ZSwgU3VwZXJKU09OIHdpbGwgbWFrZSBzdXJlIG9ubHkgb25lIGluc3RhbmNlIG9mIHJlZmVyZW50aWFsbHkgZXF1YWwgb2JqZWN0cyBhcmUgc2VyaWFsaXplZCBhbmQgdGhlIHJlc3QgYXJlIHJlcGxhY2VkIHdpdGggXFxgbnVsbFxcYC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgZGVkdXBlID0gITEgfSA9IHt9KSB7XG4gICAgdGhpcy5jbGFzc1JlZ2lzdHJ5ID0gbmV3IENsYXNzUmVnaXN0cnkoKSwgdGhpcy5zeW1ib2xSZWdpc3RyeSA9IG5ldyBSZWdpc3RyeSgocykgPT4gcy5kZXNjcmlwdGlvbiA/PyBcIlwiKSwgdGhpcy5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5ID0gbmV3IEN1c3RvbVRyYW5zZm9ybWVyUmVnaXN0cnkoKSwgdGhpcy5hbGxvd2VkRXJyb3JQcm9wcyA9IFtdLCB0aGlzLmRlZHVwZSA9IGRlZHVwZTtcbiAgfVxuICBzZXJpYWxpemUob2JqZWN0KSB7XG4gICAgY29uc3QgaWRlbnRpdGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIG91dHB1dCA9IHdhbGtlcihvYmplY3QsIGlkZW50aXRpZXMsIHRoaXMsIHRoaXMuZGVkdXBlKSwgcmVzID0ge1xuICAgICAganNvbjogb3V0cHV0LnRyYW5zZm9ybWVkVmFsdWVcbiAgICB9O1xuICAgIG91dHB1dC5hbm5vdGF0aW9ucyAmJiAocmVzLm1ldGEgPSB7XG4gICAgICAuLi5yZXMubWV0YSxcbiAgICAgIHZhbHVlczogb3V0cHV0LmFubm90YXRpb25zXG4gICAgfSk7XG4gICAgY29uc3QgZXF1YWxpdHlBbm5vdGF0aW9ucyA9IGdlbmVyYXRlUmVmZXJlbnRpYWxFcXVhbGl0eUFubm90YXRpb25zKGlkZW50aXRpZXMsIHRoaXMuZGVkdXBlKTtcbiAgICByZXR1cm4gZXF1YWxpdHlBbm5vdGF0aW9ucyAmJiAocmVzLm1ldGEgPSB7XG4gICAgICAuLi5yZXMubWV0YSxcbiAgICAgIHJlZmVyZW50aWFsRXF1YWxpdGllczogZXF1YWxpdHlBbm5vdGF0aW9uc1xuICAgIH0pLCByZXM7XG4gIH1cbiAgZGVzZXJpYWxpemUocGF5bG9hZCkge1xuICAgIGNvbnN0IHsganNvbiwgbWV0YSB9ID0gcGF5bG9hZDtcbiAgICBsZXQgcmVzdWx0ID0gY29weShqc29uKTtcbiAgICByZXR1cm4gbWV0YSAhPSBudWxsICYmIG1ldGEudmFsdWVzICYmIChyZXN1bHQgPSBhcHBseVZhbHVlQW5ub3RhdGlvbnMocmVzdWx0LCBtZXRhLnZhbHVlcywgdGhpcykpLCBtZXRhICE9IG51bGwgJiYgbWV0YS5yZWZlcmVudGlhbEVxdWFsaXRpZXMgJiYgKHJlc3VsdCA9IGFwcGx5UmVmZXJlbnRpYWxFcXVhbGl0eUFubm90YXRpb25zKHJlc3VsdCwgbWV0YS5yZWZlcmVudGlhbEVxdWFsaXRpZXMpKSwgcmVzdWx0O1xuICB9XG4gIHN0cmluZ2lmeShvYmplY3QpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zZXJpYWxpemUob2JqZWN0KSk7XG4gIH1cbiAgcGFyc2Uoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemUoSlNPTi5wYXJzZShzdHJpbmcpKTtcbiAgfVxuICByZWdpc3RlckNsYXNzKHYsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsYXNzUmVnaXN0cnkucmVnaXN0ZXIodiwgb3B0aW9ucyk7XG4gIH1cbiAgcmVnaXN0ZXJTeW1ib2wodiwgaWRlbnRpZmllcikge1xuICAgIHRoaXMuc3ltYm9sUmVnaXN0cnkucmVnaXN0ZXIodiwgaWRlbnRpZmllcik7XG4gIH1cbiAgcmVnaXN0ZXJDdXN0b20odHJhbnNmb3JtZXIyLCBuYW1lKSB7XG4gICAgdGhpcy5jdXN0b21UcmFuc2Zvcm1lclJlZ2lzdHJ5LnJlZ2lzdGVyKHtcbiAgICAgIG5hbWUsXG4gICAgICAuLi50cmFuc2Zvcm1lcjJcbiAgICB9KTtcbiAgfVxuICBhbGxvd0Vycm9yUHJvcHMoLi4ucHJvcHMpIHtcbiAgICB0aGlzLmFsbG93ZWRFcnJvclByb3BzLnB1c2goLi4ucHJvcHMpO1xuICB9XG59O1xuU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSA9IG5ldyBTdXBlckpTT04oKTtcblN1cGVySlNPTi5zZXJpYWxpemUgPSBTdXBlckpTT04uZGVmYXVsdEluc3RhbmNlLnNlcmlhbGl6ZS5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLmRlc2VyaWFsaXplID0gU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZS5kZXNlcmlhbGl6ZS5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLnN0cmluZ2lmeSA9IFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2Uuc3RyaW5naWZ5LmJpbmQoU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSk7XG5TdXBlckpTT04ucGFyc2UgPSBTdXBlckpTT04uZGVmYXVsdEluc3RhbmNlLnBhcnNlLmJpbmQoU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSk7XG5TdXBlckpTT04ucmVnaXN0ZXJDbGFzcyA9IFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UucmVnaXN0ZXJDbGFzcy5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLnJlZ2lzdGVyU3ltYm9sID0gU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZS5yZWdpc3RlclN5bWJvbC5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLnJlZ2lzdGVyQ3VzdG9tID0gU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZS5yZWdpc3RlckN1c3RvbS5iaW5kKFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UpO1xuU3VwZXJKU09OLmFsbG93RXJyb3JQcm9wcyA9IFN1cGVySlNPTi5kZWZhdWx0SW5zdGFuY2UuYWxsb3dFcnJvclByb3BzLmJpbmQoU3VwZXJKU09OLmRlZmF1bHRJbnN0YW5jZSk7XG5TdXBlckpTT04uc2VyaWFsaXplO1xuU3VwZXJKU09OLmRlc2VyaWFsaXplO1xuU3VwZXJKU09OLnN0cmluZ2lmeTtcblN1cGVySlNPTi5wYXJzZTtcblN1cGVySlNPTi5yZWdpc3RlckNsYXNzO1xuU3VwZXJKU09OLnJlZ2lzdGVyQ3VzdG9tO1xuU3VwZXJKU09OLnJlZ2lzdGVyU3ltYm9sO1xuU3VwZXJKU09OLmFsbG93RXJyb3JQcm9wcztcbnZhciB0cmFuc2Zvcm1lciA9IFN1cGVySlNPTjtcbmNvbnN0IGFnZW50Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICBhdmFpbGFibGVBZ2VudHM6IFtdLFxuICBjb25uZWN0ZWQ6IG51bGwsXG4gIGNvbm5lY3RlZFVuYXZhaWxhYmxlOiAhMSxcbiAgcmVxdWlyZXNVc2VyQXR0ZW50aW9uOiAhMSxcbiAgaXNJbml0aWFsTG9hZDogITAsXG4gIGNvbm5lY3RBZ2VudDogKCkgPT4ge1xuICB9LFxuICBkaXNjb25uZWN0QWdlbnQ6ICgpID0+IHtcbiAgfSxcbiAgcmVmcmVzaEFnZW50TGlzdDogKCkgPT4ge1xuICB9LFxuICBpc1JlZnJlc2hpbmc6ICExXG59KTtcbmZ1bmN0aW9uIGdldEFnZW50VW5pcXVlS2V5KGFnZW50KSB7XG4gIHJldHVybiBcXGBcXCR7YWdlbnQubmFtZX18fHxcXCR7YWdlbnQuZGVzY3JpcHRpb259fHx8XFwke2FnZW50LnBvcnR9XFxgO1xufVxuZnVuY3Rpb24gcGVyc2lzdFNlbGVjdGVkQWdlbnQoYWdlbnQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1bmlxdWVLZXkgPSBnZXRBZ2VudFVuaXF1ZUtleShhZ2VudCk7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInN0YWdld2lzZV90b29sYmFyX3NlbGVjdGVkX2FnZW50XCIsIHVuaXF1ZUtleSksIGNvbnNvbGUuZGVidWcoXFxgW0FnZW50UHJvdmlkZXJdIFBlcnNpc3RlZCBzZWxlY3RlZCBhZ2VudDogXFwke3VuaXF1ZUtleX1cXGApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihcIltBZ2VudFByb3ZpZGVyXSBGYWlsZWQgdG8gcGVyc2lzdCBzZWxlY3RlZCBhZ2VudDpcIiwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQZXJzaXN0ZWRBZ2VudEtleSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcInN0YWdld2lzZV90b29sYmFyX3NlbGVjdGVkX2FnZW50XCIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBjb25zb2xlLndhcm4oXCJbQWdlbnRQcm92aWRlcl0gRmFpbGVkIHRvIHJldHJpZXZlIHBlcnNpc3RlZCBhZ2VudDpcIiwgZXJyb3IpLCBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBmaW5kUGVyc2lzdGVkQWdlbnQoYXZhaWxhYmxlQWdlbnRzKSB7XG4gIGNvbnN0IHBlcnNpc3RlZEtleSA9IGdldFBlcnNpc3RlZEFnZW50S2V5KCk7XG4gIGlmICghcGVyc2lzdGVkS2V5KVxuICAgIHJldHVybiBudWxsO1xuICBjb25zdCBtYXRjaGluZ0FnZW50ID0gYXZhaWxhYmxlQWdlbnRzLmZpbmQoXG4gICAgKGFnZW50KSA9PiBnZXRBZ2VudFVuaXF1ZUtleShhZ2VudCkgPT09IHBlcnNpc3RlZEtleVxuICApO1xuICByZXR1cm4gbWF0Y2hpbmdBZ2VudCAmJiBjb25zb2xlLmRlYnVnKFxuICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBGb3VuZCBwZXJzaXN0ZWQgYWdlbnQ6IFxcJHttYXRjaGluZ0FnZW50Lm5hbWV9IChwb3J0IFxcJHttYXRjaGluZ0FnZW50LnBvcnR9KVxcYFxuICApLCBtYXRjaGluZ0FnZW50IHx8IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBjaGVja0FnZW50T25Qb3J0KHBvcnQpIHtcbiAgY29uc29sZS5kZWJ1ZyhcXGBbQWdlbnRQcm92aWRlcl0gQ2hlY2tpbmcgZm9yIGFnZW50IG9uIHBvcnQgXFwke3BvcnR9Li4uXFxgKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBob3N0bmFtZSA9IHdpbmRvdy5wYXJlbnQubG9jYXRpb24uaG9zdG5hbWUsIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXFxgaHR0cDovL1xcJHtob3N0bmFtZX06XFwke3BvcnR9L3N0YWdld2lzZS9pbmZvXFxgLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBBYm9ydFNpZ25hbC50aW1lb3V0KDJlMylcbiAgICAgIC8vIDIgc2Vjb25kIHRpbWVvdXRcbiAgICB9KTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGluZm8gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBpZiAoaW5mbyAmJiB0eXBlb2YgaW5mby5uYW1lID09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGluZm8uZGVzY3JpcHRpb24gPT0gXCJzdHJpbmdcIiAmJiBpbmZvLmNhcGFiaWxpdGllcylcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIEZvdW5kIGFnZW50IFwiXFwke2luZm8ubmFtZX1cIiBvbiBwb3J0IFxcJHtwb3J0fTogXFwke2luZm8uZGVzY3JpcHRpb259XFxgXG4gICAgICAgICksIHtcbiAgICAgICAgICBwb3J0LFxuICAgICAgICAgIG5hbWU6IGluZm8ubmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogaW5mby5kZXNjcmlwdGlvbixcbiAgICAgICAgICBpbmZvXG4gICAgICAgIH07XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBJbnZhbGlkIGFnZW50IGluZm8gcmVjZWl2ZWQgb24gcG9ydCBcXCR7cG9ydH1cXGBcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gSFRUUCBcXCR7cmVzcG9uc2Uuc3RhdHVzfSByZXNwb25zZSBvbiBwb3J0IFxcJHtwb3J0fVxcYFxuICAgICAgKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICFlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwidGltZW91dFwiKSAmJiBjb25zb2xlLmRlYnVnKFxuICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIEVycm9yIGNoZWNraW5nIHBvcnQgXFwke3BvcnR9OiBcXCR7ZXJyb3IubWVzc2FnZX1cXGBcbiAgICApO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gc2NhbkZvckFnZW50cyhzdGFydFBvcnQgPSBERUZBVUxUX1NUQVJUSU5HX1BPUlQpIHtcbiAgY29uc29sZS5pbmZvKFxuICAgIFxcYFtzdGFnZXdpc2VdIFRoZSBmb2xsb3dpbmcgZXJyb3JzIGFyZSBleHBlY3RlZCDinIVcblxuVGhleSBoYXBwZW4gYmVjYXVzZSB3ZSdyZSBzZWFyY2hpbmcgZm9yIGF2YWlsYWJsZSBhZ2VudHMuLi5cXGBcbiAgKSwgY29uc29sZS5kZWJ1ZyhcbiAgICBcXGBbQWdlbnRQcm92aWRlcl0gU3RhcnRpbmcgYWdlbnQgc2NhbiBmcm9tIHBvcnQgXFwke3N0YXJ0UG9ydH0uLi5cXGBcbiAgKTtcbiAgY29uc3QgYWdlbnRzID0gW107XG4gIGxldCBjdXJyZW50UG9ydCA9IHN0YXJ0UG9ydCwgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gIGNvbnN0IG1heENvbnNlY3V0aXZlRmFpbHVyZXMgPSAyLCBpbml0aWFsU2NhbkNvdW50ID0gMiwgZXhwYW5kZWRTY2FuQ291bnQgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGluaXRpYWxTY2FuQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IGFnZW50ID0gYXdhaXQgY2hlY2tBZ2VudE9uUG9ydChjdXJyZW50UG9ydCk7XG4gICAgYWdlbnQgPyAoYWdlbnRzLnB1c2goYWdlbnQpLCBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMCkgOiBjb25zZWN1dGl2ZUZhaWx1cmVzKyssIGN1cnJlbnRQb3J0Kys7XG4gIH1cbiAgZm9yICg7IGNvbnNlY3V0aXZlRmFpbHVyZXMgPCBtYXhDb25zZWN1dGl2ZUZhaWx1cmVzOyApIHtcbiAgICBsZXQgZm91bmRJblRoaXNDaHVuayA9ICExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwYW5kZWRTY2FuQ291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWdlbnQgPSBhd2FpdCBjaGVja0FnZW50T25Qb3J0KGN1cnJlbnRQb3J0KTtcbiAgICAgIGFnZW50ICYmIChhZ2VudHMucHVzaChhZ2VudCksIGZvdW5kSW5UaGlzQ2h1bmsgPSAhMCwgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDApLCBjdXJyZW50UG9ydCsrO1xuICAgIH1cbiAgICBmb3VuZEluVGhpc0NodW5rIHx8IGNvbnNlY3V0aXZlRmFpbHVyZXMrKztcbiAgfVxuICByZXR1cm4gY29uc29sZS5kZWJ1ZyhcbiAgICBcXGBbQWdlbnRQcm92aWRlcl0gU2NhbiBjb21wbGV0ZSEgRm91bmQgXFwke2FnZW50cy5sZW5ndGh9IHRvdGFsIGFnZW50czpcXGAsXG4gICAgYWdlbnRzLm1hcCgoYSkgPT4gXFxgXFwke2EubmFtZX0gKHBvcnQgXFwke2EucG9ydH0pXFxgKVxuICApLCBhZ2VudHM7XG59XG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRDbGllbnQocG9ydCwgb25Db25uZWN0aW9uTG9zdCwgb25Db25uZWN0aW9uRXN0YWJsaXNoZWQsIG9uQ29ubmVjdGlvbkZhaWxlZCwgY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYpIHtcbiAgY29uc29sZS5kZWJ1ZyhcbiAgICBcXGBbQWdlbnRQcm92aWRlcl0gQ3JlYXRpbmcgV2ViU29ja2V0IGNsaWVudCBmb3IgcG9ydCBcXCR7cG9ydH0uLi5cXGBcbiAgKTtcbiAgbGV0IGlzQ29ubmVjdGlvblN0YWJsZSA9ICExLCBjb25uZWN0aW9uRmFpbGVkQ2FsbGVkID0gITE7XG4gIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LnBhcmVudC5sb2NhdGlvbi5ob3N0bmFtZSwgd3NDbGllbnQgPSBjcmVhdGVXU0NsaWVudCh7XG4gICAgdXJsOiBcXGB3czovL1xcJHtob3N0bmFtZX06XFwke3BvcnR9L3N0YWdld2lzZS93c1xcYCxcbiAgICBvbkNsb3NlKGNhdXNlKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gV2ViU29ja2V0IGNsb3NlZCBmb3IgcG9ydCBcXCR7cG9ydH06IFxcJHtjYXVzZX1cXGBcbiAgICAgICksIGNvbm5lY3Rpb25TdGFiaWxpdHlUaW1lb3V0UmVmLmN1cnJlbnQgJiYgIWlzQ29ubmVjdGlvblN0YWJsZSAmJiAoY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIENvbm5lY3Rpb24gY2xvc2VkIGJlZm9yZSBzdGFiaWxpdHkgdGltZW91dCAtIGNsZWFyaW5nIHRpbWVvdXQgZm9yIHBvcnQgXFwke3BvcnR9XFxgXG4gICAgICApLCBjbGVhclRpbWVvdXQoY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCksIGNvbm5lY3Rpb25TdGFiaWxpdHlUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsLCBjb25uZWN0aW9uRmFpbGVkQ2FsbGVkIHx8IChjb25zb2xlLmRlYnVnKFxuICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gVW5zdGFibGUgY29ubmVjdGlvbiBkZXRlY3RlZCBmb3IgcG9ydCBcXCR7cG9ydH0gLSBjYWxsaW5nIG9uQ29ubmVjdGlvbkZhaWxlZFxcYFxuICAgICAgKSwgY29ubmVjdGlvbkZhaWxlZENhbGxlZCA9ICEwLCBvbkNvbm5lY3Rpb25GYWlsZWQoKSkpLCBpc0Nvbm5lY3Rpb25TdGFibGUgJiYgKGNvbnNvbGUuZGVidWcoXG4gICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBTdGFibGUgY29ubmVjdGlvbiBsb3N0IGZvciBwb3J0IFxcJHtwb3J0fSAtIGNhbGxpbmcgb25Db25uZWN0aW9uTG9zdFxcYFxuICAgICAgKSwgb25Db25uZWN0aW9uTG9zdCgpKTtcbiAgICB9LFxuICAgIG9uT3BlbigpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBXZWJTb2NrZXQgb3BlbmVkIGZvciBwb3J0IFxcJHtwb3J0fSAtIHN0YXJ0aW5nIHN0YWJpbGl0eSBjaGVjay4uLlxcYFxuICAgICAgKSwgY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCAmJiBjbGVhclRpbWVvdXQoY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCksIGNvbm5lY3Rpb25TdGFiaWxpdHlUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gQ29ubmVjdGlvbiBzdGFiaWxpdHkgY29uZmlybWVkIGZvciBwb3J0IFxcJHtwb3J0fVxcYFxuICAgICAgICApLCBpc0Nvbm5lY3Rpb25TdGFibGUgPSAhMCwgY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCA9IG51bGwsIG9uQ29ubmVjdGlvbkVzdGFibGlzaGVkKCk7XG4gICAgICB9LCAyMDApO1xuICAgIH1cbiAgfSksIGNsaWVudCA9IGNyZWF0ZVRSUENDbGllbnQoe1xuICAgIGxpbmtzOiBbXG4gICAgICB3c0xpbmsoe1xuICAgICAgICBjbGllbnQ6IHdzQ2xpZW50LFxuICAgICAgICB0cmFuc2Zvcm1lclxuICAgICAgfSlcbiAgICBdXG4gIH0pO1xuICByZXR1cm4gY29uc29sZS5kZWJ1ZyhcXGBbQWdlbnRQcm92aWRlcl0gV2ViU29ja2V0IGNsaWVudCBjcmVhdGVkIGZvciBwb3J0IFxcJHtwb3J0fVxcYCksIHsgY2xpZW50LCB3c0NsaWVudCB9O1xufVxuZnVuY3Rpb24gQWdlbnRQcm92aWRlcih7IGNoaWxkcmVuIH0pIHtcbiAgY29uc29sZS5kZWJ1ZyhcIltBZ2VudFByb3ZpZGVyXSBBZ2VudFByb3ZpZGVyIGNvbXBvbmVudCBpbml0aWFsaXppbmcuLi5cIik7XG4gIGNvbnN0IFthdmFpbGFibGVBZ2VudHMsIHNldEF2YWlsYWJsZUFnZW50c10gPSB1c2VTdGF0ZShbXSksIGNvbm5lY3RlZCA9IHVzZVJlZihudWxsKSwgY29ubmVjdGVkV3NDbGllbnQgPSB1c2VSZWYoXG4gICAgbnVsbFxuICApLCBbY29ubmVjdGVkUG9ydCwgc2V0Q29ubmVjdGVkUG9ydF0gPSB1c2VTdGF0ZShudWxsKSwgW2lzUmVmcmVzaGluZywgc2V0SXNSZWZyZXNoaW5nXSA9IHVzZVN0YXRlKCExKSwgW2ZpbmlzaGVkSW5pdGlhbFNjYW4sIHNldEZpbmlzaGVkSW5pdGlhbFNjYW5dID0gdXNlU3RhdGUoITEpLCBbY29ubmVjdGVkVW5hdmFpbGFibGUsIHNldENvbm5lY3RlZFVuYXZhaWxhYmxlXSA9IHVzZVN0YXRlKCExKSwgW3JlcXVpcmVzVXNlckF0dGVudGlvbiwgc2V0UmVxdWlyZXNVc2VyQXR0ZW50aW9uXSA9IHVzZVN0YXRlKCExKSwgW2lzSW5pdGlhbExvYWQsIHNldElzSW5pdGlhbExvYWRdID0gdXNlU3RhdGUoITApLCBwcmV2aW91c2x5U2VsZWN0ZWRQb3J0UmVmID0gdXNlUmVmKG51bGwpLCByZXRyeUludGVydmFsUmVmID0gdXNlUmVmKG51bGwpLCByZXRyeUNvdW50UmVmID0gdXNlUmVmKDApLCBpc01hbnVhbFNlbGVjdGlvblJlZiA9IHVzZVJlZighMSksIGRlbGF5VGltZW91dFJlZiA9IHVzZVJlZihudWxsKSwgY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCksIHN0YXJ0UmV0cnlDb25uZWN0aW9uID0gdXNlQ2FsbGJhY2soXG4gICAgKHBvcnQpID0+IHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBTdGFydGluZyByZXRyeSBjb25uZWN0aW9uIGxvZ2ljIGZvciBwb3J0IFxcJHtwb3J0fS4uLlxcYFxuICAgICAgKSwgcmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50ICYmIChjb25zb2xlLmRlYnVnKFwiW0FnZW50UHJvdmlkZXJdIENsZWFyaW5nIGV4aXN0aW5nIHJldHJ5IGludGVydmFsLi4uXCIpLCBjbGVhckludGVydmFsKHJldHJ5SW50ZXJ2YWxSZWYuY3VycmVudCkpLCByZXRyeUNvdW50UmVmLmN1cnJlbnQgPSAwLCBpc01hbnVhbFNlbGVjdGlvblJlZi5jdXJyZW50ID8gY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgXCJbQWdlbnRQcm92aWRlcl0gU2tpcHBpbmcgcmV0cnkgc2V0dXAgLSB0aGlzIHdhcyBhIG1hbnVhbCBzZWxlY3Rpb24gY2hhbmdlXCJcbiAgICAgICkgOiAoY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIFNldHRpbmcgdXAgcmV0cnkgaW50ZXJ2YWwgKGV2ZXJ5IDJzKSBmb3IgcG9ydCBcXCR7cG9ydH0gKG1heCA1IHJldHJpZXMpLi4uXFxgXG4gICAgICApLCByZXRyeUludGVydmFsUmVmLmN1cnJlbnQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChyZXRyeUNvdW50UmVmLmN1cnJlbnQgPj0gNSkge1xuICAgICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gTWF4aW11bSByZXRyeSBhdHRlbXB0cyAoNSkgcmVhY2hlZCBmb3IgcG9ydCBcXCR7cG9ydH0sIHN0b3BwaW5nIHJldHJpZXNcXGBcbiAgICAgICAgICApLCByZXRyeUludGVydmFsUmVmLmN1cnJlbnQgJiYgKGNsZWFySW50ZXJ2YWwocmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50KSwgcmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50ID0gdm9pZCAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNseVNlbGVjdGVkUG9ydFJlZi5jdXJyZW50ID09PSBwb3J0ICYmICFjb25uZWN0ZWQuY3VycmVudCAmJiAhaXNNYW51YWxTZWxlY3Rpb25SZWYuY3VycmVudCA/IChyZXRyeUNvdW50UmVmLmN1cnJlbnQrKywgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gUmV0cnlpbmcgY29ubmVjdGlvbiB0byBhZ2VudCBvbiBwb3J0IFxcJHtwb3J0fSAoYXR0ZW1wdCBcXCR7cmV0cnlDb3VudFJlZi5jdXJyZW50fS81KS4uLlxcYFxuICAgICAgICApLCBjb25uZWN0QWdlbnRJbnRlcm5hbChwb3J0LCAhMSkpIDogKGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIFN0b3BwaW5nIHJldHJ5IGF0dGVtcHRzIGZvciBwb3J0IFxcJHtwb3J0fSAoY29uZGl0aW9ucyBubyBsb25nZXIgbWV0KVxcYFxuICAgICAgICApLCByZXRyeUludGVydmFsUmVmLmN1cnJlbnQgJiYgKGNsZWFySW50ZXJ2YWwocmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50KSwgcmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50ID0gdm9pZCAwKSk7XG4gICAgICB9LCAyZTMpKTtcbiAgICB9LFxuICAgIFtjb25uZWN0ZWRdXG4gICksIHN0b3BSZXRyeUNvbm5lY3Rpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgcmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50ICYmIChjb25zb2xlLmRlYnVnKFwiW0FnZW50UHJvdmlkZXJdIFN0b3BwaW5nIHJldHJ5IGNvbm5lY3Rpb24gYXR0ZW1wdHMuLi5cIiksIGNsZWFySW50ZXJ2YWwocmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50KSwgcmV0cnlJbnRlcnZhbFJlZi5jdXJyZW50ID0gdm9pZCAwKTtcbiAgfSwgW10pLCBzY2FuQWdlbnRzID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICBcXGBbQWdlbnRQcm92aWRlcl0gU3RhcnRpbmcgYWdlbnQgc2Nhbi4uLiAoZmluaXNoZWRJbml0aWFsU2NhbjogXFwke2ZpbmlzaGVkSW5pdGlhbFNjYW59LCBjb25uZWN0ZWQ6IFxcJHshIWNvbm5lY3RlZC5jdXJyZW50fSlcXGBcbiAgICApLCBzZXRJc1JlZnJlc2hpbmcoITApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBhZ2VudHMgPSBhd2FpdCBzY2FuRm9yQWdlbnRzKCksIHByZXZpb3VzQ291bnQgPSBhdmFpbGFibGVBZ2VudHMubGVuZ3RoLCBuZXdDb3VudCA9IGFnZW50cy5sZW5ndGg7XG4gICAgICBpZiAocHJldmlvdXNDb3VudCAhPT0gbmV3Q291bnQgJiYgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIEF2YWlsYWJsZSBhZ2VudHMgY2hhbmdlZDogXFwke3ByZXZpb3VzQ291bnR9IOKGkiBcXCR7bmV3Q291bnR9XFxgXG4gICAgICApLCBzZXRBdmFpbGFibGVBZ2VudHMoYWdlbnRzKSwgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIFNjYW5uZWQ6IFxcJHthZ2VudHMubGVuZ3RofSBhZ2VudHMgZm91bmQsIGNvbm5lY3RlZDogXFwkeyEhY29ubmVjdGVkLmN1cnJlbnR9XFxgXG4gICAgICApLCBjb25zb2xlLmRlYnVnKFxuICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gZmluaXNoZWRJbml0aWFsU2NhbjogXFwke2ZpbmlzaGVkSW5pdGlhbFNjYW59LCBjb25uZWN0ZWQ6IFxcJHshIWNvbm5lY3RlZC5jdXJyZW50fVxcYFxuICAgICAgKSwgIWZpbmlzaGVkSW5pdGlhbFNjYW4gJiYgIWNvbm5lY3RlZC5jdXJyZW50ICYmIGFnZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHBlcnNpc3RlZEFnZW50ID0gZmluZFBlcnNpc3RlZEFnZW50KGFnZW50cyk7XG4gICAgICAgIHBlcnNpc3RlZEFnZW50ID8gKGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIEF1dG8tY29ubmVjdGluZyB0byBwZXJzaXN0ZWQgYWdlbnQ6IFxcJHtwZXJzaXN0ZWRBZ2VudC5uYW1lfSAocG9ydCBcXCR7cGVyc2lzdGVkQWdlbnQucG9ydH0pXFxgXG4gICAgICAgICksIGNvbm5lY3RBZ2VudEludGVybmFsKHBlcnNpc3RlZEFnZW50LnBvcnQsICExKSkgOiBhZ2VudHMubGVuZ3RoID09PSAxICYmIChjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBBdXRvLWNvbm5lY3RpbmcgdG8gc2luZ2xlIGF2YWlsYWJsZSBhZ2VudDogXFwke2FnZW50c1swXS5uYW1lfSAocG9ydCBcXCR7YWdlbnRzWzBdLnBvcnR9KVxcYFxuICAgICAgICApLCBjb25uZWN0QWdlbnRJbnRlcm5hbChhZ2VudHNbMF0ucG9ydCwgITEpKTtcbiAgICAgIH1cbiAgICAgIGlmICghY29ubmVjdGVkICYmIHByZXZpb3VzbHlTZWxlY3RlZFBvcnRSZWYuY3VycmVudCAmJiAhaXNNYW51YWxTZWxlY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0FnZW50ID0gYWdlbnRzLmZpbmQoXG4gICAgICAgICAgKGFnZW50KSA9PiBhZ2VudC5wb3J0ID09PSBwcmV2aW91c2x5U2VsZWN0ZWRQb3J0UmVmLmN1cnJlbnRcbiAgICAgICAgKTtcbiAgICAgICAgcHJldmlvdXNBZ2VudCA/IChjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBBdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB0byBwcmV2aW91c2x5IHNlbGVjdGVkIGFnZW50OiBcXCR7cHJldmlvdXNBZ2VudC5uYW1lfSAocG9ydCBcXCR7cHJldmlvdXNBZ2VudC5wb3J0fSlcXGBcbiAgICAgICAgKSwgY29ubmVjdEFnZW50SW50ZXJuYWwocHJldmlvdXNBZ2VudC5wb3J0LCAhMSkpIDogY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gUHJldmlvdXNseSBzZWxlY3RlZCBhZ2VudCAocG9ydCBcXCR7cHJldmlvdXNseVNlbGVjdGVkUG9ydFJlZi5jdXJyZW50fSkgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZVxcYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW0FnZW50UHJvdmlkZXJdIEZhaWxlZCB0byBzY2FuIGZvciBhZ2VudHM6XCIsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNSZWZyZXNoaW5nKCExKSwgc2V0RmluaXNoZWRJbml0aWFsU2NhbighMCksIGNvbnNvbGUuZGVidWcoXCJbQWdlbnRQcm92aWRlcl0gQWdlbnQgc2NhbiBjb21wbGV0ZS4gUmVmcmVzaGluZzogZmFsc2VcIik7XG4gICAgfVxuICB9LCBbY29ubmVjdGVkLCBmaW5pc2hlZEluaXRpYWxTY2FuLCBhdmFpbGFibGVBZ2VudHMubGVuZ3RoXSksIGNvbm5lY3RBZ2VudEludGVybmFsID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHBvcnQsIGlzTWFudWFsID0gITEpID0+IHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBBdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gYWdlbnQgb24gcG9ydCBcXCR7cG9ydH0gKG1hbnVhbDogXFwke2lzTWFudWFsfSkuLi5cXGBcbiAgICAgICksIHByZXZpb3VzbHlTZWxlY3RlZFBvcnRSZWYuY3VycmVudCA9IHBvcnQsIGlzTWFudWFsU2VsZWN0aW9uUmVmLmN1cnJlbnQgPSBpc01hbnVhbDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdG9wUmV0cnlDb25uZWN0aW9uKCksIGNvbm5lY3RlZC5jdXJyZW50KSB7XG4gICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBDbGVhbmluZyB1cCBleGlzdGluZyBjb25uZWN0aW9uIChwb3J0IFxcJHtjb25uZWN0ZWRQb3J0fSkuLi5cXGBcbiAgICAgICAgICApLCBjb25uZWN0aW9uU3RhYmlsaXR5VGltZW91dFJlZi5jdXJyZW50ICYmIChjbGVhclRpbWVvdXQoY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCksIGNvbm5lY3Rpb25TdGFiaWxpdHlUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICBjb25zdCB3c0NsaWVudDIgPSBjb25uZWN0ZWRXc0NsaWVudC5jdXJyZW50O1xuICAgICAgICAgIGlmICh3c0NsaWVudDIpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICAgIFwiW0FnZW50UHJvdmlkZXJdIEV4cGxpY2l0bHkgY2xvc2luZyBleGlzdGluZyBXZWJTb2NrZXQgY29ubmVjdGlvblwiXG4gICAgICAgICAgICAgICksIHdzQ2xpZW50Mi5jbG9zZSgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcIltBZ2VudFByb3ZpZGVyXSBFcnJvciBjbG9zaW5nIGV4aXN0aW5nIFdlYlNvY2tldDpcIixcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNvbm5lY3RlZC5jdXJyZW50ID0gbnVsbCwgY29ubmVjdGVkV3NDbGllbnQuY3VycmVudCA9IG51bGwsIHNldENvbm5lY3RlZFBvcnQobnVsbCksIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMCkpLCBjb25zb2xlLmRlYnVnKFwiW0FnZW50UHJvdmlkZXJdIFdlYlNvY2tldCBjbGVhbnVwIGRlbGF5IGNvbXBsZXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCB3c0NsaWVudCB9ID0gY3JlYXRlV2ViU29ja2V0Q2xpZW50KFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIENvbm5lY3Rpb24gbG9zdCB0byBhZ2VudCBvbiBwb3J0IFxcJHtwb3J0fVxcYFxuICAgICAgICAgICAgKSwgc2V0Q29ubmVjdGVkVW5hdmFpbGFibGUoITApO1xuICAgICAgICAgICAgY29uc3Qgd3NDbGllbnQyID0gY29ubmVjdGVkV3NDbGllbnQuY3VycmVudDtcbiAgICAgICAgICAgIGlmICh3c0NsaWVudDIpXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgIFwiW0FnZW50UHJvdmlkZXJdIEV4cGxpY2l0bHkgY2xvc2luZyBXZWJTb2NrZXQgYWZ0ZXIgY29ubmVjdGlvbiBsb3NzXCJcbiAgICAgICAgICAgICAgICApLCB3c0NsaWVudDIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICAgICAgXCJbQWdlbnRQcm92aWRlcl0gRXJyb3IgY2xvc2luZyBXZWJTb2NrZXQgYWZ0ZXIgY29ubmVjdGlvbiBsb3NzOlwiLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0ZWQuY3VycmVudCA9IG51bGwsIGNvbm5lY3RlZFdzQ2xpZW50LmN1cnJlbnQgPSBudWxsLCBzZXRDb25uZWN0ZWRQb3J0KG51bGwpLCBjb25zb2xlLmluZm8oXG4gICAgICAgICAgICAgIFwiW3N0YWdld2lzZV0gU2VhcmNoaW5nIGZvciBhdmFpbGFibGUgYWdlbnRzIGFmdGVyIGNvbm5lY3Rpb24gbG9zcy4uLlwiXG4gICAgICAgICAgICApLCBzY2FuQWdlbnRzKCksIGlzTWFudWFsU2VsZWN0aW9uUmVmLmN1cnJlbnQgPyBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICBcIltBZ2VudFByb3ZpZGVyXSBOb3Qgc3RhcnRpbmcgcmV0cnkgYXR0ZW1wdHMgKG1hbnVhbCBkaXNjb25uZWN0aW9uKVwiXG4gICAgICAgICAgICApIDogKGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBTdGFydGluZyByZXRyeSBhdHRlbXB0cyBmb3IgcG9ydCBcXCR7cG9ydH0uLi5cXGBcbiAgICAgICAgICAgICksIHN0YXJ0UmV0cnlDb25uZWN0aW9uKHBvcnQpKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gQ29ubmVjdGlvbiBlc3RhYmxpc2hlZCB0byBhZ2VudCBvbiBwb3J0IFxcJHtwb3J0fVxcYFxuICAgICAgICAgICAgKSwgc2V0Q29ubmVjdGVkUG9ydChwb3J0KSwgc2V0Q29ubmVjdGVkVW5hdmFpbGFibGUoITEpLCByZXRyeUNvdW50UmVmLmN1cnJlbnQgPSAwLCBzZXRJc0luaXRpYWxMb2FkKCExKSwgIWlzTWFudWFsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGFnZW50VG9QZXJzaXN0ID0gYXZhaWxhYmxlQWdlbnRzLmZpbmQoXG4gICAgICAgICAgICAgICAgKGFnZW50KSA9PiBhZ2VudC5wb3J0ID09PSBwb3J0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGFnZW50VG9QZXJzaXN0ICYmIHBlcnNpc3RTZWxlY3RlZEFnZW50KGFnZW50VG9QZXJzaXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzTWFudWFsID8gY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgXCJbQWdlbnRQcm92aWRlcl0gU2tpcHBpbmcgYWdlbnQgbGlzdCByZWZyZXNoIGZvciBtYW51YWwgY29ubmVjdGlvblwiXG4gICAgICAgICAgICApIDogKGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgIFwiW0FnZW50UHJvdmlkZXJdIFJlZnJlc2hpbmcgYWdlbnQgbGlzdCBhZnRlciBhdXRvbWF0aWMgcmVjb25uZWN0aW9uLi4uXCJcbiAgICAgICAgICAgICksIHNjYW5BZ2VudHMoKSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gQ29ubmVjdGlvbiBmYWlsZWQgZm9yIGFnZW50IG9uIHBvcnQgXFwke3BvcnR9ICh1bnN0YWJsZSlcXGBcbiAgICAgICAgICAgICksIGNvbm5lY3RlZC5jdXJyZW50ID0gbnVsbCwgY29ubmVjdGVkV3NDbGllbnQuY3VycmVudCA9IG51bGwsIHNldENvbm5lY3RlZFBvcnQobnVsbCksIHNldENvbm5lY3RlZFVuYXZhaWxhYmxlKCEwKSwgaXNNYW51YWwgfHwgKGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBTdGFydGluZyByZXRyeSBhdHRlbXB0cyBmb3IgdW5zdGFibGUgY29ubmVjdGlvbiBvbiBwb3J0IFxcJHtwb3J0fS4uLlxcYFxuICAgICAgICAgICAgKSwgc3RhcnRSZXRyeUNvbm5lY3Rpb24ocG9ydCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWZcbiAgICAgICAgKTtcbiAgICAgICAgY29ubmVjdGVkLmN1cnJlbnQgPSBjbGllbnQsIGNvbm5lY3RlZFdzQ2xpZW50LmN1cnJlbnQgPSB3c0NsaWVudCwgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gV2ViU29ja2V0IGNsaWVudCBjcmVhdGVkIGZvciBwb3J0IFxcJHtwb3J0fSAtIHdhaXRpbmcgZm9yIHN0YWJpbGl0eSBjb25maXJtYXRpb24uLi5cXGBcbiAgICAgICAgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIEZhaWxlZCB0byBjb25uZWN0IHRvIGFnZW50IG9uIHBvcnQgXFwke3BvcnR9OlxcYCxcbiAgICAgICAgICBlcnJvclxuICAgICAgICApLCBjb25uZWN0aW9uU3RhYmlsaXR5VGltZW91dFJlZi5jdXJyZW50ICYmIChjbGVhclRpbWVvdXQoY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCksIGNvbm5lY3Rpb25TdGFiaWxpdHlUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgY29uc3Qgd3NDbGllbnQgPSBjb25uZWN0ZWRXc0NsaWVudC5jdXJyZW50O1xuICAgICAgICBpZiAod3NDbGllbnQpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICAgIFwiW0FnZW50UHJvdmlkZXJdIEV4cGxpY2l0bHkgY2xvc2luZyBXZWJTb2NrZXQgYWZ0ZXIgY29ubmVjdGlvbiBmYWlsdXJlXCJcbiAgICAgICAgICAgICksIHdzQ2xpZW50LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoY2xvc2VFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgICAgXCJbQWdlbnRQcm92aWRlcl0gRXJyb3IgY2xvc2luZyBXZWJTb2NrZXQgYWZ0ZXIgY29ubmVjdGlvbiBmYWlsdXJlOlwiLFxuICAgICAgICAgICAgICBjbG9zZUVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkLmN1cnJlbnQgPSBudWxsLCBjb25uZWN0ZWRXc0NsaWVudC5jdXJyZW50ID0gbnVsbCwgc2V0Q29ubmVjdGVkUG9ydChudWxsKSwgc2V0Q29ubmVjdGVkVW5hdmFpbGFibGUoITApLCBpc01hbnVhbCB8fCAoY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gRmFpbGVkIHRvIGNvbm5lY3QgdG8gYWdlbnQgb24gcG9ydCBcXCR7cG9ydH0sIHN0YXJ0aW5nIHJldHJ5IGF0dGVtcHRzLi4uXFxgXG4gICAgICAgICksIHN0YXJ0UmV0cnlDb25uZWN0aW9uKHBvcnQpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtcbiAgICAgIGNvbm5lY3RlZFBvcnQsXG4gICAgICBzdGFydFJldHJ5Q29ubmVjdGlvbixcbiAgICAgIHN0b3BSZXRyeUNvbm5lY3Rpb24sXG4gICAgICBzY2FuQWdlbnRzLFxuICAgICAgYXZhaWxhYmxlQWdlbnRzXG4gICAgXVxuICApLCBkaXNjb25uZWN0QWdlbnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgIFxcYFtBZ2VudFByb3ZpZGVyXSBNYW51YWwgZGlzY29ubmVjdCByZXF1ZXN0ZWQgKGN1cnJlbnQgcG9ydDogXFwke2Nvbm5lY3RlZFBvcnR9KS4uLlxcYFxuICAgICksIHN0b3BSZXRyeUNvbm5lY3Rpb24oKSwgY29ubmVjdGlvblN0YWJpbGl0eVRpbWVvdXRSZWYuY3VycmVudCAmJiAoY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25TdGFiaWxpdHlUaW1lb3V0UmVmLmN1cnJlbnQpLCBjb25uZWN0aW9uU3RhYmlsaXR5VGltZW91dFJlZi5jdXJyZW50ID0gbnVsbCk7XG4gICAgY29uc3Qgd3NDbGllbnQgPSBjb25uZWN0ZWRXc0NsaWVudC5jdXJyZW50O1xuICAgIGlmICh3c0NsaWVudClcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXCJbQWdlbnRQcm92aWRlcl0gRXhwbGljaXRseSBjbG9zaW5nIFdlYlNvY2tldCBmb3IgbWFudWFsIGRpc2Nvbm5lY3RcIlxuICAgICAgICApLCB3c0NsaWVudC5jbG9zZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcIltBZ2VudFByb3ZpZGVyXSBFcnJvciBjbG9zaW5nIFdlYlNvY2tldCBkdXJpbmcgbWFudWFsIGRpc2Nvbm5lY3Q6XCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBjb25uZWN0ZWQuY3VycmVudCA9IG51bGwsIGNvbm5lY3RlZFdzQ2xpZW50LmN1cnJlbnQgPSBudWxsLCBzZXRDb25uZWN0ZWRQb3J0KG51bGwpLCBzZXRDb25uZWN0ZWRVbmF2YWlsYWJsZSghMSksIHByZXZpb3VzbHlTZWxlY3RlZFBvcnRSZWYuY3VycmVudCA9IG51bGwsIGlzTWFudWFsU2VsZWN0aW9uUmVmLmN1cnJlbnQgPSAhMCwgY29uc29sZS5kZWJ1ZyhcIltBZ2VudFByb3ZpZGVyXSBTdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkIGZyb20gYWdlbnRcIik7XG4gIH0sIFtjb25uZWN0ZWRQb3J0LCBzdG9wUmV0cnlDb25uZWN0aW9uXSksIGNvbm5lY3RBZ2VudCA9IHVzZUNhbGxiYWNrKFxuICAgIChwb3J0KSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICBcXGBbQWdlbnRQcm92aWRlcl0gTWFudWFsIGNvbm5lY3Rpb24gcmVxdWVzdGVkIHRvIHBvcnQgXFwke3BvcnR9Li4uXFxgXG4gICAgICApO1xuICAgICAgY29uc3QgYWdlbnRUb1BlcnNpc3QgPSBhdmFpbGFibGVBZ2VudHMuZmluZChcbiAgICAgICAgKGFnZW50KSA9PiBhZ2VudC5wb3J0ID09PSBwb3J0XG4gICAgICApO1xuICAgICAgYWdlbnRUb1BlcnNpc3QgJiYgcGVyc2lzdFNlbGVjdGVkQWdlbnQoYWdlbnRUb1BlcnNpc3QpLCBzdG9wUmV0cnlDb25uZWN0aW9uKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIFwiW0FnZW50UHJvdmlkZXJdIFJlc2V0dGluZyBtYW51YWwgc2VsZWN0aW9uIGZsYWcgdG8gYWxsb3cgZnV0dXJlIGF1dG8tcmVjb25uZWN0cy4uLlwiXG4gICAgICAgICksIGlzTWFudWFsU2VsZWN0aW9uUmVmLmN1cnJlbnQgPSAhMTtcbiAgICAgIH0sIDEwMCksIGNvbm5lY3RBZ2VudEludGVybmFsKHBvcnQsICEwKTtcbiAgICB9LFxuICAgIFtjb25uZWN0QWdlbnRJbnRlcm5hbCwgc3RvcFJldHJ5Q29ubmVjdGlvbiwgYXZhaWxhYmxlQWdlbnRzXVxuICApLCByZWZyZXNoQWdlbnRMaXN0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnNvbGUuZGVidWcoXCJbQWdlbnRQcm92aWRlcl0gTWFudWFsIHJlZnJlc2ggb2YgYWdlbnQgbGlzdCByZXF1ZXN0ZWQuLi5cIiksIHNjYW5BZ2VudHMoKTtcbiAgfSwgW3NjYW5BZ2VudHNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgXFxgW0FnZW50UHJvdmlkZXJdIFN0YXRlIGNoYW5nZSAtIEF2YWlsYWJsZSBhZ2VudHM6IFxcJHthdmFpbGFibGVBZ2VudHMubGVuZ3RofVxcYCxcbiAgICAgIGF2YWlsYWJsZUFnZW50cy5tYXAoKGEpID0+IFxcYFxcJHthLm5hbWV9IChcXCR7YS5wb3J0fSlcXGApXG4gICAgKTtcbiAgfSwgW2F2YWlsYWJsZUFnZW50c10pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICBcXGBbQWdlbnRQcm92aWRlcl0gQ29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VkOiBcXCR7Y29ubmVjdGVkID8gXFxgQ29ubmVjdGVkIHRvIHBvcnQgXFwke2Nvbm5lY3RlZFBvcnR9XFxgIDogXCJOb3QgY29ubmVjdGVkXCJ9XFxgXG4gICAgKTtcbiAgfSwgW2Nvbm5lY3RlZCwgY29ubmVjdGVkUG9ydF0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUuZGVidWcoXFxgW0FnZW50UHJvdmlkZXJdIFJlZnJlc2hpbmcgc3RhdGUgY2hhbmdlZDogXFwke2lzUmVmcmVzaGluZ31cXGApO1xuICB9LCBbaXNSZWZyZXNoaW5nXSksIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgIFwiW0FnZW50UHJvdmlkZXJdIENvbXBvbmVudCBtb3VudGVkLCBzdGFydGluZyBpbml0aWFsIGFnZW50IHNjYW4uLi5cIlxuICAgICksIHNjYW5BZ2VudHMoKTtcbiAgfSwgW10pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldElzSW5pdGlhbExvYWQoITEpO1xuICAgIH0sIDFlMyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgfSwgW10pLCB1c2VFZmZlY3QoKCkgPT4gKGNvbm5lY3RlZC5jdXJyZW50ICYmICFjb25uZWN0ZWRVbmF2YWlsYWJsZSA/IChkZWxheVRpbWVvdXRSZWYuY3VycmVudCAmJiAoY2xlYXJUaW1lb3V0KGRlbGF5VGltZW91dFJlZi5jdXJyZW50KSwgZGVsYXlUaW1lb3V0UmVmLmN1cnJlbnQgPSBudWxsKSwgc2V0UmVxdWlyZXNVc2VyQXR0ZW50aW9uKCExKSkgOiBkZWxheVRpbWVvdXRSZWYuY3VycmVudCB8fCAoZGVsYXlUaW1lb3V0UmVmLmN1cnJlbnQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBzZXRSZXF1aXJlc1VzZXJBdHRlbnRpb24oITApLCBkZWxheVRpbWVvdXRSZWYuY3VycmVudCA9IG51bGw7XG4gIH0sIDUwMCkpLCAoKSA9PiB7XG4gICAgZGVsYXlUaW1lb3V0UmVmLmN1cnJlbnQgJiYgKGNsZWFyVGltZW91dChkZWxheVRpbWVvdXRSZWYuY3VycmVudCksIGRlbGF5VGltZW91dFJlZi5jdXJyZW50ID0gbnVsbCk7XG4gIH0pLCBbY29ubmVjdGVkUG9ydCwgY29ubmVjdGVkVW5hdmFpbGFibGVdKSwgdXNlRWZmZWN0KCgpID0+ICgpID0+IHtcbiAgICBjb25zb2xlLmRlYnVnKFwiW0FnZW50UHJvdmlkZXJdIENvbXBvbmVudCB1bm1vdW50aW5nLCBjbGVhbmluZyB1cC4uLlwiKSwgc3RvcFJldHJ5Q29ubmVjdGlvbigpLCBkZWxheVRpbWVvdXRSZWYuY3VycmVudCAmJiBjbGVhclRpbWVvdXQoZGVsYXlUaW1lb3V0UmVmLmN1cnJlbnQpLCBjb25uZWN0aW9uU3RhYmlsaXR5VGltZW91dFJlZi5jdXJyZW50ICYmIGNsZWFyVGltZW91dChjb25uZWN0aW9uU3RhYmlsaXR5VGltZW91dFJlZi5jdXJyZW50KTtcbiAgICBjb25zdCB3c0NsaWVudCA9IGNvbm5lY3RlZFdzQ2xpZW50LmN1cnJlbnQ7XG4gICAgaWYgKHdzQ2xpZW50KVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICBcIltBZ2VudFByb3ZpZGVyXSBFeHBsaWNpdGx5IGNsb3NpbmcgV2ViU29ja2V0IGNvbm5lY3Rpb24gb24gdW5tb3VudFwiXG4gICAgICAgICksIHdzQ2xpZW50LmNsb3NlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgIFwiW0FnZW50UHJvdmlkZXJdIEVycm9yIGNsb3NpbmcgV2ViU29ja2V0IG9uIHVubW91bnQ6XCIsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBjb25zb2xlLmRlYnVnKFwiW0FnZW50UHJvdmlkZXJdIENsZWFudXAgY29tcGxldGVcIik7XG4gIH0sIFtzdG9wUmV0cnlDb25uZWN0aW9uXSk7XG4gIGNvbnN0IGFnZW50R2V0dGVyID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGFnZW50OiBjb25uZWN0ZWQuY3VycmVudFxuICB9KSwgW2Nvbm5lY3RlZFBvcnRdKSwgcHJvdmlkZXJJbnRlcmZhY2UgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBhdmFpbGFibGVBZ2VudHMsXG4gICAgICBjb25uZWN0ZWQ6IGNvbm5lY3RlZC5jdXJyZW50ID8ge1xuICAgICAgICBhZ2VudDogY29ubmVjdGVkLmN1cnJlbnQsXG4gICAgICAgIC4uLmF2YWlsYWJsZUFnZW50cy5maW5kKChhKSA9PiBhLnBvcnQgPT09IGNvbm5lY3RlZFBvcnQpXG4gICAgICB9IDogbnVsbCxcbiAgICAgIGNvbm5lY3RlZFVuYXZhaWxhYmxlLFxuICAgICAgcmVxdWlyZXNVc2VyQXR0ZW50aW9uLFxuICAgICAgaXNJbml0aWFsTG9hZCxcbiAgICAgIGNvbm5lY3RBZ2VudCxcbiAgICAgIGRpc2Nvbm5lY3RBZ2VudCxcbiAgICAgIHJlZnJlc2hBZ2VudExpc3QsXG4gICAgICBpc1JlZnJlc2hpbmdcbiAgICB9KSxcbiAgICBbXG4gICAgICBhdmFpbGFibGVBZ2VudHMsXG4gICAgICBhZ2VudEdldHRlcixcbiAgICAgIGNvbm5lY3RBZ2VudCxcbiAgICAgIGRpc2Nvbm5lY3RBZ2VudCxcbiAgICAgIHJlZnJlc2hBZ2VudExpc3QsXG4gICAgICBpc1JlZnJlc2hpbmcsXG4gICAgICBjb25uZWN0ZWRVbmF2YWlsYWJsZSxcbiAgICAgIHJlcXVpcmVzVXNlckF0dGVudGlvbixcbiAgICAgIGlzSW5pdGlhbExvYWRcbiAgICBdXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KGFnZW50Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvdmlkZXJJbnRlcmZhY2UsIGNoaWxkcmVuIH0pO1xufVxuY29uc3QgdXNlQWdlbnRzID0gKCkgPT4gdXNlQ29udGV4dChhZ2VudENvbnRleHQpLCBhZ2VudE1lc3NhZ2luZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgc2VuZE1lc3NhZ2U6ICgpID0+IHtcbiAgfSxcbiAgYWdlbnRNZXNzYWdlOiBudWxsXG59KSwgQWdlbnRNZXNzYWdpbmdQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiB7XG4gIGNvbnN0IHByb3ZpZGVySWQgPSB1c2VNZW1vKCgpID0+IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KSwgW10pLCBhZ2VudCA9IHVzZUFnZW50cygpLmNvbm5lY3RlZCwgW2FnZW50TWVzc2FnZSwgc2V0QWdlbnRNZXNzYWdlXSA9IHVzZVN0YXRlKG51bGwpLCBwcm9jZXNzZWRVcGRhdGVzUmVmID0gdXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLCBoYW5kbGVNZXNzYWdlVXBkYXRlID0gdXNlQ2FsbGJhY2soXG4gICAgKHVwZGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdXBkYXRlS2V5ID0gXFxgXFwke3VwZGF0ZS5tZXNzYWdlSWR9LVxcJHsoX2EgPSB1cGRhdGUuY3JlYXRlZEF0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0VGltZSgpfS1cXCR7dXBkYXRlLnJlc3luY31cXGA7XG4gICAgICBpZiAoIXByb2Nlc3NlZFVwZGF0ZXNSZWYuY3VycmVudC5oYXModXBkYXRlS2V5KSkge1xuICAgICAgICBpZiAocHJvY2Vzc2VkVXBkYXRlc1JlZi5jdXJyZW50LmFkZCh1cGRhdGVLZXkpLCBwcm9jZXNzZWRVcGRhdGVzUmVmLmN1cnJlbnQuc2l6ZSA+IDEwMCkge1xuICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5mcm9tKHByb2Nlc3NlZFVwZGF0ZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgcHJvY2Vzc2VkVXBkYXRlc1JlZi5jdXJyZW50ID0gbmV3IFNldChlbnRyaWVzLnNsaWNlKC01MCkpO1xuICAgICAgICB9XG4gICAgICAgIHNldEFnZW50TWVzc2FnZSgocHJldikgPT4ge1xuICAgICAgICAgIGlmICghcHJldiB8fCBwcmV2LmlkICE9PSB1cGRhdGUubWVzc2FnZUlkIHx8IHVwZGF0ZS5yZXN5bmMpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpZDogdXBkYXRlLm1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgY29udGVudEl0ZW1zOiB1cGRhdGUudXBkYXRlUGFydHMuc29ydCgoYSwgYikgPT4gYS5jb250ZW50SW5kZXggLSBiLmNvbnRlbnRJbmRleCkubWFwKChwYXJ0KSA9PiBwYXJ0LnBhcnQpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnRJdGVtcyA9IFsuLi5wcmV2LmNvbnRlbnRJdGVtc107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdXBkYXRlLnVwZGF0ZVBhcnRzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IG5ld0NvbnRlbnRJdGVtc1twYXJ0LmNvbnRlbnRJbmRleF07XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgcGFydC5wYXJ0LnR5cGUgIT09IGV4aXN0aW5nSXRlbS50eXBlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1cGRhdGUgYSBwYXJ0IG9mIGEgZGlmZmVyZW50IHR5cGVcIik7XG4gICAgICAgICAgICAgIGlmIChleGlzdGluZ0l0ZW0gJiYgZXhpc3RpbmdJdGVtLnR5cGUgPT09IFwidGV4dFwiICYmIHBhcnQucGFydC50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRJdGVtID0ge1xuICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdJdGVtLFxuICAgICAgICAgICAgICAgICAgdGV4dDogZXhpc3RpbmdJdGVtLnRleHQgKyBwYXJ0LnBhcnQudGV4dFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbmV3Q29udGVudEl0ZW1zW3BhcnQuY29udGVudEluZGV4XSA9IHVwZGF0ZWRJdGVtO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV4aXN0aW5nSXRlbSAmJiBleGlzdGluZ0l0ZW0udHlwZSA9PT0gXCJpbWFnZVwiICYmIHBhcnQucGFydC50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgdXBkYXRlZEl0ZW07XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJdGVtLmRhdGEgJiYgcGFydC5wYXJ0LmRhdGEgPyB1cGRhdGVkSXRlbSA9IHtcbiAgICAgICAgICAgICAgICAgIC4uLmV4aXN0aW5nSXRlbSxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGV4aXN0aW5nSXRlbS5kYXRhICsgcGFydC5wYXJ0LmRhdGFcbiAgICAgICAgICAgICAgICB9IDogdXBkYXRlZEl0ZW0gPSBwYXJ0LnBhcnQsIG5ld0NvbnRlbnRJdGVtc1twYXJ0LmNvbnRlbnRJbmRleF0gPSB1cGRhdGVkSXRlbTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgbmV3Q29udGVudEl0ZW1zW3BhcnQuY29udGVudEluZGV4XSA9IHBhcnQucGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGlkOiB1cGRhdGUubWVzc2FnZUlkLFxuICAgICAgICAgICAgICBjb250ZW50SXRlbXM6IG5ld0NvbnRlbnRJdGVtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3Byb3ZpZGVySWRdXG4gICk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFnZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhZ2VudC5hZ2VudC5tZXNzYWdpbmcuZ2V0TWVzc2FnZS5zdWJzY3JpYmUoXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAge1xuICAgICAgICAgIG9uRGF0YTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVNZXNzYWdlVXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uRXJyb3I6ICgpID0+IHtcbiAgICAgICAgICAgIHNldEFnZW50TWVzc2FnZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgICBcIltBZ2VudE1lc3NhZ2luZ1Byb3ZpZGVyXSBFcnJvciB1bnN1YnNjcmliaW5nIGZyb20gbWVzc2FnaW5nOlwiLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgc2V0QWdlbnRNZXNzYWdlKG51bGwpO1xuICB9LCBbYWdlbnQsIGhhbmRsZU1lc3NhZ2VVcGRhdGVdKTtcbiAgY29uc3QgaGFuZGxlVXNlck1lc3NhZ2UgPSAobWVzc2FnZSkgPT4ge1xuICAgIGFnZW50ID09IG51bGwgfHwgYWdlbnQuYWdlbnQubWVzc2FnaW5nLnNlbmRVc2VyTWVzc2FnZS5tdXRhdGUobWVzc2FnZSk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIGFnZW50TWVzc2FnaW5nQ29udGV4dC5Qcm92aWRlcixcbiAgICB7XG4gICAgICB2YWx1ZTogeyBhZ2VudE1lc3NhZ2UsIHNlbmRNZXNzYWdlOiBoYW5kbGVVc2VyTWVzc2FnZSB9LFxuICAgICAgY2hpbGRyZW5cbiAgICB9XG4gICk7XG59LCB1c2VBZ2VudE1lc3NhZ2luZyA9ICgpID0+IHVzZUNvbnRleHQoYWdlbnRNZXNzYWdpbmdDb250ZXh0KTtcbmZ1bmN0aW9uIHIoZSkge1xuICB2YXIgdCwgZiwgbiA9IFwiXCI7XG4gIGlmICh0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBlID09IFwibnVtYmVyXCIpIG4gKz0gZTtcbiAgZWxzZSBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIikgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICB2YXIgbyA9IGUubGVuZ3RoO1xuICAgIGZvciAodCA9IDA7IHQgPCBvOyB0KyspIGVbdF0gJiYgKGYgPSByKGVbdF0pKSAmJiAobiAmJiAobiArPSBcIiBcIiksIG4gKz0gZik7XG4gIH0gZWxzZSBmb3IgKGYgaW4gZSkgZVtmXSAmJiAobiAmJiAobiArPSBcIiBcIiksIG4gKz0gZik7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gY2xzeCgpIHtcbiAgZm9yICh2YXIgZSwgdCwgZiA9IDAsIG4gPSBcIlwiLCBvID0gYXJndW1lbnRzLmxlbmd0aDsgZiA8IG87IGYrKykgKGUgPSBhcmd1bWVudHNbZl0pICYmICh0ID0gcihlKSkgJiYgKG4gJiYgKG4gKz0gXCIgXCIpLCBuICs9IHQpO1xuICByZXR1cm4gbjtcbn1cbmNvbnN0IENMQVNTX1BBUlRfU0VQQVJBVE9SID0gXCItXCIsIGNyZWF0ZUNsYXNzR3JvdXBVdGlscyA9IChjb25maWcpID0+IHtcbiAgY29uc3QgY2xhc3NNYXAgPSBjcmVhdGVDbGFzc01hcChjb25maWcpLCB7XG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwcyxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNcbiAgfSA9IGNvbmZpZztcbiAgcmV0dXJuIHtcbiAgICBnZXRDbGFzc0dyb3VwSWQ6IChjbGFzc05hbWUpID0+IHtcbiAgICAgIGNvbnN0IGNsYXNzUGFydHMgPSBjbGFzc05hbWUuc3BsaXQoQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICAgICAgcmV0dXJuIGNsYXNzUGFydHNbMF0gPT09IFwiXCIgJiYgY2xhc3NQYXJ0cy5sZW5ndGggIT09IDEgJiYgY2xhc3NQYXJ0cy5zaGlmdCgpLCBnZXRHcm91cFJlY3Vyc2l2ZShjbGFzc1BhcnRzLCBjbGFzc01hcCkgfHwgZ2V0R3JvdXBJZEZvckFyYml0cmFyeVByb3BlcnR5KGNsYXNzTmFtZSk7XG4gICAgfSxcbiAgICBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHM6IChjbGFzc0dyb3VwSWQsIGhhc1Bvc3RmaXhNb2RpZmllcikgPT4ge1xuICAgICAgY29uc3QgY29uZmxpY3RzID0gY29uZmxpY3RpbmdDbGFzc0dyb3Vwc1tjbGFzc0dyb3VwSWRdIHx8IFtdO1xuICAgICAgcmV0dXJuIGhhc1Bvc3RmaXhNb2RpZmllciAmJiBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnNbY2xhc3NHcm91cElkXSA/IFsuLi5jb25mbGljdHMsIC4uLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyc1tjbGFzc0dyb3VwSWRdXSA6IGNvbmZsaWN0cztcbiAgICB9XG4gIH07XG59LCBnZXRHcm91cFJlY3Vyc2l2ZSA9IChjbGFzc1BhcnRzLCBjbGFzc1BhcnRPYmplY3QpID0+IHtcbiAgdmFyIF9hO1xuICBpZiAoY2xhc3NQYXJ0cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGNsYXNzUGFydE9iamVjdC5jbGFzc0dyb3VwSWQ7XG4gIGNvbnN0IGN1cnJlbnRDbGFzc1BhcnQgPSBjbGFzc1BhcnRzWzBdLCBuZXh0Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmdldChjdXJyZW50Q2xhc3NQYXJ0KSwgY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0ID0gbmV4dENsYXNzUGFydE9iamVjdCA/IGdldEdyb3VwUmVjdXJzaXZlKGNsYXNzUGFydHMuc2xpY2UoMSksIG5leHRDbGFzc1BhcnRPYmplY3QpIDogdm9pZCAwO1xuICBpZiAoY2xhc3NHcm91cEZyb21OZXh0Q2xhc3NQYXJ0KVxuICAgIHJldHVybiBjbGFzc0dyb3VwRnJvbU5leHRDbGFzc1BhcnQ7XG4gIGlmIChjbGFzc1BhcnRPYmplY3QudmFsaWRhdG9ycy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBjb25zdCBjbGFzc1Jlc3QgPSBjbGFzc1BhcnRzLmpvaW4oQ0xBU1NfUEFSVF9TRVBBUkFUT1IpO1xuICByZXR1cm4gKF9hID0gY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMuZmluZCgoe1xuICAgIHZhbGlkYXRvclxuICB9KSA9PiB2YWxpZGF0b3IoY2xhc3NSZXN0KSkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jbGFzc0dyb3VwSWQ7XG59LCBhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4ID0gL15cXFxcWyguKylcXFxcXSQvLCBnZXRHcm91cElkRm9yQXJiaXRyYXJ5UHJvcGVydHkgPSAoY2xhc3NOYW1lKSA9PiB7XG4gIGlmIChhcmJpdHJhcnlQcm9wZXJ0eVJlZ2V4LnRlc3QoY2xhc3NOYW1lKSkge1xuICAgIGNvbnN0IGFyYml0cmFyeVByb3BlcnR5Q2xhc3NOYW1lID0gYXJiaXRyYXJ5UHJvcGVydHlSZWdleC5leGVjKGNsYXNzTmFtZSlbMV0sIHByb3BlcnR5ID0gYXJiaXRyYXJ5UHJvcGVydHlDbGFzc05hbWUgPT0gbnVsbCA/IHZvaWQgMCA6IGFyYml0cmFyeVByb3BlcnR5Q2xhc3NOYW1lLnN1YnN0cmluZygwLCBhcmJpdHJhcnlQcm9wZXJ0eUNsYXNzTmFtZS5pbmRleE9mKFwiOlwiKSk7XG4gICAgaWYgKHByb3BlcnR5KVxuICAgICAgcmV0dXJuIFwiYXJiaXRyYXJ5Li5cIiArIHByb3BlcnR5O1xuICB9XG59LCBjcmVhdGVDbGFzc01hcCA9IChjb25maWcpID0+IHtcbiAgY29uc3Qge1xuICAgIHRoZW1lLFxuICAgIGNsYXNzR3JvdXBzXG4gIH0gPSBjb25maWcsIGNsYXNzTWFwID0ge1xuICAgIG5leHRQYXJ0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHZhbGlkYXRvcnM6IFtdXG4gIH07XG4gIGZvciAoY29uc3QgY2xhc3NHcm91cElkIGluIGNsYXNzR3JvdXBzKVxuICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NHcm91cHNbY2xhc3NHcm91cElkXSwgY2xhc3NNYXAsIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICByZXR1cm4gY2xhc3NNYXA7XG59LCBwcm9jZXNzQ2xhc3Nlc1JlY3Vyc2l2ZWx5ID0gKGNsYXNzR3JvdXAsIGNsYXNzUGFydE9iamVjdCwgY2xhc3NHcm91cElkLCB0aGVtZSkgPT4ge1xuICBjbGFzc0dyb3VwLmZvckVhY2goKGNsYXNzRGVmaW5pdGlvbikgPT4ge1xuICAgIGlmICh0eXBlb2YgY2xhc3NEZWZpbml0aW9uID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGNsYXNzUGFydE9iamVjdFRvRWRpdCA9IGNsYXNzRGVmaW5pdGlvbiA9PT0gXCJcIiA/IGNsYXNzUGFydE9iamVjdCA6IGdldFBhcnQoY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0RlZmluaXRpb24pO1xuICAgICAgY2xhc3NQYXJ0T2JqZWN0VG9FZGl0LmNsYXNzR3JvdXBJZCA9IGNsYXNzR3JvdXBJZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjbGFzc0RlZmluaXRpb24gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoaXNUaGVtZUdldHRlcihjbGFzc0RlZmluaXRpb24pKSB7XG4gICAgICAgIHByb2Nlc3NDbGFzc2VzUmVjdXJzaXZlbHkoY2xhc3NEZWZpbml0aW9uKHRoZW1lKSwgY2xhc3NQYXJ0T2JqZWN0LCBjbGFzc0dyb3VwSWQsIHRoZW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2xhc3NQYXJ0T2JqZWN0LnZhbGlkYXRvcnMucHVzaCh7XG4gICAgICAgIHZhbGlkYXRvcjogY2xhc3NEZWZpbml0aW9uLFxuICAgICAgICBjbGFzc0dyb3VwSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZW50cmllcyhjbGFzc0RlZmluaXRpb24pLmZvckVhY2goKFtrZXksIGNsYXNzR3JvdXAyXSkgPT4ge1xuICAgICAgcHJvY2Vzc0NsYXNzZXNSZWN1cnNpdmVseShjbGFzc0dyb3VwMiwgZ2V0UGFydChjbGFzc1BhcnRPYmplY3QsIGtleSksIGNsYXNzR3JvdXBJZCwgdGhlbWUpO1xuICAgIH0pO1xuICB9KTtcbn0sIGdldFBhcnQgPSAoY2xhc3NQYXJ0T2JqZWN0LCBwYXRoKSA9PiB7XG4gIGxldCBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0ID0gY2xhc3NQYXJ0T2JqZWN0O1xuICByZXR1cm4gcGF0aC5zcGxpdChDTEFTU19QQVJUX1NFUEFSQVRPUikuZm9yRWFjaCgocGF0aFBhcnQpID0+IHtcbiAgICBjdXJyZW50Q2xhc3NQYXJ0T2JqZWN0Lm5leHRQYXJ0LmhhcyhwYXRoUGFydCkgfHwgY3VycmVudENsYXNzUGFydE9iamVjdC5uZXh0UGFydC5zZXQocGF0aFBhcnQsIHtcbiAgICAgIG5leHRQYXJ0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgdmFsaWRhdG9yczogW11cbiAgICB9KSwgY3VycmVudENsYXNzUGFydE9iamVjdCA9IGN1cnJlbnRDbGFzc1BhcnRPYmplY3QubmV4dFBhcnQuZ2V0KHBhdGhQYXJ0KTtcbiAgfSksIGN1cnJlbnRDbGFzc1BhcnRPYmplY3Q7XG59LCBpc1RoZW1lR2V0dGVyID0gKGZ1bmMpID0+IGZ1bmMuaXNUaGVtZUdldHRlciwgY3JlYXRlTHJ1Q2FjaGUgPSAobWF4Q2FjaGVTaXplKSA9PiB7XG4gIGlmIChtYXhDYWNoZVNpemUgPCAxKVxuICAgIHJldHVybiB7XG4gICAgICBnZXQ6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBzZXQ6ICgpID0+IHtcbiAgICAgIH1cbiAgICB9O1xuICBsZXQgY2FjaGVTaXplID0gMCwgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBwcmV2aW91c0NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdXBkYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSksIGNhY2hlU2l6ZSsrLCBjYWNoZVNpemUgPiBtYXhDYWNoZVNpemUgJiYgKGNhY2hlU2l6ZSA9IDAsIHByZXZpb3VzQ2FjaGUgPSBjYWNoZSwgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBnZXQoa2V5KSB7XG4gICAgICBsZXQgdmFsdWUgPSBjYWNoZS5nZXQoa2V5KTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICBpZiAoKHZhbHVlID0gcHJldmlvdXNDYWNoZS5nZXQoa2V5KSkgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHVwZGF0ZShrZXksIHZhbHVlKSwgdmFsdWU7XG4gICAgfSxcbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgY2FjaGUuaGFzKGtleSkgPyBjYWNoZS5zZXQoa2V5LCB2YWx1ZSkgOiB1cGRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9O1xufSwgSU1QT1JUQU5UX01PRElGSUVSID0gXCIhXCIsIE1PRElGSUVSX1NFUEFSQVRPUiA9IFwiOlwiLCBNT0RJRklFUl9TRVBBUkFUT1JfTEVOR1RIID0gTU9ESUZJRVJfU0VQQVJBVE9SLmxlbmd0aCwgY3JlYXRlUGFyc2VDbGFzc05hbWUgPSAoY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwcmVmaXgsXG4gICAgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWVcbiAgfSA9IGNvbmZpZztcbiAgbGV0IHBhcnNlQ2xhc3NOYW1lID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtdO1xuICAgIGxldCBicmFja2V0RGVwdGggPSAwLCBwYXJlbkRlcHRoID0gMCwgbW9kaWZpZXJTdGFydCA9IDAsIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjbGFzc05hbWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBsZXQgY3VycmVudENoYXJhY3RlciA9IGNsYXNzTmFtZVtpbmRleF07XG4gICAgICBpZiAoYnJhY2tldERlcHRoID09PSAwICYmIHBhcmVuRGVwdGggPT09IDApIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXIgPT09IE1PRElGSUVSX1NFUEFSQVRPUikge1xuICAgICAgICAgIG1vZGlmaWVycy5wdXNoKGNsYXNzTmFtZS5zbGljZShtb2RpZmllclN0YXJ0LCBpbmRleCkpLCBtb2RpZmllclN0YXJ0ID0gaW5kZXggKyBNT0RJRklFUl9TRVBBUkFUT1JfTEVOR1RIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVyID09PSBcIi9cIikge1xuICAgICAgICAgIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID0gaW5kZXg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnJlbnRDaGFyYWN0ZXIgPT09IFwiW1wiID8gYnJhY2tldERlcHRoKysgOiBjdXJyZW50Q2hhcmFjdGVyID09PSBcIl1cIiA/IGJyYWNrZXREZXB0aC0tIDogY3VycmVudENoYXJhY3RlciA9PT0gXCIoXCIgPyBwYXJlbkRlcHRoKysgOiBjdXJyZW50Q2hhcmFjdGVyID09PSBcIilcIiAmJiBwYXJlbkRlcHRoLS07XG4gICAgfVxuICAgIGNvbnN0IGJhc2VDbGFzc05hbWVXaXRoSW1wb3J0YW50TW9kaWZpZXIgPSBtb2RpZmllcnMubGVuZ3RoID09PSAwID8gY2xhc3NOYW1lIDogY2xhc3NOYW1lLnN1YnN0cmluZyhtb2RpZmllclN0YXJ0KSwgYmFzZUNsYXNzTmFtZSA9IHN0cmlwSW1wb3J0YW50TW9kaWZpZXIoYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllciksIGhhc0ltcG9ydGFudE1vZGlmaWVyID0gYmFzZUNsYXNzTmFtZSAhPT0gYmFzZUNsYXNzTmFtZVdpdGhJbXBvcnRhbnRNb2RpZmllciwgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbiA9IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uICYmIHBvc3RmaXhNb2RpZmllclBvc2l0aW9uID4gbW9kaWZpZXJTdGFydCA/IHBvc3RmaXhNb2RpZmllclBvc2l0aW9uIC0gbW9kaWZpZXJTdGFydCA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgbW9kaWZpZXJzLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXIsXG4gICAgICBiYXNlQ2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvblxuICAgIH07XG4gIH07XG4gIGlmIChwcmVmaXgpIHtcbiAgICBjb25zdCBmdWxsUHJlZml4ID0gcHJlZml4ICsgTU9ESUZJRVJfU0VQQVJBVE9SLCBwYXJzZUNsYXNzTmFtZU9yaWdpbmFsID0gcGFyc2VDbGFzc05hbWU7XG4gICAgcGFyc2VDbGFzc05hbWUgPSAoY2xhc3NOYW1lKSA9PiBjbGFzc05hbWUuc3RhcnRzV2l0aChmdWxsUHJlZml4KSA/IHBhcnNlQ2xhc3NOYW1lT3JpZ2luYWwoY2xhc3NOYW1lLnN1YnN0cmluZyhmdWxsUHJlZml4Lmxlbmd0aCkpIDoge1xuICAgICAgaXNFeHRlcm5hbDogITAsXG4gICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgaGFzSW1wb3J0YW50TW9kaWZpZXI6ICExLFxuICAgICAgYmFzZUNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbjogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBpZiAoZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUpIHtcbiAgICBjb25zdCBwYXJzZUNsYXNzTmFtZU9yaWdpbmFsID0gcGFyc2VDbGFzc05hbWU7XG4gICAgcGFyc2VDbGFzc05hbWUgPSAoY2xhc3NOYW1lKSA9PiBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSh7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBwYXJzZUNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVPcmlnaW5hbFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBwYXJzZUNsYXNzTmFtZTtcbn0sIHN0cmlwSW1wb3J0YW50TW9kaWZpZXIgPSAoYmFzZUNsYXNzTmFtZSkgPT4gYmFzZUNsYXNzTmFtZS5lbmRzV2l0aChJTVBPUlRBTlRfTU9ESUZJRVIpID8gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMCwgYmFzZUNsYXNzTmFtZS5sZW5ndGggLSAxKSA6IGJhc2VDbGFzc05hbWUuc3RhcnRzV2l0aChJTVBPUlRBTlRfTU9ESUZJRVIpID8gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMSkgOiBiYXNlQ2xhc3NOYW1lLCBjcmVhdGVTb3J0TW9kaWZpZXJzID0gKGNvbmZpZykgPT4ge1xuICBjb25zdCBvcmRlclNlbnNpdGl2ZU1vZGlmaWVycyA9IE9iamVjdC5mcm9tRW50cmllcyhjb25maWcub3JkZXJTZW5zaXRpdmVNb2RpZmllcnMubWFwKChtb2RpZmllcikgPT4gW21vZGlmaWVyLCAhMF0pKTtcbiAgcmV0dXJuIChtb2RpZmllcnMpID0+IHtcbiAgICBpZiAobW9kaWZpZXJzLmxlbmd0aCA8PSAxKVxuICAgICAgcmV0dXJuIG1vZGlmaWVycztcbiAgICBjb25zdCBzb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICBsZXQgdW5zb3J0ZWRNb2RpZmllcnMgPSBbXTtcbiAgICByZXR1cm4gbW9kaWZpZXJzLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICBtb2RpZmllclswXSA9PT0gXCJbXCIgfHwgb3JkZXJTZW5zaXRpdmVNb2RpZmllcnNbbW9kaWZpZXJdID8gKHNvcnRlZE1vZGlmaWVycy5wdXNoKC4uLnVuc29ydGVkTW9kaWZpZXJzLnNvcnQoKSwgbW9kaWZpZXIpLCB1bnNvcnRlZE1vZGlmaWVycyA9IFtdKSA6IHVuc29ydGVkTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgIH0pLCBzb3J0ZWRNb2RpZmllcnMucHVzaCguLi51bnNvcnRlZE1vZGlmaWVycy5zb3J0KCkpLCBzb3J0ZWRNb2RpZmllcnM7XG4gIH07XG59LCBjcmVhdGVDb25maWdVdGlscyA9IChjb25maWcpID0+ICh7XG4gIGNhY2hlOiBjcmVhdGVMcnVDYWNoZShjb25maWcuY2FjaGVTaXplKSxcbiAgcGFyc2VDbGFzc05hbWU6IGNyZWF0ZVBhcnNlQ2xhc3NOYW1lKGNvbmZpZyksXG4gIHNvcnRNb2RpZmllcnM6IGNyZWF0ZVNvcnRNb2RpZmllcnMoY29uZmlnKSxcbiAgLi4uY3JlYXRlQ2xhc3NHcm91cFV0aWxzKGNvbmZpZylcbn0pLCBTUExJVF9DTEFTU0VTX1JFR0VYID0gL1xcXFxzKy8sIG1lcmdlQ2xhc3NMaXN0ID0gKGNsYXNzTGlzdCwgY29uZmlnVXRpbHMpID0+IHtcbiAgY29uc3Qge1xuICAgIHBhcnNlQ2xhc3NOYW1lLFxuICAgIGdldENsYXNzR3JvdXBJZCxcbiAgICBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHMsXG4gICAgc29ydE1vZGlmaWVyc1xuICB9ID0gY29uZmlnVXRpbHMsIGNsYXNzR3JvdXBzSW5Db25mbGljdCA9IFtdLCBjbGFzc05hbWVzID0gY2xhc3NMaXN0LnRyaW0oKS5zcGxpdChTUExJVF9DTEFTU0VTX1JFR0VYKTtcbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGZvciAobGV0IGluZGV4ID0gY2xhc3NOYW1lcy5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxDbGFzc05hbWUgPSBjbGFzc05hbWVzW2luZGV4XSwge1xuICAgICAgaXNFeHRlcm5hbCxcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGhhc0ltcG9ydGFudE1vZGlmaWVyLFxuICAgICAgYmFzZUNsYXNzTmFtZSxcbiAgICAgIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb25cbiAgICB9ID0gcGFyc2VDbGFzc05hbWUob3JpZ2luYWxDbGFzc05hbWUpO1xuICAgIGlmIChpc0V4dGVybmFsKSB7XG4gICAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/IFwiIFwiICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgaGFzUG9zdGZpeE1vZGlmaWVyID0gISFtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uLCBjbGFzc0dyb3VwSWQgPSBnZXRDbGFzc0dyb3VwSWQoaGFzUG9zdGZpeE1vZGlmaWVyID8gYmFzZUNsYXNzTmFtZS5zdWJzdHJpbmcoMCwgbWF5YmVQb3N0Zml4TW9kaWZpZXJQb3NpdGlvbikgOiBiYXNlQ2xhc3NOYW1lKTtcbiAgICBpZiAoIWNsYXNzR3JvdXBJZCkge1xuICAgICAgaWYgKCFoYXNQb3N0Zml4TW9kaWZpZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb3JpZ2luYWxDbGFzc05hbWUgKyAocmVzdWx0Lmxlbmd0aCA+IDAgPyBcIiBcIiArIHJlc3VsdCA6IHJlc3VsdCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzR3JvdXBJZCA9IGdldENsYXNzR3JvdXBJZChiYXNlQ2xhc3NOYW1lKSwgIWNsYXNzR3JvdXBJZCkge1xuICAgICAgICByZXN1bHQgPSBvcmlnaW5hbENsYXNzTmFtZSArIChyZXN1bHQubGVuZ3RoID4gMCA/IFwiIFwiICsgcmVzdWx0IDogcmVzdWx0KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBoYXNQb3N0Zml4TW9kaWZpZXIgPSAhMTtcbiAgICB9XG4gICAgY29uc3QgdmFyaWFudE1vZGlmaWVyID0gc29ydE1vZGlmaWVycyhtb2RpZmllcnMpLmpvaW4oXCI6XCIpLCBtb2RpZmllcklkID0gaGFzSW1wb3J0YW50TW9kaWZpZXIgPyB2YXJpYW50TW9kaWZpZXIgKyBJTVBPUlRBTlRfTU9ESUZJRVIgOiB2YXJpYW50TW9kaWZpZXIsIGNsYXNzSWQgPSBtb2RpZmllcklkICsgY2xhc3NHcm91cElkO1xuICAgIGlmIChjbGFzc0dyb3Vwc0luQ29uZmxpY3QuaW5jbHVkZXMoY2xhc3NJZCkpXG4gICAgICBjb250aW51ZTtcbiAgICBjbGFzc0dyb3Vwc0luQ29uZmxpY3QucHVzaChjbGFzc0lkKTtcbiAgICBjb25zdCBjb25mbGljdEdyb3VwcyA9IGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkcyhjbGFzc0dyb3VwSWQsIGhhc1Bvc3RmaXhNb2RpZmllcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb25mbGljdEdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ3JvdXAgPSBjb25mbGljdEdyb3Vwc1tpXTtcbiAgICAgIGNsYXNzR3JvdXBzSW5Db25mbGljdC5wdXNoKG1vZGlmaWVySWQgKyBncm91cCk7XG4gICAgfVxuICAgIHJlc3VsdCA9IG9yaWdpbmFsQ2xhc3NOYW1lICsgKHJlc3VsdC5sZW5ndGggPiAwID8gXCIgXCIgKyByZXN1bHQgOiByZXN1bHQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gdHdKb2luKCkge1xuICBsZXQgaW5kZXggPSAwLCBhcmd1bWVudCwgcmVzb2x2ZWRWYWx1ZSwgc3RyaW5nID0gXCJcIjtcbiAgZm9yICg7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgKVxuICAgIChhcmd1bWVudCA9IGFyZ3VtZW50c1tpbmRleCsrXSkgJiYgKHJlc29sdmVkVmFsdWUgPSB0b1ZhbHVlKGFyZ3VtZW50KSkgJiYgKHN0cmluZyAmJiAoc3RyaW5nICs9IFwiIFwiKSwgc3RyaW5nICs9IHJlc29sdmVkVmFsdWUpO1xuICByZXR1cm4gc3RyaW5nO1xufVxuY29uc3QgdG9WYWx1ZSA9IChtaXgpID0+IHtcbiAgaWYgKHR5cGVvZiBtaXggPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gbWl4O1xuICBsZXQgcmVzb2x2ZWRWYWx1ZSwgc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgayA9IDA7IGsgPCBtaXgubGVuZ3RoOyBrKyspXG4gICAgbWl4W2tdICYmIChyZXNvbHZlZFZhbHVlID0gdG9WYWx1ZShtaXhba10pKSAmJiAoc3RyaW5nICYmIChzdHJpbmcgKz0gXCIgXCIpLCBzdHJpbmcgKz0gcmVzb2x2ZWRWYWx1ZSk7XG4gIHJldHVybiBzdHJpbmc7XG59O1xuZnVuY3Rpb24gY3JlYXRlVGFpbHdpbmRNZXJnZShjcmVhdGVDb25maWdGaXJzdCwgLi4uY3JlYXRlQ29uZmlnUmVzdCkge1xuICBsZXQgY29uZmlnVXRpbHMsIGNhY2hlR2V0LCBjYWNoZVNldCwgZnVuY3Rpb25Ub0NhbGwgPSBpbml0VGFpbHdpbmRNZXJnZTtcbiAgZnVuY3Rpb24gaW5pdFRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQ29uZmlnUmVzdC5yZWR1Y2UoKHByZXZpb3VzQ29uZmlnLCBjcmVhdGVDb25maWdDdXJyZW50KSA9PiBjcmVhdGVDb25maWdDdXJyZW50KHByZXZpb3VzQ29uZmlnKSwgY3JlYXRlQ29uZmlnRmlyc3QoKSk7XG4gICAgcmV0dXJuIGNvbmZpZ1V0aWxzID0gY3JlYXRlQ29uZmlnVXRpbHMoY29uZmlnKSwgY2FjaGVHZXQgPSBjb25maWdVdGlscy5jYWNoZS5nZXQsIGNhY2hlU2V0ID0gY29uZmlnVXRpbHMuY2FjaGUuc2V0LCBmdW5jdGlvblRvQ2FsbCA9IHRhaWx3aW5kTWVyZ2UsIHRhaWx3aW5kTWVyZ2UoY2xhc3NMaXN0KTtcbiAgfVxuICBmdW5jdGlvbiB0YWlsd2luZE1lcmdlKGNsYXNzTGlzdCkge1xuICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGNhY2hlR2V0KGNsYXNzTGlzdCk7XG4gICAgaWYgKGNhY2hlZFJlc3VsdClcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgY29uc3QgcmVzdWx0ID0gbWVyZ2VDbGFzc0xpc3QoY2xhc3NMaXN0LCBjb25maWdVdGlscyk7XG4gICAgcmV0dXJuIGNhY2hlU2V0KGNsYXNzTGlzdCwgcmVzdWx0KSwgcmVzdWx0O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25Ub0NhbGwodHdKb2luLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuY29uc3QgZnJvbVRoZW1lID0gKGtleSkgPT4ge1xuICBjb25zdCB0aGVtZUdldHRlciA9ICh0aGVtZSkgPT4gdGhlbWVba2V5XSB8fCBbXTtcbiAgcmV0dXJuIHRoZW1lR2V0dGVyLmlzVGhlbWVHZXR0ZXIgPSAhMCwgdGhlbWVHZXR0ZXI7XG59LCBhcmJpdHJhcnlWYWx1ZVJlZ2V4ID0gL15cXFxcWyg/OihcXFxcd1tcXFxcdy1dKik6KT8oLispXFxcXF0kL2ksIGFyYml0cmFyeVZhcmlhYmxlUmVnZXggPSAvXlxcXFwoKD86KFxcXFx3W1xcXFx3LV0qKTopPyguKylcXFxcKSQvaSwgZnJhY3Rpb25SZWdleCA9IC9eXFxcXGQrXFxcXC9cXFxcZCskLywgdHNoaXJ0VW5pdFJlZ2V4ID0gL14oXFxcXGQrKFxcXFwuXFxcXGQrKT8pPyh4c3xzbXxtZHxsZ3x4bCkkLywgbGVuZ3RoVW5pdFJlZ2V4ID0gL1xcXFxkKyglfHB4fHI/ZW18W3NkbF0/dihbaHdpYl18bWlufG1heCl8cHR8cGN8aW58Y218bW18Y2FwfGNofGV4fHI/bGh8Y3Eod3xofGl8YnxtaW58bWF4KSl8XFxcXGIoY2FsY3xtaW58bWF4fGNsYW1wKVxcXFwoLitcXFxcKXxeMCQvLCBjb2xvckZ1bmN0aW9uUmVnZXggPSAvXihyZ2JhP3xoc2xhP3xod2J8KG9rKT8obGFifGxjaCl8Y29sb3ItbWl4KVxcXFwoLitcXFxcKSQvLCBzaGFkb3dSZWdleCA9IC9eKGluc2V0Xyk/LT8oKFxcXFxkKyk/XFxcXC4/KFxcXFxkKylbYS16XSt8MClfLT8oKFxcXFxkKyk/XFxcXC4/KFxcXFxkKylbYS16XSt8MCkvLCBpbWFnZVJlZ2V4ID0gL14odXJsfGltYWdlfGltYWdlLXNldHxjcm9zcy1mYWRlfGVsZW1lbnR8KHJlcGVhdGluZy0pPyhsaW5lYXJ8cmFkaWFsfGNvbmljKS1ncmFkaWVudClcXFxcKC4rXFxcXCkkLywgaXNGcmFjdGlvbiA9ICh2YWx1ZSkgPT4gZnJhY3Rpb25SZWdleC50ZXN0KHZhbHVlKSwgaXNOdW1iZXIgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgIU51bWJlci5pc05hTihOdW1iZXIodmFsdWUpKSwgaXNJbnRlZ2VyID0gKHZhbHVlKSA9PiAhIXZhbHVlICYmIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbHVlKSksIGlzUGVyY2VudCA9ICh2YWx1ZSkgPT4gdmFsdWUuZW5kc1dpdGgoXCIlXCIpICYmIGlzTnVtYmVyKHZhbHVlLnNsaWNlKDAsIC0xKSksIGlzVHNoaXJ0U2l6ZSA9ICh2YWx1ZSkgPT4gdHNoaXJ0VW5pdFJlZ2V4LnRlc3QodmFsdWUpLCBpc0FueSA9ICgpID0+ICEwLCBpc0xlbmd0aE9ubHkgPSAodmFsdWUpID0+IChcbiAgLy8gXFxgY29sb3JGdW5jdGlvblJlZ2V4XFxgIGNoZWNrIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGNvbG9yIGZ1bmN0aW9ucyBjYW4gaGF2ZSBwZXJjZW50YWdlcyBpbiB0aGVtIHdoaWNoIHdoaWNoIHdvdWxkIGJlIGluY29ycmVjdGx5IGNsYXNzaWZpZWQgYXMgbGVuZ3Rocy5cbiAgLy8gRm9yIGV4YW1wbGUsIFxcYGhzbCgwIDAlIDAlKVxcYCB3b3VsZCBiZSBjbGFzc2lmaWVkIGFzIGEgbGVuZ3RoIHdpdGhvdXQgdGhpcyBjaGVjay5cbiAgLy8gSSBjb3VsZCBhbHNvIHVzZSBsb29rYmVoaW5kIGFzc2VydGlvbiBpbiBcXGBsZW5ndGhVbml0UmVnZXhcXGAgYnV0IHRoYXQgaXNuJ3Qgc3VwcG9ydGVkIHdpZGVseSBlbm91Z2guXG4gIGxlbmd0aFVuaXRSZWdleC50ZXN0KHZhbHVlKSAmJiAhY29sb3JGdW5jdGlvblJlZ2V4LnRlc3QodmFsdWUpXG4pLCBpc05ldmVyID0gKCkgPT4gITEsIGlzU2hhZG93ID0gKHZhbHVlKSA9PiBzaGFkb3dSZWdleC50ZXN0KHZhbHVlKSwgaXNJbWFnZSA9ICh2YWx1ZSkgPT4gaW1hZ2VSZWdleC50ZXN0KHZhbHVlKSwgaXNBbnlOb25BcmJpdHJhcnkgPSAodmFsdWUpID0+ICFpc0FyYml0cmFyeVZhbHVlKHZhbHVlKSAmJiAhaXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSksIGlzQXJiaXRyYXJ5U2l6ZSA9ICh2YWx1ZSkgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbFNpemUsIGlzTmV2ZXIpLCBpc0FyYml0cmFyeVZhbHVlID0gKHZhbHVlKSA9PiBhcmJpdHJhcnlWYWx1ZVJlZ2V4LnRlc3QodmFsdWUpLCBpc0FyYml0cmFyeUxlbmd0aCA9ICh2YWx1ZSkgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbExlbmd0aCwgaXNMZW5ndGhPbmx5KSwgaXNBcmJpdHJhcnlOdW1iZXIgPSAodmFsdWUpID0+IGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGlzTGFiZWxOdW1iZXIsIGlzTnVtYmVyKSwgaXNBcmJpdHJhcnlQb3NpdGlvbiA9ICh2YWx1ZSkgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbFBvc2l0aW9uLCBpc05ldmVyKSwgaXNBcmJpdHJhcnlJbWFnZSA9ICh2YWx1ZSkgPT4gZ2V0SXNBcmJpdHJhcnlWYWx1ZSh2YWx1ZSwgaXNMYWJlbEltYWdlLCBpc0ltYWdlKSwgaXNBcmJpdHJhcnlTaGFkb3cgPSAodmFsdWUpID0+IGdldElzQXJiaXRyYXJ5VmFsdWUodmFsdWUsIGlzTGFiZWxTaGFkb3csIGlzU2hhZG93KSwgaXNBcmJpdHJhcnlWYXJpYWJsZSA9ICh2YWx1ZSkgPT4gYXJiaXRyYXJ5VmFyaWFibGVSZWdleC50ZXN0KHZhbHVlKSwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCA9ICh2YWx1ZSkgPT4gZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbExlbmd0aCksIGlzQXJiaXRyYXJ5VmFyaWFibGVGYW1pbHlOYW1lID0gKHZhbHVlKSA9PiBnZXRJc0FyYml0cmFyeVZhcmlhYmxlKHZhbHVlLCBpc0xhYmVsRmFtaWx5TmFtZSksIGlzQXJiaXRyYXJ5VmFyaWFibGVQb3NpdGlvbiA9ICh2YWx1ZSkgPT4gZ2V0SXNBcmJpdHJhcnlWYXJpYWJsZSh2YWx1ZSwgaXNMYWJlbFBvc2l0aW9uKSwgaXNBcmJpdHJhcnlWYXJpYWJsZVNpemUgPSAodmFsdWUpID0+IGdldElzQXJiaXRyYXJ5VmFyaWFibGUodmFsdWUsIGlzTGFiZWxTaXplKSwgaXNBcmJpdHJhcnlWYXJpYWJsZUltYWdlID0gKHZhbHVlKSA9PiBnZXRJc0FyYml0cmFyeVZhcmlhYmxlKHZhbHVlLCBpc0xhYmVsSW1hZ2UpLCBpc0FyYml0cmFyeVZhcmlhYmxlU2hhZG93ID0gKHZhbHVlKSA9PiBnZXRJc0FyYml0cmFyeVZhcmlhYmxlKHZhbHVlLCBpc0xhYmVsU2hhZG93LCAhMCksIGdldElzQXJiaXRyYXJ5VmFsdWUgPSAodmFsdWUsIHRlc3RMYWJlbCwgdGVzdFZhbHVlKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGFyYml0cmFyeVZhbHVlUmVnZXguZXhlYyh2YWx1ZSk7XG4gIHJldHVybiByZXN1bHQgPyByZXN1bHRbMV0gPyB0ZXN0TGFiZWwocmVzdWx0WzFdKSA6IHRlc3RWYWx1ZShyZXN1bHRbMl0pIDogITE7XG59LCBnZXRJc0FyYml0cmFyeVZhcmlhYmxlID0gKHZhbHVlLCB0ZXN0TGFiZWwsIHNob3VsZE1hdGNoTm9MYWJlbCA9ICExKSA9PiB7XG4gIGNvbnN0IHJlc3VsdCA9IGFyYml0cmFyeVZhcmlhYmxlUmVnZXguZXhlYyh2YWx1ZSk7XG4gIHJldHVybiByZXN1bHQgPyByZXN1bHRbMV0gPyB0ZXN0TGFiZWwocmVzdWx0WzFdKSA6IHNob3VsZE1hdGNoTm9MYWJlbCA6ICExO1xufSwgaXNMYWJlbFBvc2l0aW9uID0gKGxhYmVsKSA9PiBsYWJlbCA9PT0gXCJwb3NpdGlvblwiIHx8IGxhYmVsID09PSBcInBlcmNlbnRhZ2VcIiwgaXNMYWJlbEltYWdlID0gKGxhYmVsKSA9PiBsYWJlbCA9PT0gXCJpbWFnZVwiIHx8IGxhYmVsID09PSBcInVybFwiLCBpc0xhYmVsU2l6ZSA9IChsYWJlbCkgPT4gbGFiZWwgPT09IFwibGVuZ3RoXCIgfHwgbGFiZWwgPT09IFwic2l6ZVwiIHx8IGxhYmVsID09PSBcImJnLXNpemVcIiwgaXNMYWJlbExlbmd0aCA9IChsYWJlbCkgPT4gbGFiZWwgPT09IFwibGVuZ3RoXCIsIGlzTGFiZWxOdW1iZXIgPSAobGFiZWwpID0+IGxhYmVsID09PSBcIm51bWJlclwiLCBpc0xhYmVsRmFtaWx5TmFtZSA9IChsYWJlbCkgPT4gbGFiZWwgPT09IFwiZmFtaWx5LW5hbWVcIiwgaXNMYWJlbFNoYWRvdyA9IChsYWJlbCkgPT4gbGFiZWwgPT09IFwic2hhZG93XCIsIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiB7XG4gIGNvbnN0IHRoZW1lQ29sb3IgPSBmcm9tVGhlbWUoXCJjb2xvclwiKSwgdGhlbWVGb250ID0gZnJvbVRoZW1lKFwiZm9udFwiKSwgdGhlbWVUZXh0ID0gZnJvbVRoZW1lKFwidGV4dFwiKSwgdGhlbWVGb250V2VpZ2h0ID0gZnJvbVRoZW1lKFwiZm9udC13ZWlnaHRcIiksIHRoZW1lVHJhY2tpbmcgPSBmcm9tVGhlbWUoXCJ0cmFja2luZ1wiKSwgdGhlbWVMZWFkaW5nID0gZnJvbVRoZW1lKFwibGVhZGluZ1wiKSwgdGhlbWVCcmVha3BvaW50ID0gZnJvbVRoZW1lKFwiYnJlYWtwb2ludFwiKSwgdGhlbWVDb250YWluZXIgPSBmcm9tVGhlbWUoXCJjb250YWluZXJcIiksIHRoZW1lU3BhY2luZyA9IGZyb21UaGVtZShcInNwYWNpbmdcIiksIHRoZW1lUmFkaXVzID0gZnJvbVRoZW1lKFwicmFkaXVzXCIpLCB0aGVtZVNoYWRvdyA9IGZyb21UaGVtZShcInNoYWRvd1wiKSwgdGhlbWVJbnNldFNoYWRvdyA9IGZyb21UaGVtZShcImluc2V0LXNoYWRvd1wiKSwgdGhlbWVUZXh0U2hhZG93ID0gZnJvbVRoZW1lKFwidGV4dC1zaGFkb3dcIiksIHRoZW1lRHJvcFNoYWRvdyA9IGZyb21UaGVtZShcImRyb3Atc2hhZG93XCIpLCB0aGVtZUJsdXIgPSBmcm9tVGhlbWUoXCJibHVyXCIpLCB0aGVtZVBlcnNwZWN0aXZlID0gZnJvbVRoZW1lKFwicGVyc3BlY3RpdmVcIiksIHRoZW1lQXNwZWN0ID0gZnJvbVRoZW1lKFwiYXNwZWN0XCIpLCB0aGVtZUVhc2UgPSBmcm9tVGhlbWUoXCJlYXNlXCIpLCB0aGVtZUFuaW1hdGUgPSBmcm9tVGhlbWUoXCJhbmltYXRlXCIpLCBzY2FsZUJyZWFrID0gKCkgPT4gW1wiYXV0b1wiLCBcImF2b2lkXCIsIFwiYWxsXCIsIFwiYXZvaWQtcGFnZVwiLCBcInBhZ2VcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJjb2x1bW5cIl0sIHNjYWxlUG9zaXRpb24gPSAoKSA9PiBbXG4gICAgXCJjZW50ZXJcIixcbiAgICBcInRvcFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwidG9wLWxlZnRcIixcbiAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4xLjAsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL3B1bGwvMTczNzhcbiAgICBcImxlZnQtdG9wXCIsXG4gICAgXCJ0b3AtcmlnaHRcIixcbiAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4xLjAsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL3B1bGwvMTczNzhcbiAgICBcInJpZ2h0LXRvcFwiLFxuICAgIFwiYm90dG9tLXJpZ2h0XCIsXG4gICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMS4wLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9wdWxsLzE3Mzc4XG4gICAgXCJyaWdodC1ib3R0b21cIixcbiAgICBcImJvdHRvbS1sZWZ0XCIsXG4gICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMS4wLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9wdWxsLzE3Mzc4XG4gICAgXCJsZWZ0LWJvdHRvbVwiXG4gIF0sIHNjYWxlUG9zaXRpb25XaXRoQXJiaXRyYXJ5ID0gKCkgPT4gWy4uLnNjYWxlUG9zaXRpb24oKSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0sIHNjYWxlT3ZlcmZsb3cgPSAoKSA9PiBbXCJhdXRvXCIsIFwiaGlkZGVuXCIsIFwiY2xpcFwiLCBcInZpc2libGVcIiwgXCJzY3JvbGxcIl0sIHNjYWxlT3ZlcnNjcm9sbCA9ICgpID0+IFtcImF1dG9cIiwgXCJjb250YWluXCIsIFwibm9uZVwiXSwgc2NhbGVVbmFtYmlndW91c1NwYWNpbmcgPSAoKSA9PiBbaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZSwgdGhlbWVTcGFjaW5nXSwgc2NhbGVJbnNldCA9ICgpID0+IFtpc0ZyYWN0aW9uLCBcImZ1bGxcIiwgXCJhdXRvXCIsIC4uLnNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKCldLCBzY2FsZUdyaWRUZW1wbGF0ZUNvbHNSb3dzID0gKCkgPT4gW2lzSW50ZWdlciwgXCJub25lXCIsIFwic3ViZ3JpZFwiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSwgc2NhbGVHcmlkQ29sUm93U3RhcnRBbmRFbmQgPSAoKSA9PiBbXCJhdXRvXCIsIHtcbiAgICBzcGFuOiBbXCJmdWxsXCIsIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgfSwgaXNJbnRlZ2VyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSwgc2NhbGVHcmlkQ29sUm93U3RhcnRPckVuZCA9ICgpID0+IFtpc0ludGVnZXIsIFwiYXV0b1wiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSwgc2NhbGVHcmlkQXV0b0NvbHNSb3dzID0gKCkgPT4gW1wiYXV0b1wiLCBcIm1pblwiLCBcIm1heFwiLCBcImZyXCIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdLCBzY2FsZUFsaWduUHJpbWFyeUF4aXMgPSAoKSA9PiBbXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcImJldHdlZW5cIiwgXCJhcm91bmRcIiwgXCJldmVubHlcIiwgXCJzdHJldGNoXCIsIFwiYmFzZWxpbmVcIiwgXCJjZW50ZXItc2FmZVwiLCBcImVuZC1zYWZlXCJdLCBzY2FsZUFsaWduU2Vjb25kYXJ5QXhpcyA9ICgpID0+IFtcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2VudGVyXCIsIFwic3RyZXRjaFwiLCBcImNlbnRlci1zYWZlXCIsIFwiZW5kLXNhZmVcIl0sIHNjYWxlTWFyZ2luID0gKCkgPT4gW1wiYXV0b1wiLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXSwgc2NhbGVTaXppbmcgPSAoKSA9PiBbaXNGcmFjdGlvbiwgXCJhdXRvXCIsIFwiZnVsbFwiLCBcImR2d1wiLCBcImR2aFwiLCBcImx2d1wiLCBcImx2aFwiLCBcInN2d1wiLCBcInN2aFwiLCBcIm1pblwiLCBcIm1heFwiLCBcImZpdFwiLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXSwgc2NhbGVDb2xvciA9ICgpID0+IFt0aGVtZUNvbG9yLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXSwgc2NhbGVCZ1Bvc2l0aW9uID0gKCkgPT4gWy4uLnNjYWxlUG9zaXRpb24oKSwgaXNBcmJpdHJhcnlWYXJpYWJsZVBvc2l0aW9uLCBpc0FyYml0cmFyeVBvc2l0aW9uLCB7XG4gICAgcG9zaXRpb246IFtpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICB9XSwgc2NhbGVCZ1JlcGVhdCA9ICgpID0+IFtcIm5vLXJlcGVhdFwiLCB7XG4gICAgcmVwZWF0OiBbXCJcIiwgXCJ4XCIsIFwieVwiLCBcInNwYWNlXCIsIFwicm91bmRcIl1cbiAgfV0sIHNjYWxlQmdTaXplID0gKCkgPT4gW1wiYXV0b1wiLCBcImNvdmVyXCIsIFwiY29udGFpblwiLCBpc0FyYml0cmFyeVZhcmlhYmxlU2l6ZSwgaXNBcmJpdHJhcnlTaXplLCB7XG4gICAgc2l6ZTogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gIH1dLCBzY2FsZUdyYWRpZW50U3RvcFBvc2l0aW9uID0gKCkgPT4gW2lzUGVyY2VudCwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdLCBzY2FsZVJhZGl1cyA9ICgpID0+IFtcbiAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICBcIlwiLFxuICAgIFwibm9uZVwiLFxuICAgIFwiZnVsbFwiLFxuICAgIHRoZW1lUmFkaXVzLFxuICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgaXNBcmJpdHJhcnlWYWx1ZVxuICBdLCBzY2FsZUJvcmRlcldpZHRoID0gKCkgPT4gW1wiXCIsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF0sIHNjYWxlTGluZVN0eWxlID0gKCkgPT4gW1wic29saWRcIiwgXCJkYXNoZWRcIiwgXCJkb3R0ZWRcIiwgXCJkb3VibGVcIl0sIHNjYWxlQmxlbmRNb2RlID0gKCkgPT4gW1wibm9ybWFsXCIsIFwibXVsdGlwbHlcIiwgXCJzY3JlZW5cIiwgXCJvdmVybGF5XCIsIFwiZGFya2VuXCIsIFwibGlnaHRlblwiLCBcImNvbG9yLWRvZGdlXCIsIFwiY29sb3ItYnVyblwiLCBcImhhcmQtbGlnaHRcIiwgXCJzb2Z0LWxpZ2h0XCIsIFwiZGlmZmVyZW5jZVwiLCBcImV4Y2x1c2lvblwiLCBcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJjb2xvclwiLCBcImx1bWlub3NpdHlcIl0sIHNjYWxlTWFza0ltYWdlUG9zaXRpb24gPSAoKSA9PiBbaXNOdW1iZXIsIGlzUGVyY2VudCwgaXNBcmJpdHJhcnlWYXJpYWJsZVBvc2l0aW9uLCBpc0FyYml0cmFyeVBvc2l0aW9uXSwgc2NhbGVCbHVyID0gKCkgPT4gW1xuICAgIC8vIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAgIFwiXCIsXG4gICAgXCJub25lXCIsXG4gICAgdGhlbWVCbHVyLFxuICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgaXNBcmJpdHJhcnlWYWx1ZVxuICBdLCBzY2FsZVJvdGF0ZSA9ICgpID0+IFtcIm5vbmVcIiwgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdLCBzY2FsZVNjYWxlID0gKCkgPT4gW1wibm9uZVwiLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0sIHNjYWxlU2tldyA9ICgpID0+IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0sIHNjYWxlVHJhbnNsYXRlID0gKCkgPT4gW2lzRnJhY3Rpb24sIFwiZnVsbFwiLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXTtcbiAgcmV0dXJuIHtcbiAgICBjYWNoZVNpemU6IDUwMCxcbiAgICB0aGVtZToge1xuICAgICAgYW5pbWF0ZTogW1wic3BpblwiLCBcInBpbmdcIiwgXCJwdWxzZVwiLCBcImJvdW5jZVwiXSxcbiAgICAgIGFzcGVjdDogW1widmlkZW9cIl0sXG4gICAgICBibHVyOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgIGJyZWFrcG9pbnQ6IFtpc1RzaGlydFNpemVdLFxuICAgICAgY29sb3I6IFtpc0FueV0sXG4gICAgICBjb250YWluZXI6IFtpc1RzaGlydFNpemVdLFxuICAgICAgXCJkcm9wLXNoYWRvd1wiOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgIGVhc2U6IFtcImluXCIsIFwib3V0XCIsIFwiaW4tb3V0XCJdLFxuICAgICAgZm9udDogW2lzQW55Tm9uQXJiaXRyYXJ5XSxcbiAgICAgIFwiZm9udC13ZWlnaHRcIjogW1widGhpblwiLCBcImV4dHJhbGlnaHRcIiwgXCJsaWdodFwiLCBcIm5vcm1hbFwiLCBcIm1lZGl1bVwiLCBcInNlbWlib2xkXCIsIFwiYm9sZFwiLCBcImV4dHJhYm9sZFwiLCBcImJsYWNrXCJdLFxuICAgICAgXCJpbnNldC1zaGFkb3dcIjogW2lzVHNoaXJ0U2l6ZV0sXG4gICAgICBsZWFkaW5nOiBbXCJub25lXCIsIFwidGlnaHRcIiwgXCJzbnVnXCIsIFwibm9ybWFsXCIsIFwicmVsYXhlZFwiLCBcImxvb3NlXCJdLFxuICAgICAgcGVyc3BlY3RpdmU6IFtcImRyYW1hdGljXCIsIFwibmVhclwiLCBcIm5vcm1hbFwiLCBcIm1pZHJhbmdlXCIsIFwiZGlzdGFudFwiLCBcIm5vbmVcIl0sXG4gICAgICByYWRpdXM6IFtpc1RzaGlydFNpemVdLFxuICAgICAgc2hhZG93OiBbaXNUc2hpcnRTaXplXSxcbiAgICAgIHNwYWNpbmc6IFtcInB4XCIsIGlzTnVtYmVyXSxcbiAgICAgIHRleHQ6IFtpc1RzaGlydFNpemVdLFxuICAgICAgXCJ0ZXh0LXNoYWRvd1wiOiBbaXNUc2hpcnRTaXplXSxcbiAgICAgIHRyYWNraW5nOiBbXCJ0aWdodGVyXCIsIFwidGlnaHRcIiwgXCJub3JtYWxcIiwgXCJ3aWRlXCIsIFwid2lkZXJcIiwgXCJ3aWRlc3RcIl1cbiAgICB9LFxuICAgIGNsYXNzR3JvdXBzOiB7XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIExheW91dCAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgICAvKipcbiAgICAgICAqIEFzcGVjdCBSYXRpb1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FzcGVjdC1yYXRpb1xuICAgICAgICovXG4gICAgICBhc3BlY3Q6IFt7XG4gICAgICAgIGFzcGVjdDogW1wiYXV0b1wiLCBcInNxdWFyZVwiLCBpc0ZyYWN0aW9uLCBpc0FyYml0cmFyeVZhbHVlLCBpc0FyYml0cmFyeVZhcmlhYmxlLCB0aGVtZUFzcGVjdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250YWluZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250YWluZXJcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBbXCJjb250YWluZXJcIl0sXG4gICAgICAvKipcbiAgICAgICAqIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb2x1bW5zXG4gICAgICAgKi9cbiAgICAgIGNvbHVtbnM6IFt7XG4gICAgICAgIGNvbHVtbnM6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYWx1ZSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgdGhlbWVDb250YWluZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgQWZ0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1hZnRlclxuICAgICAgICovXG4gICAgICBcImJyZWFrLWFmdGVyXCI6IFt7XG4gICAgICAgIFwiYnJlYWstYWZ0ZXJcIjogc2NhbGVCcmVhaygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgQmVmb3JlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstYmVmb3JlXG4gICAgICAgKi9cbiAgICAgIFwiYnJlYWstYmVmb3JlXCI6IFt7XG4gICAgICAgIFwiYnJlYWstYmVmb3JlXCI6IHNjYWxlQnJlYWsoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEluc2lkZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWluc2lkZVxuICAgICAgICovXG4gICAgICBcImJyZWFrLWluc2lkZVwiOiBbe1xuICAgICAgICBcImJyZWFrLWluc2lkZVwiOiBbXCJhdXRvXCIsIFwiYXZvaWRcIiwgXCJhdm9pZC1wYWdlXCIsIFwiYXZvaWQtY29sdW1uXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm94IERlY29yYXRpb24gQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtZGVjb3JhdGlvbi1icmVha1xuICAgICAgICovXG4gICAgICBcImJveC1kZWNvcmF0aW9uXCI6IFt7XG4gICAgICAgIFwiYm94LWRlY29yYXRpb25cIjogW1wic2xpY2VcIiwgXCJjbG9uZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaXppbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2l6aW5nXG4gICAgICAgKi9cbiAgICAgIGJveDogW3tcbiAgICAgICAgYm94OiBbXCJib3JkZXJcIiwgXCJjb250ZW50XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGlzcGxheVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Rpc3BsYXlcbiAgICAgICAqL1xuICAgICAgZGlzcGxheTogW1wiYmxvY2tcIiwgXCJpbmxpbmUtYmxvY2tcIiwgXCJpbmxpbmVcIiwgXCJmbGV4XCIsIFwiaW5saW5lLWZsZXhcIiwgXCJ0YWJsZVwiLCBcImlubGluZS10YWJsZVwiLCBcInRhYmxlLWNhcHRpb25cIiwgXCJ0YWJsZS1jZWxsXCIsIFwidGFibGUtY29sdW1uXCIsIFwidGFibGUtY29sdW1uLWdyb3VwXCIsIFwidGFibGUtZm9vdGVyLWdyb3VwXCIsIFwidGFibGUtaGVhZGVyLWdyb3VwXCIsIFwidGFibGUtcm93LWdyb3VwXCIsIFwidGFibGUtcm93XCIsIFwiZmxvdy1yb290XCIsIFwiZ3JpZFwiLCBcImlubGluZS1ncmlkXCIsIFwiY29udGVudHNcIiwgXCJsaXN0LWl0ZW1cIiwgXCJoaWRkZW5cIl0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcmVlbiBSZWFkZXIgT25seVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Rpc3BsYXkjc2NyZWVuLXJlYWRlci1vbmx5XG4gICAgICAgKi9cbiAgICAgIHNyOiBbXCJzci1vbmx5XCIsIFwibm90LXNyLW9ubHlcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZsb2F0c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Zsb2F0XG4gICAgICAgKi9cbiAgICAgIGZsb2F0OiBbe1xuICAgICAgICBmbG9hdDogW1wicmlnaHRcIiwgXCJsZWZ0XCIsIFwibm9uZVwiLCBcInN0YXJ0XCIsIFwiZW5kXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2xlYXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jbGVhclxuICAgICAgICovXG4gICAgICBjbGVhcjogW3tcbiAgICAgICAgY2xlYXI6IFtcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdGhcIiwgXCJub25lXCIsIFwic3RhcnRcIiwgXCJlbmRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJc29sYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9pc29sYXRpb25cbiAgICAgICAqL1xuICAgICAgaXNvbGF0aW9uOiBbXCJpc29sYXRlXCIsIFwiaXNvbGF0aW9uLWF1dG9cIl0sXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCBGaXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vYmplY3QtZml0XG4gICAgICAgKi9cbiAgICAgIFwib2JqZWN0LWZpdFwiOiBbe1xuICAgICAgICBvYmplY3Q6IFtcImNvbnRhaW5cIiwgXCJjb3ZlclwiLCBcImZpbGxcIiwgXCJub25lXCIsIFwic2NhbGUtZG93blwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9iamVjdCBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29iamVjdC1wb3NpdGlvblxuICAgICAgICovXG4gICAgICBcIm9iamVjdC1wb3NpdGlvblwiOiBbe1xuICAgICAgICBvYmplY3Q6IHNjYWxlUG9zaXRpb25XaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIG92ZXJmbG93OiBbe1xuICAgICAgICBvdmVyZmxvdzogc2NhbGVPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIFwib3ZlcmZsb3cteFwiOiBbe1xuICAgICAgICBcIm92ZXJmbG93LXhcIjogc2NhbGVPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcmZsb3cgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIFwib3ZlcmZsb3cteVwiOiBbe1xuICAgICAgICBcIm92ZXJmbG93LXlcIjogc2NhbGVPdmVyZmxvdygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgb3ZlcnNjcm9sbDogW3tcbiAgICAgICAgb3ZlcnNjcm9sbDogc2NhbGVPdmVyc2Nyb2xsKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIFwib3ZlcnNjcm9sbC14XCI6IFt7XG4gICAgICAgIFwib3ZlcnNjcm9sbC14XCI6IHNjYWxlT3ZlcnNjcm9sbCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3ZlcnNjcm9sbCBCZWhhdmlvciBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICBcIm92ZXJzY3JvbGwteVwiOiBbe1xuICAgICAgICBcIm92ZXJzY3JvbGwteVwiOiBzY2FsZU92ZXJzY3JvbGwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IFtcInN0YXRpY1wiLCBcImZpeGVkXCIsIFwiYWJzb2x1dGVcIiwgXCJyZWxhdGl2ZVwiLCBcInN0aWNreVwiXSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gUmlnaHQgLyBCb3R0b20gLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIGluc2V0OiBbe1xuICAgICAgICBpbnNldDogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHQgLyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIFwiaW5zZXQteFwiOiBbe1xuICAgICAgICBcImluc2V0LXhcIjogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wIC8gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIFwiaW5zZXQteVwiOiBbe1xuICAgICAgICBcImluc2V0LXlcIjogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgc3RhcnQ6IFt7XG4gICAgICAgIHN0YXJ0OiBzY2FsZUluc2V0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgZW5kOiBbe1xuICAgICAgICBlbmQ6IHNjYWxlSW5zZXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICB0b3A6IFt7XG4gICAgICAgIHRvcDogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgcmlnaHQ6IFt7XG4gICAgICAgIHJpZ2h0OiBzY2FsZUluc2V0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgYm90dG9tOiBbe1xuICAgICAgICBib3R0b206IHNjYWxlSW5zZXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgbGVmdDogW3tcbiAgICAgICAgbGVmdDogc2NhbGVJbnNldCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVmlzaWJpbGl0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Zpc2liaWxpdHlcbiAgICAgICAqL1xuICAgICAgdmlzaWJpbGl0eTogW1widmlzaWJsZVwiLCBcImludmlzaWJsZVwiLCBcImNvbGxhcHNlXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBaLUluZGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvei1pbmRleFxuICAgICAgICovXG4gICAgICB6OiBbe1xuICAgICAgICB6OiBbaXNJbnRlZ2VyLCBcImF1dG9cIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gRmxleGJveCBhbmQgR3JpZCAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IEJhc2lzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1iYXNpc1xuICAgICAgICovXG4gICAgICBiYXNpczogW3tcbiAgICAgICAgYmFzaXM6IFtpc0ZyYWN0aW9uLCBcImZ1bGxcIiwgXCJhdXRvXCIsIHRoZW1lQ29udGFpbmVyLCAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggRGlyZWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1kaXJlY3Rpb25cbiAgICAgICAqL1xuICAgICAgXCJmbGV4LWRpcmVjdGlvblwiOiBbe1xuICAgICAgICBmbGV4OiBbXCJyb3dcIiwgXCJyb3ctcmV2ZXJzZVwiLCBcImNvbFwiLCBcImNvbC1yZXZlcnNlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBXcmFwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC13cmFwXG4gICAgICAgKi9cbiAgICAgIFwiZmxleC13cmFwXCI6IFt7XG4gICAgICAgIGZsZXg6IFtcIm5vd3JhcFwiLCBcIndyYXBcIiwgXCJ3cmFwLXJldmVyc2VcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleFxuICAgICAgICovXG4gICAgICBmbGV4OiBbe1xuICAgICAgICBmbGV4OiBbaXNOdW1iZXIsIGlzRnJhY3Rpb24sIFwiYXV0b1wiLCBcImluaXRpYWxcIiwgXCJub25lXCIsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBHcm93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1ncm93XG4gICAgICAgKi9cbiAgICAgIGdyb3c6IFt7XG4gICAgICAgIGdyb3c6IFtcIlwiLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFNocmlua1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtc2hyaW5rXG4gICAgICAgKi9cbiAgICAgIHNocmluazogW3tcbiAgICAgICAgc2hyaW5rOiBbXCJcIiwgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3JkZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vcmRlclxuICAgICAgICovXG4gICAgICBvcmRlcjogW3tcbiAgICAgICAgb3JkZXI6IFtpc0ludGVnZXIsIFwiZmlyc3RcIiwgXCJsYXN0XCIsIFwibm9uZVwiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgVGVtcGxhdGUgQ29sdW1uc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtdGVtcGxhdGUtY29sdW1uc1xuICAgICAgICovXG4gICAgICBcImdyaWQtY29sc1wiOiBbe1xuICAgICAgICBcImdyaWQtY29sc1wiOiBzY2FsZUdyaWRUZW1wbGF0ZUNvbHNSb3dzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydCAvIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgIFwiY29sLXN0YXJ0LWVuZFwiOiBbe1xuICAgICAgICBjb2w6IHNjYWxlR3JpZENvbFJvd1N0YXJ0QW5kRW5kKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgIFwiY29sLXN0YXJ0XCI6IFt7XG4gICAgICAgIFwiY29sLXN0YXJ0XCI6IHNjYWxlR3JpZENvbFJvd1N0YXJ0T3JFbmQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQ29sdW1uIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtY29sdW1uXG4gICAgICAgKi9cbiAgICAgIFwiY29sLWVuZFwiOiBbe1xuICAgICAgICBcImNvbC1lbmRcIjogc2NhbGVHcmlkQ29sUm93U3RhcnRPckVuZCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBUZW1wbGF0ZSBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC10ZW1wbGF0ZS1yb3dzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JpZC1yb3dzXCI6IFt7XG4gICAgICAgIFwiZ3JpZC1yb3dzXCI6IHNjYWxlR3JpZFRlbXBsYXRlQ29sc1Jvd3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0IC8gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgXCJyb3ctc3RhcnQtZW5kXCI6IFt7XG4gICAgICAgIHJvdzogc2NhbGVHcmlkQ29sUm93U3RhcnRBbmRFbmQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgXCJyb3ctc3RhcnRcIjogW3tcbiAgICAgICAgXCJyb3ctc3RhcnRcIjogc2NhbGVHcmlkQ29sUm93U3RhcnRPckVuZCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1yb3dcbiAgICAgICAqL1xuICAgICAgXCJyb3ctZW5kXCI6IFt7XG4gICAgICAgIFwicm93LWVuZFwiOiBzY2FsZUdyaWRDb2xSb3dTdGFydE9yRW5kKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIEF1dG8gRmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtYXV0by1mbG93XG4gICAgICAgKi9cbiAgICAgIFwiZ3JpZC1mbG93XCI6IFt7XG4gICAgICAgIFwiZ3JpZC1mbG93XCI6IFtcInJvd1wiLCBcImNvbFwiLCBcImRlbnNlXCIsIFwicm93LWRlbnNlXCIsIFwiY29sLWRlbnNlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIENvbHVtbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tY29sdW1uc1xuICAgICAgICovXG4gICAgICBcImF1dG8tY29sc1wiOiBbe1xuICAgICAgICBcImF1dG8tY29sc1wiOiBzY2FsZUdyaWRBdXRvQ29sc1Jvd3MoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLXJvd3NcbiAgICAgICAqL1xuICAgICAgXCJhdXRvLXJvd3NcIjogW3tcbiAgICAgICAgXCJhdXRvLXJvd3NcIjogc2NhbGVHcmlkQXV0b0NvbHNSb3dzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgZ2FwOiBbe1xuICAgICAgICBnYXA6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHYXAgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICBcImdhcC14XCI6IFt7XG4gICAgICAgIFwiZ2FwLXhcIjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ2FwXG4gICAgICAgKi9cbiAgICAgIFwiZ2FwLXlcIjogW3tcbiAgICAgICAgXCJnYXAteVwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSnVzdGlmeSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1jb250ZW50XG4gICAgICAgKi9cbiAgICAgIFwianVzdGlmeS1jb250ZW50XCI6IFt7XG4gICAgICAgIGp1c3RpZnk6IFsuLi5zY2FsZUFsaWduUHJpbWFyeUF4aXMoKSwgXCJub3JtYWxcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBKdXN0aWZ5IEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1pdGVtc1xuICAgICAgICovXG4gICAgICBcImp1c3RpZnktaXRlbXNcIjogW3tcbiAgICAgICAgXCJqdXN0aWZ5LWl0ZW1zXCI6IFsuLi5zY2FsZUFsaWduU2Vjb25kYXJ5QXhpcygpLCBcIm5vcm1hbFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktc2VsZlxuICAgICAgICovXG4gICAgICBcImp1c3RpZnktc2VsZlwiOiBbe1xuICAgICAgICBcImp1c3RpZnktc2VsZlwiOiBbXCJhdXRvXCIsIC4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgXCJhbGlnbi1jb250ZW50XCI6IFt7XG4gICAgICAgIGNvbnRlbnQ6IFtcIm5vcm1hbFwiLCAuLi5zY2FsZUFsaWduUHJpbWFyeUF4aXMoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBJdGVtc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWl0ZW1zXG4gICAgICAgKi9cbiAgICAgIFwiYWxpZ24taXRlbXNcIjogW3tcbiAgICAgICAgaXRlbXM6IFsuLi5zY2FsZUFsaWduU2Vjb25kYXJ5QXhpcygpLCB7XG4gICAgICAgICAgYmFzZWxpbmU6IFtcIlwiLCBcImxhc3RcIl1cbiAgICAgICAgfV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWxpZ24tc2VsZlxuICAgICAgICovXG4gICAgICBcImFsaWduLXNlbGZcIjogW3tcbiAgICAgICAgc2VsZjogW1wiYXV0b1wiLCAuLi5zY2FsZUFsaWduU2Vjb25kYXJ5QXhpcygpLCB7XG4gICAgICAgICAgYmFzZWxpbmU6IFtcIlwiLCBcImxhc3RcIl1cbiAgICAgICAgfV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZSBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtY29udGVudFxuICAgICAgICovXG4gICAgICBcInBsYWNlLWNvbnRlbnRcIjogW3tcbiAgICAgICAgXCJwbGFjZS1jb250ZW50XCI6IHNjYWxlQWxpZ25QcmltYXJ5QXhpcygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgSXRlbXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1pdGVtc1xuICAgICAgICovXG4gICAgICBcInBsYWNlLWl0ZW1zXCI6IFt7XG4gICAgICAgIFwicGxhY2UtaXRlbXNcIjogWy4uLnNjYWxlQWxpZ25TZWNvbmRhcnlBeGlzKCksIFwiYmFzZWxpbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZSBTZWxmXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Utc2VsZlxuICAgICAgICovXG4gICAgICBcInBsYWNlLXNlbGZcIjogW3tcbiAgICAgICAgXCJwbGFjZS1zZWxmXCI6IFtcImF1dG9cIiwgLi4uc2NhbGVBbGlnblNlY29uZGFyeUF4aXMoKV1cbiAgICAgIH1dLFxuICAgICAgLy8gU3BhY2luZ1xuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwOiBbe1xuICAgICAgICBwOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBweDogW3tcbiAgICAgICAgcHg6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHB5OiBbe1xuICAgICAgICBweTogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBzOiBbe1xuICAgICAgICBwczogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwZTogW3tcbiAgICAgICAgcGU6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHQ6IFt7XG4gICAgICAgIHB0OiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHI6IFt7XG4gICAgICAgIHByOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBiOiBbe1xuICAgICAgICBwYjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcGw6IFt7XG4gICAgICAgIHBsOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG06IFt7XG4gICAgICAgIG06IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBteDogW3tcbiAgICAgICAgbXg6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBteTogW3tcbiAgICAgICAgbXk6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXM6IFt7XG4gICAgICAgIG1zOiBzY2FsZU1hcmdpbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtZTogW3tcbiAgICAgICAgbWU6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG10OiBbe1xuICAgICAgICBtdDogc2NhbGVNYXJnaW4oKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtcjogW3tcbiAgICAgICAgbXI6IHNjYWxlTWFyZ2luKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1iOiBbe1xuICAgICAgICBtYjogc2NhbGVNYXJnaW4oKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1sOiBbe1xuICAgICAgICBtbDogc2NhbGVNYXJnaW4oKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICovXG4gICAgICBcInNwYWNlLXhcIjogW3tcbiAgICAgICAgXCJzcGFjZS14XCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICovXG4gICAgICBcInNwYWNlLXgtcmV2ZXJzZVwiOiBbXCJzcGFjZS14LXJldmVyc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICovXG4gICAgICBcInNwYWNlLXlcIjogW3tcbiAgICAgICAgXCJzcGFjZS15XCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFkgUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpbiNhZGRpbmctc3BhY2UtYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICovXG4gICAgICBcInNwYWNlLXktcmV2ZXJzZVwiOiBbXCJzcGFjZS15LXJldmVyc2VcIl0sXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIFNpemluZyAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tXG4gICAgICAvKipcbiAgICAgICAqIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aCNzZXR0aW5nLWJvdGgtd2lkdGgtYW5kLWhlaWdodFxuICAgICAgICovXG4gICAgICBzaXplOiBbe1xuICAgICAgICBzaXplOiBzY2FsZVNpemluZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aWR0aFxuICAgICAgICovXG4gICAgICB3OiBbe1xuICAgICAgICB3OiBbdGhlbWVDb250YWluZXIsIFwic2NyZWVuXCIsIC4uLnNjYWxlU2l6aW5nKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWluLVdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWluLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwibWluLXdcIjogW3tcbiAgICAgICAgXCJtaW4td1wiOiBbXG4gICAgICAgICAgdGhlbWVDb250YWluZXIsXG4gICAgICAgICAgXCJzY3JlZW5cIixcbiAgICAgICAgICAvKiogRGVwcmVjYXRlZC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgIC4uLnNjYWxlU2l6aW5nKClcbiAgICAgICAgXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1heC1XaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21heC13aWR0aFxuICAgICAgICovXG4gICAgICBcIm1heC13XCI6IFt7XG4gICAgICAgIFwibWF4LXdcIjogW1xuICAgICAgICAgIHRoZW1lQ29udGFpbmVyLFxuICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgXCJub25lXCIsXG4gICAgICAgICAgLyoqIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAgIFwicHJvc2VcIixcbiAgICAgICAgICAvKiogRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wLiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MuY29tL2lzc3Vlcy8yMDI3I2lzc3VlY29tbWVudC0yNjIwMTUyNzU3ICovXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2NyZWVuOiBbdGhlbWVCcmVha3BvaW50XVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4uc2NhbGVTaXppbmcoKVxuICAgICAgICBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGg6IFt7XG4gICAgICAgIGg6IFtcInNjcmVlblwiLCBcImxoXCIsIC4uLnNjYWxlU2l6aW5nKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWluLUhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgXCJtaW4taFwiOiBbe1xuICAgICAgICBcIm1pbi1oXCI6IFtcInNjcmVlblwiLCBcImxoXCIsIFwibm9uZVwiLCAuLi5zY2FsZVNpemluZygpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1heC1IZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIFwibWF4LWhcIjogW3tcbiAgICAgICAgXCJtYXgtaFwiOiBbXCJzY3JlZW5cIiwgXCJsaFwiLCAuLi5zY2FsZVNpemluZygpXVxuICAgICAgfV0sXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIC0tLSBUeXBvZ3JhcGh5IC0tLVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtc2l6ZVxuICAgICAgICovXG4gICAgICBcImZvbnQtc2l6ZVwiOiBbe1xuICAgICAgICB0ZXh0OiBbXCJiYXNlXCIsIHRoZW1lVGV4dCwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGhdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTbW9vdGhpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXNtb290aGluZ1xuICAgICAgICovXG4gICAgICBcImZvbnQtc21vb3RoaW5nXCI6IFtcImFudGlhbGlhc2VkXCIsIFwic3VicGl4ZWwtYW50aWFsaWFzZWRcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXN0eWxlXG4gICAgICAgKi9cbiAgICAgIFwiZm9udC1zdHlsZVwiOiBbXCJpdGFsaWNcIiwgXCJub3QtaXRhbGljXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFdlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtd2VpZ2h0XG4gICAgICAgKi9cbiAgICAgIFwiZm9udC13ZWlnaHRcIjogW3tcbiAgICAgICAgZm9udDogW3RoZW1lRm9udFdlaWdodCwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTdHJldGNoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zdHJldGNoXG4gICAgICAgKi9cbiAgICAgIFwiZm9udC1zdHJldGNoXCI6IFt7XG4gICAgICAgIFwiZm9udC1zdHJldGNoXCI6IFtcInVsdHJhLWNvbmRlbnNlZFwiLCBcImV4dHJhLWNvbmRlbnNlZFwiLCBcImNvbmRlbnNlZFwiLCBcInNlbWktY29uZGVuc2VkXCIsIFwibm9ybWFsXCIsIFwic2VtaS1leHBhbmRlZFwiLCBcImV4cGFuZGVkXCIsIFwiZXh0cmEtZXhwYW5kZWRcIiwgXCJ1bHRyYS1leHBhbmRlZFwiLCBpc1BlcmNlbnQsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBGYW1pbHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LWZhbWlseVxuICAgICAgICovXG4gICAgICBcImZvbnQtZmFtaWx5XCI6IFt7XG4gICAgICAgIGZvbnQ6IFtpc0FyYml0cmFyeVZhcmlhYmxlRmFtaWx5TmFtZSwgaXNBcmJpdHJhcnlWYWx1ZSwgdGhlbWVGb250XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgXCJmdm4tbm9ybWFsXCI6IFtcIm5vcm1hbC1udW1zXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgIFwiZnZuLW9yZGluYWxcIjogW1wib3JkaW5hbFwiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICBcImZ2bi1zbGFzaGVkLXplcm9cIjogW1wic2xhc2hlZC16ZXJvXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgIFwiZnZuLWZpZ3VyZVwiOiBbXCJsaW5pbmctbnVtc1wiLCBcIm9sZHN0eWxlLW51bXNcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgXCJmdm4tc3BhY2luZ1wiOiBbXCJwcm9wb3J0aW9uYWwtbnVtc1wiLCBcInRhYnVsYXItbnVtc1wiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICBcImZ2bi1mcmFjdGlvblwiOiBbXCJkaWFnb25hbC1mcmFjdGlvbnNcIiwgXCJzdGFja2VkLWZyYWN0aW9uc1wiXSxcbiAgICAgIC8qKlxuICAgICAgICogTGV0dGVyIFNwYWNpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9sZXR0ZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICB0cmFja2luZzogW3tcbiAgICAgICAgdHJhY2tpbmc6IFt0aGVtZVRyYWNraW5nLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpbmUgQ2xhbXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saW5lLWNsYW1wXG4gICAgICAgKi9cbiAgICAgIFwibGluZS1jbGFtcFwiOiBbe1xuICAgICAgICBcImxpbmUtY2xhbXBcIjogW2lzTnVtYmVyLCBcIm5vbmVcIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGluZSBIZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saW5lLWhlaWdodFxuICAgICAgICovXG4gICAgICBsZWFkaW5nOiBbe1xuICAgICAgICBsZWFkaW5nOiBbXG4gICAgICAgICAgLyoqIERlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMC4gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzLmNvbS9pc3N1ZXMvMjAyNyNpc3N1ZWNvbW1lbnQtMjYyMDE1Mjc1NyAqL1xuICAgICAgICAgIHRoZW1lTGVhZGluZyxcbiAgICAgICAgICAuLi5zY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICAgIF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1pbWFnZVxuICAgICAgICovXG4gICAgICBcImxpc3QtaW1hZ2VcIjogW3tcbiAgICAgICAgXCJsaXN0LWltYWdlXCI6IFtcIm5vbmVcIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1wb3NpdGlvblxuICAgICAgICovXG4gICAgICBcImxpc3Qtc3R5bGUtcG9zaXRpb25cIjogW3tcbiAgICAgICAgbGlzdDogW1wiaW5zaWRlXCIsIFwib3V0c2lkZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpc3QgU3R5bGUgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xpc3Qtc3R5bGUtdHlwZVxuICAgICAgICovXG4gICAgICBcImxpc3Qtc3R5bGUtdHlwZVwiOiBbe1xuICAgICAgICBsaXN0OiBbXCJkaXNjXCIsIFwiZGVjaW1hbFwiLCBcIm5vbmVcIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtYWxpZ25cbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWFsaWdubWVudFwiOiBbe1xuICAgICAgICB0ZXh0OiBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiwgXCJqdXN0aWZ5XCIsIFwic3RhcnRcIiwgXCJlbmRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQbGFjZWhvbGRlciBDb2xvclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3YzLnRhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlaG9sZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwicGxhY2Vob2xkZXItY29sb3JcIjogW3tcbiAgICAgICAgcGxhY2Vob2xkZXI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1jb2xvclwiOiBbe1xuICAgICAgICB0ZXh0OiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb25cbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWRlY29yYXRpb25cIjogW1widW5kZXJsaW5lXCIsIFwib3ZlcmxpbmVcIiwgXCJsaW5lLXRocm91Z2hcIiwgXCJuby11bmRlcmxpbmVcIl0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvbiBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi1zdHlsZVxuICAgICAgICovXG4gICAgICBcInRleHQtZGVjb3JhdGlvbi1zdHlsZVwiOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbLi4uc2NhbGVMaW5lU3R5bGUoKSwgXCJ3YXZ5XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFRoaWNrbmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi10aGlja25lc3NcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzXCI6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFtpc051bWJlciwgXCJmcm9tLWZvbnRcIiwgXCJhdXRvXCIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5TGVuZ3RoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvbiBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvbi1jb2xvclxuICAgICAgICovXG4gICAgICBcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFVuZGVybGluZSBPZmZzZXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXVuZGVybGluZS1vZmZzZXRcbiAgICAgICAqL1xuICAgICAgXCJ1bmRlcmxpbmUtb2Zmc2V0XCI6IFt7XG4gICAgICAgIFwidW5kZXJsaW5lLW9mZnNldFwiOiBbaXNOdW1iZXIsIFwiYXV0b1wiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgVHJhbnNmb3JtXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC10cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LXRyYW5zZm9ybVwiOiBbXCJ1cHBlcmNhc2VcIiwgXCJsb3dlcmNhc2VcIiwgXCJjYXBpdGFsaXplXCIsIFwibm9ybWFsLWNhc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgT3ZlcmZsb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LW92ZXJmbG93XG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1vdmVyZmxvd1wiOiBbXCJ0cnVuY2F0ZVwiLCBcInRleHQtZWxsaXBzaXNcIiwgXCJ0ZXh0LWNsaXBcIl0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgV3JhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtd3JhcFxuICAgICAgICovXG4gICAgICBcInRleHQtd3JhcFwiOiBbe1xuICAgICAgICB0ZXh0OiBbXCJ3cmFwXCIsIFwibm93cmFwXCIsIFwiYmFsYW5jZVwiLCBcInByZXR0eVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgSW5kZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1pbmRlbnRcbiAgICAgICAqL1xuICAgICAgaW5kZW50OiBbe1xuICAgICAgICBpbmRlbnQ6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBWZXJ0aWNhbCBBbGlnbm1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy92ZXJ0aWNhbC1hbGlnblxuICAgICAgICovXG4gICAgICBcInZlcnRpY2FsLWFsaWduXCI6IFt7XG4gICAgICAgIGFsaWduOiBbXCJiYXNlbGluZVwiLCBcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiLCBcInRleHQtdG9wXCIsIFwidGV4dC1ib3R0b21cIiwgXCJzdWJcIiwgXCJzdXBlclwiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdoaXRlc3BhY2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93aGl0ZXNwYWNlXG4gICAgICAgKi9cbiAgICAgIHdoaXRlc3BhY2U6IFt7XG4gICAgICAgIHdoaXRlc3BhY2U6IFtcIm5vcm1hbFwiLCBcIm5vd3JhcFwiLCBcInByZVwiLCBcInByZS1saW5lXCIsIFwicHJlLXdyYXBcIiwgXCJicmVhay1zcGFjZXNcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBXb3JkIEJyZWFrXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd29yZC1icmVha1xuICAgICAgICovXG4gICAgICBicmVhazogW3tcbiAgICAgICAgYnJlYWs6IFtcIm5vcm1hbFwiLCBcIndvcmRzXCIsIFwiYWxsXCIsIFwia2VlcFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJmbG93IFdyYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyZmxvdy13cmFwXG4gICAgICAgKi9cbiAgICAgIHdyYXA6IFt7XG4gICAgICAgIHdyYXA6IFtcImJyZWFrLXdvcmRcIiwgXCJhbnl3aGVyZVwiLCBcIm5vcm1hbFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh5cGhlbnNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9oeXBoZW5zXG4gICAgICAgKi9cbiAgICAgIGh5cGhlbnM6IFt7XG4gICAgICAgIGh5cGhlbnM6IFtcIm5vbmVcIiwgXCJtYW51YWxcIiwgXCJhdXRvXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NvbnRlbnRcbiAgICAgICAqL1xuICAgICAgY29udGVudDogW3tcbiAgICAgICAgY29udGVudDogW1wibm9uZVwiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gQmFja2dyb3VuZHMgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgQXR0YWNobWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtYXR0YWNobWVudFxuICAgICAgICovXG4gICAgICBcImJnLWF0dGFjaG1lbnRcIjogW3tcbiAgICAgICAgYmc6IFtcImZpeGVkXCIsIFwibG9jYWxcIiwgXCJzY3JvbGxcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENsaXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWNsaXBcbiAgICAgICAqL1xuICAgICAgXCJiZy1jbGlwXCI6IFt7XG4gICAgICAgIFwiYmctY2xpcFwiOiBbXCJib3JkZXJcIiwgXCJwYWRkaW5nXCIsIFwiY29udGVudFwiLCBcInRleHRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIE9yaWdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtb3JpZ2luXG4gICAgICAgKi9cbiAgICAgIFwiYmctb3JpZ2luXCI6IFt7XG4gICAgICAgIFwiYmctb3JpZ2luXCI6IFtcImJvcmRlclwiLCBcInBhZGRpbmdcIiwgXCJjb250ZW50XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgXCJiZy1wb3NpdGlvblwiOiBbe1xuICAgICAgICBiZzogc2NhbGVCZ1Bvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFJlcGVhdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcmVwZWF0XG4gICAgICAgKi9cbiAgICAgIFwiYmctcmVwZWF0XCI6IFt7XG4gICAgICAgIGJnOiBzY2FsZUJnUmVwZWF0KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXNpemVcbiAgICAgICAqL1xuICAgICAgXCJiZy1zaXplXCI6IFt7XG4gICAgICAgIGJnOiBzY2FsZUJnU2l6ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtaW1hZ2VcbiAgICAgICAqL1xuICAgICAgXCJiZy1pbWFnZVwiOiBbe1xuICAgICAgICBiZzogW1wibm9uZVwiLCB7XG4gICAgICAgICAgbGluZWFyOiBbe1xuICAgICAgICAgICAgdG86IFtcInRcIiwgXCJ0clwiLCBcInJcIiwgXCJiclwiLCBcImJcIiwgXCJibFwiLCBcImxcIiwgXCJ0bFwiXVxuICAgICAgICAgIH0sIGlzSW50ZWdlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0sXG4gICAgICAgICAgcmFkaWFsOiBbXCJcIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV0sXG4gICAgICAgICAgY29uaWM6IFtpc0ludGVnZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICAgIH0sIGlzQXJiaXRyYXJ5VmFyaWFibGVJbWFnZSwgaXNBcmJpdHJhcnlJbWFnZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1jb2xvclxuICAgICAgICovXG4gICAgICBcImJnLWNvbG9yXCI6IFt7XG4gICAgICAgIGJnOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBGcm9tIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgXCJncmFkaWVudC1mcm9tLXBvc1wiOiBbe1xuICAgICAgICBmcm9tOiBzY2FsZUdyYWRpZW50U3RvcFBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBWaWEgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICBcImdyYWRpZW50LXZpYS1wb3NcIjogW3tcbiAgICAgICAgdmlhOiBzY2FsZUdyYWRpZW50U3RvcFBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JhZGllbnQtdG8tcG9zXCI6IFt7XG4gICAgICAgIHRvOiBzY2FsZUdyYWRpZW50U3RvcFBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBGcm9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgXCJncmFkaWVudC1mcm9tXCI6IFt7XG4gICAgICAgIGZyb206IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFZpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JhZGllbnQtdmlhXCI6IFt7XG4gICAgICAgIHZpYTogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVG9cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICBcImdyYWRpZW50LXRvXCI6IFt7XG4gICAgICAgIHRvOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gQm9yZGVycyAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICByb3VuZGVkOiBbe1xuICAgICAgICByb3VuZGVkOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLXNcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXNcIjogc2NhbGVSYWRpdXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtZVwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtZVwiOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC10XCI6IFt7XG4gICAgICAgIFwicm91bmRlZC10XCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtclwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtclwiOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1iXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1iXCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1sXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1sXCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtc3NcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLXNzXCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLXNlXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1zZVwiOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtZWVcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWVlXCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLWVzXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1lc1wiOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLXRsXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC10bFwiOiBzY2FsZVJhZGl1cygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC10clwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtdHJcIjogc2NhbGVSYWRpdXMoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtYnJcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWJyXCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEJvdHRvbSBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtYmxcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWJsXCI6IHNjYWxlUmFkaXVzKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItd1wiOiBbe1xuICAgICAgICBib3JkZXI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXcteFwiOiBbe1xuICAgICAgICBcImJvcmRlci14XCI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXcteVwiOiBbe1xuICAgICAgICBcImJvcmRlci15XCI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICBcImJvcmRlci13LXNcIjogW3tcbiAgICAgICAgXCJib3JkZXItc1wiOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctZVwiOiBbe1xuICAgICAgICBcImJvcmRlci1lXCI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy10XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXRcIjogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctclwiOiBbe1xuICAgICAgICBcImJvcmRlci1yXCI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy1iXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWJcIjogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy1sXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWxcIjogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGgjYmV0d2Vlbi1jaGlsZHJlblxuICAgICAgICovXG4gICAgICBcImRpdmlkZS14XCI6IFt7XG4gICAgICAgIFwiZGl2aWRlLXhcIjogc2NhbGVCb3JkZXJXaWR0aCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aCNiZXR3ZWVuLWNoaWxkcmVuXG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLXgtcmV2ZXJzZVwiOiBbXCJkaXZpZGUteC1yZXZlcnNlXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aCNiZXR3ZWVuLWNoaWxkcmVuXG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLXlcIjogW3tcbiAgICAgICAgXCJkaXZpZGUteVwiOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWSBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoI2JldHdlZW4tY2hpbGRyZW5cbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUteS1yZXZlcnNlXCI6IFtcImRpdmlkZS15LXJldmVyc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1zdHlsZVxuICAgICAgICovXG4gICAgICBcImJvcmRlci1zdHlsZVwiOiBbe1xuICAgICAgICBib3JkZXI6IFsuLi5zY2FsZUxpbmVTdHlsZSgpLCBcImhpZGRlblwiLCBcIm5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3R5bGUjc2V0dGluZy10aGUtZGl2aWRlci1zdHlsZVxuICAgICAgICovXG4gICAgICBcImRpdmlkZS1zdHlsZVwiOiBbe1xuICAgICAgICBkaXZpZGU6IFsuLi5zY2FsZUxpbmVTdHlsZSgpLCBcImhpZGRlblwiLCBcIm5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sb3JcIjogW3tcbiAgICAgICAgYm9yZGVyOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci14XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXhcIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sb3IteVwiOiBbe1xuICAgICAgICBcImJvcmRlci15XCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBTXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbG9yLXNcIjogW3tcbiAgICAgICAgXCJib3JkZXItc1wiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgRVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci1lXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWVcIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci10XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXRcIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbG9yLXJcIjogW3tcbiAgICAgICAgXCJib3JkZXItclwiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbG9yLWJcIjogW3tcbiAgICAgICAgXCJib3JkZXItYlwiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci1sXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWxcIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLWNvbG9yXCI6IFt7XG4gICAgICAgIGRpdmlkZTogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtc3R5bGVcbiAgICAgICAqL1xuICAgICAgXCJvdXRsaW5lLXN0eWxlXCI6IFt7XG4gICAgICAgIG91dGxpbmU6IFsuLi5zY2FsZUxpbmVTdHlsZSgpLCBcIm5vbmVcIiwgXCJoaWRkZW5cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIE9mZnNldFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtb2Zmc2V0XG4gICAgICAgKi9cbiAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogW3tcbiAgICAgICAgXCJvdXRsaW5lLW9mZnNldFwiOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJvdXRsaW5lLXdcIjogW3tcbiAgICAgICAgb3V0bGluZTogW1wiXCIsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlTGVuZ3RoLCBpc0FyYml0cmFyeUxlbmd0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS1jb2xvclxuICAgICAgICovXG4gICAgICBcIm91dGxpbmUtY29sb3JcIjogW3tcbiAgICAgICAgb3V0bGluZTogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIEVmZmVjdHMgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogQm94IFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3dcbiAgICAgICAqL1xuICAgICAgc2hhZG93OiBbe1xuICAgICAgICBzaGFkb3c6IFtcbiAgICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2NC4wLjBcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgIHRoZW1lU2hhZG93LFxuICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGVTaGFkb3csXG4gICAgICAgICAgaXNBcmJpdHJhcnlTaGFkb3dcbiAgICAgICAgXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJveCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93I3NldHRpbmctdGhlLXNoYWRvdy1jb2xvclxuICAgICAgICovXG4gICAgICBcInNoYWRvdy1jb2xvclwiOiBbe1xuICAgICAgICBzaGFkb3c6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEluc2V0IEJveCBTaGFkb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93I2FkZGluZy1hbi1pbnNldC1zaGFkb3dcbiAgICAgICAqL1xuICAgICAgXCJpbnNldC1zaGFkb3dcIjogW3tcbiAgICAgICAgXCJpbnNldC1zaGFkb3dcIjogW1wibm9uZVwiLCB0aGVtZUluc2V0U2hhZG93LCBpc0FyYml0cmFyeVZhcmlhYmxlU2hhZG93LCBpc0FyYml0cmFyeVNoYWRvd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnNldCBCb3ggU2hhZG93IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdyNzZXR0aW5nLXRoZS1pbnNldC1zaGFkb3ctY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJpbnNldC1zaGFkb3ctY29sb3JcIjogW3tcbiAgICAgICAgXCJpbnNldC1zaGFkb3dcIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjYWRkaW5nLWEtcmluZ1xuICAgICAgICovXG4gICAgICBcInJpbmctd1wiOiBbe1xuICAgICAgICByaW5nOiBzY2FsZUJvcmRlcldpZHRoKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoIEluc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdjMudGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aCNpbnNldC1yaW5nc1xuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2Jsb2IvdjQuMC4wL3BhY2thZ2VzL3RhaWx3aW5kY3NzL3NyYy91dGlsaXRpZXMudHMjTDQxNThcbiAgICAgICAqL1xuICAgICAgXCJyaW5nLXctaW5zZXRcIjogW1wicmluZy1pbnNldFwiXSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjc2V0dGluZy10aGUtcmluZy1jb2xvclxuICAgICAgICovXG4gICAgICBcInJpbmctY29sb3JcIjogW3tcbiAgICAgICAgcmluZzogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBPZmZzZXQgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly92My50YWlsd2luZGNzcy5jb20vZG9jcy9yaW5nLW9mZnNldC13aWR0aFxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHY0LjAuMFxuICAgICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2Jsb2IvdjQuMC4wL3BhY2thZ2VzL3RhaWx3aW5kY3NzL3NyYy91dGlsaXRpZXMudHMjTDQxNThcbiAgICAgICAqL1xuICAgICAgXCJyaW5nLW9mZnNldC13XCI6IFt7XG4gICAgICAgIFwicmluZy1vZmZzZXRcIjogW2lzTnVtYmVyLCBpc0FyYml0cmFyeUxlbmd0aF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3YzLnRhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LWNvbG9yXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS90YWlsd2luZGxhYnMvdGFpbHdpbmRjc3MvYmxvYi92NC4wLjAvcGFja2FnZXMvdGFpbHdpbmRjc3Mvc3JjL3V0aWxpdGllcy50cyNMNDE1OFxuICAgICAgICovXG4gICAgICBcInJpbmctb2Zmc2V0LWNvbG9yXCI6IFt7XG4gICAgICAgIFwicmluZy1vZmZzZXRcIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSW5zZXQgUmluZyBXaWR0aFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaGFkb3cjYWRkaW5nLWFuLWluc2V0LXJpbmdcbiAgICAgICAqL1xuICAgICAgXCJpbnNldC1yaW5nLXdcIjogW3tcbiAgICAgICAgXCJpbnNldC1yaW5nXCI6IHNjYWxlQm9yZGVyV2lkdGgoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEluc2V0IFJpbmcgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3gtc2hhZG93I3NldHRpbmctdGhlLWluc2V0LXJpbmctY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJpbnNldC1yaW5nLWNvbG9yXCI6IFt7XG4gICAgICAgIFwiaW5zZXQtcmluZ1wiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtc2hhZG93XG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1zaGFkb3dcIjogW3tcbiAgICAgICAgXCJ0ZXh0LXNoYWRvd1wiOiBbXCJub25lXCIsIHRoZW1lVGV4dFNoYWRvdywgaXNBcmJpdHJhcnlWYXJpYWJsZVNoYWRvdywgaXNBcmJpdHJhcnlTaGFkb3ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXNoYWRvdyNzZXR0aW5nLXRoZS1zaGFkb3ctY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LXNoYWRvdy1jb2xvclwiOiBbe1xuICAgICAgICBcInRleHQtc2hhZG93XCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgIG9wYWNpdHk6IFt7XG4gICAgICAgIG9wYWNpdHk6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaXggQmxlbmQgTW9kZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21peC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgIFwibWl4LWJsZW5kXCI6IFt7XG4gICAgICAgIFwibWl4LWJsZW5kXCI6IFsuLi5zY2FsZUJsZW5kTW9kZSgpLCBcInBsdXMtZGFya2VyXCIsIFwicGx1cy1saWdodGVyXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBCbGVuZCBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgIFwiYmctYmxlbmRcIjogW3tcbiAgICAgICAgXCJiZy1ibGVuZFwiOiBzY2FsZUJsZW5kTW9kZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBDbGlwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1jbGlwXG4gICAgICAgKi9cbiAgICAgIFwibWFzay1jbGlwXCI6IFt7XG4gICAgICAgIFwibWFzay1jbGlwXCI6IFtcImJvcmRlclwiLCBcInBhZGRpbmdcIiwgXCJjb250ZW50XCIsIFwiZmlsbFwiLCBcInN0cm9rZVwiLCBcInZpZXdcIl1cbiAgICAgIH0sIFwibWFzay1uby1jbGlwXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXNrIENvbXBvc2l0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stY29tcG9zaXRlXG4gICAgICAgKi9cbiAgICAgIFwibWFzay1jb21wb3NpdGVcIjogW3tcbiAgICAgICAgbWFzazogW1wiYWRkXCIsIFwic3VidHJhY3RcIiwgXCJpbnRlcnNlY3RcIiwgXCJleGNsdWRlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2staW1hZ2VcbiAgICAgICAqL1xuICAgICAgXCJtYXNrLWltYWdlLWxpbmVhci1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLWxpbmVhclwiOiBbaXNOdW1iZXJdXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1saW5lYXItZnJvbS1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLWxpbmVhci1mcm9tXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtbGluZWFyLXRvLXBvc1wiOiBbe1xuICAgICAgICBcIm1hc2stbGluZWFyLXRvXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtbGluZWFyLWZyb20tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLWxpbmVhci1mcm9tXCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtbGluZWFyLXRvLWNvbG9yXCI6IFt7XG4gICAgICAgIFwibWFzay1saW5lYXItdG9cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS10LWZyb20tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay10LWZyb21cIjogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS10LXRvLXBvc1wiOiBbe1xuICAgICAgICBcIm1hc2stdC10b1wiOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXQtZnJvbS1jb2xvclwiOiBbe1xuICAgICAgICBcIm1hc2stdC1mcm9tXCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtdC10by1jb2xvclwiOiBbe1xuICAgICAgICBcIm1hc2stdC10b1wiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXItZnJvbS1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLXItZnJvbVwiOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXItdG8tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay1yLXRvXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2Utci1mcm9tLWNvbG9yXCI6IFt7XG4gICAgICAgIFwibWFzay1yLWZyb21cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1yLXRvLWNvbG9yXCI6IFt7XG4gICAgICAgIFwibWFzay1yLXRvXCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtYi1mcm9tLXBvc1wiOiBbe1xuICAgICAgICBcIm1hc2stYi1mcm9tXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtYi10by1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLWItdG9cIjogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1iLWZyb20tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLWItZnJvbVwiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLWItdG8tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLWItdG9cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1sLWZyb20tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay1sLWZyb21cIjogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1sLXRvLXBvc1wiOiBbe1xuICAgICAgICBcIm1hc2stbC10b1wiOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLWwtZnJvbS1jb2xvclwiOiBbe1xuICAgICAgICBcIm1hc2stbC1mcm9tXCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtbC10by1jb2xvclwiOiBbe1xuICAgICAgICBcIm1hc2stbC10b1wiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXgtZnJvbS1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLXgtZnJvbVwiOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXgtdG8tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay14LXRvXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UteC1mcm9tLWNvbG9yXCI6IFt7XG4gICAgICAgIFwibWFzay14LWZyb21cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS14LXRvLWNvbG9yXCI6IFt7XG4gICAgICAgIFwibWFzay14LXRvXCI6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UteS1mcm9tLXBvc1wiOiBbe1xuICAgICAgICBcIm1hc2steS1mcm9tXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UteS10by1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLXktdG9cIjogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS15LWZyb20tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLXktZnJvbVwiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXktdG8tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLXktdG9cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1yYWRpYWxcIjogW3tcbiAgICAgICAgXCJtYXNrLXJhZGlhbFwiOiBbaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXJhZGlhbC1mcm9tLXBvc1wiOiBbe1xuICAgICAgICBcIm1hc2stcmFkaWFsLWZyb21cIjogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1yYWRpYWwtdG8tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay1yYWRpYWwtdG9cIjogc2NhbGVNYXNrSW1hZ2VQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1yYWRpYWwtZnJvbS1jb2xvclwiOiBbe1xuICAgICAgICBcIm1hc2stcmFkaWFsLWZyb21cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1yYWRpYWwtdG8tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLXJhZGlhbC10b1wiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXJhZGlhbC1zaGFwZVwiOiBbe1xuICAgICAgICBcIm1hc2stcmFkaWFsXCI6IFtcImNpcmNsZVwiLCBcImVsbGlwc2VcIl1cbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLXJhZGlhbC1zaXplXCI6IFt7XG4gICAgICAgIFwibWFzay1yYWRpYWxcIjogW3tcbiAgICAgICAgICBjbG9zZXN0OiBbXCJzaWRlXCIsIFwiY29ybmVyXCJdLFxuICAgICAgICAgIGZhcnRoZXN0OiBbXCJzaWRlXCIsIFwiY29ybmVyXCJdXG4gICAgICAgIH1dXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1yYWRpYWwtcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay1yYWRpYWwtYXRcIjogc2NhbGVQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1jb25pYy1wb3NcIjogW3tcbiAgICAgICAgXCJtYXNrLWNvbmljXCI6IFtpc051bWJlcl1cbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLWNvbmljLWZyb20tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay1jb25pYy1mcm9tXCI6IHNjYWxlTWFza0ltYWdlUG9zaXRpb24oKVxuICAgICAgfV0sXG4gICAgICBcIm1hc2staW1hZ2UtY29uaWMtdG8tcG9zXCI6IFt7XG4gICAgICAgIFwibWFzay1jb25pYy10b1wiOiBzY2FsZU1hc2tJbWFnZVBvc2l0aW9uKClcbiAgICAgIH1dLFxuICAgICAgXCJtYXNrLWltYWdlLWNvbmljLWZyb20tY29sb3JcIjogW3tcbiAgICAgICAgXCJtYXNrLWNvbmljLWZyb21cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIFwibWFzay1pbWFnZS1jb25pYy10by1jb2xvclwiOiBbe1xuICAgICAgICBcIm1hc2stY29uaWMtdG9cIjogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBNb2RlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay1tb2RlXG4gICAgICAgKi9cbiAgICAgIFwibWFzay1tb2RlXCI6IFt7XG4gICAgICAgIG1hc2s6IFtcImFscGhhXCIsIFwibHVtaW5hbmNlXCIsIFwibWF0Y2hcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXNrIE9yaWdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stb3JpZ2luXG4gICAgICAgKi9cbiAgICAgIFwibWFzay1vcmlnaW5cIjogW3tcbiAgICAgICAgXCJtYXNrLW9yaWdpblwiOiBbXCJib3JkZXJcIiwgXCJwYWRkaW5nXCIsIFwiY29udGVudFwiLCBcImZpbGxcIiwgXCJzdHJva2VcIiwgXCJ2aWV3XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stcG9zaXRpb25cbiAgICAgICAqL1xuICAgICAgXCJtYXNrLXBvc2l0aW9uXCI6IFt7XG4gICAgICAgIG1hc2s6IHNjYWxlQmdQb3NpdGlvbigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBSZXBlYXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXNrLXJlcGVhdFxuICAgICAgICovXG4gICAgICBcIm1hc2stcmVwZWF0XCI6IFt7XG4gICAgICAgIG1hc2s6IHNjYWxlQmdSZXBlYXQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hc2sgU2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2stc2l6ZVxuICAgICAgICovXG4gICAgICBcIm1hc2stc2l6ZVwiOiBbe1xuICAgICAgICBtYXNrOiBzY2FsZUJnU2l6ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBUeXBlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFzay10eXBlXG4gICAgICAgKi9cbiAgICAgIFwibWFzay10eXBlXCI6IFt7XG4gICAgICAgIFwibWFzay10eXBlXCI6IFtcImFscGhhXCIsIFwibHVtaW5hbmNlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFzayBJbWFnZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hc2staW1hZ2VcbiAgICAgICAqL1xuICAgICAgXCJtYXNrLWltYWdlXCI6IFt7XG4gICAgICAgIG1hc2s6IFtcIm5vbmVcIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gRmlsdGVycyAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBGaWx0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWx0ZXJcbiAgICAgICAqL1xuICAgICAgZmlsdGVyOiBbe1xuICAgICAgICBmaWx0ZXI6IFtcbiAgICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZVxuICAgICAgICBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JsdXJcbiAgICAgICAqL1xuICAgICAgYmx1cjogW3tcbiAgICAgICAgYmx1cjogc2NhbGVCbHVyKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCcmlnaHRuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJpZ2h0bmVzc1xuICAgICAgICovXG4gICAgICBicmlnaHRuZXNzOiBbe1xuICAgICAgICBicmlnaHRuZXNzOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udHJhc3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jb250cmFzdFxuICAgICAgICovXG4gICAgICBjb250cmFzdDogW3tcbiAgICAgICAgY29udHJhc3Q6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEcm9wIFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Ryb3Atc2hhZG93XG4gICAgICAgKi9cbiAgICAgIFwiZHJvcC1zaGFkb3dcIjogW3tcbiAgICAgICAgXCJkcm9wLXNoYWRvd1wiOiBbXG4gICAgICAgICAgLy8gRGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjQuMC4wXG4gICAgICAgICAgXCJcIixcbiAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICB0aGVtZURyb3BTaGFkb3csXG4gICAgICAgICAgaXNBcmJpdHJhcnlWYXJpYWJsZVNoYWRvdyxcbiAgICAgICAgICBpc0FyYml0cmFyeVNoYWRvd1xuICAgICAgICBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRHJvcCBTaGFkb3cgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9maWx0ZXItZHJvcC1zaGFkb3cjc2V0dGluZy10aGUtc2hhZG93LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiZHJvcC1zaGFkb3ctY29sb3JcIjogW3tcbiAgICAgICAgXCJkcm9wLXNoYWRvd1wiOiBzY2FsZUNvbG9yKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgZ3JheXNjYWxlOiBbe1xuICAgICAgICBncmF5c2NhbGU6IFtcIlwiLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBIdWUgUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaHVlLXJvdGF0ZVxuICAgICAgICovXG4gICAgICBcImh1ZS1yb3RhdGVcIjogW3tcbiAgICAgICAgXCJodWUtcm90YXRlXCI6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBJbnZlcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9pbnZlcnRcbiAgICAgICAqL1xuICAgICAgaW52ZXJ0OiBbe1xuICAgICAgICBpbnZlcnQ6IFtcIlwiLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgIHNhdHVyYXRlOiBbe1xuICAgICAgICBzYXR1cmF0ZTogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2VwaWFcbiAgICAgICAqL1xuICAgICAgc2VwaWE6IFt7XG4gICAgICAgIHNlcGlhOiBbXCJcIiwgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgRmlsdGVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtZmlsdGVyXG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3AtZmlsdGVyXCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3AtZmlsdGVyXCI6IFtcbiAgICAgICAgICAvLyBEZXByZWNhdGVkIHNpbmNlIFRhaWx3aW5kIENTUyB2My4wLjBcbiAgICAgICAgICBcIlwiLFxuICAgICAgICAgIFwibm9uZVwiLFxuICAgICAgICAgIGlzQXJiaXRyYXJ5VmFyaWFibGUsXG4gICAgICAgICAgaXNBcmJpdHJhcnlWYWx1ZVxuICAgICAgICBdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJsdXJcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1ibHVyXCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3AtYmx1clwiOiBzY2FsZUJsdXIoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEJyaWdodG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1icmlnaHRuZXNzXG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3AtYnJpZ2h0bmVzc1wiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWJyaWdodG5lc3NcIjogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIENvbnRyYXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtY29udHJhc3RcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1jb250cmFzdFwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWNvbnRyYXN0XCI6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1ncmF5c2NhbGVcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1ncmF5c2NhbGVcIjogW1wiXCIsIGlzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEh1ZSBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1odWUtcm90YXRlXG4gICAgICAgKi9cbiAgICAgIFwiYmFja2Ryb3AtaHVlLXJvdGF0ZVwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWh1ZS1yb3RhdGVcIjogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWludmVydFxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLWludmVydFwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWludmVydFwiOiBbXCJcIiwgaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3Atb3BhY2l0eVwiOiBbaXNOdW1iZXIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgU2F0dXJhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZHJvcC1zYXR1cmF0ZVxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLXNhdHVyYXRlXCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3Atc2F0dXJhdGVcIjogW2lzTnVtYmVyLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2VwaWFcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1zZXBpYVwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLXNlcGlhXCI6IFtcIlwiLCBpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIC0tLSBUYWJsZXMgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sbGFwc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItY29sbGFwc2VcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItY29sbGFwc2VcIjogW3tcbiAgICAgICAgYm9yZGVyOiBbXCJjb2xsYXBzZVwiLCBcInNlcGFyYXRlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFNwYWNpbmdcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICBcImJvcmRlci1zcGFjaW5nXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXNwYWNpbmdcIjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICBcImJvcmRlci1zcGFjaW5nLXhcIjogW3tcbiAgICAgICAgXCJib3JkZXItc3BhY2luZy14XCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgU3BhY2luZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItc3BhY2luZy15XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXNwYWNpbmcteVwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGFibGUgTGF5b3V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGFibGUtbGF5b3V0XG4gICAgICAgKi9cbiAgICAgIFwidGFibGUtbGF5b3V0XCI6IFt7XG4gICAgICAgIHRhYmxlOiBbXCJhdXRvXCIsIFwiZml4ZWRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDYXB0aW9uIFNpZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jYXB0aW9uLXNpZGVcbiAgICAgICAqL1xuICAgICAgY2FwdGlvbjogW3tcbiAgICAgICAgY2FwdGlvbjogW1widG9wXCIsIFwiYm90dG9tXCJdXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIFRyYW5zaXRpb25zIGFuZCBBbmltYXRpb24gLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBQcm9wZXJ0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tcHJvcGVydHlcbiAgICAgICAqL1xuICAgICAgdHJhbnNpdGlvbjogW3tcbiAgICAgICAgdHJhbnNpdGlvbjogW1wiXCIsIFwiYWxsXCIsIFwiY29sb3JzXCIsIFwib3BhY2l0eVwiLCBcInNoYWRvd1wiLCBcInRyYW5zZm9ybVwiLCBcIm5vbmVcIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1iZWhhdmlvclxuICAgICAgICovXG4gICAgICBcInRyYW5zaXRpb24tYmVoYXZpb3JcIjogW3tcbiAgICAgICAgdHJhbnNpdGlvbjogW1wibm9ybWFsXCIsIFwiZGlzY3JldGVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIER1cmF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1kdXJhdGlvblxuICAgICAgICovXG4gICAgICBkdXJhdGlvbjogW3tcbiAgICAgICAgZHVyYXRpb246IFtpc051bWJlciwgXCJpbml0aWFsXCIsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNpdGlvbiBUaW1pbmcgRnVuY3Rpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvblxuICAgICAgICovXG4gICAgICBlYXNlOiBbe1xuICAgICAgICBlYXNlOiBbXCJsaW5lYXJcIiwgXCJpbml0aWFsXCIsIHRoZW1lRWFzZSwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIERlbGF5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1kZWxheVxuICAgICAgICovXG4gICAgICBkZWxheTogW3tcbiAgICAgICAgZGVsYXk6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbmltYXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hbmltYXRpb25cbiAgICAgICAqL1xuICAgICAgYW5pbWF0ZTogW3tcbiAgICAgICAgYW5pbWF0ZTogW1wibm9uZVwiLCB0aGVtZUFuaW1hdGUsIGlzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWVdXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIFRyYW5zZm9ybXMgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogQmFja2ZhY2UgVmlzaWJpbGl0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tmYWNlLXZpc2liaWxpdHlcbiAgICAgICAqL1xuICAgICAgYmFja2ZhY2U6IFt7XG4gICAgICAgIGJhY2tmYWNlOiBbXCJoaWRkZW5cIiwgXCJ2aXNpYmxlXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGVyc3BlY3RpdmVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wZXJzcGVjdGl2ZVxuICAgICAgICovXG4gICAgICBwZXJzcGVjdGl2ZTogW3tcbiAgICAgICAgcGVyc3BlY3RpdmU6IFt0aGVtZVBlcnNwZWN0aXZlLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBlcnNwZWN0aXZlIE9yaWdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BlcnNwZWN0aXZlLW9yaWdpblxuICAgICAgICovXG4gICAgICBcInBlcnNwZWN0aXZlLW9yaWdpblwiOiBbe1xuICAgICAgICBcInBlcnNwZWN0aXZlLW9yaWdpblwiOiBzY2FsZVBvc2l0aW9uV2l0aEFyYml0cmFyeSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgIHJvdGF0ZTogW3tcbiAgICAgICAgcm90YXRlOiBzY2FsZVJvdGF0ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9yb3RhdGVcbiAgICAgICAqL1xuICAgICAgXCJyb3RhdGUteFwiOiBbe1xuICAgICAgICBcInJvdGF0ZS14XCI6IHNjYWxlUm90YXRlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSb3RhdGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3JvdGF0ZVxuICAgICAgICovXG4gICAgICBcInJvdGF0ZS15XCI6IFt7XG4gICAgICAgIFwicm90YXRlLXlcIjogc2NhbGVSb3RhdGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJvdGF0ZSBaXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgIFwicm90YXRlLXpcIjogW3tcbiAgICAgICAgXCJyb3RhdGUtelwiOiBzY2FsZVJvdGF0ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICBzY2FsZTogW3tcbiAgICAgICAgc2NhbGU6IHNjYWxlU2NhbGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICBcInNjYWxlLXhcIjogW3tcbiAgICAgICAgXCJzY2FsZS14XCI6IHNjYWxlU2NhbGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICBcInNjYWxlLXlcIjogW3tcbiAgICAgICAgXCJzY2FsZS15XCI6IHNjYWxlU2NhbGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIFpcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY2FsZVxuICAgICAgICovXG4gICAgICBcInNjYWxlLXpcIjogW3tcbiAgICAgICAgXCJzY2FsZS16XCI6IHNjYWxlU2NhbGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjYWxlIDNEXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2NhbGVcbiAgICAgICAqL1xuICAgICAgXCJzY2FsZS0zZFwiOiBbXCJzY2FsZS0zZFwiXSxcbiAgICAgIC8qKlxuICAgICAgICogU2tld1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NrZXdcbiAgICAgICAqL1xuICAgICAgc2tldzogW3tcbiAgICAgICAgc2tldzogc2NhbGVTa2V3KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3IFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgKi9cbiAgICAgIFwic2tldy14XCI6IFt7XG4gICAgICAgIFwic2tldy14XCI6IHNjYWxlU2tldygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2tldyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICovXG4gICAgICBcInNrZXcteVwiOiBbe1xuICAgICAgICBcInNrZXcteVwiOiBzY2FsZVNrZXcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zZm9ybVxuICAgICAgICovXG4gICAgICB0cmFuc2Zvcm06IFt7XG4gICAgICAgIHRyYW5zZm9ybTogW2lzQXJiaXRyYXJ5VmFyaWFibGUsIGlzQXJiaXRyYXJ5VmFsdWUsIFwiXCIsIFwibm9uZVwiLCBcImdwdVwiLCBcImNwdVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tb3JpZ2luXG4gICAgICAgKi9cbiAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBbe1xuICAgICAgICBvcmlnaW46IHNjYWxlUG9zaXRpb25XaXRoQXJiaXRyYXJ5KClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm0gU3R5bGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tc3R5bGVcbiAgICAgICAqL1xuICAgICAgXCJ0cmFuc2Zvcm0tc3R5bGVcIjogW3tcbiAgICAgICAgdHJhbnNmb3JtOiBbXCIzZFwiLCBcImZsYXRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgdHJhbnNsYXRlOiBbe1xuICAgICAgICB0cmFuc2xhdGU6IHNjYWxlVHJhbnNsYXRlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGUgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICBcInRyYW5zbGF0ZS14XCI6IFt7XG4gICAgICAgIFwidHJhbnNsYXRlLXhcIjogc2NhbGVUcmFuc2xhdGUoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgIFwidHJhbnNsYXRlLXlcIjogW3tcbiAgICAgICAgXCJ0cmFuc2xhdGUteVwiOiBzY2FsZVRyYW5zbGF0ZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVHJhbnNsYXRlIFpcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2xhdGVcbiAgICAgICAqL1xuICAgICAgXCJ0cmFuc2xhdGUtelwiOiBbe1xuICAgICAgICBcInRyYW5zbGF0ZS16XCI6IHNjYWxlVHJhbnNsYXRlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGUgTm9uZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICBcInRyYW5zbGF0ZS1ub25lXCI6IFtcInRyYW5zbGF0ZS1ub25lXCJdLFxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAtLS0gSW50ZXJhY3Rpdml0eSAtLS1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBBY2NlbnQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hY2NlbnQtY29sb3JcbiAgICAgICAqL1xuICAgICAgYWNjZW50OiBbe1xuICAgICAgICBhY2NlbnQ6IHNjYWxlQ29sb3IoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFwcGVhcmFuY2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9hcHBlYXJhbmNlXG4gICAgICAgKi9cbiAgICAgIGFwcGVhcmFuY2U6IFt7XG4gICAgICAgIGFwcGVhcmFuY2U6IFtcIm5vbmVcIiwgXCJhdXRvXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FyZXQgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0LWluLXRpbWUtbW9kZSNjYXJldC1jb2xvci11dGlsaXRpZXNcbiAgICAgICAqL1xuICAgICAgXCJjYXJldC1jb2xvclwiOiBbe1xuICAgICAgICBjYXJldDogc2NhbGVDb2xvcigpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29sb3IgU2NoZW1lXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29sb3Itc2NoZW1lXG4gICAgICAgKi9cbiAgICAgIFwiY29sb3Itc2NoZW1lXCI6IFt7XG4gICAgICAgIHNjaGVtZTogW1wibm9ybWFsXCIsIFwiZGFya1wiLCBcImxpZ2h0XCIsIFwibGlnaHQtZGFya1wiLCBcIm9ubHktZGFya1wiLCBcIm9ubHktbGlnaHRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDdXJzb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jdXJzb3JcbiAgICAgICAqL1xuICAgICAgY3Vyc29yOiBbe1xuICAgICAgICBjdXJzb3I6IFtcImF1dG9cIiwgXCJkZWZhdWx0XCIsIFwicG9pbnRlclwiLCBcIndhaXRcIiwgXCJ0ZXh0XCIsIFwibW92ZVwiLCBcImhlbHBcIiwgXCJub3QtYWxsb3dlZFwiLCBcIm5vbmVcIiwgXCJjb250ZXh0LW1lbnVcIiwgXCJwcm9ncmVzc1wiLCBcImNlbGxcIiwgXCJjcm9zc2hhaXJcIiwgXCJ2ZXJ0aWNhbC10ZXh0XCIsIFwiYWxpYXNcIiwgXCJjb3B5XCIsIFwibm8tZHJvcFwiLCBcImdyYWJcIiwgXCJncmFiYmluZ1wiLCBcImFsbC1zY3JvbGxcIiwgXCJjb2wtcmVzaXplXCIsIFwicm93LXJlc2l6ZVwiLCBcIm4tcmVzaXplXCIsIFwiZS1yZXNpemVcIiwgXCJzLXJlc2l6ZVwiLCBcInctcmVzaXplXCIsIFwibmUtcmVzaXplXCIsIFwibnctcmVzaXplXCIsIFwic2UtcmVzaXplXCIsIFwic3ctcmVzaXplXCIsIFwiZXctcmVzaXplXCIsIFwibnMtcmVzaXplXCIsIFwibmVzdy1yZXNpemVcIiwgXCJud3NlLXJlc2l6ZVwiLCBcInpvb20taW5cIiwgXCJ6b29tLW91dFwiLCBpc0FyYml0cmFyeVZhcmlhYmxlLCBpc0FyYml0cmFyeVZhbHVlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZpZWxkIFNpemluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpZWxkLXNpemluZ1xuICAgICAgICovXG4gICAgICBcImZpZWxkLXNpemluZ1wiOiBbe1xuICAgICAgICBcImZpZWxkLXNpemluZ1wiOiBbXCJmaXhlZFwiLCBcImNvbnRlbnRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQb2ludGVyIEV2ZW50c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BvaW50ZXItZXZlbnRzXG4gICAgICAgKi9cbiAgICAgIFwicG9pbnRlci1ldmVudHNcIjogW3tcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBbXCJhdXRvXCIsIFwibm9uZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJlc2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jlc2l6ZVxuICAgICAgICovXG4gICAgICByZXNpemU6IFt7XG4gICAgICAgIHJlc2l6ZTogW1wibm9uZVwiLCBcIlwiLCBcInlcIiwgXCJ4XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLWJlaGF2aW9yXCI6IFt7XG4gICAgICAgIHNjcm9sbDogW1wiYXV0b1wiLCBcInNtb290aFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1cIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbVwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1teFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1teFwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1teVwiOiBbe1xuICAgICAgICBcInNjcm9sbC1teVwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbXNcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbXNcIjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tZVwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tZVwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW10XCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW10XCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tclwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tclwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1iXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW1iXCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1sXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW1sXCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXBcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcFwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXB4XCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLXB4XCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcHlcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcHlcIjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcHNcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcHNcIjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXBlXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLXBlXCI6IHNjYWxlVW5hbWJpZ3VvdXNTcGFjaW5nKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wdFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wdFwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wclwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wclwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcGJcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcGJcIjogc2NhbGVVbmFtYmlndW91c1NwYWNpbmcoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wbFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wbFwiOiBzY2FsZVVuYW1iaWd1b3VzU3BhY2luZygpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgQWxpZ25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC1hbGlnblxuICAgICAgICovXG4gICAgICBcInNuYXAtYWxpZ25cIjogW3tcbiAgICAgICAgc25hcDogW1wic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJhbGlnbi1ub25lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgU3RvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXN0b3BcbiAgICAgICAqL1xuICAgICAgXCJzbmFwLXN0b3BcIjogW3tcbiAgICAgICAgc25hcDogW1wibm9ybWFsXCIsIFwiYWx3YXlzXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgXCJzbmFwLXR5cGVcIjogW3tcbiAgICAgICAgc25hcDogW1wibm9uZVwiLCBcInhcIiwgXCJ5XCIsIFwiYm90aFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGUgU3RyaWN0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgXCJzbmFwLXN0cmljdG5lc3NcIjogW3tcbiAgICAgICAgc25hcDogW1wibWFuZGF0b3J5XCIsIFwicHJveGltaXR5XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIHRvdWNoOiBbe1xuICAgICAgICB0b3VjaDogW1wiYXV0b1wiLCBcIm5vbmVcIiwgXCJtYW5pcHVsYXRpb25cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICBcInRvdWNoLXhcIjogW3tcbiAgICAgICAgXCJ0b3VjaC1wYW5cIjogW1wieFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIFwidG91Y2gteVwiOiBbe1xuICAgICAgICBcInRvdWNoLXBhblwiOiBbXCJ5XCIsIFwidXBcIiwgXCJkb3duXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFBpbmNoIFpvb21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgXCJ0b3VjaC1welwiOiBbXCJ0b3VjaC1waW5jaC16b29tXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBVc2VyIFNlbGVjdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3VzZXItc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogW3tcbiAgICAgICAgc2VsZWN0OiBbXCJub25lXCIsIFwidGV4dFwiLCBcImFsbFwiLCBcImF1dG9cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBXaWxsIENoYW5nZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3dpbGwtY2hhbmdlXG4gICAgICAgKi9cbiAgICAgIFwid2lsbC1jaGFuZ2VcIjogW3tcbiAgICAgICAgXCJ3aWxsLWNoYW5nZVwiOiBbXCJhdXRvXCIsIFwic2Nyb2xsXCIsIFwiY29udGVudHNcIiwgXCJ0cmFuc2Zvcm1cIiwgaXNBcmJpdHJhcnlWYXJpYWJsZSwgaXNBcmJpdHJhcnlWYWx1ZV1cbiAgICAgIH1dLFxuICAgICAgLy8gLS0tLS0tLS0tLS1cbiAgICAgIC8vIC0tLSBTVkcgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLVxuICAgICAgLyoqXG4gICAgICAgKiBGaWxsXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmlsbFxuICAgICAgICovXG4gICAgICBmaWxsOiBbe1xuICAgICAgICBmaWxsOiBbXCJub25lXCIsIC4uLnNjYWxlQ29sb3IoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdHJva2UgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zdHJva2Utd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJzdHJva2Utd1wiOiBbe1xuICAgICAgICBzdHJva2U6IFtpc051bWJlciwgaXNBcmJpdHJhcnlWYXJpYWJsZUxlbmd0aCwgaXNBcmJpdHJhcnlMZW5ndGgsIGlzQXJiaXRyYXJ5TnVtYmVyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFN0cm9rZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3N0cm9rZVxuICAgICAgICovXG4gICAgICBzdHJva2U6IFt7XG4gICAgICAgIHN0cm9rZTogW1wibm9uZVwiLCAuLi5zY2FsZUNvbG9yKCldXG4gICAgICB9XSxcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gLS0tIEFjY2Vzc2liaWxpdHkgLS0tXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8qKlxuICAgICAgICogRm9yY2VkIENvbG9yIEFkanVzdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvcmNlZC1jb2xvci1hZGp1c3RcbiAgICAgICAqL1xuICAgICAgXCJmb3JjZWQtY29sb3ItYWRqdXN0XCI6IFt7XG4gICAgICAgIFwiZm9yY2VkLWNvbG9yLWFkanVzdFwiOiBbXCJhdXRvXCIsIFwibm9uZVwiXVxuICAgICAgfV1cbiAgICB9LFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cHM6IHtcbiAgICAgIG92ZXJmbG93OiBbXCJvdmVyZmxvdy14XCIsIFwib3ZlcmZsb3cteVwiXSxcbiAgICAgIG92ZXJzY3JvbGw6IFtcIm92ZXJzY3JvbGwteFwiLCBcIm92ZXJzY3JvbGwteVwiXSxcbiAgICAgIGluc2V0OiBbXCJpbnNldC14XCIsIFwiaW5zZXQteVwiLCBcInN0YXJ0XCIsIFwiZW5kXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCJdLFxuICAgICAgXCJpbnNldC14XCI6IFtcInJpZ2h0XCIsIFwibGVmdFwiXSxcbiAgICAgIFwiaW5zZXQteVwiOiBbXCJ0b3BcIiwgXCJib3R0b21cIl0sXG4gICAgICBmbGV4OiBbXCJiYXNpc1wiLCBcImdyb3dcIiwgXCJzaHJpbmtcIl0sXG4gICAgICBnYXA6IFtcImdhcC14XCIsIFwiZ2FwLXlcIl0sXG4gICAgICBwOiBbXCJweFwiLCBcInB5XCIsIFwicHNcIiwgXCJwZVwiLCBcInB0XCIsIFwicHJcIiwgXCJwYlwiLCBcInBsXCJdLFxuICAgICAgcHg6IFtcInByXCIsIFwicGxcIl0sXG4gICAgICBweTogW1wicHRcIiwgXCJwYlwiXSxcbiAgICAgIG06IFtcIm14XCIsIFwibXlcIiwgXCJtc1wiLCBcIm1lXCIsIFwibXRcIiwgXCJtclwiLCBcIm1iXCIsIFwibWxcIl0sXG4gICAgICBteDogW1wibXJcIiwgXCJtbFwiXSxcbiAgICAgIG15OiBbXCJtdFwiLCBcIm1iXCJdLFxuICAgICAgc2l6ZTogW1wid1wiLCBcImhcIl0sXG4gICAgICBcImZvbnQtc2l6ZVwiOiBbXCJsZWFkaW5nXCJdLFxuICAgICAgXCJmdm4tbm9ybWFsXCI6IFtcImZ2bi1vcmRpbmFsXCIsIFwiZnZuLXNsYXNoZWQtemVyb1wiLCBcImZ2bi1maWd1cmVcIiwgXCJmdm4tc3BhY2luZ1wiLCBcImZ2bi1mcmFjdGlvblwiXSxcbiAgICAgIFwiZnZuLW9yZGluYWxcIjogW1wiZnZuLW5vcm1hbFwiXSxcbiAgICAgIFwiZnZuLXNsYXNoZWQtemVyb1wiOiBbXCJmdm4tbm9ybWFsXCJdLFxuICAgICAgXCJmdm4tZmlndXJlXCI6IFtcImZ2bi1ub3JtYWxcIl0sXG4gICAgICBcImZ2bi1zcGFjaW5nXCI6IFtcImZ2bi1ub3JtYWxcIl0sXG4gICAgICBcImZ2bi1mcmFjdGlvblwiOiBbXCJmdm4tbm9ybWFsXCJdLFxuICAgICAgXCJsaW5lLWNsYW1wXCI6IFtcImRpc3BsYXlcIiwgXCJvdmVyZmxvd1wiXSxcbiAgICAgIHJvdW5kZWQ6IFtcInJvdW5kZWQtc1wiLCBcInJvdW5kZWQtZVwiLCBcInJvdW5kZWQtdFwiLCBcInJvdW5kZWQtclwiLCBcInJvdW5kZWQtYlwiLCBcInJvdW5kZWQtbFwiLCBcInJvdW5kZWQtc3NcIiwgXCJyb3VuZGVkLXNlXCIsIFwicm91bmRlZC1lZVwiLCBcInJvdW5kZWQtZXNcIiwgXCJyb3VuZGVkLXRsXCIsIFwicm91bmRlZC10clwiLCBcInJvdW5kZWQtYnJcIiwgXCJyb3VuZGVkLWJsXCJdLFxuICAgICAgXCJyb3VuZGVkLXNcIjogW1wicm91bmRlZC1zc1wiLCBcInJvdW5kZWQtZXNcIl0sXG4gICAgICBcInJvdW5kZWQtZVwiOiBbXCJyb3VuZGVkLXNlXCIsIFwicm91bmRlZC1lZVwiXSxcbiAgICAgIFwicm91bmRlZC10XCI6IFtcInJvdW5kZWQtdGxcIiwgXCJyb3VuZGVkLXRyXCJdLFxuICAgICAgXCJyb3VuZGVkLXJcIjogW1wicm91bmRlZC10clwiLCBcInJvdW5kZWQtYnJcIl0sXG4gICAgICBcInJvdW5kZWQtYlwiOiBbXCJyb3VuZGVkLWJyXCIsIFwicm91bmRlZC1ibFwiXSxcbiAgICAgIFwicm91bmRlZC1sXCI6IFtcInJvdW5kZWQtdGxcIiwgXCJyb3VuZGVkLWJsXCJdLFxuICAgICAgXCJib3JkZXItc3BhY2luZ1wiOiBbXCJib3JkZXItc3BhY2luZy14XCIsIFwiYm9yZGVyLXNwYWNpbmcteVwiXSxcbiAgICAgIFwiYm9yZGVyLXdcIjogW1wiYm9yZGVyLXcteFwiLCBcImJvcmRlci13LXlcIiwgXCJib3JkZXItdy1zXCIsIFwiYm9yZGVyLXctZVwiLCBcImJvcmRlci13LXRcIiwgXCJib3JkZXItdy1yXCIsIFwiYm9yZGVyLXctYlwiLCBcImJvcmRlci13LWxcIl0sXG4gICAgICBcImJvcmRlci13LXhcIjogW1wiYm9yZGVyLXctclwiLCBcImJvcmRlci13LWxcIl0sXG4gICAgICBcImJvcmRlci13LXlcIjogW1wiYm9yZGVyLXctdFwiLCBcImJvcmRlci13LWJcIl0sXG4gICAgICBcImJvcmRlci1jb2xvclwiOiBbXCJib3JkZXItY29sb3IteFwiLCBcImJvcmRlci1jb2xvci15XCIsIFwiYm9yZGVyLWNvbG9yLXNcIiwgXCJib3JkZXItY29sb3ItZVwiLCBcImJvcmRlci1jb2xvci10XCIsIFwiYm9yZGVyLWNvbG9yLXJcIiwgXCJib3JkZXItY29sb3ItYlwiLCBcImJvcmRlci1jb2xvci1sXCJdLFxuICAgICAgXCJib3JkZXItY29sb3IteFwiOiBbXCJib3JkZXItY29sb3ItclwiLCBcImJvcmRlci1jb2xvci1sXCJdLFxuICAgICAgXCJib3JkZXItY29sb3IteVwiOiBbXCJib3JkZXItY29sb3ItdFwiLCBcImJvcmRlci1jb2xvci1iXCJdLFxuICAgICAgdHJhbnNsYXRlOiBbXCJ0cmFuc2xhdGUteFwiLCBcInRyYW5zbGF0ZS15XCIsIFwidHJhbnNsYXRlLW5vbmVcIl0sXG4gICAgICBcInRyYW5zbGF0ZS1ub25lXCI6IFtcInRyYW5zbGF0ZVwiLCBcInRyYW5zbGF0ZS14XCIsIFwidHJhbnNsYXRlLXlcIiwgXCJ0cmFuc2xhdGUtelwiXSxcbiAgICAgIFwic2Nyb2xsLW1cIjogW1wic2Nyb2xsLW14XCIsIFwic2Nyb2xsLW15XCIsIFwic2Nyb2xsLW1zXCIsIFwic2Nyb2xsLW1lXCIsIFwic2Nyb2xsLW10XCIsIFwic2Nyb2xsLW1yXCIsIFwic2Nyb2xsLW1iXCIsIFwic2Nyb2xsLW1sXCJdLFxuICAgICAgXCJzY3JvbGwtbXhcIjogW1wic2Nyb2xsLW1yXCIsIFwic2Nyb2xsLW1sXCJdLFxuICAgICAgXCJzY3JvbGwtbXlcIjogW1wic2Nyb2xsLW10XCIsIFwic2Nyb2xsLW1iXCJdLFxuICAgICAgXCJzY3JvbGwtcFwiOiBbXCJzY3JvbGwtcHhcIiwgXCJzY3JvbGwtcHlcIiwgXCJzY3JvbGwtcHNcIiwgXCJzY3JvbGwtcGVcIiwgXCJzY3JvbGwtcHRcIiwgXCJzY3JvbGwtcHJcIiwgXCJzY3JvbGwtcGJcIiwgXCJzY3JvbGwtcGxcIl0sXG4gICAgICBcInNjcm9sbC1weFwiOiBbXCJzY3JvbGwtcHJcIiwgXCJzY3JvbGwtcGxcIl0sXG4gICAgICBcInNjcm9sbC1weVwiOiBbXCJzY3JvbGwtcHRcIiwgXCJzY3JvbGwtcGJcIl0sXG4gICAgICB0b3VjaDogW1widG91Y2gteFwiLCBcInRvdWNoLXlcIiwgXCJ0b3VjaC1welwiXSxcbiAgICAgIFwidG91Y2gteFwiOiBbXCJ0b3VjaFwiXSxcbiAgICAgIFwidG91Y2gteVwiOiBbXCJ0b3VjaFwiXSxcbiAgICAgIFwidG91Y2gtcHpcIjogW1widG91Y2hcIl1cbiAgICB9LFxuICAgIGNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVyczoge1xuICAgICAgXCJmb250LXNpemVcIjogW1wibGVhZGluZ1wiXVxuICAgIH0sXG4gICAgb3JkZXJTZW5zaXRpdmVNb2RpZmllcnM6IFtcIipcIiwgXCIqKlwiLCBcImFmdGVyXCIsIFwiYmFja2Ryb3BcIiwgXCJiZWZvcmVcIiwgXCJkZXRhaWxzLWNvbnRlbnRcIiwgXCJmaWxlXCIsIFwiZmlyc3QtbGV0dGVyXCIsIFwiZmlyc3QtbGluZVwiLCBcIm1hcmtlclwiLCBcInBsYWNlaG9sZGVyXCIsIFwic2VsZWN0aW9uXCJdXG4gIH07XG59LCBtZXJnZUNvbmZpZ3MgPSAoYmFzZUNvbmZpZywge1xuICBjYWNoZVNpemUsXG4gIHByZWZpeCxcbiAgZXhwZXJpbWVudGFsUGFyc2VDbGFzc05hbWUsXG4gIGV4dGVuZCA9IHt9LFxuICBvdmVycmlkZSA9IHt9XG59KSA9PiAob3ZlcnJpZGVQcm9wZXJ0eShiYXNlQ29uZmlnLCBcImNhY2hlU2l6ZVwiLCBjYWNoZVNpemUpLCBvdmVycmlkZVByb3BlcnR5KGJhc2VDb25maWcsIFwicHJlZml4XCIsIHByZWZpeCksIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgXCJleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZVwiLCBleHBlcmltZW50YWxQYXJzZUNsYXNzTmFtZSksIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLnRoZW1lLCBvdmVycmlkZS50aGVtZSksIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLmNsYXNzR3JvdXBzLCBvdmVycmlkZS5jbGFzc0dyb3VwcyksIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMsIG92ZXJyaWRlLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMpLCBvdmVycmlkZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnMsIG92ZXJyaWRlLmNvbmZsaWN0aW5nQ2xhc3NHcm91cE1vZGlmaWVycyksIG92ZXJyaWRlUHJvcGVydHkoYmFzZUNvbmZpZywgXCJvcmRlclNlbnNpdGl2ZU1vZGlmaWVyc1wiLCBvdmVycmlkZS5vcmRlclNlbnNpdGl2ZU1vZGlmaWVycyksIG1lcmdlQ29uZmlnUHJvcGVydGllcyhiYXNlQ29uZmlnLnRoZW1lLCBleHRlbmQudGhlbWUpLCBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy5jbGFzc0dyb3VwcywgZXh0ZW5kLmNsYXNzR3JvdXBzKSwgbWVyZ2VDb25maWdQcm9wZXJ0aWVzKGJhc2VDb25maWcuY29uZmxpY3RpbmdDbGFzc0dyb3VwcywgZXh0ZW5kLmNvbmZsaWN0aW5nQ2xhc3NHcm91cHMpLCBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMoYmFzZUNvbmZpZy5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnMsIGV4dGVuZC5jb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnMpLCBtZXJnZUFycmF5UHJvcGVydGllcyhiYXNlQ29uZmlnLCBleHRlbmQsIFwib3JkZXJTZW5zaXRpdmVNb2RpZmllcnNcIiksIGJhc2VDb25maWcpLCBvdmVycmlkZVByb3BlcnR5ID0gKGJhc2VPYmplY3QsIG92ZXJyaWRlS2V5LCBvdmVycmlkZVZhbHVlKSA9PiB7XG4gIG92ZXJyaWRlVmFsdWUgIT09IHZvaWQgMCAmJiAoYmFzZU9iamVjdFtvdmVycmlkZUtleV0gPSBvdmVycmlkZVZhbHVlKTtcbn0sIG92ZXJyaWRlQ29uZmlnUHJvcGVydGllcyA9IChiYXNlT2JqZWN0LCBvdmVycmlkZU9iamVjdCkgPT4ge1xuICBpZiAob3ZlcnJpZGVPYmplY3QpXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3ZlcnJpZGVPYmplY3QpXG4gICAgICBvdmVycmlkZVByb3BlcnR5KGJhc2VPYmplY3QsIGtleSwgb3ZlcnJpZGVPYmplY3Rba2V5XSk7XG59LCBtZXJnZUNvbmZpZ1Byb3BlcnRpZXMgPSAoYmFzZU9iamVjdCwgbWVyZ2VPYmplY3QpID0+IHtcbiAgaWYgKG1lcmdlT2JqZWN0KVxuICAgIGZvciAoY29uc3Qga2V5IGluIG1lcmdlT2JqZWN0KVxuICAgICAgbWVyZ2VBcnJheVByb3BlcnRpZXMoYmFzZU9iamVjdCwgbWVyZ2VPYmplY3QsIGtleSk7XG59LCBtZXJnZUFycmF5UHJvcGVydGllcyA9IChiYXNlT2JqZWN0LCBtZXJnZU9iamVjdCwga2V5KSA9PiB7XG4gIGNvbnN0IG1lcmdlVmFsdWUgPSBtZXJnZU9iamVjdFtrZXldO1xuICBtZXJnZVZhbHVlICE9PSB2b2lkIDAgJiYgKGJhc2VPYmplY3Rba2V5XSA9IGJhc2VPYmplY3Rba2V5XSA/IGJhc2VPYmplY3Rba2V5XS5jb25jYXQobWVyZ2VWYWx1ZSkgOiBtZXJnZVZhbHVlKTtcbn0sIGV4dGVuZFRhaWx3aW5kTWVyZ2UgPSAoY29uZmlnRXh0ZW5zaW9uLCAuLi5jcmVhdGVDb25maWcpID0+IHR5cGVvZiBjb25maWdFeHRlbnNpb24gPT0gXCJmdW5jdGlvblwiID8gY3JlYXRlVGFpbHdpbmRNZXJnZShnZXREZWZhdWx0Q29uZmlnLCBjb25maWdFeHRlbnNpb24sIC4uLmNyZWF0ZUNvbmZpZykgOiBjcmVhdGVUYWlsd2luZE1lcmdlKCgpID0+IG1lcmdlQ29uZmlncyhnZXREZWZhdWx0Q29uZmlnKCksIGNvbmZpZ0V4dGVuc2lvbiksIC4uLmNyZWF0ZUNvbmZpZyk7XG5mdW5jdGlvbiBnZXRFbGVtZW50QXRQb2ludCh4LCB5KSB7XG4gIHJldHVybiB3aW5kb3cucGFyZW50LmRvY3VtZW50LmVsZW1lbnRzRnJvbVBvaW50KFxuICAgIHgsXG4gICAgeVxuICApLmZpbmQoXG4gICAgKGVsZW1lbnQpID0+ICFlbGVtZW50LmNsb3Nlc3QoXCJzdmdcIikgJiYgIWVsZW1lbnQuY2xvc2VzdChcIlNUQUdFV0lTRS1UT09MQkFSXCIpICYmIGlzRWxlbWVudEF0UG9pbnQoZWxlbWVudCwgeCwgeSlcbiAgKSB8fCB3aW5kb3cucGFyZW50LmRvY3VtZW50LmJvZHk7XG59XG5jb25zdCBpc0VsZW1lbnRBdFBvaW50ID0gKGVsZW1lbnQsIGNsaWVudFgsIGNsaWVudFkpID0+IHtcbiAgY29uc3QgYm91bmRpbmdSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgaXNJbkhvcml6b250YWxCb3VuZHMgPSBjbGllbnRYID4gYm91bmRpbmdSZWN0LmxlZnQgJiYgY2xpZW50WCA8IGJvdW5kaW5nUmVjdC5sZWZ0ICsgYm91bmRpbmdSZWN0LndpZHRoLCBpc0luVmVydGljYWxCb3VuZHMgPSBjbGllbnRZID4gYm91bmRpbmdSZWN0LnRvcCAmJiBjbGllbnRZIDwgYm91bmRpbmdSZWN0LnRvcCArIGJvdW5kaW5nUmVjdC5oZWlnaHQ7XG4gIHJldHVybiBpc0luSG9yaXpvbnRhbEJvdW5kcyAmJiBpc0luVmVydGljYWxCb3VuZHM7XG59LCBnZXRYUGF0aEZvckVsZW1lbnQgPSAoZWxlbWVudCwgdXNlSWQpID0+IHtcbiAgaWYgKGVsZW1lbnQuaWQgJiYgdXNlSWQpXG4gICAgcmV0dXJuIFxcYC8qW0BpZD1cIlxcJHtlbGVtZW50LmlkfVwiXVxcYDtcbiAgbGV0IG5vZGVFbGVtID0gZWxlbWVudDtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yICg7IG5vZGVFbGVtICYmIE5vZGUuRUxFTUVOVF9OT0RFID09PSBub2RlRWxlbS5ub2RlVHlwZTsgKSB7XG4gICAgbGV0IG5iT2ZQcmV2aW91c1NpYmxpbmdzID0gMCwgaGFzTmV4dFNpYmxpbmdzID0gITEsIHNpYmxpbmcgPSBub2RlRWxlbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgZm9yICg7IHNpYmxpbmc7IClcbiAgICAgIHNpYmxpbmcubm9kZVR5cGUgIT09IE5vZGUuRE9DVU1FTlRfVFlQRV9OT0RFICYmIHNpYmxpbmcubm9kZU5hbWUgPT09IG5vZGVFbGVtLm5vZGVOYW1lICYmIG5iT2ZQcmV2aW91c1NpYmxpbmdzKyssIHNpYmxpbmcgPSBzaWJsaW5nLnByZXZpb3VzU2libGluZztcbiAgICBmb3IgKHNpYmxpbmcgPSBub2RlRWxlbS5uZXh0U2libGluZzsgc2libGluZzsgKSB7XG4gICAgICBpZiAoc2libGluZy5ub2RlTmFtZSA9PT0gbm9kZUVsZW0ubm9kZU5hbWUpIHtcbiAgICAgICAgaGFzTmV4dFNpYmxpbmdzID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2libGluZyA9IHNpYmxpbmcubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IG5vZGVFbGVtLnByZWZpeCA/IFxcYFxcJHtub2RlRWxlbS5wcmVmaXh9OlxcYCA6IFwiXCIsIG50aCA9IG5iT2ZQcmV2aW91c1NpYmxpbmdzIHx8IGhhc05leHRTaWJsaW5ncyA/IFxcYFtcXCR7bmJPZlByZXZpb3VzU2libGluZ3MgKyAxfV1cXGAgOiBcIlwiO1xuICAgIHBhcnRzLnB1c2gocHJlZml4ICsgbm9kZUVsZW0ubG9jYWxOYW1lICsgbnRoKSwgbm9kZUVsZW0gPSBub2RlRWxlbS5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPyBcXGAvXFwke3BhcnRzLnJldmVyc2UoKS5qb2luKFwiL1wiKX1cXGAgOiBcIlwiO1xufTtcbnZhciBIb3RrZXlBY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoSG90a2V5QWN0aW9uczIpID0+IChIb3RrZXlBY3Rpb25zMltIb3RrZXlBY3Rpb25zMi5FU0MgPSAwXSA9IFwiRVNDXCIsIEhvdGtleUFjdGlvbnMyW0hvdGtleUFjdGlvbnMyLkNUUkxfQUxUX0MgPSAxXSA9IFwiQ1RSTF9BTFRfQ1wiLCBIb3RrZXlBY3Rpb25zMikpKEhvdGtleUFjdGlvbnMgfHwge30pO1xuY29uc3QgaG90a2V5QWN0aW9uRGVmaW5pdGlvbnMgPSB7XG4gIDA6IHtcbiAgICBrZXlDb21ib0RlZmF1bHQ6IFwiRXNjXCIsXG4gICAga2V5Q29tYm9NYWM6IFwiZXNjXCIsXG4gICAgaXNFdmVudE1hdGNoaW5nOiAoZXYpID0+IGV2LmNvZGUgPT09IFwiRXNjYXBlXCJcbiAgfSxcbiAgMToge1xuICAgIGtleUNvbWJvRGVmYXVsdDogXCJDdHJsK0FsdCtDXCIsXG4gICAga2V5Q29tYm9NYWM6IFwi4oyYK+KMpStDXCIsXG4gICAgaXNFdmVudE1hdGNoaW5nOiAoZXYpID0+IGV2LmNvZGUgPT09IFwiS2V5Q1wiICYmIChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpICYmIGV2LmFsdEtleVxuICB9XG59LCBjdXN0b21Ud01lcmdlID0gZXh0ZW5kVGFpbHdpbmRNZXJnZSh7XG4gIGV4dGVuZDoge1xuICAgIGNsYXNzR3JvdXBzOiB7XG4gICAgICBcImJnLWltYWdlXCI6IFtcbiAgICAgICAgXCJiZy1ncmFkaWVudFwiLFxuICAgICAgICBcImJnLWdyYWRpZW50LWxpZ2h0LTFcIixcbiAgICAgICAgXCJiZy1ncmFkaWVudC1saWdodC0yXCIsXG4gICAgICAgIFwiYmctZ3JhZGllbnQtbGlnaHQtM1wiXG4gICAgICBdXG4gICAgfVxuICB9XG59KTtcbmZ1bmN0aW9uIGNuKC4uLmlucHV0cykge1xuICByZXR1cm4gY3VzdG9tVHdNZXJnZShjbHN4KGlucHV0cykpO1xufVxuY29uc3QgZ2VuZXJhdGVJZCA9IChsZW5ndGggPSAxNikgPT4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIGxlbmd0aCArIDIpLCBjb3B5T2JqZWN0ID0gKG9iaiwgZGVwdGggPSAwLCBtYXhEZXB0aCA9IDMpID0+IHtcbiAgaWYgKG9iaiA9PSBudWxsKVxuICAgIHJldHVybiBvYmo7XG4gIGlmICh0eXBlb2Ygb2JqICE9IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT0gXCJmdW5jdGlvblwiID8gdm9pZCAwIDogb2JqO1xuICBpZiAoZGVwdGggPj0gbWF4RGVwdGgpXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge307XG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpXG4gICAgcmV0dXJuIG9iai5tYXAoKGl0ZW0pID0+IGNvcHlPYmplY3QoaXRlbSwgZGVwdGggKyAxLCBtYXhEZXB0aCkpLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gdm9pZCAwKTtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikpXG4gICAgaWYgKCFleGNsdWRlZFByb3BlcnRpZXMuaGFzKGtleSkpXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgY29waWVkVmFsdWUgPSBjb3B5T2JqZWN0KHZhbHVlLCBkZXB0aCArIDEsIG1heERlcHRoKTtcbiAgICAgICAgY29waWVkVmFsdWUgIT09IHZvaWQgMCAmJiAocmVzdWx0W2tleV0gPSBjb3BpZWRWYWx1ZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gIHJldHVybiByZXN1bHQ7XG59LCBleGNsdWRlZFByb3BlcnRpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY29uc3RydWN0b3JcIixcbiAgXCJfX3Byb3RvX19cIixcbiAgXCJwcm90b3R5cGVcIixcbiAgXCJfX2RlZmluZUdldHRlcl9fXCIsXG4gIFwiX19kZWZpbmVTZXR0ZXJfX1wiLFxuICBcIl9fbG9va3VwR2V0dGVyX19cIixcbiAgXCJfX2xvb2t1cFNldHRlcl9fXCIsXG4gIFwiaGFzT3duUHJvcGVydHlcIixcbiAgXCJpc1Byb3RvdHlwZU9mXCIsXG4gIFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcbiAgXCJ0b1N0cmluZ1wiLFxuICBcInZhbHVlT2ZcIixcbiAgXCJ0b0xvY2FsZVN0cmluZ1wiXG5dKSwgdHJ1bmNhdGVTdHJpbmcgPSAoc3RyLCBtYXhMZW5ndGgpID0+IHN0ci5sZW5ndGggPD0gbWF4TGVuZ3RoID8gc3RyIDogXFxgXFwke3N0ci5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoIC0gMyl9Li4uXFxgLCB0cnVuY2F0ZUF0dHJpYnV0ZXMgPSAoYXR0cmlidXRlcykgPT4ge1xuICBjb25zdCByZXN1bHQgPSB7fSwgbGltaXRlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5zbGljZSgwLCAxMDApO1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBsaW1pdGVkRW50cmllcykge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAoLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICAgICAgXCJjbGFzc1wiLFxuICAgICAgXCJpZFwiLFxuICAgICAgXCJzdHlsZVwiLFxuICAgICAgXCJuYW1lXCIsXG4gICAgICBcInJvbGVcIixcbiAgICAgIFwiaHJlZlwiLFxuICAgICAgXCJmb3JcIixcbiAgICAgIFwicGxhY2Vob2xkZXJcIixcbiAgICAgIFwiYWx0XCIsXG4gICAgICBcInRpdGxlXCIsXG4gICAgICBcImFyaWFMYWJlbFwiLFxuICAgICAgXCJhcmlhUm9sZVwiLFxuICAgICAgXCJhcmlhRGVzY3JpcHRpb25cIlxuICAgIF0pKS5oYXMoa2V5KSA/IHJlc3VsdFtrZXldID0gdHJ1bmNhdGVTdHJpbmcodmFsdWUsIDQwOTYpIDogcmVzdWx0W2tleV0gPSB0cnVuY2F0ZVN0cmluZyh2YWx1ZSwgMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufSwgdHJ1bmNhdGVPd25Qcm9wZXJ0aWVzID0gKHByb3BlcnRpZXMpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0ge30sIGxpbWl0ZWRFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykuc2xpY2UoMCwgNTAwKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbGltaXRlZEVudHJpZXMpXG4gICAgcmVzdWx0W2tleV0gPSB0cnVuY2F0ZVZhbHVlKHZhbHVlLCAwLCAyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0sIHRydW5jYXRlVmFsdWUgPSAodmFsdWUsIGN1cnJlbnREZXB0aCwgbWF4RGVwdGgpID0+IHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB2YWx1ZTtcbiAgaWYgKGN1cnJlbnREZXB0aCA+PSBtYXhEZXB0aClcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBbXSA6IHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiID8ge30gOiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0cnVuY2F0ZVN0cmluZyh2YWx1ZSwgMTAyNCk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWUuc2xpY2UoMCwgNTApLm1hcCgoaXRlbSkgPT4gdHJ1bmNhdGVWYWx1ZShpdGVtLCBjdXJyZW50RGVwdGggKyAxLCBtYXhEZXB0aCkpO1xuICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fSwgbGltaXRlZEVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSkuc2xpY2UoMCwgNTApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiBsaW1pdGVkRW50cmllcylcbiAgICAgIHJlc3VsdFtrZXldID0gdHJ1bmNhdGVWYWx1ZSh2YWwsIGN1cnJlbnREZXB0aCArIDEsIG1heERlcHRoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn0sIHRydW5jYXRlUGx1Z2luSW5mbyA9IChwbHVnaW5JbmZvKSA9PiBwbHVnaW5JbmZvLm1hcCgocGx1Z2luKSA9PiAoe1xuICBwbHVnaW5OYW1lOiB0cnVuY2F0ZVN0cmluZyhwbHVnaW4ucGx1Z2luTmFtZSwgMTI4KSxcbiAgY29udGVudDogdHJ1bmNhdGVTdHJpbmcocGx1Z2luLmNvbnRlbnQsIDQwOTYpXG59KSksIGdldFNlbGVjdGVkRWxlbWVudEluZm8gPSAoZWxlbWVudCwgY2FsbERlcHRoKSA9PiB7XG4gIGNvbnN0IGJvdW5kaW5nUmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHJhd0F0dHJpYnV0ZXMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZU5hbWVzKCkucmVkdWNlKFxuICAgIChhY2MsIG5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgKGFjY1tuYW1lXSA9IHZhbHVlKSwgYWNjO1xuICAgIH0sXG4gICAge31cbiAgKSwgcmF3T3duUHJvcGVydGllcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVsZW1lbnQpLmZpbHRlcigocHJvcCkgPT4gIWV4Y2x1ZGVkUHJvcGVydGllcy5oYXMocHJvcCkpLnJlZHVjZShcbiAgICAoYWNjLCBwcm9wKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnRbcHJvcF07XG4gICAgICAgIHR5cGVvZiB2YWx1ZSAhPSBcImZ1bmN0aW9uXCIgJiYgKGFjY1twcm9wXSA9IGNvcHlPYmplY3QodmFsdWUsIDAsIDIpKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG4gIHJldHVybiB7XG4gICAgbm9kZVR5cGU6IHRydW5jYXRlU3RyaW5nKGVsZW1lbnQubm9kZU5hbWUsIDk2KSxcbiAgICB4cGF0aDogdHJ1bmNhdGVTdHJpbmcoZ2V0WFBhdGhGb3JFbGVtZW50KGVsZW1lbnQsICExKSwgMTAyNCksXG4gICAgYXR0cmlidXRlczogdHJ1bmNhdGVBdHRyaWJ1dGVzKHJhd0F0dHJpYnV0ZXMpLFxuICAgIHRleHRDb250ZW50OiB0cnVuY2F0ZVN0cmluZyhlbGVtZW50LnRleHRDb250ZW50IHx8IFwiXCIsIDUxMiksXG4gICAgb3duUHJvcGVydGllczogdHJ1bmNhdGVPd25Qcm9wZXJ0aWVzKHJhd093blByb3BlcnRpZXMpLFxuICAgIGJvdW5kaW5nQ2xpZW50UmVjdDoge1xuICAgICAgdG9wOiBib3VuZGluZ1JlY3QudG9wLFxuICAgICAgbGVmdDogYm91bmRpbmdSZWN0LmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kaW5nUmVjdC5oZWlnaHQsXG4gICAgICB3aWR0aDogYm91bmRpbmdSZWN0LndpZHRoXG4gICAgfSxcbiAgICBwYXJlbnQ6IGVsZW1lbnQucGFyZW50RWxlbWVudCAmJiAoY2FsbERlcHRoID8/IDApIDwgMTAgPyBnZXRTZWxlY3RlZEVsZW1lbnRJbmZvKGVsZW1lbnQucGFyZW50RWxlbWVudCwgKGNhbGxEZXB0aCA/PyAwKSArIDEpIDogbnVsbCxcbiAgICBwbHVnaW5JbmZvOiB0cnVuY2F0ZVBsdWdpbkluZm8oW10pXG4gIH07XG59LCBjb2xsZWN0VXNlck1lc3NhZ2VNZXRhZGF0YSA9IChzZWxlY3RlZEVsZW1lbnRzKSA9PiAoe1xuICBjdXJyZW50VXJsOiB0cnVuY2F0ZVN0cmluZyh3aW5kb3cucGFyZW50LmxvY2F0aW9uLmhyZWYsIDEwMjQpLFxuICBjdXJyZW50VGl0bGU6IHRydW5jYXRlU3RyaW5nKHdpbmRvdy5wYXJlbnQuZG9jdW1lbnQudGl0bGUsIDI1NiksXG4gIGN1cnJlbnRab29tTGV2ZWw6IDAsXG4gIGRldmljZVBpeGVsUmF0aW86IHdpbmRvdy5wYXJlbnQuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgdXNlckFnZW50OiB0cnVuY2F0ZVN0cmluZyh3aW5kb3cucGFyZW50Lm5hdmlnYXRvci51c2VyQWdlbnQsIDEwMjQpLFxuICBsb2NhbGU6IHRydW5jYXRlU3RyaW5nKHdpbmRvdy5wYXJlbnQubmF2aWdhdG9yLmxhbmd1YWdlLCA2NCksXG4gIHNlbGVjdGVkRWxlbWVudHMsXG4gIHZpZXdwb3J0UmVzb2x1dGlvbjoge1xuICAgIHdpZHRoOiB3aW5kb3cucGFyZW50LmlubmVyV2lkdGgsXG4gICAgaGVpZ2h0OiB3aW5kb3cucGFyZW50LmlubmVySGVpZ2h0XG4gIH1cbn0pLCBBcHBDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKSwgU1RPUkFHRV9LRVkkMSA9IFwic3Rnd3M6Y29tcGFuaW9uXCI7XG5mdW5jdGlvbiBsb2FkU3RhdGVGcm9tU3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZJDEpO1xuICAgIHJldHVybiBzdG9yZWQgPyBKU09OLnBhcnNlKHN0b3JlZCkgOiB7fTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBsb2FkIHN0YXRlIGZyb20gc3RvcmFnZTpcIiwgZXJyb3IpLCB7fTtcbiAgfVxufVxuZnVuY3Rpb24gc2F2ZVN0YXRlVG9TdG9yYWdlKHN0YXRlKSB7XG4gIHRyeSB7XG4gICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSQxLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gc2F2ZSBzdGF0ZSB0byBzdG9yYWdlOlwiLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIEFwcFN0YXRlUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlZFN0YXRlID0gbG9hZFN0YXRlRnJvbVN0b3JhZ2UoKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXBwQmxvY2tSZXF1ZXN0TGlzdDogW10sXG4gICAgICBhcHBVbmJsb2NrUmVxdWVzdExpc3Q6IFtdLFxuICAgICAgbGFzdEJsb2NrUmVxdWVzdE51bWJlcjogMCxcbiAgICAgIGxhc3RVbmJsb2NrUmVxdWVzdE51bWJlcjogMCxcbiAgICAgIGlzTWFpbkFwcEJsb2NrZWQ6ICExLFxuICAgICAgdG9vbGJhckJveFJlZjogY3JlYXRlUmVmKCksXG4gICAgICBtaW5pbWl6ZWQ6IHN0b3JlZFN0YXRlLm1pbmltaXplZCA/PyAhMSxcbiAgICAgIHJlcXVlc3RNYWluQXBwQmxvY2s6ICgpID0+IDAsXG4gICAgICAvLyBUaGVzZSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb25zXG4gICAgICByZXF1ZXN0TWFpbkFwcFVuYmxvY2s6ICgpID0+IDAsXG4gICAgICBkaXNjYXJkTWFpbkFwcEJsb2NrOiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgZGlzY2FyZE1haW5BcHBVbmJsb2NrOiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgc2V0VG9vbGJhckJveFJlZjogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIHVuc2V0VG9vbGJhckJveFJlZjogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIG1pbmltaXplOiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgZXhwYW5kOiAoKSA9PiB7XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2F2ZVN0YXRlVG9TdG9yYWdlKHtcbiAgICAgIG1pbmltaXplZDogc3RhdGUubWluaW1pemVkXG4gICAgfSk7XG4gIH0sIFtzdGF0ZS5taW5pbWl6ZWRdKTtcbiAgY29uc3QgcmVxdWVzdE1haW5BcHBCbG9jayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBsZXQgbmV3SGFuZGxlVmFsdWUgPSAwO1xuICAgIHJldHVybiBzZXRTdGF0ZSgocHJldikgPT4gKG5ld0hhbmRsZVZhbHVlID0gcHJldi5sYXN0QmxvY2tSZXF1ZXN0TnVtYmVyICsgMSwge1xuICAgICAgLi4ucHJldixcbiAgICAgIGFwcEJsb2NrUmVxdWVzdExpc3Q6IFsuLi5wcmV2LmFwcEJsb2NrUmVxdWVzdExpc3QsIG5ld0hhbmRsZVZhbHVlXSxcbiAgICAgIGxhc3RCbG9ja1JlcXVlc3ROdW1iZXI6IG5ld0hhbmRsZVZhbHVlLFxuICAgICAgaXNNYWluQXBwQmxvY2tlZDogcHJldi5hcHBVbmJsb2NrUmVxdWVzdExpc3QubGVuZ3RoID09PSAwXG4gICAgfSkpLCBuZXdIYW5kbGVWYWx1ZTtcbiAgfSwgW10pLCByZXF1ZXN0TWFpbkFwcFVuYmxvY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgbGV0IG5ld0hhbmRsZVZhbHVlID0gMDtcbiAgICByZXR1cm4gc2V0U3RhdGUoKHByZXYpID0+IChuZXdIYW5kbGVWYWx1ZSA9IHByZXYubGFzdFVuYmxvY2tSZXF1ZXN0TnVtYmVyICsgMSwge1xuICAgICAgLi4ucHJldixcbiAgICAgIGFwcFVuYmxvY2tSZXF1ZXN0TGlzdDogWy4uLnByZXYuYXBwVW5ibG9ja1JlcXVlc3RMaXN0LCBuZXdIYW5kbGVWYWx1ZV0sXG4gICAgICBsYXN0VW5ibG9ja1JlcXVlc3ROdW1iZXI6IG5ld0hhbmRsZVZhbHVlLFxuICAgICAgaXNNYWluQXBwQmxvY2tlZDogITFcbiAgICB9KSksIG5ld0hhbmRsZVZhbHVlO1xuICB9LCBbXSksIGRpc2NhcmRNYWluQXBwQmxvY2sgPSB1c2VDYWxsYmFjaygoaGFuZGxlKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5ld0Jsb2NrUmVxdWVzdExpc3QgPSBwcmV2LmFwcEJsb2NrUmVxdWVzdExpc3QuZmlsdGVyKFxuICAgICAgICAoaCkgPT4gaCAhPT0gaGFuZGxlXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgYXBwQmxvY2tSZXF1ZXN0TGlzdDogbmV3QmxvY2tSZXF1ZXN0TGlzdCxcbiAgICAgICAgaXNNYWluQXBwQmxvY2tlZDogbmV3QmxvY2tSZXF1ZXN0TGlzdC5sZW5ndGggPiAwICYmIHByZXYuYXBwVW5ibG9ja1JlcXVlc3RMaXN0Lmxlbmd0aCA9PT0gMFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSwgW10pLCBkaXNjYXJkTWFpbkFwcFVuYmxvY2sgPSB1c2VDYWxsYmFjaygoaGFuZGxlKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+IHtcbiAgICAgIGNvbnN0IG5ld1VuYmxvY2tSZXF1ZXN0TGlzdCA9IHByZXYuYXBwVW5ibG9ja1JlcXVlc3RMaXN0LmZpbHRlcihcbiAgICAgICAgKGgpID0+IGggIT09IGhhbmRsZVxuICAgICAgKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGFwcFVuYmxvY2tSZXF1ZXN0TGlzdDogbmV3VW5ibG9ja1JlcXVlc3RMaXN0LFxuICAgICAgICBpc01haW5BcHBCbG9ja2VkOiBwcmV2LmFwcEJsb2NrUmVxdWVzdExpc3QubGVuZ3RoID4gMCAmJiBuZXdVbmJsb2NrUmVxdWVzdExpc3QubGVuZ3RoID09PSAwXG4gICAgICB9O1xuICAgIH0pO1xuICB9LCBbXSksIHNldFRvb2xiYXJCb3hSZWYgPSB1c2VDYWxsYmFjaygocmVmKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIHRvb2xiYXJCb3hSZWY6IHJlZiB9KSk7XG4gIH0sIFtdKSwgdW5zZXRUb29sYmFyQm94UmVmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldFN0YXRlKChwcmV2KSA9PiAoeyAuLi5wcmV2LCB0b29sYmFyQm94UmVmOiBjcmVhdGVSZWYoKSB9KSk7XG4gIH0sIFtdKSwgbWluaW1pemUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0U3RhdGUoKHByZXYpID0+ICh7IC4uLnByZXYsIG1pbmltaXplZDogITAgfSkpO1xuICB9LCBbXSksIGV4cGFuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRTdGF0ZSgocHJldikgPT4gKHsgLi4ucHJldiwgbWluaW1pemVkOiAhMSB9KSk7XG4gIH0sIFtdKSwgdmFsdWUgPSB7XG4gICAgcmVxdWVzdE1haW5BcHBCbG9jayxcbiAgICByZXF1ZXN0TWFpbkFwcFVuYmxvY2ssXG4gICAgZGlzY2FyZE1haW5BcHBCbG9jayxcbiAgICBkaXNjYXJkTWFpbkFwcFVuYmxvY2ssXG4gICAgaXNNYWluQXBwQmxvY2tlZDogc3RhdGUuaXNNYWluQXBwQmxvY2tlZCxcbiAgICB0b29sYmFyQm94UmVmOiBzdGF0ZS50b29sYmFyQm94UmVmLFxuICAgIHNldFRvb2xiYXJCb3hSZWYsXG4gICAgdW5zZXRUb29sYmFyQm94UmVmLFxuICAgIG1pbmltaXplZDogc3RhdGUubWluaW1pemVkLFxuICAgIG1pbmltaXplLFxuICAgIGV4cGFuZFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChBcHBDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlLCBjaGlsZHJlbiB9KTtcbn1cbmZ1bmN0aW9uIHVzZUFwcFN0YXRlKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChBcHBDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUFwcFN0YXRlIG11c3QgYmUgdXNlZCB3aXRoaW4gYW4gQXBwU3RhdGVQcm92aWRlclwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5jb25zdCBhZ2VudEF2YWlsYWJpbGl0eUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgaXNBdmFpbGFibGU6ICExLFxuICBlcnJvcjogQWdlbnRBdmFpbGFiaWxpdHlFcnJvci5OT19DT05ORUNUSU9OXG59KTtcbmZ1bmN0aW9uIEFnZW50QXZhaWxhYmlsaXR5UHJvdmlkZXIoe1xuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBhZ2VudCA9IHVzZUFnZW50cygpLmNvbm5lY3RlZCwgW2F2YWlsYWJpbGl0eSwgc2V0QXZhaWxhYmlsaXR5XSA9IHVzZVN0YXRlKHtcbiAgICBpc0F2YWlsYWJsZTogITEsXG4gICAgZXJyb3I6IEFnZW50QXZhaWxhYmlsaXR5RXJyb3IuTk9fQ09OTkVDVElPTlxuICB9KTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFnZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhZ2VudC5hZ2VudC5hdmFpbGFiaWxpdHkuZ2V0QXZhaWxhYmlsaXR5LnN1YnNjcmliZShcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB7XG4gICAgICAgICAgb25EYXRhOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHNldEF2YWlsYWJpbGl0eSh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRBdmFpbGFiaWxpdHkoe1xuICAgICAgICAgICAgICBpc0F2YWlsYWJsZTogITEsXG4gICAgICAgICAgICAgIGVycm9yOiBBZ2VudEF2YWlsYWJpbGl0eUVycm9yLk5PX0NPTk5FQ1RJT05cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5kZWJ1ZyhcbiAgICAgICAgICAgIFwiW0FnZW50QXZhaWxhYmlsaXR5UHJvdmlkZXJdIEVycm9yIHVuc3Vic2NyaWJpbmcgZnJvbSBhdmFpbGFiaWxpdHk6XCIsXG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICBzZXRBdmFpbGFiaWxpdHkoe1xuICAgICAgICBpc0F2YWlsYWJsZTogITEsXG4gICAgICAgIGVycm9yOiBBZ2VudEF2YWlsYWJpbGl0eUVycm9yLk5PX0NPTk5FQ1RJT05cbiAgICAgIH0pO1xuICB9LCBbYWdlbnRdKSwgLyogQF9fUFVSRV9fICovIGpzeChhZ2VudEF2YWlsYWJpbGl0eUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGF2YWlsYWJpbGl0eSwgY2hpbGRyZW4gfSk7XG59XG5jb25zdCB1c2VBZ2VudEF2YWlsYWJpbGl0eSA9ICgpID0+IHVzZUNvbnRleHQoYWdlbnRBdmFpbGFiaWxpdHlDb250ZXh0KSwgU1RPUkFHRV9LRVkgPSBcInN0YWdld2lzZV90b29sYmFyX29wZW5fcGFuZWxzXCIsIGxvYWRQZXJzaXN0ZWRTdGF0ZSA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdG9yZWQgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcbiAgICByZXR1cm4gc3RvcmVkID8gSlNPTi5wYXJzZShzdG9yZWQpIDoge307XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcIltQYW5lbHNQcm92aWRlcl0gRmFpbGVkIHRvIGxvYWQgcGVyc2lzdGVkIHN0YXRlOlwiLCBlcnJvciksIHt9O1xuICB9XG59LCBzYXZlUGVyc2lzdGVkU3RhdGUgPSAoc3RhdGUpID0+IHtcbiAgdHJ5IHtcbiAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihcIltQYW5lbHNQcm92aWRlcl0gRmFpbGVkIHRvIHNhdmUgcGVyc2lzdGVkIHN0YXRlOlwiLCBlcnJvcik7XG4gIH1cbn0sIFBhbmVsc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgaXNTZXR0aW5nc09wZW46ICExLFxuICBvcGVuU2V0dGluZ3M6ICgpID0+IG51bGwsXG4gIGNsb3NlU2V0dGluZ3M6ICgpID0+IG51bGwsXG4gIGlzQ2hhdE9wZW46ICExLFxuICBvcGVuQ2hhdDogKCkgPT4gbnVsbCxcbiAgY2xvc2VDaGF0OiAoKSA9PiBudWxsLFxuICBvcGVuUGx1Z2luTmFtZTogbnVsbCxcbiAgb3BlblBsdWdpbjogKCkgPT4gbnVsbCxcbiAgY2xvc2VQbHVnaW46ICgpID0+IG51bGwsXG4gIGlzQWdlbnRDb25uZWN0aXZpdHlPcGVuOiAhMSxcbiAgb3BlbkFnZW50Q29ubmVjdGl2aXR5OiAoKSA9PiBudWxsLFxuICBjbG9zZUFnZW50Q29ubmVjdGl2aXR5OiAoKSA9PiBudWxsXG59KSwgUGFuZWxzUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCB7IG1pbmltaXplZCB9ID0gdXNlQXBwU3RhdGUoKSwgcGVyc2lzdGVkU3RhdGUgPSB1c2VNZW1vKCgpID0+IGxvYWRQZXJzaXN0ZWRTdGF0ZSgpLCBbXSksIFtpc1NldHRpbmdzT3BlbkludGVybmFsLCBzZXRJc1NldHRpbmdzT3Blbl0gPSB1c2VTdGF0ZShcbiAgICBwZXJzaXN0ZWRTdGF0ZS5pc1NldHRpbmdzT3BlbiA/PyAhMVxuICApLCBbaXNDaGF0T3BlbkludGVybmFsLCBzZXRJc0NoYXRPcGVuXSA9IHVzZVN0YXRlKFxuICAgIHBlcnNpc3RlZFN0YXRlLmlzQ2hhdE9wZW4gPz8gITFcbiAgKSwgW29wZW5QbHVnaW5JbnRlcm5hbCwgc2V0T3BlblBsdWdpbl0gPSB1c2VTdGF0ZShcbiAgICBwZXJzaXN0ZWRTdGF0ZS5vcGVuUGx1Z2luID8/IG51bGxcbiAgKSwge1xuICAgIGNvbm5lY3RlZCxcbiAgICBjb25uZWN0ZWRVbmF2YWlsYWJsZSxcbiAgICByZXF1aXJlc1VzZXJBdHRlbnRpb24sXG4gICAgaXNJbml0aWFsTG9hZFxuICB9ID0gdXNlQWdlbnRzKCksIGF2YWlsYWJpbGl0eVN0YXR1cyA9IHVzZUFnZW50QXZhaWxhYmlsaXR5KCksIFtcbiAgICBhZ2VudENvbm5lY3Rpdml0eU1hbnVhbGx5RGlzbWlzc2VkLFxuICAgIHNldEFnZW50Q29ubmVjdGl2aXR5TWFudWFsbHlEaXNtaXNzZWRcbiAgXSA9IHVzZVN0YXRlKHBlcnNpc3RlZFN0YXRlLmFnZW50Q29ubmVjdGl2aXR5TWFudWFsbHlEaXNtaXNzZWQgPz8gITEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNhdmVQZXJzaXN0ZWRTdGF0ZSh7XG4gICAgICBpc1NldHRpbmdzT3BlbjogaXNTZXR0aW5nc09wZW5JbnRlcm5hbCxcbiAgICAgIGlzQ2hhdE9wZW46IGlzQ2hhdE9wZW5JbnRlcm5hbCxcbiAgICAgIG9wZW5QbHVnaW46IG9wZW5QbHVnaW5JbnRlcm5hbCxcbiAgICAgIGFnZW50Q29ubmVjdGl2aXR5TWFudWFsbHlEaXNtaXNzZWRcbiAgICB9KTtcbiAgfSwgW1xuICAgIGlzU2V0dGluZ3NPcGVuSW50ZXJuYWwsXG4gICAgaXNDaGF0T3BlbkludGVybmFsLFxuICAgIG9wZW5QbHVnaW5JbnRlcm5hbCxcbiAgICBhZ2VudENvbm5lY3Rpdml0eU1hbnVhbGx5RGlzbWlzc2VkXG4gIF0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbm5lY3RlZCAmJiAhY29ubmVjdGVkVW5hdmFpbGFibGUgJiYgYXZhaWxhYmlsaXR5U3RhdHVzLmlzQXZhaWxhYmxlICYmIHNldEFnZW50Q29ubmVjdGl2aXR5TWFudWFsbHlEaXNtaXNzZWQoITEpO1xuICB9LCBbY29ubmVjdGVkLCBjb25uZWN0ZWRVbmF2YWlsYWJsZSwgYXZhaWxhYmlsaXR5U3RhdHVzXSk7XG4gIGNvbnN0IGlzQWdlbnRDb25uZWN0aXZpdHlPcGVuID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gKHJlcXVpcmVzVXNlckF0dGVudGlvbiB8fCAhYXZhaWxhYmlsaXR5U3RhdHVzLmlzQXZhaWxhYmxlKSAmJiAhYWdlbnRDb25uZWN0aXZpdHlNYW51YWxseURpc21pc3NlZCAmJiAhbWluaW1pemVkICYmICFpc0luaXRpYWxMb2FkO1xuICAgIHJldHVybiBjb25zb2xlLmRlYnVnKFwiW1BhbmVsc1Byb3ZpZGVyXSBpc0FnZW50Q29ubmVjdGl2aXR5T3BlbiBjYWxjdWxhdGlvbjpcIiwge1xuICAgICAgcmVxdWlyZXNVc2VyQXR0ZW50aW9uLFxuICAgICAgYXZhaWxhYmlsaXR5U3RhdHVzOiBhdmFpbGFiaWxpdHlTdGF0dXMuaXNBdmFpbGFibGUsXG4gICAgICBhZ2VudENvbm5lY3Rpdml0eU1hbnVhbGx5RGlzbWlzc2VkLFxuICAgICAgbWluaW1pemVkLFxuICAgICAgaXNJbml0aWFsTG9hZCxcbiAgICAgIHJlc3VsdFxuICAgIH0pLCByZXN1bHQ7XG4gIH0sIFtcbiAgICByZXF1aXJlc1VzZXJBdHRlbnRpb24sXG4gICAgYWdlbnRDb25uZWN0aXZpdHlNYW51YWxseURpc21pc3NlZCxcbiAgICBtaW5pbWl6ZWQsXG4gICAgaXNJbml0aWFsTG9hZCxcbiAgICBhdmFpbGFiaWxpdHlTdGF0dXNcbiAgXSksIGlzU2V0dGluZ3NPcGVuID0gdXNlTWVtbygoKSA9PiAhcmVxdWlyZXNVc2VyQXR0ZW50aW9uICYmIGF2YWlsYWJpbGl0eVN0YXR1cy5pc0F2YWlsYWJsZSAmJiBpc1NldHRpbmdzT3BlbkludGVybmFsICYmICFtaW5pbWl6ZWQgJiYgIWlzSW5pdGlhbExvYWQsIFtcbiAgICByZXF1aXJlc1VzZXJBdHRlbnRpb24sXG4gICAgYXZhaWxhYmlsaXR5U3RhdHVzLFxuICAgIGlzU2V0dGluZ3NPcGVuSW50ZXJuYWwsXG4gICAgbWluaW1pemVkLFxuICAgIGlzSW5pdGlhbExvYWRcbiAgXSksIGlzQ2hhdE9wZW4gPSB1c2VNZW1vKCgpID0+ICFyZXF1aXJlc1VzZXJBdHRlbnRpb24gJiYgYXZhaWxhYmlsaXR5U3RhdHVzLmlzQXZhaWxhYmxlICYmIGlzQ2hhdE9wZW5JbnRlcm5hbCAmJiAhbWluaW1pemVkICYmICFpc0luaXRpYWxMb2FkLCBbXG4gICAgcmVxdWlyZXNVc2VyQXR0ZW50aW9uLFxuICAgIGF2YWlsYWJpbGl0eVN0YXR1cyxcbiAgICBpc0NoYXRPcGVuSW50ZXJuYWwsXG4gICAgbWluaW1pemVkLFxuICAgIGlzSW5pdGlhbExvYWRcbiAgXSksIG9wZW5QbHVnaW5OYW1lID0gdXNlTWVtbygoKSA9PiAhcmVxdWlyZXNVc2VyQXR0ZW50aW9uICYmIGF2YWlsYWJpbGl0eVN0YXR1cy5pc0F2YWlsYWJsZSAmJiAhaXNJbml0aWFsTG9hZCAmJiAhbWluaW1pemVkID8gb3BlblBsdWdpbkludGVybmFsIDogbnVsbCwgW1xuICAgIHJlcXVpcmVzVXNlckF0dGVudGlvbixcbiAgICBhdmFpbGFiaWxpdHlTdGF0dXMsXG4gICAgb3BlblBsdWdpbkludGVybmFsLFxuICAgIG1pbmltaXplZCxcbiAgICBpc0luaXRpYWxMb2FkXG4gIF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBQYW5lbHNDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGlzU2V0dGluZ3NPcGVuLFxuICAgICAgICBvcGVuU2V0dGluZ3M6ICgpID0+IHNldElzU2V0dGluZ3NPcGVuKCEwKSxcbiAgICAgICAgY2xvc2VTZXR0aW5nczogKCkgPT4gc2V0SXNTZXR0aW5nc09wZW4oITEpLFxuICAgICAgICBpc0NoYXRPcGVuLFxuICAgICAgICBvcGVuQ2hhdDogKCkgPT4gc2V0SXNDaGF0T3BlbighMCksXG4gICAgICAgIGNsb3NlQ2hhdDogKCkgPT4gc2V0SXNDaGF0T3BlbighMSksXG4gICAgICAgIG9wZW5QbHVnaW5OYW1lLFxuICAgICAgICBvcGVuUGx1Z2luOiAocGx1Z2luTmFtZSkgPT4gc2V0T3BlblBsdWdpbihwbHVnaW5OYW1lKSxcbiAgICAgICAgY2xvc2VQbHVnaW46ICgpID0+IHNldE9wZW5QbHVnaW4obnVsbCksXG4gICAgICAgIGlzQWdlbnRDb25uZWN0aXZpdHlPcGVuLFxuICAgICAgICBvcGVuQWdlbnRDb25uZWN0aXZpdHk6ICgpID0+IHNldEFnZW50Q29ubmVjdGl2aXR5TWFudWFsbHlEaXNtaXNzZWQoITEpLFxuICAgICAgICBjbG9zZUFnZW50Q29ubmVjdGl2aXR5OiAoKSA9PiBzZXRBZ2VudENvbm5lY3Rpdml0eU1hbnVhbGx5RGlzbWlzc2VkKCEwKVxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfVxuICApO1xufSwgdXNlUGFuZWxzID0gKCkgPT4gdXNlQ29udGV4dChQYW5lbHNDb250ZXh0KSwgUGx1Z2luQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICBwbHVnaW5zOiBbXSxcbiAgdG9vbGJhckNvbnRleHQ6IHtcbiAgICBzZW5kUHJvbXB0OiAoKSA9PiB7XG4gICAgfSxcbiAgICBtYWluQXBwV2luZG93OiB3aW5kb3cucGFyZW50XG4gIH1cbn0pO1xuZnVuY3Rpb24gUGx1Z2luUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IHsgY29uZmlnIH0gPSB1c2VDb25maWcoKSwgeyBzZW5kTWVzc2FnZSB9ID0gdXNlQWdlbnRNZXNzYWdpbmcoKSwgeyBvcGVuQ2hhdCB9ID0gdXNlUGFuZWxzKCksIHBsdWdpbnMgPSAoY29uZmlnID09IG51bGwgPyB2b2lkIDAgOiBjb25maWcucGx1Z2lucykgfHwgW10sIHRvb2xiYXJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHNlbmRQcm9tcHQ6IGFzeW5jIChwcm9tcHQpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJNZXNzYWdlID0ge1xuICAgICAgICAuLi5wcm9tcHQsXG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgIGNyZWF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIHNlbnRCeVBsdWdpbjogITAsXG4gICAgICAgIG1ldGFkYXRhOiBjb2xsZWN0VXNlck1lc3NhZ2VNZXRhZGF0YShbXSksXG4gICAgICAgIHBsdWdpbkNvbnRlbnQ6IHt9XG4gICAgICB9O1xuICAgICAgc2VuZE1lc3NhZ2UodXNlck1lc3NhZ2UpLCBvcGVuQ2hhdCgpO1xuICAgIH0sXG4gICAgbWFpbkFwcFdpbmRvdzogd2luZG93LnBhcmVudFxuICB9KSwgW3NlbmRNZXNzYWdlXSksIHBsdWdpbnNMb2FkZWRSZWYgPSB1c2VSZWYoITEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHBsdWdpbnNMb2FkZWRSZWYuY3VycmVudCB8fCAocGx1Z2luc0xvYWRlZFJlZi5jdXJyZW50ID0gITAsIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBwbHVnaW4ub25Mb2FkKSA9PSBudWxsIHx8IF9hLmNhbGwocGx1Z2luLCB0b29sYmFyQ29udGV4dCk7XG4gICAgfSkpO1xuICB9LCBbcGx1Z2lucywgdG9vbGJhckNvbnRleHRdKTtcbiAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgcGx1Z2lucyxcbiAgICB0b29sYmFyQ29udGV4dFxuICB9KSwgW3BsdWdpbnMsIHRvb2xiYXJDb250ZXh0XSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFBsdWdpbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlUGx1Z2lucygpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUGx1Z2luQ29udGV4dCk7XG59XG5jb25zdCBnbGFzc3lCb3hDbGFzc05hbWUgPSBcXGBcbiAgei0wXG4gIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6Y29udGVudC1ub3JtYWwgYmVmb3JlOnNpemUtZnVsbCBiZWZvcmU6aW5zZXQtMCBiZWZvcmU6Ym9yZGVyIGJlZm9yZTpib3JkZXItemluYy05NTAvMjAgYmVmb3JlOnJpbmctaW5zZXQgYmVmb3JlOnJpbmctWzEuNXB4XSBiZWZvcmU6cmluZy13aGl0ZS8zMCBiZWZvcmU6YmFja2Ryb3AtYmx1ci1zbSBiZWZvcmU6LXotMjAgYmVmb3JlOmJnLXdoaXRlLzg1IGJlZm9yZTpyb3VuZGVkLVtpbmhlcml0XVxuICBhZnRlcjphYnNvbHV0ZSBhZnRlcjpwb2ludGVyLWV2ZW50cy1ub25lIGFmdGVyOnJvdW5kZWQtW2luaGVyaXRdIGFmdGVyOmJsb2NrIGFmdGVyOnNpemUtZnVsbCBhZnRlcjppbnNldC0wIGFmdGVyOnNoYWRvdy1nbGFzc1xuXFxgO1xuZnVuY3Rpb24gR2xhc3N5KHtcbiAgY2xhc3NOYW1lLFxuICBhcyxcbiAgcmVmLFxuICBjaGlsZHJlbixcbiAgLi4ucHJvcHNcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIGFzIHx8IFwiZGl2XCIsXG4gICAge1xuICAgICAgcmVmLFxuICAgICAgY2xhc3NOYW1lOiBjbihnbGFzc3lCb3hDbGFzc05hbWUsIGNsYXNzTmFtZSksXG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiLXotMTAgcG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSBpbnNldC0wIGZsZXggc2l6ZS1mdWxsIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1baW5oZXJpdF1cIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic2l6ZS1mdWxsIG1pbi1oLTQ4IG1pbi13LTQ4IGJnLVtpbWFnZTp2YXIoLS1nbGFzcy10ZXh0dXJlKV0gYmctY2VudGVyIGJnLWNvdmVyIGJnLW5vLXJlcGVhdCBvcGFjaXR5LTMwXCIgfSkgfSksXG4gICAgICAgIGNoaWxkcmVuXG4gICAgICBdXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUGFuZWwoe1xuICBjaGlsZHJlbixcbiAgYWx3YXlzRnVsbEhlaWdodCA9ICExLFxuICBjbGFzc05hbWVcbn0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgR2xhc3N5LFxuICAgIHtcbiAgICAgIGFzOiBcInNlY3Rpb25cIixcbiAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgIFwicG9pbnRlci1ldmVudHMtYXV0byBmbGV4IG1heC1oLWZ1bGwgbWluLWgtNDggZmxleC1jb2wgaXRlbXMtc3RyZXRjaCBqdXN0aWZ5LXN0YXJ0IHJvdW5kZWQtM3hsXCIsXG4gICAgICAgIGFsd2F5c0Z1bGxIZWlnaHQgJiYgXCJoLWZ1bGxcIixcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApLFxuICAgICAgY2hpbGRyZW5cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBQYW5lbEhlYWRlcih7XG4gIHRpdGxlLFxuICBkZXNjcmlwdGlvbixcbiAgaWNvbkFyZWEsXG4gIGFjdGlvbkFyZWEsXG4gIGNsYXNzTmFtZVxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgXCJoZWFkZXJcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBcImZsZXggdy1hdXRvIGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gZ2FwLTIgcm91bmRlZC10LVtpbmhlcml0XSBib3JkZXItemluYy01MDAvMTUgYm9yZGVyLWIgYmctZ3JhZGllbnQtdG8tYiBmcm9tLXRyYW5zcGFyZW50IHZpYS10cmFuc3BhcmVudCB0by13aGl0ZS81IHB0LTMgcHItMyBwYi0yIHBsLTQgdGV4dC1mb3JlZ3JvdW5kXCIsXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIGljb25BcmVhLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmbGV4IGZsZXgtMSBmbGV4LWNvbFwiLCBjaGlsZHJlbjogW1xuICAgICAgICAgIHRpdGxlICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJoM1wiLCB7IGNsYXNzTmFtZTogXCJmb250LW1lZGl1bSB0ZXh0LWxnXCIsIGNoaWxkcmVuOiB0aXRsZSB9KSxcbiAgICAgICAgICBkZXNjcmlwdGlvbiAmJiAvKiBAX19QVVJFX18gKi8ganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJmb250LW1lZGl1bSB0ZXh0LWZvcmVncm91bmQvNzBcIiwgY2hpbGRyZW46IGRlc2NyaXB0aW9uIH0pXG4gICAgICAgIF0gfSksXG4gICAgICAgIGFjdGlvbkFyZWEsXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSByaWdodC0wIGJvdHRvbS0wIGxlZnQtMCBoLXB4IHctZnVsbCBiZy1ncmFkaWVudC10by1yIGZyb20td2hpdGUvMTAgdmlhLXdoaXRlLzMwIHRvLXdoaXRlLzEwXCIgfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBQYW5lbENvbnRlbnQoeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5wcm9wcyB9KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBcImZsZXggZmxleC0xIGZsZXgtY29sIGdhcC0yIG92ZXJmbG93LXktYXV0byBweC00IHB5LTQgdGV4dC1mb3JlZ3JvdW5kXCIsXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKSxcbiAgICAgIGNoaWxkcmVuXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gUGFuZWxGb290ZXIoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lXG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICBcImZvb3RlclwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgIFwiZmxleCBmbGV4LXJvdyBpdGVtcy1lbmQganVzdGlmeS1lbmQgZ2FwLTIgcm91bmRlZC1iLVtpbmhlcml0XSBib3JkZXItemluYy01MDAvMTUgYm9yZGVyLXQgYmctd2hpdGUvNSBwdC0yIHByLTMgcGItMyBwbC00IHRleHQtZm9yZWdyb3VuZC84MCB0ZXh0LXNtXCIsXG4gICAgICAgIGNsYXNzTmFtZVxuICAgICAgKSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgdG9wLTAgcmlnaHQtMCBsZWZ0LTAgaC1weCB3LWZ1bGwgYmctZ3JhZGllbnQtdG8tciBmcm9tLXppbmMtMTAwLzEwIHZpYS16aW5jLTEwMC8zMCB0by16aW5jLTEwMC8xMFwiIH0pLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgXVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEJ1dHRvbih7XG4gIGNoaWxkcmVuLFxuICB2YXJpYW50ID0gXCJwcmltYXJ5XCIsXG4gIHNpemUgPSBcIm1kXCIsXG4gIGdsYXNzeSA9ICEwLFxuICBhc0NoaWxkLFxuICBjbGFzc05hbWUsXG4gIC4uLnByb3BzXG59KSB7XG4gIHJldHVybiBhc0NoaWxkID8gLyogQF9fUFVSRV9fICovIGpzeChcImJ1dHRvblwiLCB7IC4uLnByb3BzLCBjbGFzc05hbWU6IFwiY3Vyc29yLXBvaW50ZXJcIiwgY2hpbGRyZW4gfSkgOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwiYnV0dG9uXCIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBcImZsZXggaC0xMiBjdXJzb3ItcG9pbnRlciBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC1sZyBweC00IHB5LTIgZm9udC1tZWRpdW0gdGV4dC1zbSB0ZXh0LXdoaXRlXCIsXG4gICAgICAgIHNpemUgPT09IFwic21cIiAmJiBcImgtOFwiLFxuICAgICAgICBzaXplID09PSBcIm1kXCIgJiYgXCJoLTEyXCIsXG4gICAgICAgIHNpemUgPT09IFwibGdcIiAmJiBcImgtMTZcIixcbiAgICAgICAgdmFyaWFudCA9PT0gXCJwcmltYXJ5XCIgJiYgXCJiZy1ibHVlLTYwMFwiLFxuICAgICAgICB2YXJpYW50ID09PSBcInNlY29uZGFyeVwiICYmIFwiYmctYmxhY2svNSB0ZXh0LXppbmMtOTUwLzcwXCIsXG4gICAgICAgIHZhcmlhbnQgPT09IFwib3V0bGluZVwiICYmIFwiYm9yZGVyIGJvcmRlci16aW5jLTUwMCBiZy13aGl0ZSB0ZXh0LWJsdWUtNTAwXCIsXG4gICAgICAgIHZhcmlhbnQgPT09IFwiZ2hvc3RcIiAmJiBcImJnLXRyYW5zcGFyZW50IHRleHQtYmx1ZS01MDBcIixcbiAgICAgICAgZ2xhc3N5ICYmIFwib3JpZ2luLWNlbnRlciByb3VuZGVkLXhsIGJvcmRlciBib3JkZXItYmxhY2svMTAgcmluZy0xIHJpbmctd2hpdGUvMjAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMTUwIGVhc2Utb3V0IGFmdGVyOmFic29sdXRlIGFmdGVyOmluc2V0LTAgYWZ0ZXI6c2l6ZS1mdWxsIGFmdGVyOmNvbnRlbnQtbm9ybWFsIGFmdGVyOnJvdW5kZWQtW2luaGVyaXRdIGFmdGVyOmJnLWdyYWRpZW50LXRvLWIgYWZ0ZXI6ZnJvbS13aGl0ZS81IGFmdGVyOnRvLXdoaXRlLzAgYWZ0ZXI6dHJhbnNpdGlvbi1jb2xvcnMgYWZ0ZXI6ZHVyYXRpb24tMTUwIGFmdGVyOmVhc2Utb3V0IGhvdmVyOmJvcmRlci1ibGFjay81IGhvdmVyOnNoYWRvdy14cyBob3ZlcjphZnRlcjpmcm9tLWJsdWUtNTAvMjAgaG92ZXI6YWZ0ZXI6dG8tYmx1ZS01MC8xNSBhY3RpdmU6c2NhbGUtWzk4JV0gYWN0aXZlOmJvcmRlci1ibGFjay8xNSBhY3RpdmU6c2hhZG93LWluc2V0IGFjdGl2ZTphZnRlcjpmcm9tLXRyYW5zcGFyZW50IGFjdGl2ZTphZnRlcjp0by10cmFuc3BhcmVudCBkaXNhYmxlZDpwb2ludGVyLWV2ZW50cy1ub25lIGRpc2FibGVkOmJnLWJsYWNrLzUgZGlzYWJsZWQ6dGV4dC1mb3JlZ3JvdW5kLzYwIGRpc2FibGVkOm9wYWNpdHktMzBcIixcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApLFxuICAgICAgdHlwZTogXCJzdWJtaXRcIixcbiAgICAgIGNoaWxkcmVuXG4gICAgfVxuICApO1xufVxuY29uc3QgZmFsc3lUb1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09IFwiYm9vbGVhblwiID8gXFxgXFwke3ZhbHVlfVxcYCA6IHZhbHVlID09PSAwID8gXCIwXCIgOiB2YWx1ZSwgY3ggPSBjbHN4LCBjdmEgPSAoYmFzZSwgY29uZmlnKSA9PiAocHJvcHMpID0+IHtcbiAgdmFyIF9jb25maWdfY29tcG91bmRWYXJpYW50cztcbiAgaWYgKChjb25maWcgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbmZpZy52YXJpYW50cykgPT0gbnVsbCkgcmV0dXJuIGN4KGJhc2UsIHByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wcy5jbGFzcywgcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzLmNsYXNzTmFtZSk7XG4gIGNvbnN0IHsgdmFyaWFudHMsIGRlZmF1bHRWYXJpYW50cyB9ID0gY29uZmlnLCBnZXRWYXJpYW50Q2xhc3NOYW1lcyA9IE9iamVjdC5rZXlzKHZhcmlhbnRzKS5tYXAoKHZhcmlhbnQpID0+IHtcbiAgICBjb25zdCB2YXJpYW50UHJvcCA9IHByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wc1t2YXJpYW50XSwgZGVmYXVsdFZhcmlhbnRQcm9wID0gZGVmYXVsdFZhcmlhbnRzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0VmFyaWFudHNbdmFyaWFudF07XG4gICAgaWYgKHZhcmlhbnRQcm9wID09PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCB2YXJpYW50S2V5ID0gZmFsc3lUb1N0cmluZyh2YXJpYW50UHJvcCkgfHwgZmFsc3lUb1N0cmluZyhkZWZhdWx0VmFyaWFudFByb3ApO1xuICAgIHJldHVybiB2YXJpYW50c1t2YXJpYW50XVt2YXJpYW50S2V5XTtcbiAgfSksIHByb3BzV2l0aG91dFVuZGVmaW5lZCA9IHByb3BzICYmIE9iamVjdC5lbnRyaWVzKHByb3BzKS5yZWR1Y2UoKGFjYywgcGFyYW0pID0+IHtcbiAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW07XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgfHwgKGFjY1trZXldID0gdmFsdWUpLCBhY2M7XG4gIH0sIHt9KSwgZ2V0Q29tcG91bmRWYXJpYW50Q2xhc3NOYW1lcyA9IGNvbmZpZyA9PSBudWxsIHx8IChfY29uZmlnX2NvbXBvdW5kVmFyaWFudHMgPSBjb25maWcuY29tcG91bmRWYXJpYW50cykgPT09IG51bGwgfHwgX2NvbmZpZ19jb21wb3VuZFZhcmlhbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY29uZmlnX2NvbXBvdW5kVmFyaWFudHMucmVkdWNlKChhY2MsIHBhcmFtKSA9PiB7XG4gICAgbGV0IHsgY2xhc3M6IGN2Q2xhc3MsIGNsYXNzTmFtZTogY3ZDbGFzc05hbWUsIC4uLmNvbXBvdW5kVmFyaWFudE9wdGlvbnMgfSA9IHBhcmFtO1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhjb21wb3VuZFZhcmlhbnRPcHRpb25zKS5ldmVyeSgocGFyYW0yKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gcGFyYW0yO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuaW5jbHVkZXMoe1xuICAgICAgICAuLi5kZWZhdWx0VmFyaWFudHMsXG4gICAgICAgIC4uLnByb3BzV2l0aG91dFVuZGVmaW5lZFxuICAgICAgfVtrZXldKSA6IHtcbiAgICAgICAgLi4uZGVmYXVsdFZhcmlhbnRzLFxuICAgICAgICAuLi5wcm9wc1dpdGhvdXRVbmRlZmluZWRcbiAgICAgIH1ba2V5XSA9PT0gdmFsdWU7XG4gICAgfSkgPyBbXG4gICAgICAuLi5hY2MsXG4gICAgICBjdkNsYXNzLFxuICAgICAgY3ZDbGFzc05hbWVcbiAgICBdIDogYWNjO1xuICB9LCBbXSk7XG4gIHJldHVybiBjeChiYXNlLCBnZXRWYXJpYW50Q2xhc3NOYW1lcywgZ2V0Q29tcG91bmRWYXJpYW50Q2xhc3NOYW1lcywgcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzLmNsYXNzLCBwcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcHJvcHMuY2xhc3NOYW1lKTtcbn07XG5leHBvcnQge1xuICBBZ2VudFN0YXRlVHlwZSBhcyBBLFxuICBCdXR0b24gYXMgQixcbiAgQ29uZmlnUHJvdmlkZXIgYXMgQyxcbiAgR2xhc3N5IGFzIEcsXG4gIEhvdGtleUFjdGlvbnMgYXMgSCxcbiAgUGFuZWxzUHJvdmlkZXIgYXMgUCxcbiAgdXNlQXBwU3RhdGUgYXMgYSxcbiAgdXNlUGx1Z2lucyBhcyBiLFxuICB1c2VBZ2VudE1lc3NhZ2luZyBhcyBjLFxuICB1c2VQYW5lbHMgYXMgZCxcbiAgY29sbGVjdFVzZXJNZXNzYWdlTWV0YWRhdGEgYXMgZSxcbiAgZ2VuZXJhdGVJZCBhcyBmLFxuICBnZXRTZWxlY3RlZEVsZW1lbnRJbmZvIGFzIGcsXG4gIEFnZW50UHJvdmlkZXIgYXMgaCxcbiAgQWdlbnRBdmFpbGFiaWxpdHlQcm92aWRlciBhcyBpLFxuICBBZ2VudE1lc3NhZ2luZ1Byb3ZpZGVyIGFzIGosXG4gIFBsdWdpblByb3ZpZGVyIGFzIGssXG4gIGhvdGtleUFjdGlvbkRlZmluaXRpb25zIGFzIGwsXG4gIGNuIGFzIG0sXG4gIGdldEVsZW1lbnRBdFBvaW50IGFzIG4sXG4gIGdldFhQYXRoRm9yRWxlbWVudCBhcyBvLFxuICB1c2VBZ2VudEF2YWlsYWJpbGl0eSBhcyBwLFxuICBnbGFzc3lCb3hDbGFzc05hbWUgYXMgcSxcbiAgUGFuZWwgYXMgcixcbiAgUGFuZWxIZWFkZXIgYXMgcyxcbiAgUGFuZWxDb250ZW50IGFzIHQsXG4gIHVzZUFnZW50cyBhcyB1LFxuICBQYW5lbEZvb3RlciBhcyB2LFxuICBjdmEgYXMgdyxcbiAgQWdlbnRBdmFpbGFiaWxpdHlFcnJvciBhcyB4LFxuICBBcHBTdGF0ZVByb3ZpZGVyIGFzIHlcbn07XG5gLCBcImluZGV4LmpzXCI6IGBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmLCB1c2VMYXlvdXRFZmZlY3QsIGZvcndhcmRSZWYsIEZyYWdtZW50LCBpc1ZhbGlkRWxlbWVudCwgY2xvbmVFbGVtZW50LCBjcmVhdGVFbGVtZW50LCB1c2VJZCBhcyB1c2VJZCQxLCB1c2VSZWR1Y2VyLCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSwgU3RyaWN0TW9kZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlUm9vdCB9IGZyb20gXCJyZWFjdC1kb20vY2xpZW50XCI7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IGFzIEZyYWdtZW50JDEgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IEEgYXMgQWdlbnRTdGF0ZVR5cGUsIHUgYXMgdXNlQWdlbnRzLCBhIGFzIHVzZUFwcFN0YXRlLCBiIGFzIHVzZVBsdWdpbnMsIGMgYXMgdXNlQWdlbnRNZXNzYWdpbmcsIGQgYXMgdXNlUGFuZWxzLCBlIGFzIGNvbGxlY3RVc2VyTWVzc2FnZU1ldGFkYXRhLCBnIGFzIGdldFNlbGVjdGVkRWxlbWVudEluZm8sIGYgYXMgZ2VuZXJhdGVJZCwgQyBhcyBDb25maWdQcm92aWRlciwgaCBhcyBBZ2VudFByb3ZpZGVyLCBpIGFzIEFnZW50QXZhaWxhYmlsaXR5UHJvdmlkZXIsIGogYXMgQWdlbnRNZXNzYWdpbmdQcm92aWRlciwgUCBhcyBQYW5lbHNQcm92aWRlciwgayBhcyBQbHVnaW5Qcm92aWRlciwgSCBhcyBIb3RrZXlBY3Rpb25zLCBsIGFzIGhvdGtleUFjdGlvbkRlZmluaXRpb25zLCBtIGFzIGNuLCBuIGFzIGdldEVsZW1lbnRBdFBvaW50LCBvIGFzIGdldFhQYXRoRm9yRWxlbWVudCwgcCBhcyB1c2VBZ2VudEF2YWlsYWJpbGl0eSwgRyBhcyBHbGFzc3ksIHEgYXMgZ2xhc3N5Qm94Q2xhc3NOYW1lLCByIGFzIFBhbmVsLCBzIGFzIFBhbmVsSGVhZGVyLCB0IGFzIFBhbmVsQ29udGVudCwgdiBhcyBQYW5lbEZvb3RlciwgQiBhcyBCdXR0b24sIHcgYXMgY3ZhLCB4IGFzIEFnZW50QXZhaWxhYmlsaXR5RXJyb3IsIHkgYXMgQXBwU3RhdGVQcm92aWRlciB9IGZyb20gXCJpbmRleC1Ec0M1enBlcy5qc1wiO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsLCBmbHVzaFN5bmMgfSBmcm9tIFwicmVhY3QtZG9tXCI7XG5pbXBvcnQgY29uZmlnIGZyb20gXCJAc3RhZ2V3aXNlL3Rvb2xiYXIvY29uZmlnXCI7XG5jb25zdCBhcHBTdHlsZSA9ICcvKiEgdGFpbHdpbmRjc3MgdjQuMS4xMSB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20gKi9AbGF5ZXIgcHJvcGVydGllc3tAc3VwcG9ydHMgKCgtd2Via2l0LWh5cGhlbnM6bm9uZSkgYW5kIChub3QgKG1hcmdpbi10cmltOmlubGluZSkpKSBvciAoKC1tb3otb3JpZW50OmlubGluZSkgYW5kIChub3QgKGNvbG9yOnJnYihmcm9tIHJlZCByIGcgYikpKSl7Kiw6YmVmb3JlLDphZnRlciw6OmJhY2tkcm9wey0tdHctdHJhbnNsYXRlLXg6MDstLXR3LXRyYW5zbGF0ZS15OjA7LS10dy10cmFuc2xhdGUtejowOy0tdHctc2NhbGUteDoxOy0tdHctc2NhbGUteToxOy0tdHctc2NhbGUtejoxOy0tdHctcm90YXRlLXg6aW5pdGlhbDstLXR3LXJvdGF0ZS15OmluaXRpYWw7LS10dy1yb3RhdGUtejppbml0aWFsOy0tdHctc2tldy14OmluaXRpYWw7LS10dy1za2V3LXk6aW5pdGlhbDstLXR3LXNwYWNlLXktcmV2ZXJzZTowOy0tdHctc3BhY2UteC1yZXZlcnNlOjA7LS10dy1kaXZpZGUteS1yZXZlcnNlOjA7LS10dy1ib3JkZXItc3R5bGU6c29saWQ7LS10dy1ncmFkaWVudC1wb3NpdGlvbjppbml0aWFsOy0tdHctZ3JhZGllbnQtZnJvbTojMDAwMDstLXR3LWdyYWRpZW50LXZpYTojMDAwMDstLXR3LWdyYWRpZW50LXRvOiMwMDAwOy0tdHctZ3JhZGllbnQtc3RvcHM6aW5pdGlhbDstLXR3LWdyYWRpZW50LXZpYS1zdG9wczppbml0aWFsOy0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbjowJTstLXR3LWdyYWRpZW50LXZpYS1wb3NpdGlvbjo1MCU7LS10dy1ncmFkaWVudC10by1wb3NpdGlvbjoxMDAlOy0tdHctZm9udC13ZWlnaHQ6aW5pdGlhbDstLXR3LXNoYWRvdzowIDAgIzAwMDA7LS10dy1zaGFkb3ctY29sb3I6aW5pdGlhbDstLXR3LXNoYWRvdy1hbHBoYToxMDAlOy0tdHctaW5zZXQtc2hhZG93OjAgMCAjMDAwMDstLXR3LWluc2V0LXNoYWRvdy1jb2xvcjppbml0aWFsOy0tdHctaW5zZXQtc2hhZG93LWFscGhhOjEwMCU7LS10dy1yaW5nLWNvbG9yOmluaXRpYWw7LS10dy1yaW5nLXNoYWRvdzowIDAgIzAwMDA7LS10dy1pbnNldC1yaW5nLWNvbG9yOmluaXRpYWw7LS10dy1pbnNldC1yaW5nLXNoYWRvdzowIDAgIzAwMDA7LS10dy1yaW5nLWluc2V0OmluaXRpYWw7LS10dy1yaW5nLW9mZnNldC13aWR0aDowcHg7LS10dy1yaW5nLW9mZnNldC1jb2xvcjojZmZmOy0tdHctcmluZy1vZmZzZXQtc2hhZG93OjAgMCAjMDAwMDstLXR3LW91dGxpbmUtc3R5bGU6c29saWQ7LS10dy1ibHVyOmluaXRpYWw7LS10dy1icmlnaHRuZXNzOmluaXRpYWw7LS10dy1jb250cmFzdDppbml0aWFsOy0tdHctZ3JheXNjYWxlOmluaXRpYWw7LS10dy1odWUtcm90YXRlOmluaXRpYWw7LS10dy1pbnZlcnQ6aW5pdGlhbDstLXR3LW9wYWNpdHk6aW5pdGlhbDstLXR3LXNhdHVyYXRlOmluaXRpYWw7LS10dy1zZXBpYTppbml0aWFsOy0tdHctZHJvcC1zaGFkb3c6aW5pdGlhbDstLXR3LWRyb3Atc2hhZG93LWNvbG9yOmluaXRpYWw7LS10dy1kcm9wLXNoYWRvdy1hbHBoYToxMDAlOy0tdHctZHJvcC1zaGFkb3ctc2l6ZTppbml0aWFsOy0tdHctYmFja2Ryb3AtYmx1cjppbml0aWFsOy0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczppbml0aWFsOy0tdHctYmFja2Ryb3AtY29udHJhc3Q6aW5pdGlhbDstLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTppbml0aWFsOy0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTppbml0aWFsOy0tdHctYmFja2Ryb3AtaW52ZXJ0OmluaXRpYWw7LS10dy1iYWNrZHJvcC1vcGFjaXR5OmluaXRpYWw7LS10dy1iYWNrZHJvcC1zYXR1cmF0ZTppbml0aWFsOy0tdHctYmFja2Ryb3Atc2VwaWE6aW5pdGlhbDstLXR3LWR1cmF0aW9uOmluaXRpYWw7LS10dy1lYXNlOmluaXRpYWw7LS10dy1jb250ZW50OlwiXCJ9fX1AbGF5ZXIgdGhlbWV7OnJvb3QsOmhvc3R7LS1mb250LXNhbnM6dWktc2Fucy1zZXJpZixzeXN0ZW0tdWksc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiLFwiU2Vnb2UgVUkgU3ltYm9sXCIsXCJOb3RvIENvbG9yIEVtb2ppXCI7LS1mb250LW1vbm86dWktbW9ub3NwYWNlLFNGTW9uby1SZWd1bGFyLE1lbmxvLE1vbmFjbyxDb25zb2xhcyxcIkxpYmVyYXRpb24gTW9ub1wiLFwiQ291cmllciBOZXdcIixtb25vc3BhY2U7LS1jb2xvci1yZWQtMTAwOm9rbGNoKDkzLjYlIC4wMzIgMTcuNzE3KTstLWNvbG9yLXJlZC0yMDA6b2tsY2goODguNSUgLjA2MiAxOC4zMzQpOy0tY29sb3ItcmVkLTUwMDpva2xjaCg2My43JSAuMjM3IDI1LjMzMSk7LS1jb2xvci1vcmFuZ2UtNTA6b2tsY2goOTglIC4wMTYgNzMuNjg0KTstLWNvbG9yLW9yYW5nZS0xMDA6b2tsY2goOTUuNCUgLjAzOCA3NS4xNjQpOy0tY29sb3Itb3JhbmdlLTIwMDpva2xjaCg5MC4xJSAuMDc2IDcwLjY5Nyk7LS1jb2xvci1vcmFuZ2UtMzAwOm9rbGNoKDgzLjclIC4xMjggNjYuMjkpOy0tY29sb3Itb3JhbmdlLTUwMDpva2xjaCg3MC41JSAuMjEzIDQ3LjYwNCk7LS1jb2xvci1vcmFuZ2UtNjAwOm9rbGNoKDY0LjYlIC4yMjIgNDEuMTE2KTstLWNvbG9yLW9yYW5nZS03MDA6b2tsY2goNTUuMyUgLjE5NSAzOC40MDIpOy0tY29sb3Itb3JhbmdlLTkwMDpva2xjaCg0MC44JSAuMTIzIDM4LjE3Mik7LS1jb2xvci15ZWxsb3ctNTAwOm9rbGNoKDc5LjUlIC4xODQgODYuMDQ3KTstLWNvbG9yLWxpbWUtMjAwOm9rbGNoKDkzLjglIC4xMjcgMTI0LjMyMSk7LS1jb2xvci1ncmVlbi0zMDA6b2tsY2goODcuMSUgLjE1IDE1NC40NDkpOy0tY29sb3ItZ3JlZW4tNDAwOm9rbGNoKDc5LjIlIC4yMDkgMTUxLjcxMSk7LS1jb2xvci1ncmVlbi01MDA6b2tsY2goNzIuMyUgLjIxOSAxNDkuNTc5KTstLWNvbG9yLWdyZWVuLTYwMDpva2xjaCg2Mi43JSAuMTk0IDE0OS4yMTQpOy0tY29sb3ItZW1lcmFsZC01MDA6b2tsY2goNjkuNiUgLjE3IDE2Mi40OCk7LS1jb2xvci10ZWFsLTMwMDpva2xjaCg4NS41JSAuMTM4IDE4MS4wNzEpOy0tY29sb3ItdGVhbC00MDA6b2tsY2goNzcuNyUgLjE1MiAxODEuOTEyKTstLWNvbG9yLXRlYWwtNTAwOm9rbGNoKDcwLjQlIC4xNCAxODIuNTAzKTstLWNvbG9yLWN5YW4tMjAwOm9rbGNoKDkxLjclIC4wOCAyMDUuMDQxKTstLWNvbG9yLXNreS0xMDA6b2tsY2goOTUuMSUgLjAyNiAyMzYuODI0KTstLWNvbG9yLXNreS0zMDA6b2tsY2goODIuOCUgLjExMSAyMzAuMzE4KTstLWNvbG9yLXNreS01MDA6b2tsY2goNjguNSUgLjE2OSAyMzcuMzIzKTstLWNvbG9yLWJsdWUtNTA6b2tsY2goOTclIC4wMTQgMjU0LjYwNCk7LS1jb2xvci1ibHVlLTEwMDpva2xjaCg5My4yJSAuMDMyIDI1NS41ODUpOy0tY29sb3ItYmx1ZS0yMDA6b2tsY2goODguMiUgLjA1OSAyNTQuMTI4KTstLWNvbG9yLWJsdWUtNDAwOm9rbGNoKDcwLjclIC4xNjUgMjU0LjYyNCk7LS1jb2xvci1ibHVlLTUwMDpva2xjaCg2Mi4zJSAuMjE0IDI1OS44MTUpOy0tY29sb3ItYmx1ZS02MDA6b2tsY2goNTQuNiUgLjI0NSAyNjIuODgxKTstLWNvbG9yLWJsdWUtOTUwOm9rbGNoKDI4LjIlIC4wOTEgMjY3LjkzNSk7LS1jb2xvci1pbmRpZ28tMjAwOm9rbGNoKDg3JSAuMDY1IDI3NC4wMzkpOy0tY29sb3ItaW5kaWdvLTMwMDpva2xjaCg3OC41JSAuMTE1IDI3NC43MTMpOy0tY29sb3ItaW5kaWdvLTQwMDpva2xjaCg2Ny4zJSAuMTgyIDI3Ni45MzUpOy0tY29sb3ItaW5kaWdvLTUwMDpva2xjaCg1OC41JSAuMjMzIDI3Ny4xMTcpOy0tY29sb3ItdmlvbGV0LTQwMDpva2xjaCg3MC4yJSAuMTgzIDI5My41NDEpOy0tY29sb3ItdmlvbGV0LTYwMDpva2xjaCg1NC4xJSAuMjgxIDI5My4wMDkpOy0tY29sb3ItcHVycGxlLTIwMDpva2xjaCg5MC4yJSAuMDYzIDMwNi43MDMpOy0tY29sb3ItcHVycGxlLTUwMDpva2xjaCg2Mi43JSAuMjY1IDMwMy45KTstLWNvbG9yLWZ1Y2hzaWEtNDAwOm9rbGNoKDc0JSAuMjM4IDMyMi4xNik7LS1jb2xvci1mdWNoc2lhLTcwMDpva2xjaCg1MS44JSAuMjUzIDMyMy45NDkpOy0tY29sb3ItcGluay01MDA6b2tsY2goNjUuNiUgLjI0MSAzNTQuMzA4KTstLWNvbG9yLXJvc2UtMzAwOm9rbGNoKDgxJSAuMTE3IDExLjYzOCk7LS1jb2xvci1yb3NlLTYwMDpva2xjaCg1OC42JSAuMjUzIDE3LjU4NSk7LS1jb2xvci16aW5jLTEwMDpva2xjaCg5Ni43JSAuMDAxIDI4Ni4zNzUpOy0tY29sb3ItemluYy00MDA6b2tsY2goNzAuNSUgLjAxNSAyODYuMDY3KTstLWNvbG9yLXppbmMtNTAwOm9rbGNoKDU1LjIlIC4wMTYgMjg1LjkzOCk7LS1jb2xvci16aW5jLTYwMDpva2xjaCg0NC4yJSAuMDE3IDI4NS43ODYpOy0tY29sb3ItemluYy03MDA6b2tsY2goMzclIC4wMTMgMjg1LjgwNSk7LS1jb2xvci16aW5jLTkwMDpva2xjaCgyMSUgLjAwNiAyODUuODg1KTstLWNvbG9yLXppbmMtOTUwOm9rbGNoKDE0LjElIC4wMDUgMjg1LjgyMyk7LS1jb2xvci1ibGFjazojMDAwOy0tY29sb3Itd2hpdGU6I2ZmZjstLXNwYWNpbmc6LjI1cmVtOy0tdGV4dC14czouNzVyZW07LS10ZXh0LXhzLS1saW5lLWhlaWdodDpjYWxjKDEvLjc1KTstLXRleHQtc206Ljg3NXJlbTstLXRleHQtc20tLWxpbmUtaGVpZ2h0OmNhbGMoMS4yNS8uODc1KTstLXRleHQtYmFzZToxcmVtOy0tdGV4dC1iYXNlLS1saW5lLWhlaWdodDogMS41IDstLXRleHQtbGc6MS4xMjVyZW07LS10ZXh0LWxnLS1saW5lLWhlaWdodDpjYWxjKDEuNzUvMS4xMjUpOy0tZm9udC13ZWlnaHQtbm9ybWFsOjQwMDstLWZvbnQtd2VpZ2h0LW1lZGl1bTo1MDA7LS1mb250LXdlaWdodC1zZW1pYm9sZDo2MDA7LS1mb250LXdlaWdodC1ib2xkOjcwMDstLXJhZGl1cy1zbTouMjVyZW07LS1yYWRpdXMtbWQ6LjM3NXJlbTstLXJhZGl1cy1sZzouNXJlbTstLXJhZGl1cy14bDouNzVyZW07LS1yYWRpdXMtM3hsOjEuNXJlbTstLXNoYWRvdy1sZzowIDEwcHggMTVweCAtM3B4ICMwMDAwMDAxYSwwIDRweCA2cHggLTRweCAjMDAwMDAwMWE7LS1kcm9wLXNoYWRvdy14bDowIDlweCA3cHggIzAwMDAwMDFhOy0tZWFzZS1vdXQ6Y3ViaWMtYmV6aWVyKDAsMCwuMiwxKTstLWVhc2UtaW4tb3V0OmN1YmljLWJlemllciguNCwwLC4yLDEpOy0tYW5pbWF0ZS1zcGluOnNwaW4gMXMgbGluZWFyIGluZmluaXRlOy0tYW5pbWF0ZS1wdWxzZTpwdWxzZSAycyBjdWJpYy1iZXppZXIoLjQsMCwuNiwxKWluZmluaXRlOy0tYmx1ci1zbTo4cHg7LS1ibHVyLW1kOjEycHg7LS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb246LjE1czstLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC40LDAsLjIsMSk7LS1kZWZhdWx0LWZvbnQtZmFtaWx5OnZhcigtLWZvbnQtc2Fucyk7LS1kZWZhdWx0LW1vbm8tZm9udC1mYW1pbHk6dmFyKC0tZm9udC1tb25vKTstLWNvbG9yLWZvcmVncm91bmQ6dmFyKC0tY29sb3ItemluYy05NTApOy0tY29sb3ItbXV0ZWQtZm9yZWdyb3VuZDp2YXIoLS1jb2xvci16aW5jLTcwMCk7LS1jb2xvci1ib3JkZXI6dmFyKC0tY29sb3ItemluYy01MDApOy0tZWFzZS1zcHJpbmc6bGluZWFyKDAsLS4wMDk0NiwuMDIxOSwuMDc5MywuMTUyLC4yMzcsLjMyNiwuNDE5LC41MDksLjU5NywuNjgsLjc1NSwuODIzLC44ODIsLjkzMywuOTc2LDEuMDEsMS4wNCwxLjA2LDEuMDcsMS4wOCwxLjA5LDEuMDksMS4wOSwxLjA5LDEuMDgsMS4wNywxLjA3LDEuMDYsMS4wNSwxLjA0LDEuMDMsMS4wMywxLjAyLDEuMDEsMS4wMSwxLDEsLjk5OCwuOTk2LC45OTQsLjk5MywuOTkyLC45OTIsLjk5MiwuOTkyLC45OTIsLjk5MywuOTk0LC45OTQsLjk5NSwuOTk2LC45OTcsLjk5NywuOTk4LC45OTgsLjk5OSwuOTk5LDEpOy0tZWFzZS1zcHJpbmctc29mdDpsaW5lYXIoMCwtLjA1MzEsLjExNywuMjkzLC40NiwuNjEsLjczOCwuODM4LC45MTMsLjk2NSwxLDEuMDIsMS4wMywxLjAzLDEuMDMsMS4wMywxLjAzLDEuMDIsMS4wMSwxLjAxLDEuMDEsMSwxLDEsMSk7LS1nbGFzcy10ZXh0dXJlOnVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQWxnQUFBSENFQVFBQUFESjZxT3NBQUFnQUVsRVFWUjQydTI5UzVJankzS1lEVUFUYlVEVWxTaFNHbWpVM2FlTzlWekRmd1Yzb1Z3Rk9TNDdkYXA3QjVJWkwwV1o1cFJkL0lNcUhHUkcrTnM5WHBrT3M3YXVBaEpaUU1iTDR3dlBMNjcvL2IvLysvL3ZjcmxjN3ZmTDduRy9YMStmUDIrZmozdE85Nzc3ZCtpNDdldjc1KysvYmw1NzJYeTF6Yy8zWHpZL2Y3dGVQMzY2WGkrWDYvWCs5ZVAvajMrMzIvTm42Ti9IKzY0L0htZDdQQWM5eW11TlhZUEw1ZjYxTHBmN0YraWMvL04vM3Y5OENYejhqLzl4L1lmOWQ3bisvUHp0eC9PbzYvdm4vNzkvUHZIMitmdmJ4K2UrL3JZNTl2WDVYVDdxRmwyZXRub0IxMlhkZHkvTGJ2djdwcXhmOTcvWC8xK3ZsOWZOejlEcjVYUGY5My9uL3ZuNy9mdnpNM3pVNjBlZHZ0OHZMNXRyOGN2OS92SHovWDcvOXRlL2Z2eTgvYjk4N242L3ZqL2Y4MGZiLzkzYWhyZWY0L0g3NTNQZjluL2pjcm5mbi9WNzg3bS83Ti8zOGY5Zi9oSmJ2N2VQcjE4LzZ2cW1iSDl1NnYyUHpmTi8xUGZQNTk0MnJ6M3EvbTlsSGRtYzZ4V3FTNStQVjZyUFlCN2ZwWDBML1R2ZXgwcmFhOHc1N3I5Sy9nNys4NjZ2cjQ2QjIvYjFEV3VmOU84ZmY2c28wNWY5K1o5dDRYSzVmOXUzbFkvNnYvMzMwUzd2WCtwMml2Lzh2LzRYM0RiK3czKzQvZ1BVaHZmWDVOR3Y3OGIrSDNDWmZkUi9iYjhnNnpQWWN2MEdsK3Y5Sy9Ec0YrQzRadjBIOWJnUlljRDNad2ZQRDBKY1VLRVowRHpIWVEzSWU2R29RWG9iRUVWK1gvall1a0gwZmNpKzR6NFlLTC9MUjcwaUJodjNjODJ2QXRGSjhJT1EvQnpiZ05UYXJyQ2dycnorbS9MNVJYcDl5NytCSC9QUk9YUEJLeHpNWGk1Lzh6ZlBnTDlWV1JvZUwzU2R4L3RQS2tpYTVSSFpML2Y3ekhCZlg5YXRvc3hlcEhWajM2WS8vbFp4ekZ2RTVJNmFpRUVCWDJ3WllYMzhQc2lKK3R1eWNmMHh1VEhYaTM4WVVSOXZnb3Y5M1hNQlc3d0dEODdsSUxTbEozZ0QwSGJFdGxsZFhNZUd2ZmEzZnp1bUFzazdMUGxnRTkxaGU4K25LZGZpOWUvV3dWeEI0ZDZRUVB3ZEM0Q29vRVlYTktIQjFPL2F5UkFWZUEyb3YxK2d3V1l6a2ZwRlVxNzFjM0s2RTFuWDVkZjIraG85WUZ1TzgvemNNc2oyOSs5bGtQQkJSNm1KQlJWd1BSNy8rVC9qZlgvRXRZbHFpeGp0ZHdaT1A0Qm5CME1JSU1DaU85TW56WXBvV05yWHZBVkJkQ2kvWTVYL2ZyLytLSmRPeWtBcm9rT2tQK05INVJreDJQempQejZSS3Y0OUh6T2FQd2FjRjBXWDl0MTdmZURBdXRmMW9qKy9sRjVwT3ZyOWE5Qk0vU093Z1pZek9JSVZPZHVVRDV4US9iNyt4QWFiVm8rZlB6L3FPdCtlNjJXS1RkRDFFdkJSckJUck5iN3ZHWFVjT2pGdTA0cWRFMlkrU042T01YU2RmcmJKanpZZ2FiLzl4d1o0cVM2cXZVWUh6dE1FV0xMS3Z4OVV0QjEwUkdCbFdTYkVCeVFmdllJYVZoK0tOU0pDaDJmMWd2ZjkybnBHSGgwWWFNdk5TcVd3ZXJNSjhsOTlBOUQxbmM4dCtjZzlyR2ZSOG1WQ1NlY3FKUkZVQjl0eW1aQXFFNlo4WCtyMzE4dUUyenlubFFZSWZiQkVUM2g2REpyWU1tRlVtOVpNbUt6WFhMdThEMUVzamx4KzVubCtnZCtIOS9HYS9sY2FjTm5IZFUwZDdiL0tjek5VUFRBM3l4bzh5UXZMMG5DZmcxSHgraHMwdzdqZjkwbDgrNFJ1bUY3VmdaY20rTEIzZE5EM25XU1o4RFB4RTE0bTNIL3UvZS8ybkt3eEZBdWJ2UlpCdG1hWmtDQVI5WTBCWEgybWdpeHZwOGFmQjFvbWZINlcyU2dXUFVEV2JmcCtseTBUY244THFFUGZvL3NLYWYveHFHZXRWeWtzZ2JmbVoyTU5lTkdXRjBHMTNxaEpUL0g3RDRnNmJ5a1dGbHlWci8ybi93VDMveTNialpWb1d5Wmo5YlhEeCtsWmxnbHZsZ3U1djhQSlR4L2lHbXg1MTQ2LzB5My9TUVpZNjh5R1dpWWM4WkRSdUdxWmNJSlpkRXhud0YrTG1HVkM2VjAxbTRuQWI1Ly92MUZ0RkpzSjAwUUxUM2FQNmxRdEZPdnhmeStLQmMzc1B3T3JiN0pCZW5jWDgvZDZraHIrYUxaTUtBMWtLSXFscXovK1pVSUx4ZExkMVNaL0g3Uk15STJSRm9wMXZUNkRyUC80SC9kM3hucjd3R0ppckZvbWpBendWcU5ZdDIxajF4ZEdTU1Q2QkZiV1dVelI2TjZrTXd3bzZLSUgwLzJNMTRxUDZmTFl6L0piVUt4LytxZnkxbGJ0TXVGandLSHVyT0tYbmEwTnF1Y2FQck9rOE4xZUYrREJDampQRzE1dlBzZ1JIVXp4eWU0YW1vVy9CNkpZc3IvZnNreTVQQ3ltZkY4a3gwdEpTQVRGbW1WU000cG85WnBnbHBNYzRiZDhML3J5SDFCZ3RlM2pwUlRyY3JsYy92U25PcmlpQXhONE1xRmRqWkZPY0NWOWhhVmM1N3ZqL2crQ1JTc1p1Q0NyWDJDbHUxMzljd2xDTUJ1cVp4aVN1OFVnc2lYdG9LUHZ6QmdkUkJURTQ4VWVPT29EOWUweVlSVEY4dDd0SngxZ2RSUUx6TWw2bytvemRYZFNtWWNGVXlTYVl0SFhzLzRjY01mNWRFMDkvLzdXUmJVLy9qRTdiMW0vNjNLUUxoUGVrV0NyQzhWU3RSMzhkeStCaWppdUg4WFMzcWdnektWOGsxSXNyQ3lrUzRUWWUremdSTktQUGlsVzMyVDBNamlGUWNnc0ZPdFdOM3FaKzZwSWlQMnVhZUFST1ZuNFovRjFEcC95dGZkOUlMVy9vMUFTUk1WU0sweGdDa2Zva1JSTDlqMWdaRnhnWlRIRjhnUmJVZStUbDY5NG1WQktzWVNUQ0hBQTJvb3ZmOTkzeExDMlFhdHNpS0ZZNCttRXNNUy9LT283NDhUU1RjQ01GT3MxOHR2cmx3YmprOTIxOVNGS3lXSmRHdFFFQ2xBZkg1R0xwYjNtVW9wbHVkSEYrbi9rcEh3Q2dsVmQ3Ty82RDR4ckhFWXFHMnFLaFMwVGNoUUxYaXJFS1Jaa1llODNXNDE2bE11RWU1TThhTkV0S0pac1ZoaVo3TjY3a1dtbG8xd0hYVDlmVy9CNWlnWE8zTjZwM1FpMEZNczZXRzZsZ1JURmVrd2dlbEVzZnBud283NFhON1g4QWp6M0FwOW5INHpmNy9OUnJNMHJ3eWlXUndWaXBWaTZTUldzVE9FcGxxNHNLSnU4bG1JMTZ2bSs5YTYvWlhES1V5d1lRdlNpV0dxVE85MFE1UGswOXNBS1RtU1BwRmhRSVhJSjc5SWdTaEprV1NoVytaNVpLQlkybzYrcDUzd1VTN0dsMFhmaGJQaTdOZ2lqWDZjcGxzU0x0WmxVZmROU0xBbUp2bDQvSmk2UkZLdlgzWVNmRTZVdmNMbnN0ejNaVGlxS1lPdFhhUnVhZ1dMRjNobm9wVmkyWlVKTC9lQ1dDYlVVQzFuaS8xMUNzZXAyNlBOaVVXMi8rTlJmNE9zSTUySkpKOExTL2tPYmk3VUN4YnA5ZEFDVXEwZzJ5OXB1ZzlKemVkRFc0SzZiUWFpbVdIaGo4Vk9zN2Z0bW9WVHhGR3MvNE1nbGpEQTVQUlBGK3Z6L0ZhSllORjJvWitwSUh1UHlGT3Z4R0VHeDRMTFVVYXppaGhpdWZ3Mm5YRkhLQnNzU29vVmllWmVRdFJUTHNsZWViakxLVTZ2ZUZNdCtYRDJ4amlTUWh0bzlGY1c2d1hTaC9DQmFsQzFiWW93V2o5SU56akliK3RnSU41cGkyU3Vkam1MOWwvOHlpbUk5QitQTkFQM0NVYXlXTktyVkhvYlJGRXN6ZTZZbzFuYlNVSGU0bUlBMEtSWkdzVFlCMFZkcWNHbEFzU3dQbDY3bW1CUkxFMlJaS05iMURRbk0zaXdVQzJpelA2V0JGdForTFJTTG0waEhVU3o5SFlYdzNxYXpVYXd5eVoyZ1dUeGQwTjZtYWFkWUVobmV2bUZyS1JiZXVHSW9WcXVaWjZ1SzVhZFk5WUF6QThXUzNmU2dHL1FFRnVqdmtoa3ovWGRvaXNXMUorNHVKYml6bm9OaWJWOXZTYkYwWlFwZG14aUsxVUxiY0Q2S1padklXQ2lXdGwrUTl1dmMwaUJIdjZLZ0JqNnhuaVhBZ2VYRkl5aldEVEZ1L3dwZk1NMkd2Zk5Sck91MW5nMWhmMzhUVUUxTHNZcm5mMEx2bTVOaXdmVmtCTVdLSlI5M1VlQWtES0plNjNOaE52ZElpaVdmSUxXa1dOU0EwcTg4c1puOU50bDlQN2g4dmdmdFV5MFV5L2dZUXJIYTNGRW83N2Zwd0tVMXhVTC9MLzZ1bjJKcDd5cmtCTDRhaWtVRmhETlJySWtJRmpqd2tTUkxGdFRnU2ZKOWNyRTRiNWI4anNKUkZFdnVydWsvZzlEZlVZZ0Y4WGpDK3dvVVMwdTU1cUZZa0lCMHZ6ZmhDSXAxdlVKTDRmajJPUzBvbHBSbVVCVHI4N2tOeGRyWCtTTlNyTWk2SVEzRUlvTnVEOFhDcEtNVzRpVTF2RXZ6c2FLaFJpK0taVC9ISEJUcnRvL1l5MENMWHk2ME5CUk5vVXIzbit0UHNmWnVMTW5BSEtkcDRDblc5aEZGc2Y3cG4rNS85dDlSeUNlOFIxQ3NVWUhuV2hTTFQzUnZTYkc0R2JVbTRUMzZBU2U3ZXltV3ZCOUFqdEVHV2FFVWE2d1g2Nk4rZTVjTlcxSXNwbDIvRmUzNDkrSnppU2pXVnNDcnljZWlsZ3ZqS05Zemh6T0tZZ25xbFpKaTliVzczL2hLaFNXLzQwczdFUlFyYmxEbDhyV3NGS3QrbnFOWXJXYWFJeEdwbEdKZHJ6akZncGVmZlJScjI2bTNXajRjVGJHMkFaZU1ZcFdkT2lZZzdVT3h5c0dsVUszOGtBNmVKNkpZNFk4VjdPNWorN2Q0aXNXTk1WQWJnRWdXOURORXVyVGwwR1B2d0JibkFQS3NmOGo3L3pZVTYvWTUwM3FSQmxrMjBzQkxTQ01vbHJ3Q2tSUUxDYko0aWdVUnEzM0RqRXQ0THluV2RpbWxOOFdpUEVFK2lrVVBPTEtBdXc2eUxIUkxsOHlxb2xqZmhUU0xDYW9rRkF1YjFlTHFCcnh6di84U1RiRmtBZFh4S0JZV1pNMUFzYXlCejhvVUM5SnRhSUp2T2NXQ0p4clE1OWRTTENtaGxsS3NBcHBNU2JFVXRiZ2J4ZG9TckNySWdyWTZzVkNzVVpzL2F5a1dkRXhoN0gyWGtBbUw1OG83MDVROEloUGVzWVlZUzdGczlhbG53cnR4dVVEejJpcy9jMllwMWh0R3NmQk9lSzlza042TnBObFNKeWtXUDRtWW5XTDVBaTV0Y0IzNW5lVkxoVktLOVh6dStnYTlKcUZZUURCSVVpek5Yb1ZIcEZqOHVEaVdZcFZMaEdxU0pYZGt6VSt4NEZuL3ZnRklLQmEyWEJpdmJkQlJyS2lIazJLSjVhTmFpdFU2NGQxRHNaaWdTa1N4aW1CZlFMSGdRUVR1bktHN0N2ZWJRTmZYcUtaWXNxQUxwbGd6YWh0aUtkYSt6aCtCWXVtUG80TTAvbnd4RkVzWHlOb29GbEtHYjB6QTlRNjFHNGhpU1pQZGoweXhvT3Ztb1ZqUlFkWU4yQkhlc0Z3b2RXVDV0dEx4YlI3YmttTHhPM2xISkx4SGRJN3R0QTFpaW5XSnBsaWp0UTI5S0ZiOTJqYmhmV2Q2aDViQUs0cEZMMFB3QWtNTHhZcmVDTHBIcmc1UHNmYjFIYUJZTDBCT3BwaGk5ZGpUZEFXS1JkVnYyM2ZVVUt5OTA0eGZJb1QzSjVSb0c3WVRqWEo4MFFSUzBQR2FjdWZia3p5djJOTTIvVnZveUNsV0k0SjEvNlhzRURTRFY0UWEzNnBvOEd5UFVsTXNXY0k3NThWcW1mQStFOFdTRVI0cHhZS0RMTDEvN1ZnVVM2ZHR3Q2NPRU1HcU8yQW9GK3VaOEE2OW42TlkrR3Z3MGdpbWJhZ0hsSDdhQnA1aTdkcjJ0KzJrQW1qN0NNVnFybTFRVXl5cnRxRTl4V3BIcnJSdFhicHNhUDBiMUhMZmcySnBKa1RheVJKTnNhaDRJSTVpS2ZxNmQxMTliRSt4YmhCbHFFbFdYNG9WNGNPU1VpeXB0bUZOaXRVNzRkMUNzWFRhaHRVb2xpUlFFZ1pQWVJSckcrRFVIWE45VnlIZHllczdSNDFZc1BVZ0tuMzgrUEdjVU1ncEZqU3B3Q2lXZjdDUG11UmEyb3FlVG5rTjhYTlJMTGp0eXlpV1I5dXdYUzZYSkxoVGs2MFJGRXNhVFBubG8vejQzSWhnVVhkNzRVRldLU0xWZFhMMGh0QzJEaUZxazkvZFVpRkxzYVFFcTYyMkFhTlkvUjk2aWxVSDdpMjBEYjBwRnJkSElUSll1eWdXL3JsZ2JjUGpqajZzTTQ2V2ozSVVDeHBjb0RvK1NqN2FobUxkZngxQnNmd1R1dmd0ZEx6Sjc5NHQzRnBRck1pZFBpTGtvOXgraGIwcGxuVHlGVE8rOVplUDN1b0JzTzRzcWExT2JCVExGOW4yb0Zod285aHJHNERYZjNEaTBhS0RQcUMyNGY1bE0yQUFHK042S0ZhRXRrSGYyTDJVUVJNb2xkb0dEY1hhVGpTSVdUNnBiWGdFT0hyNXFGWGI0S1ZZL2JRTk9vcDEvd1lNdUtJa2QyWDlNaHZlVzFJczJUbThiaTA1eGFMN0FUL0Z3c3NTcGxobFcrd3RIOFVvbGkyM2tZSUYrOGwxOUpMaDdQTFJHM3doc0tYQzhzdEJGRXQrVjJGOHNDVWxGS3FFOXpjaTRIcUhBeWQrejBKdllEVzN0b0ZyZlB3V09wSGFockxzSXdia2hoU0xDODVlK1dET3JtM0FPMXVPWXBsSkNFbXhadE0yeUNrV1dOOVJpclh0Rnh2TFIxL2orcFoxS0JiL25hOXYxb2tURnpSN0tGYUV0cUZzMTFpd0pRaWtEQlJMTm5HS21CellLUlphSjl6OXg0MjRtTUo4TEYrRHNNNm12QnRCQXhkVHBHM1lVeXdvcUJvbkg1MUgyN0NsV05MWnpIcnlVVjFuZkJjdC93a29saUtva3MzeU5SUnJCZmxvUzVvMWhtTE5wVzA0NGhZNnVqWU8zNmlBQjFkMmloV2hiWkQrb3dLZ3pTcldGeS9GOHRDcjNoVExHMlRkNEdVY1RXT1RVNno2eSs0cFZzeEcwTkxCTTBiYnNLVllkT0JsdjlNa1BvcnZRYkg4RzBIUExoK1Z6RXkxNVN6SjUyZ3RIOFdYR3RhUWoyNmZheVVmeFNnV1RpMDhGTXRQVXlPREtDNUFzclNwR2JiUTBWRXNYdHZBdFd1ODdHajVLS1J0d05vdTFwNGorc0FJaXRWaS9KdEoyM0FES281Z3FaQytxekJ5Qi9TSS9DdzVGZXNuSHkwNjJ0UEtSejgvMzdMeVVlWE1WMHl4TGhQSVJ4OFVhOS9tMXBLUHR0UTI3TXNIbTFCd0ZPdit3dDJCdXEwN3hBQ2VXK2gwbEk5cUpsZGJpb1c4M3l3ZjNiZmZ0dkxSQ0lwMU52bm83YlB4ZnQwUC9Mb2dDNUZIQ3UvNmdyVU52dndzbW1MUkNlOTZpcFh5VWV3N2lDbldKWnBpUldzYnNPZXRGRXVZZC9XZGVPMzA4bEZ1MDl1V2ozcXBuNTQwdFphUHRuaWNZUXVkRmVXanRMWWhYajZxNnkvdlg2VTVmR2VnV0xkeUFMVHZwYWZYTm13aTR1K1JwTXJYQUdINXFGVGJVRjdEbEk5NktCWTg0SXlRajBZTmRrcjU2RVZDdk00cUg0WHFkMi81YUZHMmFtMERSRzVubG84U2RlcDF4UzEwdEFQL0RQSlJ1bCtUeVVjbHJpd2J4U0svMldRVUM0SWdzUlRyaGdkVEgyajc0MTg3aWhWNUoyR1JxeUdjVlhtMERldFFyRjdhQm9oaVNiUU4xSURqM1U2bE5jV1NYSWRJaWdVTmtGNks5UWh3NEE3WUloOGRwVzJZaTJJeGJadWhXSEdCdlc4aW9pRUQvU2tXVmI5dDMzdThmTlJEc1VwdGczWXphTTNkd1NNcGxsOCtpcFovR0lpNHhWS1VQdG9HZVllUTh0SGVENGhpS1Q3LzFQTFIzaFJMWTRUM1VLeGkyNmtnK2FoMVV1RFZOb3pkUXNkQ3NWSStpdmZYUjVTUFdpZGttZ0EzV2o3S1VTeDUvemxpQ3gyeXBIL0k2NzIrLzdpVnM3Q0NQZ1RrWXNXUmh0WGxvOWpzWmhadFE4cEgrMUdzWHZKUkNjVzZMQ1FmbGZVbGEyZ2I2cjQwNWFObmtJOWlGQXRxaTd5MjRlT0dqeG5sbzNnd3FKZVB6a0t4dEVIVzdUSGoyZzZBdmdFKzVhTndzQXJUcmRCWWZHcHR3Nzd4QWM5Tkp4K04wamJBeDRUS1I4bS8zMG8rdXMzRm1sayt1bjF1SnZrb1I3RzIvV0xLUitNcGxxYy81YlFOWE5Dc3V6bkdwbTNRNWwxcDI2K0VZbW1kYWZOc29SUHp1R0Y1Qkw0N0N2RThncFNQMXRRcTVhTlllWXlWajBZRnNsYjVhQlRGc3N6eUtXMkRMbzhqVmo0cUgwVDdhUnRTUGpxbmZOUVRpT2twRmo5QnNteWhnM3kvYnRvR1dmdnp5MGRYMmtKSFE3RnUyQUN2bnduZFh6eURZRytLMVY4K1dxLzFjZ251UjlBMllMT2RzOGxITGVVS0ROYmZpZGVhYnFHRGQ4THg4bEc2QTlWVHJGNmJuL2ZkUWllbWprVUZVVnlBWkdsVFh2bG9US0FZTHgrTnBsaFIyb2FJUHZBTVcrZ1lDTllIWFNDU3IxWDdGUG9wRnB5OEhCTnNhYWxZbEh6MG5OcUdsSS82S0piMjdzUDY5Vmo1NkVQYnNHOXpQdmxvaExZQms0LzJTbmlIS2RZMi9TTGxveU1vVnZ0dGN5UnRIRzJiTG9vbFdiYWx0QTFTaWtXMTAyTnRvUk92YmJqaHkxYlBDOFBNdkVUN0ZPcTIwSkZIdHZMSU8rV2ptbU5TUGlxbk1QSmdpajVtWnZsb3FXMklsSTlxT2xoSkgyRkx5bTFSMSt2Qmh1dExVejY2dG54VVFyR29oUGZpMkRlS1lrRUo3M0NnQkdzYlpwR1A5dDlDcDEvQys0MG5LWC9NbHI3cHY2U01ZaUd6M3U4UlBxeVlRbHhQUGlyWE5xd3BIeTJEck5ua283cEJPVTQrYWg5c2Fma29QOXROK1NoUHNmYjFmWlBubXZMUmc4aEhaVnRhNlo2am5vL1FOc3dnSCsxQnNZUTFKMVJ2ZEtNSGUyaTdoemlLRlZYQnRWdm9DREJpVS9tb0xuOGlMdUdkaU9pWGs0OWFaN1JIcFZpYlk1cktSN2NKN3hRNVN2a29WbjVVbnlxaFdCNkNGa01EVWo3S1RwaTZiYUhqMVRaUXdSYzEyWXFsV1BzVWc1WGtveHpGdXYzMXIzOHNDWDZoN25TcloxMGVpaVhObDRuWlFxZk5rb0ZkUHNvUnJhak9Na0krR2hGa25WVSsyb0ppeGNsSDJZVDM3ZlVBdFEwcEg2MGYvRWJRdThCSnNZVk95a2R0RkNzdUFMZG9HN2pKVThRV09wcnJvVWwyOThwSEk0UDVXZVdqWEpCMXU5OHZsMmVRQmYycjd5amNvbTBieFlvakRmcGdxd2ZGT281OE5PcHhSdm1vbG1MMWxZK3lzL3hUeUVkYkJORS9manpyT3IrRkRpd2Y5VXkweml3ZjlWS3NhRzJEVno0cXBWakZoQWlsV0pLOFNXcDVzQ1hGc3RTUkdTaVdrR0RSQTM0NTY5SnRTSm55MFRKd2dnS3FsSTlXejZWOGxKa0JXNEt6TXVBaUtGYTRmTlNpYllpaFdQaTVlOGhIY1lxMXIrOE50OURSUGxJK0drU3h2UEpSK0gyNGV4RkxlS2NuUzdyQWFoV0s1ZFUyQU0rcmxnci95TUdpS0JaTlVLUVVLK1dqKzRBS2xvL2lTN1FwSCsxUHNjNHFINVZyRzdUeTBVZWZJU0ZJWjVXUFFwT0tJOGhITGErbGZCU2pXTlhuZXBma3hyV1dqMjc3OWhZVWkvdmIwZG9HTDZBUUxCSGlYaXgrd1A4WURQRXZtL0pSYXlPTnBsZzl0UTFRUTV5Rll2Vk1lTGVVYTF2NXFFemJ3QWRkS1IrRnk3WDFGam94ZGN6VHQxRGFodGhsUS9seE04bEhlWW9GbjF1bWJlQXBWbXY1YUN2TlF0c2w2VHFOaDM2L25HTHRsZ2lsZ1JiUUFiRHkwUkVVcTU5OGROY29scFNQY3BXbkhjVTZqbnpVTi9qS0tWWTcrU2cvVTVmSVJ6RnRnNFppUmN0SE41LzFZUEpSZktsd0JvcGxuY3pNTGgrVlhnc054Ykl1RzJvbzFtZGIrU25OdllxUWovYWlXSjQ4VFlwaUtjZlZmNmdJMXVlUzFVOG8wQ3Jwd3FhaitDYWJHZGtvRmxBbzMyZVNqMG9iWGNwSFpUTjdPT0c5b2xpWGFJcVY4bEVieGFMa285UU0yVE1EOXNoSG8yaEdaQ0Q5cU84KytXamtaMmxQc1dJRHJyYmtpcUVZNFZ2b1BKL3pVQ3lmZkJTZlJFWFRxcnFmSDd1RlRnekZxZ2pXSTdpUzBDdElsb2QxQ2w2S2hVUzMwOGhIVjZSWU04dEhrYnFpa284KzZvaUdZc2xtU3lrZkxZS3AzeW1pSmRjMnBIeTByTy9SOHRIWnQ5RFJIN2VxZkJUWE5zUlNyQmo1S1BlNm4ySlIxMi9FRmpvV2lzVXZGZDQwd2RYOS9qSGJFa2JpTC9FVXkwcXFxSXNlcTIyd1VLeHR3anZXV0Z2SlI0blo1bkx5VWE1K3BYelVUckV1UW0wRDlocCtuZWFRajdiTXplTHZEdDYyWjZtMllWWDU2RGlLeGRUdlVJcWxtZnhZNWFNVXhaSnFHNkJBaWdxdVBCUnJsSHhVM2wvSEpidy9ncXhLMDRBRlczaWpSU25XUlVleDZrRXdtbUp4eDQrU2owS2RNWGJ0bytXamxxMEIvdTd2UnNsSC94aU11Mm9iVWo3NngzVmd0UTExWjcyR2ZIVDc2Q2tmWlFLdmxJK21mTFRoSkZxK2JRN1Z6cVVVSy9yN3RORTMwRXVGVW9yMUNMSnUwdUNxcEZnRUN2M0ZSckZzbGYwSThsRk0yNEROZ2tkckc2TCtybDQrQ242YWc4dEgrMmdiaFBMUmk0UmlTUU9xelZLaWtXTEIyZ1o1WHpLWGZGUlBzWFFVRFhpa2ZOUVJsRVZSTEk5OFZFS3h0Z1NtcGxLNHR1R2NXK2lRZFFhaFdIaVFkZFBjUVFqbEQzME9BdC8wRFYrL2hjNzJ1SGdmVm52NUtLOXR3R2xXWkhBVGtmQWVRYkVFNWZ4MUZvcEYxWkVXU2FCV2JRUFRvU3UxRFRhS1ZYZlc4ZG9HWnNMazFqYTBrbzhXaERMbG8rWUFLZWE0VWZKUnpTUkwzbGZFYVJ1d2dJc0x0bHBRclA1YjZGQVVTN2ZpYzVNbVd1OUpGcGRvTGFWWXp5QnJQTVh5TkY2WmZKUlBlT2Zsby9pc041WmljZEY1SDRxMWUzNDUrYWgyWUl2UU5qQVVTeEZVbGJOOHZYd1U2cXp4NjJ1VGoyN3ZhaXpvMXJ1R1lrSG5iNUh3VHBkaHlrZDFBZEs2OHRFMlcralVnWUpHMnlBTnZpdzdOV3lEckZaYjZFZ0pxbzlpb1hUcnB5ckFraWUrZXlpV2ZoQzBVS3haNWFPcGJjQytnMWpia1BKUnVQTTJ5RWY5MmdZNjZPb3RINFhLc2FaWThzRWhrbHpWZzQ2WFltMzd4WlNQMmlsVzFIZVVVS3crOGxHWnRvRUxwS2hKVW92cjZ4blhZN2JRc1ZDc09zaTZXWUtyY3VDREs0cWVZbmtLTE9Xai9TbFcxR01tYmNONTVhT2lHdktHRWF5eVUzN01uc3NnaTk3bnJJKzJBYUJnaDVPUHpreXhySk9adWVXaldvcjE3Sy9heWtkbHdXQnIrV2hyaXRWRzIxQVRRTzFZZWRNTTdQeUFUeVVqMXhGODlCWTY0K1dqTWRvR1BjV3lMUlhxeU13czJvYUtZbFgxeWhJd3AzelVSckVlQVE3Y0NlOXpvYmpac0NiaFhkcXhjczl4eDdhaVdwSHlVV2lpdWhMRmlnMjQrcEVWM3hZNmZDQzFQeTZXWWttMERaSHlVZG0xcG1GQjdHYk9MWW4xYzZ5OFdZS3A3U2JRZEVYcHNZVk9PL21vdjhCMEZNc1cxSVozRWo4dUF4NHhGQXVyVXlrZmJTMGYzZFpwbjN4VVZoNGN4ZHJVNTNkcTlqbEMyeEF0SDQzWVFpZmxvK2VTajFMSHRaS1A4aFNMM0ZwcklZcjFETEp1c0lwQkYyZ1Y1SUdpV0V2SlJ5MFVTeTRmeGJVTm42Ly80RHhrN2JRTnMxT3NsSThLWFZoVHlFYzF3ZFJZK1dnL2JZT09ZcVY4dEJYRll1cTNkMUl0S2dPcmZGUkxzVHp5VVUwK1ZqdUtCV3NiMmxNc1BCK0xDN0p1NVlDdC8vZTB1OE1KN3lrZnhRWWtUTnRBQlZTOEZUcWtrNWhVUGpxUHRtRTJpcVdaOWZhV2o5WnRhMWI1S0g3dXNSUnJYOTlUUG9yWDB6UEpSL2x4Z05NMnlNaVYxUExlYWdzZHpjUzI3eFk2L0hncFdpSXNrOTdyUUlCT2VFLzVLTm9wL0U0MVJFbytDcFhIOGVXalVsS2E4dEZ5MEJ3bEh5MDNnbDVaUHRwRDIxQVFxWlNQcXY3dWNlU2p4RVJjSVIrdFNRd2xIMzIydjE3eVVjeU5SVzBFUFdJTEhlamF5WUtzRzBkS05NdUVXTUw3R2VTakVvb1ZLUitsT3NwUjJvWjI4bEUrNFQzbG8vUU1tT2pRWDF0U0xMeVRYazgrMm9sUXBuelVIQ0RGSERlRGZKU21XUElBYm03NXFEMHc3MEd4b0FDVkNmQi9nQUdXSkhBYW9XMVlTVDZxM0VLbnFYdzBxck9mUno2S2RsVkNiVU5yaW5WYytTaE5zZVR5MFRvSDVLbHRJR2FydytTalBiVU5kWm5KdEExMVg1cnkwWFBJUjhuL2xSU3J2WHpVU3JIbTNFS0gyNnR3UDJiZUpQaytFUlNMdWNndkhKMktwbGdwSDIxRHNlYlNOclNqV0NrZnJiNFRLQi9WTGpXTWtvOWl3dEVSOGxGWnZrM0tSNzE5V1JTdDBwTzZkdkxSN1FRK1VqNHEzUXphRXNSRUJ1WnR0OURCU1ZhNTlMb2pXTnFnQ2crMmZOcUduaFRMUTdia002ejE1S055YlVQS1I2TXBscDV1eGN0SDlZTXNyRzJBWmFMenlrZUJnWDRKK1dqZGw2Wjg5T2p5VVFuOWlnZ0d0L0pScUgxYnR0RHBLUi9WanVIZUxYUWdrblhEQm5RdnljSUdRQXZGYXIyRkRsOG9jOGhIZFlOaVhNSTcvdmxUUHRxTFl2V1NqOVoveDZwdDJNdEh0d252V0REbWxZL0dheHRhekg2dFFTMHNIOTA4bC9MUnk0enlVY3ZFaVM2dnFDMTBMTnFHbGVTamJiYlFrVktzajJ0Njg1SVRTTnNBQldvZWlsWE91alR5MFI0VVMxY0JjSXFGcmJOTGc5Nm96akhsby9xZzZUenlVVGJoZlhzOVFHMURLL2tvOElwVDI1RHkwVmtvbHY2NFdlU2oxN2RaNWFNYTJKRHlVYkNPdkhQWDlSWVJYUEd6b3lqNWFCd0MxQWRiN1NuV2ZrQ1lUVDZxMHpha2ZIUTh4V29qSDZYcjlXVWgrYWhzNEp4WFBncjFwU2tmVGZtb2hXSTlpQXRHc2JSN0ZQYWpXTnlOTXUwQysrYzREZDg4YzdrQVNlN1E3eWtmVmEvaHY5b28xc3p5VWYweEtSOGRTN0Uwczk1ZTJnWThweVBsbzFyNUtFZXh0blUrNWFOMktuWXUrV2lkOEU1UGx1cDJqUjNiaG1McHgvQTI4bEdZWnQyd1FweEgyeUQ3Z25QSlIyWGFoczB4Ym0xRFdVWTlLTmJtbFpTUEdtZHFFM1NnTE13QUFDQUFTVVJCVk1wSEx3RVU2MEpSTEVnK0NuWFNkVkFXS3grVkQ1d3BIMjFKc1RTdnAzeVVwMWpSMm9iVzh0SDk4M0w1S0VheCttMmhBOUdzL1h0dmtrYkltZDNqdFEweWlpVjQ3L1R5VWI2VDQrV2pCQ0oyQlR1enkwZG5vbGlTT25KMitTZzF3MjBsSDZVRHNwU1BhZ2pvbWhRcjVyakY1YU52WG9wbDhWKzFsby9PdVlYT2ZzbndSaFdpTnNGYVFyRmtDZS9ua1k5R1VxeXp5VWNsRkt1WGZCVG9wS2FUai9haFdMUzJRU29mSlJKYm0yc2JIcmtvKzgrZThsRnJrRFVqeFRxWmZQVGlwVmlmYmVXblo0L0NGbHZvY0JUTE45YTUzdjErdVZ6ZmI1b0N0eTRaUm1zYldsRXNqM3pVTXZ2eVVheVVqNlo4MUUyeHpQSlI0R2VWdHVIWkNkY0o3eERsOGxCQTZ5dzExb3ZqcStzcEg0MmxVOUxQZFRUNUtFNnhwTm9HT29BcUF5MXBtendXeFhvK2QrT2lZWnR3ZERiNWFIbExmbHV5cFpXUFloVExXeVpSRkN2bG85YkFhMjc1cUZaU0tCK1FNVzBESER4UjhsRzQwNTVMUG5xNXpDUWYvYU0vVGZub0plV2p1bllyK1E2MWZGUWJoTW1XMjhkdUJNMTlSdW01YjlvL3ZLWjgxTGNFS0tWWThpMTBwTnFHbW1MdHkrSzVWQ2drUG9FSjcraHM4eERhQnV1TTl1ankwVzNkajVDUGJnTWM2bzRrb08ybmZCUnB6eWtmdFZHc2xJL0t0UTFsTy9YSVIvVjBTQThMSXJiUXNlUnUzM2pzR1BGdkR2bG9hNHBsTHd5YmZGUVMrRVoxanBDbFZudU9QdG9HOHZPTEU5N1BMaC9Wdlo3eTBURVVhejlwVGZtb2oyTHg1enUzZk5TNlI2RlhQcXI3ckhLS0piMXB4aE40cXdpV0p1amlvKzA5eFNvcXdvdWNZdG1JMVJIa28xRENPMFljTjlkOW1IdzBjZ1ljVGJFNFNucDJpbFcvbHZMUkhoUnJtL0RPVTZ5VWoycnBsUDY0ZGVTajBSUnIzMzczMmdhOFhmdmxvM3FLUmN0SEpYYzFSdlhwTjAxQWhmMnNsWTl1Wmt1YkRvR1dqMm9wRnZMZVE4bEhzVEpMK1dqS1I2VVVhMlg1cUVYYkVFT3g4TDhSVGJIZ3NrdjVxQ05BT29sODlQb21wMWgxZXlnVDNpVUJGUFVjOXp4SHNWYVJqN29KbGlmeHZZZDhOR1pBUElaOEZLZUs1NVdQRmxLN2xJOFdnMlpMYlFORnNTenkwU0p3VnQ1SkdDTWZoYzZmOGxFL3hiTDI4N0p6bkVFK1N0VVhYajRxSFB0K2FnSXRMT0RpeTlTdmJkRFdsU2pBY09NYUUxVlExbVQzbHZKUi9pSWNWVDY2anJaaHBIeTBEdDdiVXl5cWpxd3ZINVZyRzFJK0drb28xZkxSWUlxbGZhUjhkQURGSXNxTGxZOXFLWmJrZFN5d3NpN1R6YjZGanVzdVFpN1FnbzVQK2FpZFlsRTViVDIxRGZOU3JMbmtvd0QxT0tCOFZGS21kdmxvdVZSb29WZ3BIeTBwMXYxRlZzWXBIeVhPZEhqNWFQbmR0UEpScmJhaE5jVnF1WVVPOXZ4TlF6NWlOb0pPK1dpTUp5WGxvL0IzU1Btb2sySk5KUitsZ3pFN0JUeW1mQlJhK29ma28vczZqMU9zbURybTZWdFNQZ3FQZ2IzbG85dEpodFI3aFUyb3BHMVNlcTNLaFBjUjhsSHN0WnVsd2tYSlJ5TzFEVDNrbzFFVUM1Z0ZwSHpVUWJHRVExUEtSNmVVano0N2RYcUd5MmtiVWo1YTF2ZVVqM0xIcFh4VUV5aDc1YVBjUC80NnliVU5ITVh5MURYTkpPdjJPV1A4d1VXWVhMNkdMZENLcFZpdDVhTVdpdVdSajBvcDFyNHNhUGtvUUE5VFBnclVLN3d0cExhQm9saDYrZWpjMm9hVWo4NU5zYnowMkJhWUhVTStHa3V4OWt1RkdMM3FKUjl0UWJFczVQTzJ2WERhUnU2Vmo5TGVySlNQV2lnV1YwYVJuYU5FUGpxSHRvSDgvRXI1cU9mNkhFWSsrc3BUcm5odFE4cEhXOHBIWlFudnMxTXNQZTA2aTN5MDFqYmdnVFNYOEY1UGpMREowcXJ5MGFpRTk1dXRzNlk3WXptOUtoUGVVejRxK3o0NitTZ1dlRzJ1KzhHMURTa2ZEYVpZeVB0VTh0R0xsV0poMXpmbG94REZrc3BIN2YxLy9FUXQ1YVBTTXBETFI4bnpNSCszWENsNTN2Q3hiMys0dG1FRythZ2tvTEtXSC9iempTTVFYTVB5NW1NZFV6NXEwemEwa28rVzF6c3l1SmxiMjdBZmRJRG5VajU2V1VNKzJsTGI4SmkwSUhkSnBYejBrdkpSenlBN1FqNEtQMGZMUjNVVVM2NXRvSWhWUDRvbDc2c3RLUVRZdVc3ZWhrM1JxNy8rdGIxOHRCd1FMUlRMUnFyc3o4MGlIeTNvWWNwSERSVExTMHQ3VTZ6WjVLUDg4c0plMjFCMjRNaWt5U1FmTGQxY0Z2bm9XRzBEMXA1VFBzb2ZkeXo1cUdaL1FodkZrbXNidEhjRVM3VU4wVnZvdEtpdlFJQ2xwMWdXbWlXbldCNDZFa094YkJjNDVhTnpVS3lVaitxRHBIN3kwVWZIWHNwSDZhV0dPZVdqa1VuUVJrS1o4bEZ6Z0JSejNPcnlVWnBpbFpNZG5iYWhoWHpVY3ozalVnZXV2MzljcSt2djVjODNYNE11cVFuK014MXNwWHlVcGxpNmhIZE53RnZPZXFNcThUSGxvM1p0QTBFOVVqN0tkcnBRTGxZdEh4MmhiUUFvV01wSGpVRldUNHJWVXR2Z0NjU2lLRlliK2FnNDJQMHBXU2FrZ3JCZUZFc1R4Rm1XQ3BFQXkwYXhKQU43ZVF6ME96UUFFcC9tQlBKUmNaZ3pqR0xwR3VRczJvYUtZZ0gxYWt1eDdEUGZ4ZVdqWFNqV0k4REI1S05ZTUliUGZwL2xhdHV2RUMrN1diVU5Cdm5veXhubG85YWd6VHBwOTM1SENjV1N5a2VaQUM1TTI2QUpxcVJ0VWo2UmpkYzJXQ2JSTnlJSy9hRnAzSm90ZEZJK0tqbmZrZVdqYlI4eDh0SDlnQk5Cc1JhV2ozN25BaTlCcDg0bHZHK3ZSNUI4MU5wNTA5b0dySTZ2cG0yQUpoVXBIejIrZkRTQ1ltRnR4N3BIb1VZK0t0dENoKzczb3hMZXVYcHlzMVpxNlIxcmtmSlIvRzlHVWF5VWorS3ozdWpaWjhwSGUxR3NPZVNqYkwwK21IeTBuN2FCSHhCVFBtb1B1TnFTcXppS3BRMnVmQlNyaERId2NqMHNIK1h5c1N6WE9wcGlhY3FMK293M0tQS01vRmd0NUtQRklLaWtXQ2tmeGNvb3NuTmNXejdLYXhza2RjUVd3S2Q4OUZqeVVmemNxOHBIVjZWWSt1T09MUi9kbnIrbGZGUzdSNkdWUkkraVdNQzRVYjErczFZazdjeFlvbTRvNlVJUCthZzBhbDVOUGlyUk5tQVU2N3p5VVo2TzRtV2U4bEg0dFRqNWFMa1JkSHY1S0t4dGtNK3cxNVdQV3VwUTI0bGF5a2Mxb0VOR3NjalR1ZVdqbjIwb1ZENGFTN0ZvK2FnMjJCSnFHcXJnb09rV09oUUIyOHkwbThsSE1Zb1ZTYXBHeUVmaGhIZThyQ0tEbTVTUDZnT3JsSS95RkF2dnBGdkpSOUhic2c4dkg0M1lRaWZsby9QSlI1VmI2THhwNWFQV2JYSm1rNDlhN2k2RW5ydHhzOGNJaXFWUHVQWnBHOG9CMGRLSjJraVZMcnBWM0xZcmxvL1Myb2FVajBybG8xeW5SVkVzNjZ3ODVhTjErNEU3NFJua283VzJBYU5ZSTdRTmNEbWtmRlQzZDg4akg3WDF2M3VLaGZkVHRYd1VhN3VqNWFOMmV2VVJrNkE1V0F4OTZid1J0RWZiY0R6NXFMM0JyUzBmYlpud1BoUEZrdFNSTThwSHl3Q24xRGFNbFk5QzViamZQb1NyQnkxSlpVbXhtS05UUG5weStTalJ4c1h5MGNmNHNySjhWRHZXaXpRTnNsa0JQakJ6c2t0cDBMVi9UM3VLbGZMUnVlV2pVUThvNGQwbkg0M1JOaEJ0TGVXamdrNTNWdmtvUUVKK1ltMTdoSHhVVHJGU1BucEcrYWdsT0JiczlmbFRHMmlObG8vcUoySzFkKy9XYWphRkRleVNnUjU2RHpRQVV0b0dDY1dTZEJ3ajVhT1N4bXFoV0krbHd0WVVTeGVFclNRZjFYZjBLUi8xVVN3czRSMEx4aWo1cUVVa21QTFJsSTlxajF0VlBtcWhXTVh2SXZrbzFIYWo1S1BJVlFyUk50QmovVDdJdXVtaSsvWVVxOVEyUU9kQUJzSER5VWY1QnViVE5xUjhWRXV4WURLYThsRmMyOEIwNmliNUtEMERqdEUycEh3VXBsZ3BIN1ZUclBubG94cHRnNnp0YU9tVWxITFpLQmJkNzFzUzNybkpsVXJUb0szbzF1VXBadmJsMWpib0tOYXE4dEc5dHFFdW0zM0NPMVIydmJRTktSL3RUN0Y2YVJ0U1Byb0xFaWVWano3NzFKU1B4aDQzazN5VUt6dWR0a0ZHc2VyMnE5TTJZTmZFMm5ZNCtXakVVdUcyZjdsSkNsVktJTHhidHNqbG96NXR3MXJ5VVQ3aEhhWlkxYkxnTzBTeHNBQzRaVWRvT2FhUGZEUW00VDNsbzNzSzBWcyt1czNGU3Ztb1h0dEFVNnlVajlyT04xNCtLZ01Za2ZMUi9VMGZGS25panBQY3VDS2hXRXlNOE0wQ1dVaVR1K1h1cElqa1c2KzJvUmdVaEFudjl1L2drWTlhS0paVzJ3RFBOR3phaHJKOGVsQ3N6U3VIMHpZY2hXSWhFNmptOGxIS0ZBM2RVVWpOZ0Z2SlIrWHRHS2RZUGJVTmRvcWxxME9SYlRqbG8vVUVSRFBlVXVYVlFqNkt0MEdjWW5GQmxXNnNqRTE0MTVIcmo1amt4blZHeUlYOEllbk1yUlNMZXU4bXFESm9HOGJJUi8yRVFrV3gyQWJnVFhBZnBXMW9KeCtkUzlzd0s4V1N6SVQ5Q2UvZ0lGSlJMRDdvNnExdDhNdEgyNWFwam1LbGZCVHZoMU0rS3FOWTIxakJJaGYxeTBkanhpZFBMdlhOY2lKTHd5NmZPNko4VklzVHJRMFJtdzMxa285R2RmcnpVQ3l2dG9HbldOYkdxKzJBMTVHUFl1ZVR5VWZMVHJlVWoxSXo0SjdhQnZpemo1YVA3aWNVbWkxMEJzbEhoMmdicENTc0ZjV2FUVDRxL05UdnN2RU9sNDlLdHRIcHFXM2d5Z1R2bysrL2lKTGNrWXJ5UTlPWjk1Q1BlclVOWHZtb0xUOHI1YU9hWTBiS1I0a3pkWkdQU3EvVkdlU2pjQ2Y4WENyODdPQytRWlRMYy8wODhsRkpQZWdqSCtYTGJqTDVxTHJmU1Btb25HSko1YU55aWlYVk50QkJGUlJJOVpTUFdsTTd5THNJbzRJc2FzYnFsWTlhdFEwZWluVkUrYWdscUUzNUtFYXg1dGMyUk10SEtXMkRqMkxCRXdlc2JkRkxFUHVFOTdxVFR2bm9FZVNqbm1Ea3pQSlJyazFHeTBjTDZqeWRmSlJLZUxlTTFiZUlXVEIwcktRQUxYbFpTbTFER01YYUhuY1UrZWordWoyWENvWEVKekRoSGZ2OWZQTFJLT0xYUXo0cWFlczk1YVBiQUllYUFkZlhhWlMyUVU3Rm91dDZ5a2Q5N2M1NjNHenlVWTVpRWVWbG9sajF4R2kvVkFpMTNaYnlVWHFwVU5hL2tuY1JZdGhOL3NkazRraUtZdWtDTGtqYkVFV3gybWtiMmxHc2VsYmprWTlTWlJIVk9RS2ZPZVdqS1IrbEpoRlR5RWVCVjV6YWhwU1A5cVJZMXNsT3lrZmJVU3l0RXl1YVl0SHZlOTRvWXlXTk4yMTBySmt4UjFFc2VnQmdLZGFMbkdMNXFOMEs4dEhOUVBiT0pieEQxenJsb3lrZmJTVWZGZExaWmVTanNvNDQ1YU9qS0pZdlFMSUdabXZKUjVuM3VDbldaM3Y5cVYwbWhLNkpkWU4xejFJaHUwUm9LVHlNUUhBVnA0VjhkRFBURnN0SFIxR3NHZVNqVUFPZ0dtSEtSMU0rMmtzK3FxQllZdmtvbG91RkxVdG8ybXdNeGNML1JzcEgrMUlzUGUwNnZueFV2NFVPTHgrVmtpcHNBc1U5VDF5Skw3M3J5YzBpYjR1Yk1ka0NybkxnMDJvYldsQ3NvOHRIY2FwNFh2bG9nYUM3eUVlMXRHb0YrZWkyN2x1MURaaDhGRHFXbUszK1l0c0FPa1krQ3AwLzVhUFdpVWhiaXJXeWZGUVhYTVhJUi9tSlRLMXRHQzBmdFN3VmxvK2JsU1pFVXl4cG9FV1RGV25DZTl3V09xM2tvNElTYVNnZlhVZmJNRkkrV2dmdk5NWFNkcjdVcmViV1dWVTB4WkowMWx6Q08weXVkQW52TkwxSytTaGRaaWtmZFFSSVRvcGwrMW5iemltS0pRdXVmUExSTWxhdzNESEl0WEZ2Vy9MQUVVd2xjZk5RSyttc09ZSml3WUVWVGJId2hQZjU1YU5qS1ZZL2JjTzhGT3M0OGxFdFBaaFBQZ3JQMUhsWERweUxOVjQrK3N4Rk9ZOTh0TzlTWVcvNWFDK0tkVVQ1YUhuVGgzV1BRbi9DT3kwZjVlSWs2RFZWa3J2Z3pvZ2Yyc0wxeUVaVFBwb1U2M0pKK2FobDBoTVJpRWtvRnRHaE45YzJQSllLOSszcmFXa2VKeC9WQmNySGtJL0cxREZQMzVMeVVhcnNKTUZWRy9rbzFCYWxRbEpwbTVSUFpIVkxoVnhacVpQY3JVdUYxR0M4dm54VWx2Q2U4bEZwUjVqeTBaUElSd1hhQmpuRml0TTJwSHcwUmo0NmQ4Sjd5a2Mxd2ZVejRUMGk2SlhJUnkzU1VRM0YwZ1ZlOHQ5M21vYldTZTZhRG41ZCtXZ2ZiWU9FWW1tUk16N0Q0T1dqQUQwOHBId1VwbGg3YlFPVjhHN1ZOa1FUdndubG81ZFlpalczdHVHSThsRm9vc29sVGM5RXNWSStxcVZZWlBzTmxZK1c5Wi9la1FFNmo1VU84MHVGMGlEOHBna09lbElzWGNDVjhsR21QSnJJUnlNN3h3ajVhQ3R0ZytLN0tlV2p0azQ0bW1McDZkWjA4bEd4dG1FVFFLVjhORUErdWpyRnNsS24yZVdqMG12eFNIaVhhaGowOGxGTzIrRGZvNUJxdzFadGczVk1CazN1bHBtek5HcVdKTHg3NUtQNCtWSStLdnpVS3Zrb0ZuaHRydnN3K1dqa0RIZ1dpcFh5VVZtOWxtb2JwTGQ3cDN3VW9saHkrZWlxRk1zWElGa0RzM2o1cUczaVpHLy9tOGNiczd4ZjVFVENFK2tvK1NoL3JmR0VkL3ljNEkwZjRQbURrOXoxQk1LYjhQNThMeThmRmQ3dE1wbDhGTmMyakpDUGxtVVYyVEhPTEI4dGwwS0JxNkxXTnFSOE5JNWlYUkJ0UXhrMHRkWTJQUDQrWXF4TytlaGlGRXRQdTFJK1dvOHZkbTJENXM1Qmo3WkJNeUV0Z3l4cVhMOTVncXBJaWtVTjRsSHlVVXJiTUlwaVdjNGhyd3o5NUtORlkwMzVLRUN4OERKTCthaWRZdEhhaGlLQnRwdDh0QXp5VWo3YWoyS2xmTlJQTTUzeTBZdU9ZcUhIL2JRc0U1YVRLdjVhWVV1RmVDNldkTWVibTVaYzZhaVdqMkpKQXkzc3ZkQUEySU5pU1JOY0IxTXN0Z0drZkxUNmhpa2ZGVkFzU1djTnZJYktSeEVScVVyYjhPeHd5NlhDT2VXamttMTgycEJKSGNWcUpSLzFVQ3gvWHhNakgvVXVMNDZrV0xMQTJFT3hjRzJEUno2S0JWWjJpZ1V2Rlg0Y1gwK3VVVTJEaDF6TlFyRzg4dEVpcWszNXFMSWNTb29WMWVtbmZQVDQ4bEZML2dkSHNiRE9EMW9xcER2cFB0b0dnSUtkVmo3NitmdlM4bEZMSUdXaFdEM2xvM0VVaXlhN2tMWkJHbWg1dEEwUnF3R21IQ3o3VWlHY1l5Q2xXRnJaYU1wSDIxSXNiYU5LK1doYmlwWHlVVG5Gd3VXajlKS2haellzWFNLVUJzbzlFdDd4Z2JhZXZLWjg5RHp5VWJoT3hNdEhvWWtSdDB3bzE2OVlydU5IdlVjSTE3ZXdIQ3o3ekJnbUVLM2tvL2Y3T1Brb05Ec2JMUit0QnlJOE9aaVRqM0xsRVVXeFVqNXFEYnptazQ5S0tWWkpJZkJaTkt0dDJGNlBjUG1vdFBPR0J4V2FZZ0VrWktpMllTOGYzVDBQYVJ0U1BubzVybndVZjY2OWZGUktyeVRIRWQvK2kzR3MvK2JLd2JKMCtKNVpzMWMrQ2xlQzNoU3JoUS9MUTdIMmpWVTJxNkhsb3hpVlNQbG95a2NkRk92Q1V5eDZFTHBjTG0vVUhZU1BBQ2ZsbzdMK3Q1ek5NOHU1S1I4Tk9PNXM4bEZvcVh6ZmZuWGFCdnYxeFlLc1p6K3Y2VXRGT1ZqV3BjSW9pbVg3QjJrYm9paFdyTGFoenhZNjlhd0drNDlpRFlzS3FGSStpajVTUG5ycEx4OTkxR21OZkhTYmk1WHkwWlNQZXNhL0dlV2p1amJ1bDQ4U24rVjN5VFdYa0NwOEF1WFROaUJYaGdpeTlqZkxWQUdXcmZMRXVTV2tnWmRQMjdEZlUrc284bEdNWXFWOHRLMjJZUlRGU3Ztb3JGNXI1YVBVRE5ndkg0VzFEZkkrdHA5OHRJMjJJZVdqUGNoVkhNWGkyN0NpL1lmS1J6Vko3clkra0Y4cWxKYnBMYUx5eUFzVlRuajNCbE9TYlhicUFmQ2pzenlDZkZTYTlKenkwWlkwSitXamZlU2ptTFlCcDFqYldmTTQrU2hXVnZQSlIrSHlTZm1vblhhZFR6NEtIQk1tSDZVbVRSRGxrbElzMmZpODcrZUx3S3pLdzcxeGQ4MjB1QlhjMDlpMy8vNzYxNTd5MGUyeVRsdUtaVGxIeWtmSFVLeVVqL2FtV09oVk80VjhkS3kyd1V1eGRIVW9zZzJuZkRRaXlLYkx6ckN0RGtHeDBPTitXcFlKeTBtVjRGdC9rVjdENG1hWVhkOS84eFMrTGYvSFI3RzJ6MmtwRnpZQWFodnZnYmZRWVJ0QXlrZnhocmk2ZkxRbnhVcjVLRDY0WUJUTExuenVTN0UwOGxHczdxUjh0Qlh3T0s1OGxKb2tTZVdqbU9HOWVQNnJ0TzdjTE5GMnE4ZzVVajY2RDhTczJvWTJGTXZudy9JMVBuZ2dzbXNiVWo0Nmg3WWhvZ09Pb2xqQjh0RlhXem5LNWFQWVV1Rks4dEhMWlhiNUtFeHVnZk4vWjhhSGxJODZnaktndjFmUkt4bkZ3czgvbTN4VTQ4YVNCbGxidy91dFYrVGNTejdLRVM4OXhZSTdCczhXT3BiZ0NUNStIbTNEWEJSckZtMERHTUNEOVVyVDBaOU1Qb3JObEVNb1Zobmc2T1Nqc29SM2ptS3RvRzF3eUVkZmdOZEY4bEg5TWxNTURFajVLRDhHU3BjSXZSUUwxelpFbTl6UnEvSEZGbFIvVE5DYWlrWmJhUnRzUWRkVDI2Q1ZqOFp0b1RPVGZKU2MxYWkxRFhQSlI5cytZdVNqR0JsTitTaEZJZkJCZUlSOFZEOFRod2VWbW1KQmRYeFIrZWdsNWFOSGtJL1cyZ1k2dUlxaFdIZ2JoZVdqM0NUSmsvQU9RQk4yTEhPSlJuMFVTL2Yzckh2ajBRTURTYkVVMm9aenlVZTVoSGQrQnB6eVVSM0ZTdmtvUnJHa2c5RGxjUExSZnRvR25peWxmRlJQT0h4amEzLzVxS3dOdDVLUEloT1NuOXBsUXR2WXU2ZFkrK0NOQ3JMdTMxeWkwZDRKN3paeXBaT1B6cUp0R0NVZmxWQXNDZFdnQXE3SWpuQXQrU2lmOEM2cEk2TW9scDV1MmVXakxTalc1VkR5VWZ6Y0tSK05wMWdSVUNIbG8rUm5DWk9QY3JUS0poK3RneXhKV1prMmUrNTVWeExWa2JlUWp4YVB3OGxIdWRrK05TQm81YVBVWG9ibmxJOUMxempsbzVvY2pwU1B5aWpXR3RxR2NSUnJsTFpCVDA5U1BpcWhXSnJOb0tWM0Y4cjcwUHRYN0xpYkZWMk9vbGdwSDZVSkJWOFcvZVNqSEkyMGRwUXBIN1VPSHRQTFI0MWI2UGpsbzNTSHZKNTh0TWRFZDJYNWFLdUpjaFRGNHMrWDhsR3JmRlFTV01IUHd4VHIwZGREZmNNdDRsYnZpQUhQMDlqMTJvQ1VqMHBtKzlDQUZDMGZqZXZzbHBTUHZrQVVDeSt6M0VKSFYzWnkrZWorOTcxOGxGb2F0R29iZVBsb3JXM0FLRmJLUjIxQlZzcEhJNEpzZmZ1WGx5RXVIKzJwYlpBSFdmWG51MGt1dURXNTFxdHRzTWhIYlFGWFBRQ21mRlQwclplV2owWW12QmZmeUtCdG9DbVd0cDJ0U0xGbWxZOStQUGZzSHl3VVMwSzQrQW5UUjl1Q0JnUkpjSkFVSzVwVXhjaEg0NmpZZlBMUmttSkZ5VWVoWUVhelRHZ1pML2l5cWZ2Nm02ZHhSb2tNTFEyYkNyaFNQbW9wby9Ya28zSnRBMHl4b2g2cnlrZDdVcXlqeVVkaEN0WkhQZ3JRbE9ubG96REY0dVdqbjMzRW9lV2p2U2hXVkM2WFJOdFF0L0gyOGxFcHZlS0NMbXZDT3hSa3VaUGM0eXFqakdKRjBLd3lzTnBVbXBTUENzdE9JaC9sTm9lR08rVldzODhqeVVkbDJnWk9QcXJQUWRCM2pFZVJqMHFvMVZodGc1eUt4Vk9zaWxoMWxZLzJvRmJIbDQvS0taWVdmdkQxUlVheG9CME80R0FyVHR0Z1d5cDgxbjlWa3J1MVErK2hiZEJTRklPMkllV2pTQU9nalBreWloWFpFWjVCUHVxYnFjNnFiWkJTckpKQzRJTnduSHgwRTBCTnFtM29LeDhGZ2lwVVBncE5LaUsxRFMwb2xyMGNZN2JRU2ZtbzdQcFI4dEd5alZ1MERmYnkvUWl5YnA2S0ZJRWJvenB5LzlZNWVtMEQ4K2tPTGgvVmFSdWdhejJMdGlIbG84ZWlXTkpCNkxLUWZGUTJXTTRsSDkwRTF1QlNJVFNwT0xwOE5GcFNlaVQ1cUpaaUlYMy9UKytkaHZKMnlDZTgzN1NZYkdhS1pkdWpzS1pZVW0wRFQ3SHEzSUg1NUtOOHdqdE1zYXJqM21sNjBWTStxaittajN6VXBtMDRFOFdhV1Q2SzVXSmhIYk9tSGNkUUxQeHZqSkNQd3VYQlVTeTR6bk1VNi9PUjh0RUY1S1BFK1lacUc3U0JKeDlrM2IvZVdoQ1VFVTRXYTdCVno3YkFnVkdZOEI0YkFQU1JqL0t6L2VJY29kcUdYaFJyODhyTTJvWlFpcFh5VWFwZTQ5b0dURDRLSFl0Zkl6cmhIYWRZbUxaQlI3R2c4OCtvYmREVW05a3BWc1NZNktWWUxiNmp0cTFMeTVFTHlMQkpQSzlTcUxVTlVQdm1nakRKdGVXQ3JOdEhjSEgvZXIzU2QzTkZMSFgxa285S0F5MmFyRmkwRGNlVmp3cWI2cnVsb3p1NmZGU1I4Sjd5MFV0cithaFYyOUJlUGtvdlRSeFRQbnBraXFVUGtMeHVyWFhsbzNCYnBLaHVUYkhLOXFnSnFtU1RIMmtmdnd1d3RpZjhDTFlrUVZDRUQydVVmQlFPckZJK09vcGlGWTMxZ1BKUnI3YUJuRDB0U3JINGhIZUZmUFRWVm5aeWJjTkRQaXBKY08rcGJkaDZnVXJ4NGppS1pkVTJES05ZS1IvdExoLzlhSHRXaW9WZEQwZys2dFUyeU1mWE9zaEM3aUo4QmxvUitSNjI0S0R0RmpyY2ZuazZpaFduYldoTnNZanI3WktQbHRxR2xJK2FLZFpGU3JHMDdYQXVpbVh2ckRHYTFVbyt1bDBxM0xlNWoxd3NhT1pzblZoYUU5M3RHN3kzb0ZoNEdaOWRQc3FmNHl6eVViTFBiNkp0a0JBdGVIS2xhVGY3SUl1NWkzQlB0RHd6WmUrZEQ1ckN0aThUOHZKUnJiYkIwM0JYa285Nmc5NG9pcFh5VVIvVjlBUUlNOGxIL1JTTDFqWnNObnBtdEEwcEgwMzVxUGE0YzhsSDlWdm80TitGMGpad1M0ZmI1Ly81bis5Ly91ZC8vcmlSUTU3d1h0ZjltMnlRMGcxNG5vTENLSmFsSTdjUDhMdEs4MDFZeFZJK2ltZ2JQbDRiSngrbGtpRmJVNnpWNUtQU3R1enZqUFZFUkVKTHZCUnJGVzFEeWtkOWcvRklpcFh5VVJIMUROSTIrSkxjLy9LWCs1Ly84aGM0MEpLUXJKdWNJTUhMaGl2SVIzVUJWMHY1S0sxdHdBbEZUTEJsSlpFV2lnV1ZCUmY4Um5XWUFBMVF5MGY3YUJza0ZBc2pvM05xR3pSM0dVa28xc3phaGswQWxmSlJRajRLQkU2c2ZKU2FSRUMvOTVDUDl0NUN4d2N4amlnZjViUU5NTVhTSkw1amozLzVsMzJRSmFzZjl5OEdUWU9NWnMyZ2JaaFBQaXFuQW1lUWoyS0IxK2E2RDVPUFJzNktVejdxdjc0ZDVhTmliWU1rb05vc0paNVdQZ3BUTEZyYkFGT3MrYlVOTTFPcytPL1lXejVhZlZJUnhZSVMzaTJCMWlQSTBsemJtKzFDMzc5RzdFM1lTOXVROGxHZmZGUk9zZUFHd0MwTHBueTBPaUxsb3hOUXJPMnNtVm82YktWdGlLRllZK1dqK0JZNng5UTJXTys4VC9rb2VqNnp0a0ViVkVuSTg3Lzh5LzNQLy90LzEzMDZHMkRwS3hNZVpGa2o2VkhhaG1qNWFNc0FZSVI4VkVDeFVqN0tCRmtwSDVVUmlGbmxvMlZIL05BMllNY2lFOVBUeVVlaExYVE9MQisxakhlOXlGVTB4WXFTajBvb0ZuWU5JRzJEaEY3OTdkL1M3ZUlSWkhIWDZhWWQwSXRPL3lzMEE0OEt2RmFWajBvcFZndHRnNVJRYUNtV2RtMytLTnFHbEkvMmVhd3BIeTJYQ2xNK0NwZGR5a2RiVVN6cHhIaGwrU2hQc1hUYUJtOCsxamJJNG1qV0xhYnl5Snhaa2ZKUmJjVzNMUmxhdFEwbHhlb25IL1V1RHpKQmxaaGlTWUxlbEkrS0tWWlgrYWkyYlo1VlBzcjlLNCtYVUt5VWozN1U5d25rb3c3d2tQSlJYWEMxYjN0NmlvVi9mcXUyUWZQZC8vVmY3My8rMTMrRkE2MWJSR1h5VkE0cnhaTFFEcTlzRk00Tmtta2JydGVVajVZVXEzanZEMjNIbVBKUm5tSnAyeUdWcER1S2VGZzY2MWJ5MGMxQStUdW1iZGkzdVZvK0tpRlNJK1NqWTdVTk5NWGFUbFlIeVVkZjQvcWFsSTlLZytSSWlrVUZYUko2cGUzM0g0SFc5aHJkSWhvUlJyR09JaCtGYzRNNGloVXBINjJEckNQSVI3bnlpS0pZS1IvMVVjMWp5MGZaaFBmdHhDUk1QaW9wbTlieTBlMGo1YU4wa0pYeVVXdHc3Wk9QZXZVOXJiUU5YS0QxZi83UHg3K2I1YUxqRng0ZkJGZVdqd0tWNXB0dzgrY2dpaFd6TEFoUnJKU1Axb05RYTRwbDBUWlE5U3Jsb3pRdG9Ta1dPd2k5Y2NzSUtSKzFVaXhZUHJwNUt5c2ZsUVR0UFI4cEg5VzFkVTA3dmdUSlI3bWd5ckpNaUQxdVVSMmxST0hnS2ZBbythanRINlJ0aUtKWS9lU2pFZVdDTlRvSnhZS0lJbGMrVVIybVJENDZoN2FCL1B3cEgxVlFySkpDNE1mcHRRMWxSMTIyczhkU1ljcEhxd0NKbFkvZTczTDVhSDF6eEpvVVMzYU9HRzJEZHl6dVJiRmtmUWFuYmNBcGxvUmVlZnQ4MVJLaFBCY0xKbGt6eUVmTHdyU1FyQWo1cVBSYXBuejBlTm9HSzhVNm9yYWhOOFhhMW1rRnhWTExSOHVPR2c3S1VqN2FVajRhdGNkZDNMZ1lUN0VzRXlpLzMydW1MWFNxVC9xTzlmSFNiWElpS2RiTlc0aDRnVDRiem9yeTBmcTlSNVdQMnJRTjhoay8zQUJTUGtvR1hLZlJOb3lWajJJSjd6ekZrblhXN2VTamNGbXRMeDhGNm52S1J5L0hsSS9Td1ZXY2ZCVFdOdWk4V0k0QTYvNmx4TFl4MGJvdlBVNXJQd0FBSUFCSlJFRlVTbTlOdWxySlIyWGFodGdBb0pYcG5mOGNLUi8xQkZrNHhjS0NlSnBpNGVXVTh0R0xTdHZBeTBkaEl0VlBQbG9hNWkzeTBWSGFCa2crS3FWWWtucVQ4dEU0Y21VZCt6VnRIUzlIcTdZQnVtdWQxelpnRTZXLy8zdDdlN2p4SFh3OHhWcE5Qa292RzBxMURUS0tsZkpSZWFNOW1uejBJV1NNcEZqYTczWmcrZWhGUjdGMDJvWm41N3lHZkZTK1V0Q0dXSmJ5MGFOdm9STXgzcDFQUGtxZXU1bTJBZm81SU1DcWd5enBESld1SVBUdDlTdklSN2ZIcG55VW11MWZMdGVyWGR2UVN6N3ExVGFzSVIvbHRRMHBIeFhYbURkSkh6aXpmSFM3VElJbHZHOS9ubEhiTUFIRlVpVzhwM3hVZnUzaktSYisrU2x0QTdaTStGLy9xNjA5QURsWWZwSmxUZGkya1poMjhsRTYwTm9OOWlrZlZUZXVHdU0rbGdwYlU2eUlqbVIrK2FpOTh6MmFmTFFYeFpwQlBycTJ0bUY2aWhYWWo2UjhWSGRuWVR1S2hkR3JpRVQzRzk3SmYzVDBWb3FsU1hoZlFUN0thUnVrOHRFNGl0VlhQdHFEWWtuSTRpd1VLK3F4bm55MERySm1sNC9xS2RhNjh0Rk5mWDRIbmp1a2ZKUWVvRmx0UTFPS1pRVUhLUit0MjU2SFltbTFEZERQRm9wMXUzUjcwSnRDK3diSTl2SlIvbnd5K1dnY3hXb25IN1ZSTEw5OEZFcDRoOTZiOHRGMjJnWnJoN3FxdGlIbG83TlJyRmo1cUtBK1RVdXhVajVxcDFpYnZqdFUyeEFjWUVWU0xGdUhia25HbkYwK3lsT3NHUGxvTk1WcUxSL0ZucWNjV2JFZDMxcnlVYnh1elM4ZjFYYkdLOGhIcVFUWmxJOUtLVmFzZkhUbExYUms1emlYZkZSR3Njb2dDMnFMVlZ2NUtVbDQxMUlzQWNIUzVXVFJGNTZtV0w0T203OExqZXBVYmZMUmNyWlZVeXdveU9JcGxqeUFqRXh1NzdlRlRzcEhvU0FyNWFOaktOYTJUbnZrby9Vc3VLZDhGTlkyeUFmT2Z2TFJSNUFsbzFncEgyMFRtQjFIUGxwVHJHcUo4UjJLRmJqRWR1cm53QUNMRHJMMENiWDFwdENlaXRCVFBrcmxiZFVENEhNUTVLL2JPZVdqdExZQkoxbVJIZVBjMmdaNmNwTHlVYkl6UHBsOEZDdXIrZVNqQ0szNnd0ZUJsSSttZkJROTM1dU9Za0VUYWZ5T3d1Mi8vL2JmNU8zaDluLy9iNzA4QVJlc1hVWnFqYXFqenE4cGRIMWdGU1VmaFJQZWp5d2ZwV1l2RXZsbzBWaFRQZ3JXSzZ5Y1VqNTY2U2dmbFN3TldyVU5SNUtQV2lpV3BONmtmRFNPWE5sSVhYLzU2T08xUnp2RXZyODI0VjFOc0tSQlZrdUt0YUo4RkNNck52a29UYWNpS0phRlVHZ3BWc3BIbzRQK2xJOUNGRXNZY0EyVmoyNlhDdmNCeTdOL3NGQXNDZUdTeWtjeG9XTEtSOXRUcklqeGJqWDVLRVN4NU1FVmV6NlJ0b0dmU1BQTGhGS0s5Y2NTb1NUSWlxSllYazlQVkZSdm9WZ2o1S01yVVN4b0lFcjVxSWRpOWRVMnJDd2ZSZXJTTVBrb1BFT0dFOTdyV1hJZitTZ3dVS2Q4TkRESVN2bW92cTN6NVdpbFdQaTE0Q2lXOWNZVWc2WUJEckwwczJBWnhiSUZiVEh5VWNsZ1h3WldtOEcrczdhaHZYeFVSN0hralZVaUg1VTBvdWhnQjcrRzdiVU4xS0NEVWF4ZTJvYmlsV25rbzBMYmUzZUs5UWh3T0xON2ZiMWxDZThjeFRxeXRpSGxvM1ZiOUlLSU04aEhvWWswbFVOWlQ0QmtGR3NYWU1rb2xvY0tWQjNJVisxTTJhdHQ0QW83VWo1YURvSXp5MGRiVVFzdnhaTFF4ZjRVcSszRFNySHd1aFdqYmNEcnd4cnlVUi9GOHN0SDYzWVpvMjA0dG55VTFUYWtmUFNTOGxFUHhiSnFHeVJMaFJYQmt1VmoyU2hXTkc1a3p0Uk5Qb3JqelNodFEzdjVhSnN0ZEd3VXl5TWZqVTk0SDBleFVqNXFId0NWdDNrajc0bVRqOEliUWM4c0grMm5iYkJSTEhoU01hdDhkS1MySWVXanp3bEhtZkMralJVNGJVUFlFaUVYWkgwMi9DL2VpaldLWWtYTFI1L3ZneWlXVE52QVU2eTdzTkhQS3grVlVpeEpNRXdGWExFQi9rcnlVVDdoM1V1eHppSWZOVklzVkQ2S2Q5UTB4YkxURDY5OEZEOTNTNHJGYXh2V2xJOTZ3RUxLUjdIZ2lxUlliL3Z6WSsyQnBIay9KWTRzaW1LWnQ4clJ6RTViYXh1MEZFdmFrY2ZJUjhtQXppVWZiYm1GemdyeVVleE96dlBLUjZGcm5QSlJoWHowMVVheFlHMERuTXZ4UWJHd1krRnJGQ3NmMVdnYnNQZlByRzJJa0krMmVHZ1MzbE0rS2l1blI4Szc1dHc2aWtWckd6akRPeHBndFZ3cVRQbG9ITVd5YktGekZQa29SeU9qSncrOUtSYi9mVk0rR2l3ZnhlcWlLdUY5TzJtWVVUNUthUnV3dGozbUpnYTdmSlFqdCtYdlNEOXlXRzNEeXZKUnhVMHNTb3FsMHphVXYwTkJGa213WkV1RmNZT1doMkxOS0IvVmFodHFpclVkRUhWVTRFankwZWUxVGZtb1VqNzZBbEVzdkp4U1Bub0owRGFzSVIvRnhZc2x4VnBSUGhwQnJ1TDNPazM1cUlkaWFiVU5Hb3BsMFRaQXYvLzkzKy9ieE0zZkxOcFJyRm5rbzFhU1ZRejIzMklxN1hyeVVlMnNodEkycEh4VUpSKzlTQ21XcC8zMm9sakU5VGlFZkJUcnRDMUJLaDEwb2UwMjVhUDF3MHl4WWlaMjdTaVdkR0k4UWo0cVVhNEkyeTlLc2FDbFFramI4SmhJYzlxR3grL2JJSXNOc0hwUnJHMlFaWTIySTZKNmo3WmhmMXlkOE82aFdGRUJ3RHdVSytXamRvcVY4bEdnUFUwc0g0VzFEVFc1NHJRTktSOU4rYWlQVHVtUE81NThWRElob1lnV05Ba3AzL09ZWE45aW1rV1VmRFFXVjFya28xU2dwUjNnZ2NqOG0yU2dUUGtvcm0zNGJFeEsrV2pjVWlGK0RXZlJObEFVSytXakkrU2orQjJDSzJrYjVGUXNubUpWZENybG8rSnpuRWMrR2tXeHloV3Z6ZEwrVHl5NGdvNy91Nys3L29Nb3dEcTZ0a0ZEc1hRQkZ5OGYzZnpTWEQ1cXBWS2o1YU5RV1hEQmJ4UkZta2srS2dzcUtJcUYxYW56eWtlSmdDdENQdnBHVWFTVzhsSGdGYWUyNFdqeVViVzJvU25Gc3ZiSEtSKzFVaXcrNFIzT29kUnRCaTBtV05ZTm9YdmVUU0U0VXplS05aTjhWRElUOVZBc2dobzZLSlplMjRBRlk2MFQzbE0rNmd2T1lqcGpQUkdSMEJLbmZQUmlsWTlTK3hxMm9GaXlpZXVSNUtQcStwVHkwU1hrbzZpMjRRMDdEMHl4OEhaTEJWZmxjYmZZeXRLZVlta3JnclJUajBwNHI5ODdYajRLYmFHakpSTjJvc2pkRFJPbmJlZ25IOVVmMDBjK2F0TTJlQ2xXeTRSM1RYNUdCTVhDS0VRWlpGa3AxbGh0UTV4OHRQd2JLUi9WVXl4UG41THlVYm92a0dnYmFzTjdUYkdROWlLaVdOZXJNc0N5SnJ5UGtJOFNuWXhyaWNkR3NUajVxRFRoWFJxZzZvaFdXL2tvT1BCU0ZJdE5lS2NvRmgzMG5sN2JFRXF4emlZZjVmOGVMeCtGaVZTTWZGUVNkRVhKUjZIeno2SnQwRkNzMmVXakxTbFdCTHpRZjhlaEZJdjVXMUp0dzBjN2tCQ3RXM3lWT2I2MndSSm8wUlJMV3JtT0tSOHRLTmJGUTdGc0RXc2Rpb1hNeEtVSjd5a2Z2WXlSajJMYWhwNFVpMTdhTzQ1OGxLZFk2OGhIcFpOcDJiaDRUUGtvMGJZTkZBdlhOc0NUSS9wbmRZRFZWOXZnaTlnanRBMGVpclU5VmlJZmhXWmVLUitObDQvR3pUNlBvbTJneWlubG81ZHdiUU0wTzViSlIzdHJHeTZYWjdKdk9YdWZtV0xOS2grMVVLeVVqOUp0RjI3SE12a29MeU45dGdFdHhXcEVzR0lvMXJieDZEWVUxbE1zQ2Uxb0pSOFZEcFNpaEhlK29SeFRQdm9Jc2xhZ1dKRUo3M2liUy9ub2F2TFJiWUJEeVVjOVFTcFBzV1MwYXJSODlGSFg2ZkthVXo0Nit4WTYwb254eXZKUlBjWENyOGYxQ3FzYnpBUkxUckZzQ2UvQWVVSzFEWmJQb1pXUDRxL1p0QTFBNE9tUWorcTBEU3ZJUnlWa01ZcGllZVdqVVkrVWowbzZWejdoUFZZK3lpYThiK3QreWtkZEZBdWVVSEFVQzljMk5LZFlLUitkUkQ0Szk1dTB0Z0duV0hYUys3WTltd2xXSzIxRDYzMEhlOHRIK2ZQRlVpenZVczZLOGxGb3FSQjZieXY1S05FWlRpa2Y3YVZ0Z0lLUEdlU2pGTTN5VVN4MkVFcjVhRkNaMXYrejhsRXc0YjBqeFFvY0sxTStLcWRZTW0wRE1DNHBLTlp6d3RGTTB4QkpzVkkrYXFWWWVtMkRsVXFOa285S2wvbzRSMVpzeDZlL003V1B0Z0dtV1BXc1hrS3g5QjE1eWtmQlRyNnEwMVFPeHlQaFBlV2pidm5vSmVXamE4dEg5Y0VWMis3Zk1JcTFEYkpLK1NqdXhhbzljYTRBYXlWdEEzR21BOGxIOWJPSlZoU0xvSVl1K2VqbTU2WGxvNUhKc2lrZnRWL2ZHZVNqTmRIYVU2enlXSGdHbmZMUkNHMkRzajVOUzdHT0tCOHRLWlk4dUpKcEd6VHhBcDdjdmlkWnQwdnpSenR0ZzdVaVNEdjEwZkxSS0cwRFI3RjhQaXhMUXh3ckg0MElibEkrcXUrc2p5Z2ZoU2NPNENRaTVhTmRLZGF1L0plUmo4YmR4Q1dqV0w3SjBiSGtvektLSlhka1hTNEJBVll2YlVNRXhaTEtSMXRwRy9hRFBTOGZoV1plS1IvMXkwZUx4cHJ5MFVDS2RUYjVLQis0WDMrNzMrc2dLK1dqdmlDckY4VksrV2liZ0dsVythanNPOWRMaFZpd2RldFRaZGFTajFJRkVDRWZ4Y2hLeWtkUmluWFJVU3crSnlybG95a2Z4WUlyajN3VUlWcHFiUVBzeGtyNUtIemRZK1dqdGVJajVhTWN4VHFLZkJTK294QktlSytoVEptUEZSWmdwWHowK1BKUjdmRmo1YVB5WExnankwY1ZGSXVSajhMYWhwU1A2c29UV0Nva3J4ZjNEK3JjenlzZnZYOUorV2liOFc0MStTamVqa21LSlhKamNjdURicFA3U0lxMWJUd3BIK1ZNM0xIeTBSRVVTeU1mcmE5WnlrZWxGQXVobTc5NjI5WW9pa1ZjajJIeTBmdTludWxmZHRxR1dQbW9KdW04bFh5MFo4SzdKSGhPK2VqeDVhUGNKT2x5dWI3SjlFbVNZUENaOEE0SFhkZWZZUUZXUy9ub2F0b0czYjlZYllQRnJId0UrU2hVRmx4NVJGR3NtZVdqRW9xMXIxc3BIeDBoSDhVb2tsVStLcW12cmVXajIwZktSL1ZCVnNwSDdXMWRzMndvb1ZpUGlYelpmdWdiVTRJSlZpdjVhSzl6YUNnV0ZXaFo2RlVreGRKdm9XTi83aWp5MGZpRWQ3UXo3Q29meFNuV0dHMERGSHljUlQ3S1V5enNYOHBITldXVzhsRlRnQ1IyMUhtaHhrenlVU3ZGNGd6dm5aUGN6ME94Yk11RU1vcjErYnBhUHRxQ1lrbXYxU3J5MGZpT2IzYjVLUGhJK1doOWpxSHlVVHp3U3Zsb2hIeVVwMWpIa0kvS3ppSFA1NXBWUGlwci8rVC9KTVVxYVM0ME9kcitIaDVnSFZFKytqaVhOTnExM0ZWWWF4dHFpZ1VQaENrZjNmeXNrby9DcnJMMTVhTzB0dUdZOHRGUjJvYkhJQ21WanlJVWkxMTIwR29iVWo0SzlhdmdYZG9wSHcwK2JxUjgxTHVGRHZ4MzRLVnpxcDhmUXJDd1dZWWxXby9RTmxqeWxhSVQzbW15d3N0SFcyMmhFeWNmM1RmNm1lU2owY0hOM05xRzNXK0hrNDlxZzZvbytTaGRiM0Q1S0ZTbk1XMERSYkdnMTZSQktrV3g0TEpLK1dqS1I5a3pMU0VmL2RReHZNa29WdldOME1sT2x5WENZMmdiMnNwSDRjREtwbTJJcEZqeDhsRVBqZlRKUjUvWE51V2pJK1dqMGNIbzZ2TFJCOFhDWnRLY2ZGU3lOT2lWajBMN0pPcjZrUDdhaHBTUHRxRllsakYyRGZrbytmWTNpbUxWUVJhY2l6V0lZTVZRckczam1WSGJvQ0ZiRUZtUkpyeGJLZGJSNWFOVXdLd3AxK05RckRIeTBWVXBWZy81S0pid1RzbEg5KzJ3MWpiTUlCLzFyaFQ0eXpybG85cng3a3p5MGUzZmtGQnM2Y1NrVzRBMWdtSkZKYnhIZkdacmNHWFhOcHhGUGlyVE5xUjh0SVY4bEwvREt1V2pzczlVN0R6Z2tvK1cyb1k5OWVJcFZwUzJBYUJnUDdFNmtQTFJlSW9WRnlEWng5MFY1S05haW9XMWgxcmJzTjhJZWpEQmlxZFlVYk9rRnZKUnlXQlBST1lwSDFYUFlISDVLSmVmMVpkaXRkYzJHQ2tXV3ErSTVhanYxdXR6ZFBrb1JMRTg4bEhPN0M0aFVoYjU2RXJhQnRsZ2VnNzVxUFM0TThoSGdSdFMzaVJlUEF2SmFocGdwWHhVVDFGYWFCdFNQZ3AzdW5QSVI5cytZaWhXWGFlb1FOeEtzWTRzSHkySWxWcytXcmU5UHZMUlRYMStCNTVMK2FpZllxVjhkSWg4RkYyT0ZGR3N6Vmoxbyt0V09aSGFCazlCUldvYnRJWGJTajZLL1BYRHlVZTFqVFhsbzF5ZFRQbW9aaUJjU1Q1Szk2Y3BIMDM1cUNwQWNsSXMzK1RMUTdGMHdSVmRaNEFKMHUrU2ljb0VTNFIvZkh6UlVxR0hZbWtMUDVKaXBYelVGL2dpdDR3ZlFqN2FJK0hkSmg5dHIyM0E2OE1hOGxFdHhlSUhMN3hPZTdRTjBvQW01YVA0WlBYTTh0RmVGTXNLUkRRMjloaUtCYmVEYlJ0NGZQNHVBVmF2aFBlSVF0TnFHMUkrNnFOWStPZnBLeCtGeXFjTnhacFIyd0JSTEtnY1V6NHFuZkZlRFBMUngyeWRhMHRXK2VnamNMWlJMRmpiSU85UCtzbEhmL3o0R0craTVhT093VDZjWW8zVU5oeFhQa3EyNlRlSVluRjM4RTVDc09RVWl5OVFuM3pVRzlCWmdxbVVqNkxCU0RmNXFJWjYrU2lXL3BpVWo3YjgzajZLRlNjZjFXa2J0QlJMR3FUcWFmUjg4bEc0RFB6YWh2c2QxamFNa0k5NitwVHp5RWN0d2RYMXpkYnZsMXZvZkxTQmJnSFdrZVdqbWxud09Qa29uL0ErZzN5VUw5dVVqN2FoV0ZnUW4vSlJhaWJNZE9nSytlaCt0aTRoRmx3dWxsVStpbE1tVEQ1YWF4c3dpclcyZkRTMlByV21XSEhMZk5iQWJMUjh0RjdKa2Qyd2NIM0RLRmJ4NmRDRTkwYy9QeEhCaXFGWTI4WXpvM3pVU3JLS3dkNGdIOFVIUWMxeEtSODlHc1h5eTBmUFJMRm1rNDlDRk1rckg1VVFMbjVWWU84RTRzcDhkZm5vakJRcklwQ2FVVDRhcVczQWZpWlNmNWdnYS8vb0dtQzFwRmdSdDRaSEo3eEQ5RW9hZE8yUHN5Vzg5NkpZMHV2U1N0dFF6UGlubEkvS3RRM3J5VWZ4TzFSVFBucFJhQnUyejBFVGg4KzYvenRNc21qNUtLUnQ2Q0VmQlFicTZlV2pHb3BsVlRoRUJWa3p5VWU5NTQ2SUN5TGtvd3pGNGo3dCswU2kwVGlLQlp3blZENHFJUjhTd1oyRllpR1JPYXR0K094b0R5b2ZmUVpaWExuT0lCL1ZkU1FwSCsxQnNZanIwVmsrQ3RkcmlHTGhkd2pTOGxHa2J6aWR0a0h5dklaaWFiUU5Sb3JWcUkreEJFaGV0OVpxRkF0ZUhkbFNyTSs4TFhTcHNIdUFsZkpSSzAyeFVxenF1SVBJUnlzaXBOWTJwSHlVRzRCU1BpcVVqM0xCV0FURnF1bzBkT2VnVGo1cUhZelgxVGI0dHRDUnlrZkhhaHRTUHVxbldJSjJEaTRWYnE3MSs1QUFTeDVrdFIrY0krV2pHbTJETlI5TFNiRmVPSXJWUXo3YWkySXB5aTNsbzNCQUlaS1BhaWhXR2F3Y1dENHFvVml2RU1XQ2o0WHJOUlpRV2VTam02WEVjSW9sQzZyN2FSdXdnUktTajVZVDFzL2psUEpSdGg2bGZIU0pMWFJJaWlXWWVGemZKMXdpaERwOGVXR09rbzlxb21WdGt2dnpmUkRGNHJVTk5IRjRkaEt6VUt5VWo5TG5HQ2tmOVZBc2ZmQmRCK0lMeTBleFR2bFZRN0htMFRaNEtWWS9iWU5FUGdwVHJKU1BZaVRzQ1BKUitiSmh2VmNoVExIcXg3QUFhNlMyWVNiNXFKNWkxVnM5eEZBcy9XemlEUEpSUE9nOXIzeTBGOFZxa2ZBZVFhOGtIYlJjUG9vRmJMQjhsR3Eza2ZKUlNkQ0Z5VWZsZEdKZnYxdHJHNlFVSytXaityRjFSdmtvUkxIMHdSVnZlYWUyMFptWVlNVlFyTzFnMFVZK0tzdWpvUVNpSG8xRE5NV1NOZVR6eUVjbFFiS2ZZdW1QR1NrZmJVMnhXaWE4YTVLZHJSUnJ2SHkwWENxTXAxajAwcDZmWXZWUmMraTBEVERGU3ZtbzdYeHg4bEVQc1pZRlYzOU1lbGcvMWpQcC9hTnREZzJ3WnBlUGVtNWpqWktQd2s0c21YeDBtL0FPVTZ5eDhsRnZBeEpTcktieTBialo1NUx5MFpkSWlqVmEyeEJGc1JpYTFVRStTditycVJkUHNTSzBEVEJWNjY5dGlOMUNKK1dqVVJUTDloMnZiOUwzU2UveXAzL1c3RmQ0L1gxeWd0V2ZZaGtMdVpsOHREeStES3cyZzcxUTI4QmU3Mjd5VVN6UGhtK1VjZkpSVE51d0FzV2FTOXNBQmUwNmlpV2pueWtmdmV5MERYYjVxQ2RJNVNrVzJHNS9TQWJidnRxR2xJL2FBNlQ1NWFOMVgvMVJicmJncXQ1T3Avai9yZnpid3dPc2xJL3FnNjZVajBvb2xrL2JzSUo4Tk9vUm8yM1FlWUpTUHNvU0s1RjhGS05JSzh0SHQ0OFY1YU9hK21SOE5OTTJXUHJoczhoSE9hSzhHV3YrZUcwQmdtV25XTUI1dnJZcmRGbkN1MGMreWpma1B2TFJTSXFGRVFvYnhaTExSemZ2SVJQZXVjRDRVYStPSUIrVkpieFRGQ3ZsbzUrUGxJOHVMUit0Njd1VllwWDFmWGI1YUUrS05VNCtHa0d4Y0lYRGRsSS9SWURsa1kvS28vVzV0UTFsZ1krWGorTGFodjMxbUZjK2FxRllXRENGYVJ1OGdkVk04bEhaQUpUeTBaWGxvNCtsd3BTUFVoUnJOeGhEMm9hVWoxN09KeCtGejNOOW81TGZweUZZdlJMZUk5QmxDMjFEYS9rb24vRHV2MDZ6eVVlWkdZOWEyNEJSck5iYWhwU1BnbGRKUmJFaVNNZ1I1S1Bsc2VXNXppb2ZyY3VRWHZvL2szeFVNSkZkVUQ0YVE3SDJrL21hYUMyeVJBaDErUExDbEZDc09HMkRybUZiZ2lxTGZGVHdpVlFVYS8vOVIxS3NLek9UaTlNMjRIbFlyVG8rK1RGOTVLTmp0QTNFZ1B5cWFhY1JGQ3ZsbzhlVWp6NG9GaklZbjFvK09odkZvczhsVDNpUG9GaDFPOTRIV2xNRldMTnJHMXBRTEdvUWx3ZGRVZG9HZjBOcEpSL1ZMZG1PMHpZY1d6NktCZkZWWUo3eTBaU1BvdTA4NWFOSGxJL3FKanVSNU1yYXJpVkwvVHFLVmVablhkOFdJMWd4RkdzN0c5ZDAzalBLUjh2QWFqUFlmOU1QdWpGYjZFd3VINzF3Rk1zNytCNVBQaXBPZUUvNUtFS3hSc2xIOFgwSzU1U1BRcmxqRVFHeXZPeFRQcW85MzJqNUtIQWVJY1dTNXMvcEE2MHBDVlpyaWpWYTI5QlNQdnFZYldrUzNsZVJqOW82aHBTUHhsRXN0RTZsZkZSSXNaaFpzMGsrQ2swY3FOeXFPZVdqMXgvMWVkYVhqMFpTMFhVb1ZzeHgwWUdpWlhKTXBZSklsd3VuOEdEMXBGakFlYjVHRlJUd2FYNW9PbmJyZGpuTW5TdmZaRE5udmJhQk95NUNQc3BSckpTUDFvODE1YVB6YWh0bWxvK1drNFpXOGxGTjByazEwZjFvOHRHVktkYTU1S1AzRjI1QzQ2RllVd1pZZlNrV3JtMklwRmpTV1drUCtlam40d1gvdkI2S0pYVm82WUt0bEkvS0tGYlVvNjk4MUU1R2UxQ3NzOHRISmRjNDVhUHlRVGZsbzNIa2l2NmJzcnNLTmE1S1B0QzYvbmE1WEg5Ny9MOG93ZEpSck5iYUJpM0ZpdFEyUUlYZmkySlpsdkdPSUIrVnpIUmlFOTdSempEbG81ZVVqOElVQy91WDhsRWpzVXo1YUFlS0ZTc2ZGZmRyTDVxRWQyRHJuRTFRdGNnU1lhUjhsQy9zT2VXanRqMEw1UlRya1Q4Z3AxZ3BIOFhLU1BJZXgweE1MUi90bzIyUVVLeTZUcFVEVE1wSFkrV2pVTUk3VGJKU1BtcVZqMEkzZUtSOE5PSzR1YlVOMGpZK05jRTZ1M3kwTExobytXalpNYVI4OURqeTBjZ0VXb3Q4dEplMm9YaWxHOFhTa3FpZThsR3NqVmkxRFNrZnBTalc3bWZ4cEVMWVhsTStPcW0yWWFOaitJMDZmdUVsUXFqRGo2VllxOGhIWlJSckcyVFZhRHVDWXUyLy83enlVWnhpVlFOYnlrZU44dEU2ZUpkVExIM3dYUWZpSHJyVlE5c2c3ZGpoQVdzdCtTZ2lBRDYwZkJTbldHZVNqN3JkV3FvSkJIR2tnR0x0SjRFUjJvWWw3aUpNK2FoVzE0RExSNUZCY0JxSzFVbytLcUJZS1I5bGdxeXp5VWRiYXh1aTVLUDdlcTJYajBxV0JyM3lVV2lmUkIycGdMVU5vK1dqWlgwdktWYktSMk9PcytSY1FVdUZrdXN1MFRic2Y3Ny9paDF6RUlJVlE3RzJzL0VlOGxHdHRrRkR0cURBU3BMdzNwSmk5WmFQS3JmUXVYQVVpd3FZSloxbHlrZmpLZFlSdFExYStlZ3p5YmFlTkVqa28vdTJWbXNiWnBHUDZvT0R5RExHS05hdS9GTStpbEFzWHg4WEpSK1YvQzE0ZjBJWHdmcDMvNjVOQjd3S3hSb2xIN1hNZ2kzeVVXM0NPMHl4N05vR2E0Y2NUUmt0OGxGNDcwZUxteXpsb3pURmd1K3dpdTA4eDFJczZuaXZmSlNiT0dqa28xQncxVnMrZXIyT2w0L1c1ZkZNZUxkdG9lTUw0SHRUckxobHZuaUtaUThVWlJTTG8xczR6VUlJMWdwQlZpdUtCWnpucTdWeUNJbzhSRDRxR2V6eDgwcTMwSW1SajBJVVMxcE9vK1dqMjVrMkpoL2w4ck5tb0ZqenkwY2xRZGQ1S0JaVDJpYUtSY2xIb1RzS3VZRTNRajQ2czdaQkt4WXVLZGJxOHRIWUFHa1crU2o5K21jNXZGQjlOenpacVpjSkgvK1dXU0wwYUJ2MEZLdXZ0bUVXK2VqOWZua2hjbU9heUVjOVM0WXp5RWU1UURpQ1lxVjhWQk5ZOWFGWXZlV2orTi9UeTBlcGZmOTZ5a2Mzbi9jZGVHNEtiUU5Hc2FMbG80MG8xbkJ0Z3dWMklFSGFieEY5SjBXeHNDQUxXOG5BcUJXWTVINEVpcVhwUEdlVGowb2FXMnY1YU4yNFV6NktVU3l0ZkRRKzRSM3REQ2VSais2MURSUWRUZmtvT2JDQzJnWnFwbDk4NXpjc29PTGtvM1IvbXZKUmdYeVVuRlIwb0ZoZHh0ZldGRXRMcmlMU0NaaUpEM1RuL3EvUWNUdUNOWHVReFZHc3VzTzNYZlFJYlVNcml0VmFQbnE1YUNsV3lrZXhNbXJidWMwdUh3VS8veW5rb3hKdGcyRkRhT0l6MVJTcnJOTlIyZ1pwUUpQeTBlcDFsWHhVZndQRXZCUnJoSHcwaW1KcDJqSDBiN203Q00rb2JZaVJqNWJhQnBKaXBYd1VIQkJrOGxHb2ZOcFFyREh5VVZyYmtQSlI1YXk0SWNYU2F4dktTUTU5cmM4ckg0VXAxa2Q5VC9ub2VQbW90eTZVUVJZMjl1NmZxeWxXRldDZE9lRzlyN1pCTjN1MnlrZVp2Q0JRUHNwYzI4bmtvOUpHMzA4K3FxRmVNUjJmL0poMjJvYTYzUlJIcEh6MEVpc2Z2ZDlqdEExYWlpVzloa2VXai9JckRpa2Z4VWpZREZ2b1NHNXdrbWdZNmtuME04aGFrbUNOb2xqeDJnWjRpYWVsdG1GTHNaQ3pMaWdmMVplSmtHS2xmTlJNc1hiUHAzeVVwMWlTb0txWnRrR1NpNVh5MFpTUHhnUklNY2UxSWxmeW9KZ0t0cDUzRllJQlZsSXNlalllVjRneDJnYk5FcFZVUGpvTHhaS1ZVWC81YUgzTlVqNmE4bEVkeFJvcEg2VzBEZnVBWlI3NUtKWURsdkpSUDhXS0FoR3ljOFRMUnkyVGJLbW1wd3l5dVBiOFdYNi9rZ1JyOVlUM0k4dEhlMmtiYUlybGw0OUtrTCtGWWtrSDMwaHRROHBIeVJvcjFqYWtmSlRzdk1YYUJ0bEFVc3MvSmZKUlNOdlFRejRLRE5RcEgrMUlzV2FXajdiT3NiemY3eTl5Z3ZVa1diZWV0ekRQVExIbzZ6Q1hmRlE3dU5PemJBM0ZXbE0rV2d3Mnp0a1RUTEhLcGNKNUtGWjdiWU9SWW9uclZjcEgyZEoraFQrUFROdWdsWTlLaVZUS1I0OUZzV0lEcERIeVVTdkZlcFNieE95K2ZlNjJiV2pIcEZqdHRBMCtQR21mMVhLRjJvNWlWY2N0SVIvbEc3K2ZZbUdVY2J4OHRPMGpSajY2cjFOY1FKWHlVVDNGa21nYnlyRWc1YU0xeGZMSVIvY1U2NjRpV2lrZjdVZXJ0RUVXNWNpNjJXYnZxd1Zac1lWdExYU3R0a0hTMkR4M0VvNmtXSFpTbGZKUmVkRFZqMktsZkpTa2VrUGtvd1RGUXR1SVJUNzZmRDdsbzNMNWFEMVI3VVN4UWgrajVLUGpLTllqeUpMUnJCdDN3VExobmFaWW5ydVp1TmNpNWFOMUpZQXBGcUp0VUZLc2ZjSzdoV0pGa0MxZkozRU0rV2lQaEhlYmZQU1B3VGpsb3diQ0pkVTJhQ2xXQzIyRFlJSVpKaCtkUzl1UThsRXZuT0RidVUwK3FnbWs4Zjc3SThpaXR0QzVZVjlxSlpwMVJQbW9waU8zazZ4YVBrcDh2WlNQZ2dPQ1hENktCNzFIMXpiUXQ3RkxLVllaZEtWOGxQOGJOY1dhVlQ0S2F4dmtnKzIrZnFkOHRCZXBXbE0rS3JHN2M2a2Z6ejRMRHJURUhxeWtXTHZ6VENzZjFRUmFaY1M5R2V4VFBzcFNyTElCeXVTamtpQTVydVByUzdINDd3Y252SHNvbGo3NHJnUHhNOGhIaWNrRHFXMkFsd3BieVVkUmRZcGJQdnFuUDZWODFFdXhyT1BXYlBKUmE1OUIwYTN0NUxBY1UyL1NQNXJhQmoySldVRStHcTF0NkVHeFpwS1A0amNhNk9XamNiUE50ZVNqKzdxVjhsR05mQlFlbkxtL0w4czVvYVNqVUdCbDFUYnc4dEZhMjRCUnJMSGFocFNQeGdSYzgxQXMzYmo3UWJPMno5MnNIYzZaS0Jad25pWGxvNUo4SUx0OEZQcTg2OHRINVkydWxvOCtncXh6VXl4ZTI4QnRMdTZsV0N0cEd5Q0twYjBqRVpLUFdpa1dSSkVnK2FnblNLV0RMcXhNWmZMUnZ0cUdsSS9hQXlTNVBxY254YklGV3g5SjhKZkwvZVdtK2NOSnNYcFFMTnNzV0xKTWlMODJwM3cwa21KSkcydXBiZmo4M1NRZmxaREY0MU1zaTdiaHZQSlJRNks3U052QVVheVNJbkc1R1lSTUFBQWdBRWxFUVZRVVM2SnRtRUUrdW4ya2ZQUTRGQ3VLWExYTzBidFpML1NxaitzMTVhTllEcGFOWXJXVGovcURMWTk4TkY3YklPc3NiUW52TTh0SDhZUjNNSUFYMWF1VWo4SWtBaVpYYkwxKzR3SXFUTnRBWC92amF4dk9MaCtWVHFabGJUTkcyK0Q1RHVWTklOVGZsSXl4NnMyZVY2ZFlkWWZ2SVIvOTVLTWFiVVBaV2NzQ3JaU1AwcS8xa285R3pqWlRQbm9TK2VnbGdHS3gyb2J5LzhkU29TYndFdEtRTUcxREQ0cVY4bEV1cU5jRmNHUHlyK0lKb29wZ3JVU3hSbW9iV3NsSE5RWGVTVDZxMERZY1hUNnExelpBZ2RmbXVqZlROcVI4dEMvRndxOU5PL2tvUmJHMDh0RTkxZHBUck8xcjBEbGFVU3paNFBsUnYxTSsydit4K2hZNmV2RW8vcmhaM3BUYWh0MTVwcEdQV29JcW5tSzEwVFo0NWFOYVF0RldQbHAyc0x5Mm9aOThWSDlNSC9sb3ZMWmhOZmxvS1pDTWtvL3UzOC9MUjZHRTk5YnlVVDdnOFZJcy9HK3NLUitGZzZ3amJhRVRtWC9WdTA4TkM3Q1NZdWtxaFE5WDl0RTIwUEpSOGpGTVBqbzN4YkpwRzg0bEg5MEg4VVF0UHF4OFZKcS8wMW8rQ3QwcHk4bEhwVnZvRklHejhrNUNUTnVnbzFqUStWc252Tk1VeXlJZmxaT3pYaFJyWHZub1dJcWxGbzBteFpKUnJLaEFkUDllbjdaQkUyaEJnVlhLUiswVXl4S29wSHcwNWFNRXNacEdQcnB2Zi9FVWkxN2E4MU9zMWdudktSOGRRN0dndXQwaW1KUzIvMXZFSHpzanhacGQyNkNsV1B0alV6NnFvRmhpYlVQS1I5VVVLK1dqUWZKUi91L1BKUjh0MjFSOUhDMGYzUkMzbEk4T0NEUUM3T3l2bHJicUoxY3hGTXNWWUIySlloMVYyekJPUGxvdkZhWjhkRWNUbHBHUHR0STJ0SldQSGsvYkFGRXMvUjJKOGZMUk1oZExJaC9WSkoxNzVLTVNtcFh5VVQzRjh2UXBLOHBIdldEcDV2MWp4OUEyMkM2b05kbXVwYllCSWllMm9DdFcyekFqeGJJMjFsWGtvM0p0QTB5eG9oNTk1YVA2dG5raytlaGprR3doSDRVQ3FQMy92SHhVY28xWGw0OVMyb1pGNUtPdnVuNEZENUJXbDQ5U0ZFdlNiOXd1K1VBcGx2NmkraW1XVjlzd3EzelVTN0ZHeWtjM0hZWmhSc1JyRzZqQStGR3ZXcG1ienlZZmxkV2JkZVdqbStmQzVhUGJuMU0rNnFrRHRMWmhBb3Jsb2pheEFkSVkrV2dFZEFrTHNGSSt1dXRBcHRFMjJNalY5bjB0NWFOK2JjTkkrYWlWWWxHa0VYTmtSWFlJRnZsb2xMWWg1YU1jVmJJUnEyajVxRmZia1BKUlRqNjZDNnhTUGhvWTZNMUdzVndCMWtyYjU0eVVqMm9EcXhieTBiTEQxZVpqYlRRT1FmTFJtUHFXOGxITGRkVEpSeVBwV2NwSFNiSXhSRDRxbWVsejJvYXlMYVo4bENXV0tSL3RUTEY2N1YrNGZUMXNpVEMxRGJ2emZQVVVTaVRGOGlTN2J5bFcwWmhQSkIrTjB6Wnd3VXFMN1hPOGRDYWFZakVCVjhwSEVmbW9sWEJKNUtNdEtCYjBtdlFhcG55MGV2MkZxaXRsa0pYeTBSWVF5RWF4VHBXRGRReHRnMjkvT1oydW9aYVBJbWNWYWh2OEEzMS9pa1hQOWpYYUJvdDh0T2hBVXo0cW9GamxBTFNDZkZRYWtNMG9IOFZ5c2FpN0NWTSs2cGVQYWpRY0tSK05sWTlLZzh0YjVBVTlNOFVDemhNcUh5M085TU5Ec1RSa2Ezc3NUckhFMTBRbEg3VlFyQW5rbzlSNVVqNEtEelJTYmNOaDVhT1FVSElWK1NoRWtTQnR3d3p5VWVnT3lQaittU3BqWGo3S1V5elhVbUZUaXFWNS9XanlVZWoxMDkxRmVGVDVxT1p6UzRPdC9Xc3BINDJnV0hVWnBIeVVxS2xDYlFPVmUzVk8rYWlkWXVFVEIrbzdZK1NLM2h5NmgzejArcU0rejl6eVVaNWl1V2hveWtjN0pyemZvaTl3eWtmbEZDdFNQa3JNY0ZYRTZ1enkwZDRVcXd5eVpxZFlJK1dqeEx0L3BiL0wrZVNqd1B0ZXZSUnJNOGlvNWFQVVFOeFdQaW9iUEZlUWp3WlNySlNQT3I2REJvSTBJVmdwSDkzK1hDZThSeFpnK1pwVTIyQUx1bWFRajlaRVloNks1ZGMycEh6VVNyRlNQc3E5RnFCdHVFQUo3eVdaU3Ztb2hHTEI4bEg1RmpxK0FON3djTWxINHloV3pIRyt1d1Zwc3R2a0xzS1ZsQTBlaWhYeDNYdkxSNmxBYXozNXFEOTRTdm1vdEhPY1JUNTZiRzNEN1BKUmFOSUE3VG5JSmJ4RDEvVXM4bEYrMTQzNlJxSWp5VWVsNlRTeXNUSmVQdXBkS3NUK1pyTWNySlNQMGhUcmFQSlJSTnVncEZncEg4WEtLSEpXQ2dTWWs4dEh3Yzh2VG5oZmdXS05sWS9PcVcwUVREQlBJQi85NkU4eCtlZ29pblUwK1doMG9CbDJGK0hLajlubG8wSmNPWVY4bFBpVEwzS0tGVlBKWjVlUGZ0NFNMNUtQUXVXejZhQlRQbm9RaWtXUURiTjhsQnNrQlZmQ3BHM1F5a2NmNVpyeVVVZytpdldsWXlsV1RKOHpubUw1bGczNXBjSmJaRWRaL29HVWorN084MVZmQ2RwUUxFL0NlOHBIOTQzYkloL2RITWZLUnpYVUs2citTSTlKK1dndmltV1RqOFpRTEwyMkFWNHFiQ2NmaGN2dGVQTFJZdmt3NWFNWGIvNlZQTDNEdWxSNGk1Nk5Kc1dLN2NpdDhsR3J0a0dlajVYeVVRWEZTdmtvRTJRZFZUNGFRVUpHeVVlWmlRUDVuYmwvVW9vbEM3cjg4bEVzNEVyNWFNdkozR2o1cUtXZkIvdE5OTWk2UlhlV1I2UllHbTBEMDFWT3EyMmdBcTN5dFgyZ2hWRXM4VFZKK2VpZEw4c1dWQ3ZsbzdwZ3ZRekVQVzEzQmZtb2gySkJGR2xtK2FpVXdNVFViU25GUWllc0FNVksrYWp0T1BrZW5KcDZBdVpnblpWa1JXb2JQQlFyb21CYlU2d1liY000K2FqbkhQM2tvL0pjdUpTUGJ1dVdWTnN3aDN6VUU0aHhBVlFNeFFMekRWRnRnNFJpY2EvMWtJOWVyM1BKUit2eVN2bW9vczl0S2grVmYwYzRSL0hXb3NNOEU4WFNkNmgraXFWSmVMZmtZa2xld3h2djNQTFJGU2hXeWtmbEZFdFNyK0R2TWw0K0txRll4ZlhvTEIvZGJWYk9haHVrdVZnV2thajNQVE5yR3g0VWl6OHU1YVB3Y2ZIeVVRdmdnQ3p2dDFhejB0V0NyQ05yR3lRTlBGbytHcU50a0Y2UGxJK21mQlJlS2t6NXFJaG1rUlRMcTIwby8zOEVXYTNsbzV2Ni9BNDhsL0pSLytPdzhsRjdjTGdQc2s2dGFXZ3gyNCtJMEQxM0x2V1FqM0pDVEViYjBJQmkrWU1ucTN3VXBsajk1YVB4Q2Uvb2JMRzVmRFJhMjJDaFdMSjZzNzU4VkVLeHFKaytWMmNnaXJWOURUcEh5a2YzOVQzbG81TGorbWtiQkJQVU56YkFTb3JWam1KdEcwK01jTTlXd2EzQlZkbWhseFNyN3V4OThsRU54ZktRcW9nQWVKUjhOSDd5TUU0K2F1bUxqa2l4VWo1cWFhUEhrWThXZ1ZYS1J3TURQWXUyUWRmdmYvVDVTYkNVUVZZTGl0VkQyNkJwYkRhU1ZjNjI0dVNqVm9xbERiYWd1OFdFMnlhOGFtZjdjSkQxcEZnYWJjUFI1S08wdGlIbG96UEpSeVVENkZZK0txVllqM0pOK1dqS1IzdFFyQmh5VlFkWnQ1NFhiQVdLSld3T29SVExTNklpR3JZbTBWMnlYK0Z4NUtQK2hIZWFZbFhuZWJjRUtzZlhOdER0SnVXalBTa1duUEF1a1kvdXFWWEtSM3ZMUjZHNk16UEZta0hiNE5GNEpNSHFUTEZHeWtlMUE1bzJ1T3FwYmJBVEI1L21ZWXkyUVM4Zmpac2dwWHlVZno5TXNWcHFHMXJLUjVVMTVFMGFGRW5sb3g1dFE4cEg2ejZVVzJvZVFiRldrbzk2SnUwM0M3Wk1pcVdUajdiV05oQ2ZVaFJrUld5aGc1L1hJaCtGdm5zc3hWcE5Qdm9Jc3M1TnNkYVNqM29wSlArOFN0c2dDY1pldlJSckU1aWo4dEg5NzdWODFCdWtXdVdqME4yUEZtcmhMZnVlOGxGcFhZbW1XTmFncFNmRmlsZ3E3RWF3ZWk5OXRhWlludTg2VWo2cW9WZFUwSVcvbHZKUm1tTHBFOTZsTnlNY24yS2hkZW93OHRHRzJnWUp4Ukw4RFoxOEZNdTVtbEUrQ256K3dmTFI1NFFpNWFPcVBsY2xINVVtdkx0TjdqMGZLUitOcFZoZWJRT1dyMkhOd2JKUnJLUEtSK08xRGZOUXJQYmFCaTNGa3RRcitMdU1sNC9xNmRiYzh0SHR6eWtmMVZJc25qQ2xmQlR0bDVyZmxTZ0pzbTQ5cVZOcUc2akcyMDgrS20zZytJYkVYS0NWOGxINjh4NUpQdHIya2ZMUlVJb2xmczFKc1V6YWhwU1Bwbncwam1KRkhFZFRMTWtqazl5ZFFWYktSK2w4ckkzR0lVamJrUEpSMmZWTytXZzB4WkxWbTNQSVJ6R0twZFUybE8xdFR2bG9QMjFEeWtkREE2UW1keVZxbGdwdnZlalZxaFJMMkN4T0x4L0ZLQlkrVzlacEc0cm5scEtQdHFKWVVEbTFiS3RRb040ajRkMG1INlVUM2xNK1NnZGo4SG4yQ2U4UXhkcldhVXpiUUZFczZEVi9YK2lWai9iWE5xUjhGS3RqK3ZFdE91RmQ4MzF1M0MyeitUaW50a0VySDRXT09acDhWRU94dHZKUlBjVmFSejY2ZVdVeStTajRhVkkrZW5sU0NhMThGQS82YWZrb1JxVHFYS3lXOGxHL3RnRTdmM1NRSlNDV1pNTDdKZVdqWW9vbCs3djhVdUZVU2U1bjF6WXd6YXFoZk5TbmJkQlFyZTJ4UldQK0ZrV3hlc3RIdDQxV21oaFBOOENVajhZTlFDa2ZYVTArQ2xHa2R2SlJsRkM0S1ZaMElLMlRqKzdyTzBDNVVqN2E0RGhKdWJOSjdqMkRyTlVwbHBWYTlhVlkvZ0Z0cEh6VSt6MVNQbnBraXJWN0hxSllMeEtLVlE0NDBmTFJ0aFNMbnpCaEZPdmM4dEZhMjRCUnJMSGFCam5GU3Zrb1BORjFrREQxVXVFd2dnVTlVdHNncDFncEgyMURzVkkrdWlMRkVzdEhMM3FLSmRNMkVBT3kyTWNUUmJFazJnWU40ZW90SHkyMURYM2tvMUQ1cFh3MFlKSTBrWHhVZmxjaWNRNzFVdUhRQUN2bG8xWUswcDlpV1pZSk9ZckZheHRTUGtwUkxBbFpqS0pZY20xRGYvbW9STnVBVXl4N3dydDE4cFB5VVZ3K1d2NmY4bEdkdGlIbG8yMldBeldmZVlqSlBTbVd0aENQTHg4Vk52V1VqeUlVQzFvcXBBTGpCK1dKdnRzUUdvU2cxMXZKUi9HRWQ0cGlwWHowODdtRjVhT2p0QTF5S3RhcWpHbmFsZkpSakdJRmtMRGZORUhXOEFBcjVhUFU2M1BLUnozYUJyelRUL21vbG1KUnBKRW1ocTBwVnR0SHlrZERLWmI0dGZwNVh0dlFWajVxbm1BNnRRMTk1YU8wdGtFakh4MnZiWmlOWW1uT29aMGNEMDF5WC9reFFqNGFsZkN1cFZoWVk3UGNWVmlmYTV4ODFQcmNHUGtvckczQUtGWmYrZWkrSHFWOGRBMktGU01meFg1Zld6NHE2MVA3eVVjRnRZQ1RqMDZqYlpoZFB1cDViZG9rOTlRMjhCVExXMGtqS0pZbjRSMlhqOFpwRzZ3VXE1OThGQmZuYWJVTjNBd1R6OE9LYmF1V1kvcklSL1hhaHBTUDBzRllTL2tvL3ErVnR1RlU4dEhMVEJSckpma28vcHBzcVRBSlZpT0sxU0pDSHkwZnBRWnhXblJKeVVmclFkQkdzV0xrb3kwcGxuUy9LempJMmk4Vld1U2pSV0I3Y1Bubzd2bVVqL0lCVnpmNUtLMXR3T1dqUk5uOFl0c0FlaDM1cUZmYmNFbjVhQmpGMGdSWjB3UllaNmRZcTJvYk5HUnJIMmhoRkVzOGZEU1JqOXFYREp2SVI2bHlTL2tvUE5CSUU5NEh5RWZsSGZ2RTh0RXUyb1o5RzZ1MURWNktSUy90elNjZmhjc241YU14QVpmK3MyeGUrWTE2LzFRRUs3VU50bzdjOHI0VzhsRXEyTnEvbHZKUlNTUGxLRlpkQmlrZkpXcXFRVDRLRHpqZTVjRUlyNU0xb0dZQ0tKVzJRVmxEWFBKUktManFyVzI0WEs0LzZyK2Q4dEV4TVVHTWZOUTZSa3FPblQ3SlBiVU5zUlFyVXRzd1RqNnFTM2hmVFQ3cW9WaGxrRFU3eFdxbGJZaVRqMHFDTGh2RjhnUlBMZVNqMUxsN1V5eUp0Z0ViNERSSjU5WkU5MW0wRFMza285djZ6Y2xIZTFBc3plc1crYWoxL01WNVVNdjdkQUhXTWJVTjdTaFdiMjBEUkU1c1FaZFZQaW9iRURYWDR5anlVWW91emlnZmpYckVhQnZXa285NkFqRW1nQm91SDhXREZVN2JRTjhrMDBzK3VuMnNKaDgxVE13T0pSKzF0ejg0eUxxdHRpeDNab29GeVVlMUZXcWtmSlFUWXFaOFZDY2ZsV29icU1ENFFYbmlFdDdSV2Q1MDhsRkp2ZkpRckpZSjd6SlBsWmxpTlpXUGZuNXZnM3lVOW1DbGZKU2lYU2tmYlp2d0RnZFp0MWFWSUNrVzFlSGJLTloyc0xEbVpVWE1rSzNCVmRsUnQ1V1AyclVOY2NGV1cvbW9adER0SlIrMTNKa2FwVzFJK1dnWXhSSy9Wajl2MHpabzVLUFlhNzdCK1p6eVVXNVNZYTFQbWlETFFyRWk5aGlNQ2FyZ0lHc1hZTTBZWkszMmFDa2ZuVlhiNEpXUHdqa2pVZkpSKzZEbVh6SWNKeC9sRXQ3TDh0bDAwTVBrbzVISjFDa2ZYVUUrdWw4cXhOcHV5a2RkdFVBa0h5MWVYMFkrS2kyWEtJcWxneGpYMzhDN0NHY0tzbEkreWplZWtXVVhsZkMrc256VW02UVpMUisxRUkyVWo2WjhWUEphakh3VVRuam41YU4xd2p0RXNhVFhrS0pZY0xtbGZIVGJCbzZwYmFoSm1JK01mUVJaVTk5RmVHWnR3MUhsbzIyMURldkpSNUV5R0tadFNQbG9YYTlTUGlvYkpIVkJ2RS9iMEVvKyttaFRIdmtvRm5DdEx4OWxKMjdUeUVldHg4VXRGWDcwNDdlVmdwclVOc2dwMXF6eTBmSTEvTHpua0krV0ZDdGFQdHFMYXFWODFEcjVtVWMrU2hFcmhsNmxmUFNxbWNSRzF1MnEzM1RMUnlGcWRSYUs1UTJxUkZ2bHpMeFVlQ2FLWlNGVG52ZTFrSSsyMXpha2ZKU2lXSmRMUC9tb1Y5dVE4bEY3a0dVZGxBVTBLMGcrcXRFMjFHMU9JaCtGdEEydDVhUFg2MTQrK3FqZks4dEg5eFJMWFcrbWxZLzIwaGROdVZWT1VpeDlZVVBhaHRua285TFhNSW9sSERLWUhJS1VqL2FRajBaTUlsSStHaHMwelNNZnhiVU5HTVdxQXloYVBpb2xVdDczV0NaUEtSK05vMWk2TVZMYkwva3AxdmE1Mndya0tPV2oxT3N5YlVQTDZCM1NObWhJMXZQWU9QbW92VkhxdEExOUtWYktSejBVSytXamE4cEhxYURuRVdTMWxvOXU2dlAwOHRIUDcvM0ZRN0drZFNaUVB1clNOc1JTTEQ3aFhieFZ6ci85Mi8zUC8vWnY5b0FnSDZNcGx2eTkraVZHdTdiQkt4OTlQdGRlUHVveHZmZVNqMG9IMVpTUGtsZG5pTFloNWFNOHhhTGtvM3VTdGFkWTI5ZWc2M3BHK1NoY2pyVzJRVU94WnRjMnhNcEhiWitEM0NvSENyU1NZcldsV0ZadFE0UjhOTHFDUjh0SDhjNGk1YU1VeGRJTXVpa2ZKVDkveWtjSHkwZkxoUGQ5b09YWE5nZ21tQWVTais1S1owT3gva2g0VC9ub3hlL0dZcFBjazJiMURiTDhGQ0RsbzNLS2xmTFJsSS82S2RhSzJvWVY1YU00a2RMSlJ4L2xtdkpSU0Q1YTk2Vm5sby9hZ3pyNEFlWmd6UnBrblYwK09rN2JvSi94SGxFKzZxZFlzRlEwNWFOdEtSWVRjSVZvRzFhZ1dGcHRBMGVzVWo3cWs0Lys2VS9qS2RhMlAwMXRnNnkvMW53bU5NbjlFV1ROdmsvaGtTbldQTnFHbEkvR0Ixc3BIOTI4a3ZMUnkwajVLRDloMmp5V2tvOTZ0QTJ0NWFPWHl6aHR3emEvVlNjZmxiZlA4ZkpSYWU2ckwrR2RPaCtwYVZoaHVUQzFEYkVVcTdXMlFadnNqbE1zOGZCaHBsaXp5RWNGRk91aW9WaVBJS3MxMVVyNXFKNWlqWktQU2hMZW8rV2pITVhhQk9hb2ZIVC9leTBmOVZ4RExxaEsrZWpzRk1zK3dRMjdpNUQ3cGpNR1dVbXhkQjE1YjIyRE51akNYMnNuSDQyNFE2U1hmRFNhWWtuSVlrbXhvdXJ2Y2VTalZNTDdPdkxSSHRvRy9KdzJiVU1aUUtWODFFYXh0dlY5ZFlyVlF0dmdYU3BrQ2RiajhmLyszOXdrS3luVzdqeGZMUUZaUzRxbElWcFFJRkJTTEdIM25mSlJoR0tsZkZSTnNjVDFhalg1YUhFOXBwR1BVdHFHWHZMUlkya2IvQlRyRFBKUkQ5V0NuaE9iM0djTHNvNHBIeDJuYmVncEg1VUVYTTlqOWhUTG8yMndkMlFwSDAzNWFLeTJRVFBoOFZDc2h0cUdwdkxSYlozbTVLT1F0aUZDUGdxOHdzcEhvVHFlOGxFenhlb3VIOFZmZ3ljOFhKdFdiWlV6TzhsYW4ySjVCaTEvcDk1YTJ4QWhINFVHUUEzRm91U2ozcnUvVWo0YVVYL2J5MGVqdFExZWlyV1N0cUU0UncvNUtQbTdSZHVROHRGOWZVLzVxRHhRMDA2a2w5dUw4T2dVeXlvZkJhcjAxNGhLR3RuQWJjcUdsSS95YmVBWTh0RTV0QTNrNTAvNTZNSGxveEp0QTBXeE5QTFI4bStrZkpTbVdGNXRROHVsUWV5aERyQ1NZclVQc3F3RnZaSjhWSzVyMkM5UkhWaythcUZZZ3ZjdUl4L2R2REpRMjlDUFlzbnFVc3BIdVdzRTUyTEJnVlZSTnIvWU5vQ0d0UTN5L25WZnYxTStPZ2JLMklJcTNWS2hpV0RORkdTZFNUNnFKMXZ6eWtjMVZHdDdiTkdZRHlVZlpUcmxsSTllV21vYjZIYkRhUnRXcFZnZDVhT3Zjb3BsMXpiczI5MXpFaFpMc2JCeVMva29WSGRtb2xpYThUQmlxZEM4Ukpna2F3Nks1ZW5JTGUrYlVUN2FTOXVROHRHVWoxSVVLK1dqdnIvUldqNEs1MmVsZkRUbG94YXF4ZnNNWFFIV1hNUW5LVlpMaWpXN2ZEUm9TRW41YU1wSEc4cEhaVGRVYU1yK0NCUkxLaCt0dFEyOGZCVFNObUJCc0NicDNDb2ZMWU04MmZuaUErWTQrU2kxYmRTYTh0R0k4NXJ2SXB5WllxVjhWRWVqUnNwSExjdUVLUitWeWtmMTJvYVVqM0xuanBDUDZ0dWdwY09QYUtQU1pQV2U4bEg0dTlIeTBmSi9yN2JCS3g4RlB2OHkyZ2FZWWttQzlIRVVxNFcyb1R3UGQ4UWhDQmIwU0lxMU84OVU4bEhKWUg0RSthaHVJSjFmMnhCRnNYU0JRM3R0US9HTlVqNjZwM3JkNWFOeWlyVi9MZVdqV29vbEtVZWJmSFFHaXVYdG8yV1RHbnIxd1IxZ1pjSjdXNHBsMVRhc0poKzFhQnRtbDQrMnBsaEU2VFRSTnJTa1dONmN2ckVVQzZ0VEtSK1YvNDFua0NXZ1dDWnRROHBIKzhsSEcxS3NJZkpSYTVBVlFyQXk0YjF0a09XbkFQUExSeldCRnR5UTdkb0dHOFhTQlVxclVpeHFTVEUrNFgwY3hkSnFHMXBUclBQSlI5R3I4cHYyR3EwbkgvMm8zMGVXajdiWVppdENQaHE1RVhmb1hZU3pQczZVOEs3SHBQTm9HN1FCVlUyeVZQTFJpNDVpblVzK0t0bVRrRHVtRmNXYVZ6NzZSLzFLK1dnRCtXaVIvUDRiUkxFMlpPaDNtRTdWUzRVUTRaSmV3M2J5VWZ4dkhGaytHa0d4V21vYmRPZUZKejVoQVZaU3JERVVhMVZ0ZzFVK3VqKzJUSGhQK2FpdzF1emtvM1VaOE5xR2xJK0N5L0FwSDcyMGtJL3Vya0NZdGdFcG0xRDVxRWJiZ0owL09zZ1MxQUtSdHVFWTh0SFlwY0xERTZ5elVTeDkwRFd2dGtGRHRmRHpwbnlVcDFqVjBlK1dRQ1hsb3lrZmxSQ3JGdkpSamJaaDMrNmVDZTlSRk11cWJaQlNyT2hBV2tleDl2VWRDS3dXbDQvYTJwbzBZQXNOc0pKaXJVdXhSbW9iSUlwRkJWczB4U283aVpTUHdrRld5a2NsRk11bmJVajVxRjgrcXRFMlNKTGQrZGUwOHRHeVRkWEgxZHFHOGp3cEgxMUgyOENQRTgvekhWYlRrQlNMUE05VTJvYlY1YVBRWUJraEg1V1ZUUnY1YUJsa3lRZkVZMUVzbTdiaEdiUkRkU1Rsb3hxS3RYdWVwVmhsb05WYTJ5Q2pXRkQ1UGVXamtzbGF5a2Y5RkVzM1JzWUVXZUVCVnNwSDU2ZFlWbEt5aW54VXJtMW9SN0ZpZ3kxdCtmbmxveFJkVFBtb2htSWRRejRhUWJHMFNmTTJpZ1ZyRzdEL1V6NjZ2SHowMWRQUFVCVExmeGZoOWJVSndacDFxZkRzRkt1UVpYN1Z6WmI1d1VDYjhPNlJqMUlhQVdJQWhENEZxMjJRWFpkKzhsSG9PQ3pJYWkwZnJaOC9ocmJCVDdHT0pSOHRpQVdyYmRBUXJsYnkwWDBRQlZNc09oZ2RwVzBZU2JHV2s0OTJtWnhvajMwOERydEVpRjJFTTh0SGdXYnpkVFQxc3daWFpZZWcxRGFvNUtQeWEzSSsrV2drUlVyNXFMN3N0VFAxRm9FWUUwQTV0dENSeVVjZlFaWkZQb3E5WmhtY3VUWWwxemFNbzFpUHBVSXB4VHFDZkZTamJkRCszaXpBeW9UM3RrR1d2ekxOS3grdGc2ZVVqMm9HSXozRjJtc2I2bXMvVWo2NnIwY3BINFZlbjM0TEhiRjhWRFlnYnlrV252QmVVcXlIZkJUYnZ4QXBtM0NLSmV0SHhzaEhrYnJQeVVkZnBCUnJSdm1vcmIrVmZZYkRFNndWS1pic084MmpiWWhxNE42RWQ1aGkyYlFOdmVTanNSU0wyM3cwVHR0QUI3WnRPOGc1NUtQd1VtRUxpblVpK1NpWjhBN0xSM2ZmU1NRZjNWT3JsSThHeUVmSlNZWGhKcG1COHRHWTkzYTVpekFwMWh3VXk5T1JXOTVucFZqVUlDN2RERHBPMjlCSFBocExzY0F5b0NoV2FodVlJQXVuV1BXZ0ExL25sSTlpRkVzVGpDa21EaWtmYlZEV1BlV2puNCtwNUtQV0lPc1VCQ3NwMWpIbG94aEpxYzlyMFRhY1FqNTYwVkFzQytFNG1yYmhmaGNudktkODlESWZ4WHBRcFAzdmM4cEhxWHl3VnZMUm90ODB5VWZ4U1lVczRkMHhRUXFsV0V2c1JaZ1VhMTJLTlp0ODFLcHRzRk1zdjdhaEZka2FJUis5WFBRVUsyNHljUlJ0UTAydDhOL2JVcXplMm9ZNGltWFROa0JCeTF6eTBlc1B3SWUzbkh3VXAxank5am1EZkZRYm9FR1AweENzcEZqcnkwZWxyL2tvVm95MkFSb3N0WGNTVWhTTC9neCtpaVhSTnN4T3NlYlNOanlEZHZxN1NPdVh2T3kxZ2RUczh0SGllYkcyWVg3NXFHekNtL0xST0lwRnYrNWZLdXdTWUtWOHRDM0ZzdDZTZlVUNTZQTllxM3kwSGhEdEZNdW5iYkJTckFqNXFHVFFuVjArR3ZWSStXZ2N4Ym9FeVVjcGlnWGxRa2xwVmNwSGp5OGZqVjRhcE03ZmpXQ2xmTFRsSStXamM4cEgvUUVwdElXT1ZqNWF6dlpUUGhvUlNLUjh0TGQ4VkVxeHRwTUdpYlpoTXlINlJta2JVajY2RE1VS25FRG9LZGIydVZNdEVXSVhKT1dqKzhGd05QVmJRejU2Rjg2c3hzdEhpYVZiTWNYaWJpU1lXVDdhUjlzZ29WaFluVXI1cUNMZ1Y4bEhuOThSMHpiSTVLTldja2kxcVMzRm1saytxcVZZZS9uby9XVTB4Zkludk51RHJLNEJWaWE4dHcyeUxOVEtRMkRPTFIrTnVWSEFGbXoxbDQvV3dSU2M4RjZXei9NYzQrU2prVFBqbEkvR3lrZTFGQ3RLUHZvTW9zcGNySlNQeWlpV1ZENjZxeDlES0ZZdjJqWGtMc0trV0QyL1U4cEhaNUdQYWltV3RJeG1sbzlTUVhIcmptOW0rZWdSdFEwQkZJc053cllrb3JXMllSK3d0Sk9Qd3VWMmJ2bm9MQlNMZnQyMkdYVDNBQ3NwMWh3VXk5T1JXOTUzRlBtb1pjQksrZWk1NWFQQWF5OVUyWjVaUGlxa1g1S3I4a2ExUjAyeU8vUStxM3owMGFZODhsRXM0R3ExVk1oTnhJbTd0RTN5VWFKOHUyc2JscmlMTUNuV2VoUUwwamJNSWgrMUpydVhGTXN3ckhUYlFxZVhmQlFhalBCckJzbEhQNEtzMWxUcnlQSlJyQzdOVHJGV2xZK1dBUk9uYmFBdDcvcDI2NVdQU2dmM3FFQmFSckYyeHl3ckgyVmF6cXUycnhvU1lDWEZha3V4ZW1zYmVzdEhxYUFMZnkzbG94NktSWFc4WEJCY1VxeTQyV1hLUjZNcDFoSGxveEJGZ3JRTjJQOGo1YVBYNjl6eVVmOFdPdkwyT1llMlFiWlVlT3E3Q0k5T3NUemFCb3hpemFCdHNPVmdVV2J5bEk5dVhwOWVQaG9SSUtSODFCWklyU3dmM1U0YU1CbzFXajdxdmJsb2xIeVVLUDlEYVJ1VzI0c3c1YU90S1paTjJ3QXNnWDJkNlhyaFNnYTVmQlR2NEk4ckg2VW9Wam5qMTFBc0RWbWNnV0pGUFZJK0drZXhMa0hhQmdIRlFoUGVjVnIxZEdPMWxJOXVQbGZLUnlla1dNV3JyOUoyTTVSZ3BYeDBqb0J5ZG0xRHlrZTVUcHVYaitJVXE0MThGS2VHejhEOVBQTFJmdG9HcnV5UEp4L0ZQaCsrLzZaT1BrcHJHMUkrdXEvdlI2SlkycVZDNkQyblh5TEVMc3lSNWFQNlNqZVB0c0VUWEtWOFZGSm1NZkxSc3B3a0E3VzlyczR1SHdVL2Y4cEhiZkxSMTFZVUsrV2pIb3ExZTU2aFdHdklSd1d0aDcyVGUzaUFsUW52YllNc2F4US9xN1lCVndab2t0N0xoSGV3UTBBN0J1LzNQNXQ4RkRmdW4xTStDcHdoNWFNWHNYeFU4VG5pNWFPRVVpUGxvenpGbWw0K0dyRlA0ZkM3Q0pOaTlmeE84MUNzaU0yZm9ZQkpRN1h3ODI2WEN1UGtveDZLSmIyR2piVU5idmxvaStBbTVhUDJ3TjFMc1dhUmoySVVxNVY4Rk1yVmtsN0RFZkxSUC8wcDVhTmFpcVVQdXVpbHdpa0NyS1JZNjFLc0dHM0RjZVdqZlNtV1BvaE4rYWova2ZKUkg4V3l5a2MxQS9KMjRvRGxOMG5VRE5qdkdNV1MwS3RXOHRITEplV2prZ0RkRHdMd0lDc0pWbElzQlQyaDcvN1N6T2lBVjFJK0doSnNqWldQYm9Nc3pXQ2M4dEY5bmNMcTB1TzVsSS9hNWFQbHBNRWlIK1hKaG02U21mSlJ2UDlzSUI5Vlh4Lyt1c0pCMWpRQlZsS3N0aFNydDN4VTI4RkVOWGJkdnozRmtpZThuMFUrNnRNMm5GMCtxcUJZSW0yRHRvNk5vRmg2dWlXaldJS0F5eVVmeGJRTjJQOHBINTFEUGhwQnNTSW5KVlBmUlRoTGtKWHlVV3JBbmtzK0tyZFZ0VW9BQUJnWlNVUkJWQm5NcGZKUllnQ0VQc1VKNUtQU3N1QzFEYTBvbHE0K3Q5YzJHQ21XdUY2TmtJK09vRmpDL1FuRDVLUFFkNllvbGpUbktsbytPcSsyZ2FaWTJ3bHJwTGFoWlFLOHh0aStyWHVaNUg3QUlLdWxmQlNib1VTU0tHOERQNnA4ZEJURkttZjhWb3BGQmNEOUtWYmJSNHg4Rkt0VDU1YVBTcy9YU3o2S3ZRYjBHV2FLdGZsYzc4QnpTOGhIT1lvbENjeG5UbmdIam5pZGxtRE5STEZXZkVRbXZNOHVINlVDTFd0TzFvenlVZnVTNFRqNUtKWHdEZ1ZkMnlBcjVhTjJpcVdaYmE4bUg5VnRvWU45dnBTUHRxVlk2OHBIN1FFVm5ZK1ZCT3RBRkV2Mm5WSStXcE9zbEkvU1phYVRqM0pseGdsS1l6ckNsSTlhMitXeDVhT1BJRXNySDYyWENpR0tKYjJHUGVTajVkK1lSejc2UjM4NnZYelVNbm5aQmxsVEJsaEpzZWFnV0paQjJ2TyszdkxSL2JFcEh5M0tJT1dqamlBcjVhTmg4bEV1Q0ZQS1IrdUpnMVhiWUpHUFNvS3V4MTJOWHZtb1BLanJUYkYyeDgwZ0gzMjE5c05jLzVzRUt5bVdPZWlDdEEwcEgwMzU2Tm5sby96M1Mvbm9IQlJyOXlDMURRK0t0UCs5bFh3VUs3ZVVqemFpV0VIVWFxRzlDSk5pdGFWWXZiVU5JK1dqOG1BclNqNjZuWUdOcGxncEgwVmVTZm5vNWRqeVVUcmdrbE1zcVd3MFF0dVE4bEdhWWdubG8rRVV5eHFNSmNFNktjWHlhQnM0aXVVTkxEemFCdnNtMEJLSzVabnhwSHhVc2ptME45aEorZWg4Rkd1VWZCUVBxbWlLOVpselZYbXBKUEpSYVFEVlFqNEtPYnkwZjlzN29lVXAxdTRZQmNWU2FSdUdVcXdsQ0ZaU3JPTlJyRzZobzNHWk1GbytHaldveFM0WmpwV1BVbVZTVXF5NGpuRWUrYWhlMjJDWGorcnFrbzVpOWRZMlJNaEhwUlJyVTI5K2w5SXFqbUpKcnFWWFBncTAzV20wRFVlUWoxcjY1K2tKVnNwSHgxQXNuYlpoYmZrb3BSRWdCa0RvVTd5MG9sZzJPM1NVZk5TbmJZQW9GaFY0OWFWWWZlV2plTUo3UmJISVdUMzhYV0swRFo1QWFwUjhGS05ZWmQyUGtJL1cyZ1pjUHByYUJxNGRUeWNmTlMwVjVsNkVKd3l5UFBKUi9jQzFycmFoN0FoU1Bzb2QwMFkrV3I4bjVhTjBuVnBYUGlxOTgwOHFIK1VEdEJqNUtQN1BwbTBRdExXVWp4b29WdStsUXV6NUpRS3NYQ3BzRzJSWlNjQksyZ1pMMEFWUkxMKzJJZVdqS1I5TitlaisrVm5rbzNqQ2UwMmx5bHdzV2o1YWxtdGZpdlZSdjFNK0drZXhwTmN1Q2RiQktaYnNPODFEc2FLMERkcUFTaVlmamRFMnBId1VKMW5TOTlqcWFoMm85MGg0dDhsSDIyZ2JvdHZsc2VTanV3ZEpzYllVYWF0dHNGQ3M5dkpSL0cra2ZEUzI3aStqYVVpS2RSeUtOVUxib0pXUHdvbnhuTGJCU3JIc0pQQXM4dEVpc0QyNHRnR2lXT0NuU2Zub1pUMzVxRWJiZ0ZNc3Y3WUJPMzkwa05WQ1BqcVNZbm5HekNSWVNiRkNLWlpWMnlBN3YwL2JRQVZhR0VtcHp6c2Z4ZExQcnZySlI2R0U5KzIxMWdiSjBST0VYaFNMLzM0cEg1MlZZcFhhQm00TEhXcS9RZ3ZGc21vYnBCUXJlcW13aFh4MEVNVXlMeFV1dVJkaFVxeTJGR3VrdGtFYkxGZ0hOUDIvUHRxR284cEhzVEo0Qk1zYWloVTNtVmhTUHZvQzFTdGMyNUR5MFNqNUtCeFkwY0ZQcEh3VWExT1V0Z0g2TENQa284VGRnMkh5MFlZVXl6VSs1bDJFU2JIS1NtK21XRE5yR3lURVNpSWYxV3NidUlhWTh0RlY1S090dEEwSytTajA3bC9wNzVMeVVaNWk3YjRGbzIyWVZUNEtsZTlUUGlxaFdYMFMzdHZJUnpmOTh2ZVdGTXZTTHBZTHNKSml6VW14b2dhNlpxRmpnSHdVNzh6WGw0LzZLTmI4OGxHNXRnR21XRkVQU052Z28xaHR0QTFIazQ5aXd0R1VqL2FtV08zbG8wVDdhclpVaUwyMkpNRksrZWdZaXBYeVViRzJBWjE5SFlkaWdiTjlGOFhpNUtQUkNlL0VkZWtxSDdWUnJISGFobVBJUjlHcjhodHdUVkkrR2theGJQTFJjbEtCOVorTjVLUG1pV3d1RVo0c3lFcjVhS3g4dE93VWFvcFZIZWVnV1BzZ0t6by95MExUTEJTTHU1R0F1OW1nUGNWcSs3REtSOCtpYldna0gwV1hDam1LVmRicDJlV2pmTUw3ZXZKUkNhMXF1SVZPVlg4Tzc4SEtwY0syUVpZdG9EcStmSFEvOE52a28xYUt0YTU4MUtadEtNdW5CY1VxZzZ5WjVhUEFHVTZ0YlZES1J4V2ZReVlmclZVTXVId1U3OGZpS1phc0h6bWZmRFNnejFEbll5WEJPaUhGa24ybjQ4bEhyZUxSclh5MFB1OXg1YVA2Z2RhdWJkQUV4WkZ0MVhKTUgvbG9QMjFEOUhVNnVyYmhRYkZLT2dWUkpFamJNTHQ4OUU5L09xNTgxRW14eEcza1VjNUxCMWhKc2RwU3JBaHR3MHp5VWFpVGpwZVBTaFBlNDBoZ0svbW9VRWdhb20xSStXaEpzZXBCQjNsdEdZcWxwMXZIa0krV3g5Vy9qNU9QOXRJMnZMOC94eHVlWXUzcmU2UjhOSnBpY2UwaENWWlNMS3JyTzdWOFZKSVBSSGhjaGxJczZUVzBKcndMS2RaRlNyR2tlVmZIbDQrS0U5NVRQcHJ5VVpkOFZKYUtFUnRJeStTanUyTm1rNCtxZ3F6bEE2eWtXUE5UTEF1bHNnUUxMU2xXeWtmSjRNeE5zYmJCOHJubG8yaE5UZm5vWlViNUtLeHR3UDRmS3grOS9nQnlNRk0rMmpESVNvS1ZGTXRNc1ZiV05saVMybVBrbzBmVk5rUlJySlNQemkwZnJjdiszUExSK2p2UEt4K1Y5YS9yeVVjLzZueEgrYWk0dmg4aXdFcUtOWVppUlpDbG1lU2prdURyZVl4VlBzb1BpQ2tmcGNzaWltS3RMaC9kTHhYMmtvLzJiN2M5NUtQYjRGRklzUXphaHBTUFd1U2pQTVhTQnV4dEtCWlVOb2NoV0NrZm5ZTmkwWjN5Y2VTamNPTk4rYWgrNEh4U0xDcmhuUTZNSXhQZTBlc3luWHlVcTFjVXhiSUczVnI1YUJURndwWUtKVzJib2xpQ25LMExJaDlsdi9lRFlqMlBTL2tvVno2UkZBdnJUNE1wRmhsazVSSmhCbGtwSDNWb0c5ckpSL2w4bWFQSlJ5VzBzYlY4MUhKbmFwUzJ3VSt4OW5YcVNQSlJ6WVRwTW9sOGRCczRwWHhVVHJGYXlVY2JiS0hEQmxtSENyQnlxYkJ0a0JWRHNmd2RmRXY1cU03dURnMzhVZkpSKzJBWElSK1ZmUVlQeGJMSlIvRXlHU2NmYmJWMUQwNnhVajZxSVZZY0pkRnZvYVBSTnFSOFZFdXh0dldka0k5K0JsblRiS0VEQmxsSnNKSmlLYjVUZjIyRDV4anB6TmVuYlJnckg0VW9Wa3l3ZFgyVlhXdDRvT1VwVmtVTzNpMmQzZEhrby9RQWtQSlJCYzJTTGlrcUtKWmUyL0NnU1B2ZjE1T1A5cWRZdStjaCtXZzFxWmhBUGxvRldZY0xzSkppdGFWWXZiVU5LUi8xMHo5TllLVjVqdWpvVXo0YUZtU2xmRlJMc2FoenRKS1Bsb0VWdDF4SS9ZNVJMRW5RMVVvK2VyMm1mTlFTWkNYQlNvcWw3ZnJNRkd0MWJjUHE4bEY5RURXRGZIUWRiY09hOGxHdnRxRWR4YkxjQlRaYVBncmQwU2ZSTmtUSVIrbGoxcEdQOGdIeTFCUnJWNThPR1dBbHhacVRZa1VOZE0xQ3g3c242R29uSDQya1dPdkpSM202V0ZLc3FMcDNIUGxvSFdSRjZGUmFVeXdpNEZ4U1BvckpTS1BrbzV1MnA5STJ6Q0FmeGR2UmtoVHJqeUFyQ1ZaU3JGQ0t0Yko4bEJ2SXBTUXJXdHZRYWd1ZEZlV2pzcVdjSHRvRytER25mSlQ3Ym5hS2haWDkyZVNqMXlzdkg3MWNZSXBGWDZ1NlhDUGxvOUwrdFhYQ2Uvd1dPdTNrbzFTWmxYWHFzQUZXVXF6V0ZDdEsyeUJ2N0MzSkZkN1lOWGNWdHRRMnhGTXNIYW1Jb0ZnNmJRTTE2UEpPc3BpQUNnL1U1NVNQYWlpV3R0MUZKTUczYUxPQ0NaTlkyMkNWajVaMVdpNGZoYlVOL2tsU3lrZXRkVWpUVjV4NnMrZVVqN1lOc3F3ZHJZWmlhWU1NQzhXaUFxMlVqM29wbGswK1dwZURYRDdhajJMTkloOTlhaHVBZXBQeTBZdFlQaXA2bmFCWWJCc3BjN0dvZ1ZvckgrV28wOXJ5VWZCdTdTbTIwS0VDclZ3aXpDREw4WjNtb1ZoUjJnWnZjRFdIZkZRVFBPbVBieTBmbFExd2tpWGFkaFJybExaQjhmbW5sbzk2cU1JODh0RkhrSVZUckpKT2xlMU1JaCtWWG1PT1ltMCsxM0x5MFNLdzZpRWZEUUVMaHcrd2NxbXdMY1dLMERaZ0ZHdUV0aUZHUGxwcUczckxSK3ZCVXh0c1VSUkxRakpzRkdzN0lNd3RIOTI4MGp6aFhVdXhnRTh6bmJZaEt2QWFLeC9kZmFObTh0RldXK2pJeU5VYzhsSDhCcFphUGdwUkxMaCtrd252M3kwQmZsbUdTYkNTWW5tYlJYZjVxRDZvODJrYk5GUUxQNjlOUG1xbldENXRBL3phZVBsb2o5eUtxQ0FoU3R0QWY1K1VqeXBvMWhUeTBUTEkrbXpYSnZtb29PODduSHkwcGxqNy92VHp1UWh0ZzZ2L09JM0pQU25XL0JTclJRY2ZOY3V5QlZzeDJvYW92RFRMdFpLNGNlVGxSVklzc1h6MGNrbjU2SjVpN2Y1aXlrY3Y3ZVdqMjBrRVJiSGd3S3B1V3g3NXFJeGlZZkxST3VHZG9salErUTh1SDNWN3NaSmdKY1ZxU3JGVzFqYlljckI0YllQeTJpNGhIM1ZTckl1VVlrbUlJZEZoTGt1eGdLQ2lvWHpVRzdpUDBEYkVVYXpQQjBPeDZNbkRYdHN3cTN3VUtsOGR4V3BUdDZWYjZPd21VcTNrbzZyNmVkb0FLeW5XR0lvVlFaWldrNDgrajRVVDNvOG9IN1Z0b1NQWE51eXYyM01RU1Btb2lHSXA1YU95QUQ0aUNUNHc0T3drSDFWcEc3YjFocFNQUW00c2kzd1ViOU4yK1dqdkxYUzI4dEhWS1ZZU3JLUlkzU2tXM1NtbmZCUUtzbnJKUnowVVM3K0ZqclFzbmhRTFMzam5nNXN6YVJ2cXdSZ1Azckh2NHQxQ1p6MzVxSXhpMFpNSG5HTFYzM2tySHkyREZrNCthcGtrUmN0SGUwNXNSOGxIdlk5VEJWZ3pVNnpaZzZ5VWorcm9GVWV4dG9NZ1RMR3E0N3JJUjF0dG9lT2hXSktjbURua28yMGZNUlJyWDZkYXlFY2oyNnFtN0x6eVVZUmVUU2tmdGQyb0Vpc2Y3VUd4UnN0SEtZb2xPZC9wQ05hczh0RVZIcU8xRFpvQm9JVjh0QTZlckxsWjU1T1BGaHZQL21ab01aUEpSL2YxS09XamJiYlFrVTZBTnRlamlYelVRYkhBYTBOcEc2UVVLMklMSGE5OHRPY2t0LzYvajN3MENkYWlqOVEyNkY1YldUNUtkOUl4Rk10NkxTUEt3MUxlYTh0SDljZWNWVDdhZzJLMWxvL0tLUll1SDhXMERXVncwM01MbmMyRXdTUWZIVXV4ZG9HVm1tSkprOTg5dVZpbkRMQXk0WDEraXJXZG5hd21INFVUNDF2SlIrMFV5KzdEc2xFc2JyYVBsRnJLUjRFZ1MwdXhnRTh6VE52UWdtSVYxeU5FUGlvTTBxaXJ5R29iTUlvRjNWVllCMmF4MmdaSjJVTHkwY2twbGtrK0txOXJHV0FseFZxSVlsa2RXRFBKUnltU2dzKzZlc2hIZmFScVpmbG9pN1k2aW1MeDMzbGQrV2hMaW9VTTFOK0ZBWmRMUG9wcEc2ZzdCckc3RFNQcnE0MWk0Uk8xZWJiUThjbEhrYnFrcGxpbkRiQ1NZczFKc2JDQlltYjVxUHpmYVBtb2Z3c2RxUTluTnZsb0ZNV2FTZHVBVTZ6ZEswdkpSM3RTTE9vYzBmSlJqRUx0QTZwbmdBTnBHM3BRTEsxOHRJY2ZpNUtQYmlsV0oyMURCbGhKc2VhbVdEcjVxR3pBMTc0dmdtSnBhWlorQU1RcGxsM2JZQ1ZWNU14M1FmbW8zWTNsRFJLaUV0NkJYTDVEeUVmMXdWUTdpbFU4T3NoSGFhSUZVeXljZmxzbm0xcUt0WDB1bW1JaDdYZVVmUFM3WnRKMDZnQXJLZFlZaXFVN0ZoNElQVE9taUtSYnIzelVTN0hzOGxHY1lua0NzWjViNk1DQnExWSthcWRKWG9vVjlhZ3BsaXFJZjRIcUZSNzg5cE9QVXNmb3RBMHErYWlVWXFFSjcxRVVxMTRtNUNpV3puVlZ5a2RsRk9zcEg4VW8xdlp4OEMxMGttQWx4WnFEWXNWb0crSXAxb3p5VWY5QTM1OWlqZGhDNS9PNGQ2b2NrbUt4RkFzNkd6amd4UG5XL0JSTGNoMk04bEVweFZMUU14dkZnb2xXZlZmaC9ocnFLSlpXUHFyNXVkVnlJU1FmbFZJc1hEN2FsbUtkUHNCSytXaGJpaFV6S1BFVTZ3ankwUWlLSmVzSVpSU3I5eFk2eUl4Zm9XMDRKOFdTRFE3N0lINi9WRWh2b1ZNR0t6M2tvM0VVU3pWaGNzdEhKUlNydUhzUWtJOUNGQXRlSHFRQ0hHSFFLNWFQanFaWTJ5MTBOcFRTS1I5dFM3R1NZRTFNc1k3eDZFT3hMTzhiSlIvMVVTeWR0c0ZEc2ZUSGV5alc5VGQ5L2FjcGxuUUxuYmoyTzRkOFZFS3h1SHBsNlpzT1FMRk1BNm1XWWwyQXUyUWxkdzlhS0pac3lYQy9WTGdXeFpLVUt5Y2YzUjM3M1VxeE1zQmFnR0t0dGxSNFpJckY1V1hZeGFNZWlsVjlvb05RTEh6R2I2VllXRG0xb2xpakhqRVVhMStuamtDeExGNnJqaFNMbEk5Q1hpd0x4ZkpNYkZlaFdQNHRkSjU5S0xCUnZKaGlRYzlsZ0pXUERrSFd1aFJMTTR2bFhGajFNZHZPNE5raDlOdENKeW5XVVNoV21mQ09VNndJK2VnY0ZFdERuWHB1b1NPa1dDREJ3dTRZVElxbG9WajJMWFRnU1lXZFltV0FsUlJydXU5TFVheldtOHRLUG9kRlBpclJOekR5MFFaYjZMU2lXUFFBQ2dWajR5bVdMY2lhYVZtZjJWU2NJc0JMVWl4ckVDYWdYTzR0ZElDZmY2TW9GaVFmTFFPcDUzTzE0VDFpaDRiVktKWmVQa3BSTE9wbmV5NVdCbGo1R0U2eHJKMXN4TjJGTFNtV0xMZ3FLUmI1YUxDRlRndUs1UmxFMjFBc1Q0Nk53WWc5SWNYYVBaOFU2eEsyaGM2ckxNQkZKdzRFeGFxVDNhMWVMTmxHMFBnV09wNmZXenlrOGxIb3VoVExnNkVVcXl6M0RMQ1NZaDJDWXNYTmVtVkJsaVVYcXp5ZW9saElMaFkxMVB3cXY0Ym5vMWhRV1drb1ZvL2RBVm9TTFp4aVNlV2pjQURmZzJMRlh3ZlJjVktLZGRGVHJOMzNENlZZTmg4V08yRXdVNnpIejczbG8xS0toWjByaW1KbGdKV1BwRmpDODFPTkN3dWFlbElzYkJBOEE4VzYzOXRTTE8yMTBHb2JvaWpXUC82amxtSkJueCtpbzdBWHF3ZkY0djdlckJTTCtwNlF0a0ZQc1o0QzBsWVVTOXVYOXB4czZMYlFhVXF4TXNCS2lqVXZyWklHUGRFYnptb3BscVNEWDVOaTZaNmJrV0xCQTF3c3hmTFVxMUdVcXhReU10b0drR0pwdnR0TUZNdXpoVTRFeFVLQ0xWVGJ3QkVwaVJjTGFxY2pjckVzcEN5YVloWFBONk5ZRjJLWk1BT3NmSFNuV1A2QmFUOUl0TG9UVVRKYjVpaFdvMXlzaTV4aVNhNEZUU2RHVVN4OTJYd01BaHFDSmJubTFseXRlU2dXK3MyY0ZJdWU0VnNwbGlWQWpkeENoM3NPZWJ6UzVFcEtzZmJpVVNpZzJnZFdlNHBWbE9FdmxyN0JTN0d3OTdaWUp0UnRvU09qV05vK09QY2lUSXExTE1YeXpKYjF5Y2t3L1NqUHd5MUo4SG9HTjhWU0pDTGZ2MGRTTFAzeGRvcFZsSWVZWW5HZEliOXNlQ3lLVlU5c3lPLzM0djF1WG9wbHZVNlNkaGw1SHVzZWg5UVNPRXl4OWs2c010aVNuc2M2K2RGUXJNL2pmdmF1ODFhS2RiL1QxUFlSakdzcFZnWlkrVmljWXNVRVpoRWR3SGlLQlhjT0xRYkRpRUJNVWZLLzZRZkNrbUpkZjlqMktZeWFJSXluV1BUMzJ0OVJpQkRqWDJlZ1dMRURzcGhpZlZmVUVSWEZLcTdEbTRaaTdaOTdKcnpYYml6ckhvVXlpcVZ0RjMvek4zTlJyS0pPaEZHc3grOFpZQ1hGV281aWNiTnd6NkNPVVN6TExGZEtzYURnYkRzQTZ2Y290RkFzK0JocjhGUmN4MWRaa0h0OXBaY2Fhb3IxY1czOEZFdnFqV3BGclh4QmRTdUtGYkg4ckgvT1NscGFVU3hsMHZ1cjdPOThUQjZ1MSt1YmpHTFJRUlpGclNLdTdhYU52dGZQZi9TVFJWdjlhUzNEK1NtV3ZDNWxnSldQUVE4ZHhiTFNLQW10aWxpU3NGQXNLQkRiRG56MlFWZEhzWHpCVTh6QWFLVlkxT3hSazRmRkRaelEreFRiL3Z5UXZDYzZ5TkxuWWtrcGx1NGFTQ2xXN3lWVWhkMmRwVmowT1doQ3QvbmViOUFkaFkvQWhncXlIb1ozNnZ4NldsMVBYQ3c1V09WcjYxTXMrZDJGR1dBdFNudU9za2VoOVk3Q2ZnRUVORHVUQjExY3NFVUZCUFVBNktGWWR0V0ZyRFBXVXl6a3I1anVLTHpmdDRQQmZwWk5tZDI5QVk1azBNSy9jNzFNZUwrMzJRVGFFYXkvOEFNTWZKTkViNElSUmJHa3VWVEVlVjUxOVJ1aVdMUVRpeUpia21SM0MwMHNnNzJvdnZvb0ZPdXhqK1gydFF5d2lNZE15NFQ1Z0JyeHg2eGtaS2VPTFJ0b3ZWalkzbmplRFlsMXN5NzRtRlo1Vi9MWnNPV09RamlnZ29JcW5HekY3VkdvVlgrMG8xZ3laY1AxaWllN1IxRXNiVDBZVExIVTlLcFFoa0NCMVc4U2lnVUZPckNLb2FaWWtySmk5Z3o5WFZPL3FXWENrWFozSWdqN3hSYU15eWhXQmxoSnNRWlNySS9PdmlmRnNuWG05c0ZSc2w4aE50QVRqVnR3K3pXL3BOTkRQTHAvVFpyTWJFdDZsbElHYWJLN1p5c2RCU0g5R1VlYlBCU0xINXdsUzgvV0FGdGE3bEU1YlliWHYwc3AyR09mUW1XdzlRWk1MSDZuQWlyT2R4VnhNd3VlNi9WQmlhMDVZQzJXQ2FreDVqT1kvc3BRck1kUEw1WTZrd0ZXUGc0YmNFYlBqalRuMDFBc0xzaDZ2bGJTQlRUSFFtRjI3eEV3ZUdmTW9rK0lLaHVlWlhGOTM1Zkw4MjVDakY2MVQzYVhCK3AvKzdkeEE1Q2VZcFYxQzFwK3huY0pzSlQvREZ2bWFBTDB1R0FZcHJPSXVQZWRsNDgrdlZpYVNabVVZbGs5V0wyV0RkL2Y3My9tSmJCb3VRSDVWN0RaWGJwTW1BRVc4OGhsd3Y3Qmt1NjRlb0JvTktqL3NDWW9VNVNxSE5pMUNiUzY3eWJaZDFBMmNOb0RLL3hXZFRwZzFpOFRZbVZqemIraWpwbDFQMExsbGFvMmdmYlVyWWhyNUxtdThqc0c3OSs1OXFaMVkzMCtYakZ5aFNXK2YzN2ZuWUMwVmkvZ1M0ZVNhOWl1cnNydkp1eGNyeEdLOWNkenZ3Q0JsVm5aa0FIV2dRS1JveXdUdGhxNGVnZ09wUjJ2eklXMTkySkprOTBqN3Z5eUI3a3RPbS9TR1hRcGxsVGVMSVJCWW5mM2RLNkt1d3gvdG02SERvb0YxaW11WG5tV0NYdm5UQ3JlODkwakt4VmNqVGN1TU1JQ0xTNFhTelB4aE0vNTRlWXFKa3Z2MmphL1BiYmxNcUdNWW9IWDZVVWFWRXNtRlJsZzVXUGE0Rkg3bnZZekpYcUpoOU1GVUlHV1p3RFlmLzhWbGdtdGc2aUVZc0YzRTBvUzNmSHJMZ3RBWk45SmZsZHE1REtodms0OTl5ZkU2NVVzMFRlYUtGdVg3K25qN01udU92a29uZXdPRUNCUWxTQlpudE51blJOQkdHZTRvM0NiN0M2dEV6REZlazRxTm1STDVjVEtBT3NBajZPSVI2Mk51RlduSHIwOElka1VHcGdsTlJkZTluUmlhWTZETm92MkRhelBBRmtTYU0wd2dlai93SDFLbyt0aGl5QXpNaGxlZnk3NVBveFFYaFVWYUhuYXRMMjk3dHZZUnV2d2MwaE5McFFOVWE1QlRUbi8vd2pvK29PQ2U2dVNBQUFBQUVsRlRrU3VRbUNDKTstLWdyYWRpZW50OnVybChkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUNBQUFBQWdDQVlBQUFCemVucjBBQUFKcW5wVVdIUlNZWGNnY0hKdlptbHNaU0IwZVhCbElHVjRhV1lBQUhqYXJaaHBydVE0RG9ULyt4UnpCTzNMY2JRQ2M0TTUvbndoT2JPV3JnWUdtSDZ1ekxSbFdTSVp3U0Jkei9yUHYvZnpMLzVjTnVrSk1aZFVVekw4aFJxcWE1d1VjLy9hK2JZbW5PL3o1OTViWFA4eS9ueHZPSVk4di81ZWx2VE8vNHpiN3dMM3AzRVdmMXFvalBkRy8vVkdEZS82NWJlRjNvMjhMSklWODEyb3ZndDVkMi9ZZDRGMjNUS3Bsdnl6QzMzZDMvbnhwTnpQb3krZnIrdWZSWDYvRHBub3pjaWdkMjU1NnczZnpvZHJnTmNuUEw1eDR2bjIzbW9pUjJPcTVUdjQrbHBDUVA0VUovT1RWYy92cUh6UDdOK00vd2FLVDNmOFllRFhZS2J2N3gvSGJmeHo4SjhUNHA5Mjl1Tzc4eS9qWVp2NnV6dWZ6OTZ6UEh1djYxMExpWkNtMTZtUEsrZU1pWjJsL0hrc2NjQmtxRkw0MVZFNXlnTjdCK2hNTTB6bkdMWmFCeXpiQmp0dHM5dXU4enZzd01UZ2xzdjhPamVjUDJQRloxZmQ4T1lCbjZERGJwZDk5ZE1YY0J2QTZ4bDFYMXZzMmJlZTdZWXRiRHd0TTUxbE1TdXNud1A0UDNEODdVSjdpL0xXbXZLTkZYWTVFUlV6aEp5K21RVWdkbjk0RkUrQVA4ZnZmOExWZzJBOFlTNDQyRXkvUy9Sb1gyNkpSLzRBN1prWStiMXBZZk44RnlCRTdCMHhCcjRIYTVMMTBTWnJzblBaV3VKWXdLZXhVQ0ZSWEFjQ0c2T2JXT21DOXdsd2l0UGVQSlB0bWV1aXU4Tm9Ga0JFbjN3R211b2JXQVdFRGY3a1VPQlFpejZHR0dPS09aWllZMHMraFJSVFNqbEovRnIyT2VTWVU4NjU1SnBiOFNXVVdGTEpwVHlsbGxaZDlZaGpyS25tV21xdHJiRnBZK1hHMDQwSnJYWFhmUTg5OXRSekw3MzJOcURQQ0NPT05QSW96NmlqVFRmOVJDZG1tbm1XV1dkYmRrR2xGVlpjYWVWVlZsMXRRN1h0ZDloeHA1MTMyWFczTDJyMnViRCs1ZmpmVWJNZjFOeEJTaFB6RnpVZXpmbXpoSldjUkdFR1lpNVlFTTlDQUVJN1lXYUtEY0U5Z2s2WW1lcklpdWl3TWdxY2FZVVlDSVpsWGR6Mmk5MFA1SDdCN1FuaC84TE5mWkI3Qk4wL2dkd2o2UDRHdWIvaTlnZlVwcXJOTVA0NUNDa05GVlRqU2IvdEoyYUU1dm9PemE5RWFUdlhpZEpRYTlpTlJXc3FoWUlsTXcyS3VLMUQyRnFQZmtZOHlKR1lqK05OYUdPRk1SWFV3b291aldSRDVKL3JCUVNuNDN3dEF5UkVObm9HbjM3dXh6aUNwa1hMckRKNG5sZ1JrYlBBTlhBazlPMnppeTBqbkhOdEFodW9hejBNcnViMGc2SzlXMkl6aDZyQUdFS2R3UkRERU44YTQrTEp0cVhBOE1iZmEvSk1qa1JUSDB6cmdBWDR0Um1aRktDUmpDb0tVM00vN0NkYU5zbFFvaE9Hd1JxZFFseWJtUHMwVitUMjhTdW8ycjByMTI0TFF3cEg0ckVmenNxRURBY1VLa2lReXlTc016enpnQkNBcG15eGhleVpKa0VpRjJQR3Q1aWFXWldRcE9tMWN5dlZ3MHIzYnBJOXJuQmxIMW1TelBYRmFhRy9vdEpqcUtVY2l5QTNaVEllQkY4emVZeXorRmdjaVh5TTlzTnZQclpBOFhCaW1lRlhXanplcGlXNkZSNlRPa0NDdFRBTHdycEV4TUhsa1dOUXluaWxoSEl4ZHZMdFE2QUttNXI5Qk1oVXIwME9JT0hEckhBampFVzBUQkpyeU5TQ09RWmFMQXZPdEdONFo2WVd4YXhkZzhKeHBveDJmTWk2Sk1UcG1hOXZ4WXdUQW84ZGpiUXQzU3FnQ0U3enRWQ2lMd25RRU5BOHB5bXRTMUdtalByMEc1RXUrb3gwZUFTN3pURzdCd2VjaWoxSFJKdTZtZGpnVzAxZDdnOXRveGh3ODdGb2lTRENrRWp4b2l0UlBKS3NwMEVOZW1xVFFJcVgwaWRzUUZTMVFubTJvbkhoeWY1QnpZb1NZMUx3S2xuU2I4YkZNVDZVZHBmU0owNWZ4c2FneHZkWTNZUStQRm9LV0hJTk95c2J0ang5UjFHSm1ieFkyQk5RMkZhc1piY2dYUU9KU0tnUWJ3UVZGZzdhbEVHbFRWVTY0bEU5NG1vQkJ1eW52T0NSV1Zhb3ZiTklPRU44alpVcW5OaFkwQkYwV0pUQ1N2RVJCeWRzbytPbFB4SW5qNThRS21RQzhGS2JidnNsL0dGNUZGS3V2YnhBekpKNXJHSXJsOEFNaXpJQlB1NHQ4Ty9qcU9MV0NPcGxlenNPYzVPSDA2OE9QNi9IMVI1Tmc0b0Q3QmJsQ3dXQTRqWDJOczNLbGNLc0lFSVNNWWNCeXgxcjhCYjNhcXVQOTJQV2dBSVRWZlIvTlZzcEorcGplSVpSa0xXSGpRd3NLdUw2T05aaHVaVElIVktaazdUeUJ1Mm9vdHM4eEVFMDFDaXFTQjBrcVlTOC9TUTV0ZTkxNDlYQjFodUdWbW1QNXlSUkR1MHdzWVhDM3BSRWUrUW1sV3JJcjlKTzJYTTlJYkVGbjVULzRtSlAyYzRVdTRFbUR4N25HZXFDRDZ1RXl3eE1uSXlBajNhUVNjSVl6V0t5YU4rWW56dzh1STROR0xPZjFnMlFSMkJKby96c0hScUpzZUhISmNrdTc0NVU1WWxVWkd5SDFNSXdzRkRycWd1bHZDc0FBZ0JKSTQ2ekYzYW4yMnltM0kybHIyaFBOU0JiMVV0aWFacXFJalFMdkdXbEltYmluQ1F2QTNRRmNNVldVRlEvZkZzOThRNTIxaU8vRjdHYUNJQ2lpNUVQY3lyZC9WRW8rTzdDOXRkVHYvcWcwZGdJcHJWZDBuUTlES24vRENqZUhONCtTZEhXVTBFbC9KMkJXK2dXbDBVQXk0WUk0N0VudlJZbXZOZVZrZ0t3dmFUVzluQ1AwYVJiMnFmR1ZGRGcyUTV4bE82UTJsa1c1eUhDREdrWFRVdEVSQlY3WlUxNDlQWnpxU0R1RitodWwza240Y3lwSmpRVWRwK3RJdkFIM3FjUFZMaWJpYkRkZVRYZWp0NmtGUHNFejRzL2kvWkQ3NE9tY3VmMS9ZZXp1S2JvM1V0a1JEbGNKSHJDT2tyU0x0UUVIMTJVRFBxbVhraCtLNXdnUmhYR3UzQzJUTnJBdS9BNENYSkRVVllkWlptRDhWRFdXeUhnQmZ1MHN4Q0ZyQ0JQSDNLcGNSMVI3a2N4UEdRWkV6MUNPNkFrMjlEYzF2bG1IU1J3WHVwdXJYdVJvc0RCc3hDK3J2cElTM0NNbk1xMUU1bWlvTWF2YjdvU2ZHcU56QzByMUdONm4zWWt4SmpiS0NoQmJpOUJPWEx4TVB6QVRESTVwR2toYmdnYnNHTWlodVZ1YzJJSmtQZlFhL0NlMjBhbUJyS0ZpbzRmRXJhd2FjNE95blFHZHFXeGFGZlZHWGxWWFRNODc3SGxldFA2V04xdWhySDU5R1RYM3loL24rTWh3TjNMMzY4a2U2T3JycHhlQlJXNnAyeU40QitsNUwxZjNhVDB5SHpiSnFyclVFTkZlS2I2dTFHaFFvb3Z2VlBHQ1pGWkNrb1RiNXRYb3Z0SkpzNEhsdEFxSDIzRExicitLcS9rT3dJQjFmRlRsQTZxVXQ1dldxSVVOVjhwemp2OUdqUUtNdjA1T1hjYW9obmtsNzhGOHRSbE9YVmdpdXhsYmhkUEZ4aC9PcnQ5MURKcS9WUUMxV1dmSmpSWU43UzdWemNaQ2ozN2w4OU5ja3NkOCtuWVIwcFYrRUJkT1cyekZrcStyaGphcHRDaEIxRmtnZTJuMDhhUHFreTJQRW1ENEtGNExmc3NESWcwU291R1RpR3RjaTJsY3J5WkI1ZlNqMldSbDVQVHhRSkxMK3RTaHBlMk9RNnkzRXIrTTA0SEdwK1BuN0QwOUxMbnhVTE56QVhScDNvVmlpNVkveUZ5L0VSa3M3U1ovbFBhZzJlOVBtWkp0U1NsTEVPek1zTDNOcFVjdmZuWUNrU1U2UDEyR1labDhtMEJQVmJHOXFoamRkV3M1Vy9EUlZ2U2lZTEl6aXRKL2dxYS92dHZ2NDZncGNjcEphSGVnTlNGVVk3TUd3czE1ZmZOVE0zQmJXbHpsdlFvb1VTY1JaSFVYbDZOWTYvdWh4cVRJblNtSVcvZUJPbm9uLzhDSXBSSE8vYWpjc0VBQUFHRWFVTkRVRWxEUXlCd2NtOW1hV3hsQUFCNG5IMlJQVWpEUUJ6RlgxdWxvbFVITTRnSVpxaE9Ga1JGSEtXS1JiQlEyZ3F0T3BoYytnVk5HcElVRjBmQnRlRGd4MkxWd2NWWlZ3ZFhRUkQ4QUhGMmNGSjBrUkwvbHhSYXhIaHczSTkzOXg1Mzd3Qi92Y3hVczJNQ1VEWExTTWFpWWlhN0tnWmZFY0FJQlBTZ1QyS21Iazh0cHVFNXZ1N2g0K3RkaEdkNW4vdHo5Q281a3dFK2tYaU82WVpGdkVFOHMybnBuUGVKQlZhVUZPSno0bkdETGtqOHlIWFo1VGZPQllmOVBGTXcwc2w1WW9GWUxMU3gzTWFzYUtqRTA4UmhSZFVvMzU5eFdlRzh4Vmt0VjFuem52eUZvWnkya3VJNnpXSEVzSVE0RWhBaG80b1N5ckFRb1ZVanhVU1M5cU1lL2lISG55Q1hUSzRTR0RrV1VJRUt5ZkdELzhIdmJzMzgxS1NiRklvQ25TKzIvVEVLQkhlQlJzMjJ2NDl0dTNFQ0JKNkJLNjNscjlTQjJVL1NheTB0ZkFUMGJ3TVgxeTFOM2dNdWQ0REJKMTB5SkVjSzBQVG44OEQ3R1gxVEZoaTRCYnJYM042YSt6aDlBTkxVMWZJTmNIQUlqQlVvZTkzajNWM3R2ZjE3cHRuZkQxb1hjcDMvRDEwVUFBQU45MmxVV0hSWVRVdzZZMjl0TG1Ga2IySmxMbmh0Y0FBQUFBQUFQRDk0Y0dGamEyVjBJR0psWjJsdVBTTHZ1NzhpSUdsa1BTSlhOVTB3VFhCRFpXaHBTSHB5WlZONlRsUmplbXRqT1dRaVB6NEtQSGc2ZUcxd2JXVjBZU0I0Yld4dWN6cDRQU0poWkc5aVpUcHVjenB0WlhSaEx5SWdlRHA0YlhCMGF6MGlXRTFRSUVOdmNtVWdOQzQwTGpBdFJYaHBkaklpUGdvZ1BISmtaanBTUkVZZ2VHMXNibk02Y21SbVBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHhPVGs1THpBeUx6SXlMWEprWmkxemVXNTBZWGd0Ym5NaklqNEtJQ0E4Y21SbU9rUmxjMk55YVhCMGFXOXVJSEprWmpwaFltOTFkRDBpSWdvZ0lDQWdlRzFzYm5NNmVHMXdUVTA5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM5dGJTOGlDaUFnSUNCNGJXeHVjenB6ZEVWMmREMGlhSFIwY0RvdkwyNXpMbUZrYjJKbExtTnZiUzk0WVhBdk1TNHdMM05VZVhCbEwxSmxjMjkxY21ObFJYWmxiblFqSWdvZ0lDQWdlRzFzYm5NNlpHTTlJbWgwZEhBNkx5OXdkWEpzTG05eVp5OWtZeTlsYkdWdFpXNTBjeTh4TGpFdklnb2dJQ0FnZUcxc2JuTTZSMGxOVUQwaWFIUjBjRG92TDNkM2R5NW5hVzF3TG05eVp5OTRiWEF2SWdvZ0lDQWdlRzFzYm5NNmRHbG1aajBpYUhSMGNEb3ZMMjV6TG1Ga2IySmxMbU52YlM5MGFXWm1MekV1TUM4aUNpQWdJQ0I0Yld4dWN6cDRiWEE5SW1oMGRIQTZMeTl1Y3k1aFpHOWlaUzVqYjIwdmVHRndMekV1TUM4aUNpQWdJSGh0Y0UxTk9rUnZZM1Z0Wlc1MFNVUTlJbWRwYlhBNlpHOWphV1E2WjJsdGNEb3pZbVF6TUdFNE15MDFNemxsTFRRNE16WXRPRE0zTkMwMk5ESmpabVl3WWpNd1lURWlDaUFnSUhodGNFMU5Pa2x1YzNSaGJtTmxTVVE5SW5odGNDNXBhV1E2WkRZeU1EUTFNVEV0WkRoaFpTMDBaV0V6TFRrNE4yUXRPRGN3Wm1JM09EUmxNMlptSWdvZ0lDQjRiWEJOVFRwUGNtbG5hVzVoYkVSdlkzVnRaVzUwU1VROUluaHRjQzVrYVdRNlpXTm1OMlZrWkdVdFkySXlZeTAwTWpZMUxXRXhOVFV0T1RCbE5XSm1PVGsyTUdJeElnb2dJQ0JrWXpwR2IzSnRZWFE5SW1sdFlXZGxMM0J1WnlJS0lDQWdSMGxOVURwQlVFazlJakl1TUNJS0lDQWdSMGxOVURwUWJHRjBabTl5YlQwaVYybHVaRzkzY3lJS0lDQWdSMGxOVURwVWFXMWxVM1JoYlhBOUlqRTNNVEU1TVRVNU1UQTNOVGMzTmpBaUNpQWdJRWRKVFZBNlZtVnljMmx2YmowaU1pNHhNQzR5TkNJS0lDQWdkR2xtWmpwUGNtbGxiblJoZEdsdmJqMGlNU0lLSUNBZ2VHMXdPa055WldGMGIzSlViMjlzUFNKSFNVMVFJREl1TVRBaVBnb2dJQ0E4ZUcxd1RVMDZTR2x6ZEc5eWVUNEtJQ0FnSUR4eVpHWTZVMlZ4UGdvZ0lDQWdJRHh5WkdZNmJHa0tJQ0FnSUNBZ2MzUkZkblE2WVdOMGFXOXVQU0p6WVhabFpDSUtJQ0FnSUNBZ2MzUkZkblE2WTJoaGJtZGxaRDBpTHlJS0lDQWdJQ0FnYzNSRmRuUTZhVzV6ZEdGdVkyVkpSRDBpZUcxd0xtbHBaRHBpWTJNM01EZ3hOaTFqWWpJekxUUXhOREl0WWpnMFl5MWxOV016T0RoaU9HTTNPRElpQ2lBZ0lDQWdJSE4wUlhaME9uTnZablIzWVhKbFFXZGxiblE5SWtkcGJYQWdNaTR4TUNBb1YybHVaRzkzY3lraUNpQWdJQ0FnSUhOMFJYWjBPbmRvWlc0OUlqSXdNalF0TURNdE1qWlVNVEE2TVRrNk16WWlMejRLSUNBZ0lDQThjbVJtT214cENpQWdJQ0FnSUhOMFJYWjBPbUZqZEdsdmJqMGljMkYyWldRaUNpQWdJQ0FnSUhOMFJYWjBPbU5vWVc1blpXUTlJaThpQ2lBZ0lDQWdJSE4wUlhaME9tbHVjM1JoYm1ObFNVUTlJbmh0Y0M1cGFXUTZaVGhqTkdKalpqRXRZbVE0TmkwMFlqVmtMVGc1TXprdE9HSm1OekJsWTJNeVpHWmtJZ29nSUNBZ0lDQnpkRVYyZERwemIyWjBkMkZ5WlVGblpXNTBQU0pIYVcxd0lESXVNVEFnS0ZkcGJtUnZkM01wSWdvZ0lDQWdJQ0J6ZEVWMmREcDNhR1Z1UFNJeU1ESTBMVEF6TFRNeFZESXlPakV4T2pVd0lpOCtDaUFnSUNBOEwzSmtaanBUWlhFK0NpQWdJRHd2ZUcxd1RVMDZTR2x6ZEc5eWVUNEtJQ0E4TDNKa1pqcEVaWE5qY21sd2RHbHZiajRLSUR3dmNtUm1PbEpFUmo0S1BDOTRPbmh0Y0cxbGRHRStDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0NpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQUtJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQW9nSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnQ2lBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBb2dJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdDaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FLSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUFvZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBS1BEOTRjR0ZqYTJWMElHVnVaRDBpZHlJL1BsRTZGdWNBQUFBR1lrdEhSQUQvQVA4QS82QzlwNU1BQUFBSmNFaFpjd0FBQ3hNQUFBc1RBUUNhbkJnQUFBQUhkRWxOUlFmb0F4OFVDekpKRlkyeEFBQUZKVWxFUVZSWXczV1cwWmJiTmd4RUwwaVFsSnltelMvMS81LzZKVTE2ZG1OYkVvaytFS0pwTlpVUGpyUmFTVE1ZREFFS2YvNWxoQUJOd0F4MmcrT0F4d1lmVC9oNHdJOEhQQjdBSGRpQkF6QkFQQ0lRUElSK05IL3VBSjRlZHo4Ly9MeWpJQjFjeEw5cC9kMUdKM1FZSE9lTk9uM1VIRWo4L3BXQVRjK2Y3OXBFdkQrdnRQTWRnMlpRRFZycm9IdUR2VUtyVSthSFg5ZUpRTGpFU2FCZFNGeFZheWkxTVk1bVVCMTRxeDRIdEdNaXNFM1g1M0dXSUU0QXN3cnRrbmtjYWloYkJYRVpxZ00vZG5qdS9ieWY0THVEbjFIL0krZnI0OWRTTUlIeVJrUzViNzMrU0svM2RuVHduMXVQdXJsaHRrc1o1cXlhQTNCUllDWm5nRjQ4VVZFKzdpREIxYkplOC9zQlA1K3diOE90cjlvZms2d3ppRTBaaGt0WjVxTk5VVkgrdVROV2dobHNyU3RROTJtNWJCZncyYzFjYXBzODAvTWNMdXJZWk5DRzh2MnpLNEIwRTdZMlpUdUQ3MVBXWE9xdUNJcFFNQkpHY2dKbnhIZWx4S092Z285Zk5KRHFzZjFQNDFHbkVEMHlnVVFnQTVsRzVxQndEQlcwSjZrQk1oQU1vb0UwRkQ2bWV2RW16N3ZoWkJBVmhFZ2dvUlFTU2tMSlRxRFF5R3hrSG1UdUtLWUpiaEhXTUZYbUxBR2ZUaUQrWXVtY1RqK0Jvd01IRmlMRkNmUmZKbEF3TXBYQ1JpYVRDU254OGJ2Q2w1T0FRSHFWUWVIblJDQk1YVXFtV2dzQlFRa3NCRllpSzhveUNHU1VqSkNkUU9aSlFVT0dyNG5uMThqKzIwekF5OUFKUEZ5VE9KMTVJNlZFQ3BHVnlHMENYMGhEZ1VnYUJBNEttVXhjRSsxTDR2RmI1UHRKSURzQjRTekJmbGxXTXNBakVVVlpTYXdvTnlJM3YxNDg4a1FBRXRYTkY4blltdGhYWlYyVTcrdUZRRGhiOFd2MGpiVWFITHlRV1VuY1BQcTFUdkozK3ltSmdBS1pTbUlqRVRUUlNtSXJpYVVvTVVkcUZpamlRbzhTeUhCNFgxSktSbG5KSTI3a1FXQnhSUXFSakpKY0pTSFJTRlMwcTZHSlBTV0tLamtwU3c1OHBta1ZSSU5nNkFuY1A2T2U5Um1GbGNMTmxUZ0pkUGRIc3I4VlVJUklROW45dXNaSURwRVVJemtHbGhENGpHSHEwRTVBdlY1bEFsd3BMQlJ1TElQTU1vRXZJL01lNHA1cDNwaU1TSlpBRWlFaEpCSEtPZkNRMS9URjBCdUZRbVpoZlNPd3NqaVJFenk1NlhSa3JnUUNBU0ZnUktxMzVvcXdOeUdhb0FiYUlMZSs5TTE4eDRXQmdYNWpwZml2WjdzTUJUcDQ5dVYyZ3F0WHVUdEdITlFJN0lReG1PTnV4R3JFQ2xxTlhJM2xNTzdSdDNyQlo4RlhWcGY0SkZFR3BRNmNCM2h5NlUvd01MWG5PdTBLQWtZNGpMZ2JlalR5THBUZCtEMDI3c0tZQTJEb0g2eGtNbWNwQ291YkxaTkhqNXZCZTk0UjhleGZYYVQzVCt1YW1CRWZEWDBLYVJPV0ozd1ZlSnJ3UGZxOE1WZWd1TlJsK0VFSGVCcXk5NDRZdlMySEFTNVR3Mjd1aXRhSDlJZWdONkZrV0tOeG1OQU95Tkg0cFBGc0RmM0M0cG4zcFphbWVxZmg5ck0xNGVBeWpTMGJzN0xQeVRhMklIR0QvQUZGalJ1R1ZTRW9yTUg0Um1Veko1RGQ1YStzKzZUcndQSTJLMCtacjRkZ1hoUWgwTWJlS1ArQUtvWTFJK3hDVnRoaVk3ZEdiUTN0RGpoN2VsOWl5Y2Z1dWNoa1ZGcG9ORGZmKzhBMmYrYjBSMi9NZlp0cGZ4dXlOZlNMVUNMczBhZzBqdHJRTWttZDNlRTk4OWR3Rm9jeTN4dTBhVzdZUkthWHdGeXBoZ0lGUXdqb3AxQit3aVp3T0lIV0dxb09xR05GOTQvMHJCck5CWmVoUkhQN3llUUU4VGU3QW1uU3A0KzJ4bzV3R0dTRG83Vk9nSWFHVVRmeG5ZQjVEalpsK2xKQ0VLcUR5eUFodzRxOUZSdnFOTHNmK3BiMWNCMFA3RVhnWlNNYnZ6YTIza3dVekFGT2xjSTR5OWhQQnFCNkFadi83K1dMNkFUVUNWUXFlaTZrNWdhekliajUzL2k5VjUyamIwcTdVYzNySHQ3MmtyMVBOQlR4SFlmNUhieFBkTVIvQWYyU1FJTk5nUlROQUFBQUFFbEZUa1N1UW1DQyl9fUBsYXllciBiYXNleyosOmFmdGVyLDpiZWZvcmUsOjpiYWNrZHJvcHtib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym9yZGVyOjAgc29saWQ7bWFyZ2luOjA7cGFkZGluZzowfTo6ZmlsZS1zZWxlY3Rvci1idXR0b257Ym94LXNpemluZzpib3JkZXItYm94O2JvcmRlcjowIHNvbGlkO21hcmdpbjowO3BhZGRpbmc6MH1odG1sLDpob3N0ey13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlOy1tb3otdGFiLXNpemU6NDstby10YWItc2l6ZTo0O3RhYi1zaXplOjQ7bGluZS1oZWlnaHQ6MS41O2ZvbnQtZmFtaWx5OnZhcigtLWRlZmF1bHQtZm9udC1mYW1pbHksdWktc2Fucy1zZXJpZixzeXN0ZW0tdWksc2Fucy1zZXJpZixcIkFwcGxlIENvbG9yIEVtb2ppXCIsXCJTZWdvZSBVSSBFbW9qaVwiLFwiU2Vnb2UgVUkgU3ltYm9sXCIsXCJOb3RvIENvbG9yIEVtb2ppXCIpO2ZvbnQtZmVhdHVyZS1zZXR0aW5nczp2YXIoLS1kZWZhdWx0LWZvbnQtZmVhdHVyZS1zZXR0aW5ncyxub3JtYWwpO2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOnZhcigtLWRlZmF1bHQtZm9udC12YXJpYXRpb24tc2V0dGluZ3Msbm9ybWFsKTstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6dHJhbnNwYXJlbnR9aHJ7aGVpZ2h0OjA7Y29sb3I6aW5oZXJpdDtib3JkZXItdG9wLXdpZHRoOjFweH1hYmJyOndoZXJlKFt0aXRsZV0pey13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZSBkb3R0ZWQ7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZSBkb3R0ZWR9aDEsaDIsaDMsaDQsaDUsaDZ7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdH1he2NvbG9yOmluaGVyaXQ7LXdlYmtpdC10ZXh0LWRlY29yYXRpb246aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246aW5oZXJpdH1iLHN0cm9uZ3tmb250LXdlaWdodDpib2xkZXJ9Y29kZSxrYmQsc2FtcCxwcmV7Zm9udC1mYW1pbHk6dmFyKC0tZGVmYXVsdC1tb25vLWZvbnQtZmFtaWx5LHVpLW1vbm9zcGFjZSxTRk1vbm8tUmVndWxhcixNZW5sbyxNb25hY28sQ29uc29sYXMsXCJMaWJlcmF0aW9uIE1vbm9cIixcIkNvdXJpZXIgTmV3XCIsbW9ub3NwYWNlKTtmb250LWZlYXR1cmUtc2V0dGluZ3M6dmFyKC0tZGVmYXVsdC1tb25vLWZvbnQtZmVhdHVyZS1zZXR0aW5ncyxub3JtYWwpO2ZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOnZhcigtLWRlZmF1bHQtbW9uby1mb250LXZhcmlhdGlvbi1zZXR0aW5ncyxub3JtYWwpO2ZvbnQtc2l6ZToxZW19c21hbGx7Zm9udC1zaXplOjgwJX1zdWIsc3Vwe3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO2ZvbnQtc2l6ZTo3NSU7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjpyZWxhdGl2ZX1zdWJ7Ym90dG9tOi0uMjVlbX1zdXB7dG9wOi0uNWVtfXRhYmxle3RleHQtaW5kZW50OjA7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlfTotbW96LWZvY3VzcmluZ3tvdXRsaW5lOmF1dG99cHJvZ3Jlc3N7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9c3VtbWFyeXtkaXNwbGF5Omxpc3QtaXRlbX1vbCx1bCxtZW51e2xpc3Qtc3R5bGU6bm9uZX1pbWcsc3ZnLHZpZGVvLGNhbnZhcyxhdWRpbyxpZnJhbWUsZW1iZWQsb2JqZWN0e3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtkaXNwbGF5OmJsb2NrfWltZyx2aWRlb3ttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6YXV0b31idXR0b24saW5wdXQsc2VsZWN0LG9wdGdyb3VwLHRleHRhcmVhe2ZvbnQ6aW5oZXJpdDtmb250LWZlYXR1cmUtc2V0dGluZ3M6aW5oZXJpdDtmb250LXZhcmlhdGlvbi1zZXR0aW5nczppbmhlcml0O2xldHRlci1zcGFjaW5nOmluaGVyaXQ7Y29sb3I6aW5oZXJpdDtvcGFjaXR5OjE7YmFja2dyb3VuZC1jb2xvcjojMDAwMDtib3JkZXItcmFkaXVzOjB9OjpmaWxlLXNlbGVjdG9yLWJ1dHRvbntmb250OmluaGVyaXQ7Zm9udC1mZWF0dXJlLXNldHRpbmdzOmluaGVyaXQ7Zm9udC12YXJpYXRpb24tc2V0dGluZ3M6aW5oZXJpdDtsZXR0ZXItc3BhY2luZzppbmhlcml0O2NvbG9yOmluaGVyaXQ7b3BhY2l0eToxO2JhY2tncm91bmQtY29sb3I6IzAwMDA7Ym9yZGVyLXJhZGl1czowfTp3aGVyZShzZWxlY3Q6aXMoW211bHRpcGxlXSxbc2l6ZV0pKSBvcHRncm91cHtmb250LXdlaWdodDpib2xkZXJ9OndoZXJlKHNlbGVjdDppcyhbbXVsdGlwbGVdLFtzaXplXSkpIG9wdGdyb3VwIG9wdGlvbntwYWRkaW5nLWlubGluZS1zdGFydDoyMHB4fTo6ZmlsZS1zZWxlY3Rvci1idXR0b257bWFyZ2luLWlubGluZS1lbmQ6NHB4fTo6LW1vei1wbGFjZWhvbGRlcntvcGFjaXR5OjF9OjpwbGFjZWhvbGRlcntvcGFjaXR5OjF9QHN1cHBvcnRzIChub3QgKC13ZWJraXQtYXBwZWFyYW5jZTotYXBwbGUtcGF5LWJ1dHRvbikpIG9yIChjb250YWluLWludHJpbnNpYy1zaXplOjFweCl7OjotbW96LXBsYWNlaG9sZGVye2NvbG9yOmN1cnJlbnRDb2xvcn06OnBsYWNlaG9sZGVye2NvbG9yOmN1cnJlbnRDb2xvcn1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpezo6LW1vei1wbGFjZWhvbGRlcntjb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsY3VycmVudGNvbG9yIDUwJSx0cmFuc3BhcmVudCl9OjpwbGFjZWhvbGRlcntjb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsY3VycmVudGNvbG9yIDUwJSx0cmFuc3BhcmVudCl9fX10ZXh0YXJlYXtyZXNpemU6dmVydGljYWx9Ojotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfTo6LXdlYmtpdC1kYXRlLWFuZC10aW1lLXZhbHVle21pbi1oZWlnaHQ6MWxoO3RleHQtYWxpZ246aW5oZXJpdH06Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdHtkaXNwbGF5OmlubGluZS1mbGV4fTo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWZpZWxkcy13cmFwcGVye3BhZGRpbmc6MH06Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdHtwYWRkaW5nLWJsb2NrOjB9Ojotd2Via2l0LWRhdGV0aW1lLWVkaXQteWVhci1maWVsZHtwYWRkaW5nLWJsb2NrOjB9Ojotd2Via2l0LWRhdGV0aW1lLWVkaXQtbW9udGgtZmllbGR7cGFkZGluZy1ibG9jazowfTo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWRheS1maWVsZHtwYWRkaW5nLWJsb2NrOjB9Ojotd2Via2l0LWRhdGV0aW1lLWVkaXQtaG91ci1maWVsZHtwYWRkaW5nLWJsb2NrOjB9Ojotd2Via2l0LWRhdGV0aW1lLWVkaXQtbWludXRlLWZpZWxke3BhZGRpbmctYmxvY2s6MH06Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1zZWNvbmQtZmllbGR7cGFkZGluZy1ibG9jazowfTo6LXdlYmtpdC1kYXRldGltZS1lZGl0LW1pbGxpc2Vjb25kLWZpZWxke3BhZGRpbmctYmxvY2s6MH06Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1tZXJpZGllbS1maWVsZHtwYWRkaW5nLWJsb2NrOjB9Oi1tb3otdWktaW52YWxpZHtib3gtc2hhZG93Om5vbmV9YnV0dG9uLGlucHV0OndoZXJlKFt0eXBlPWJ1dHRvbl0sW3R5cGU9cmVzZXRdLFt0eXBlPXN1Ym1pdF0pey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247LW1vei1hcHBlYXJhbmNlOmJ1dHRvbjthcHBlYXJhbmNlOmJ1dHRvbn06OmZpbGUtc2VsZWN0b3ItYnV0dG9uey13ZWJraXQtYXBwZWFyYW5jZTpidXR0b247LW1vei1hcHBlYXJhbmNlOmJ1dHRvbjthcHBlYXJhbmNlOmJ1dHRvbn06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9ue2hlaWdodDphdXRvfVtoaWRkZW5dOndoZXJlKDpub3QoW2hpZGRlbj11bnRpbC1mb3VuZF0pKXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fSp7bWluLXdpZHRoOjA7bWluLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlfWJvZHl7YWxsOmluaXRpYWw7Y29sb3I6dmFyKC0tY29sb3ItemluYy05NTApO2xldHRlci1zcGFjaW5nOm5vcm1hbCFpbXBvcnRhbnQ7Zm9udC1mYW1pbHk6SW50ZXIsTm90byBDb2xvciBFbW9qaSwtYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxTZWdvZSBVSSxSb2JvdG8sU0YgQ29tcGFjdCxTRiBQcm8sSGVsdmV0aWNhIE5ldWUsc2Fucy1zZXJpZiFpbXBvcnRhbnQ7Zm9udC13ZWlnaHQ6NDAwIWltcG9ydGFudDtsaW5lLWhlaWdodDpub3JtYWwhaW1wb3J0YW50fUBzdXBwb3J0cyAoZm9udC12YXJpYXRpb24tc2V0dGluZ3M6bm9ybWFsKXtib2R5e2ZvbnQtb3B0aWNhbC1zaXppbmc6YXV0byFpbXBvcnRhbnQ7Zm9udC1mYW1pbHk6SW50ZXJWYXJpYWJsZSxOb3RvIENvbG9yIEVtb2ppLC1hcHBsZS1zeXN0ZW0sQmxpbmtNYWNTeXN0ZW1Gb250LFNlZ29lIFVJLFJvYm90byxTRiBDb21wYWN0LFNGIFBybyxIZWx2ZXRpY2EgTmV1ZSxzYW5zLXNlcmlmIWltcG9ydGFudH19KntzY3JvbGxiYXItY29sb3I6aW5pdGlhbDtzY3JvbGxiYXItd2lkdGg6aW5pdGlhbH19QGxheWVyIGNvbXBvbmVudHN7LmNoYXQtbG9hZGluZy1ncmFkaWVudHtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgjZjhmYWZjY2MsI2Y4ZmFmY2NjKSBwYWRkaW5nLWJveCBwYWRkaW5nLWJveCxsaW5lYXItZ3JhZGllbnQoNDVkZWcsIzhiNWNmNiwjMDZiNmQ0LCM4YjVjZjYpIDAgMC80MDAlIDQwMCUgYm9yZGVyLWJveDtib3JkZXI6MnB4IHNvbGlkICMwMDAwO2FuaW1hdGlvbjoycyBpbmZpbml0ZSBncmFkaWVudC1hbmltYXRpb259LmNoYXQtc3VjY2Vzcy1ib3JkZXJ7YW5pbWF0aW9uOjJzIGVhc2Utb3V0IGJsaW5rLWdyZWVuLWZhZGV9LmNoYXQtZXJyb3ItYm9yZGVye2FuaW1hdGlvbjoxcyBlYXNlLW91dCBibGluay1yZWQtZmFkZX1Aa2V5ZnJhbWVzIGJsaW5rLWdyZWVuLWZhZGV7MCUsNTAle2JveC1zaGFkb3c6MCAwIDAgMnB4ICMyMmM1NWViM310b3tib3gtc2hhZG93OjAgMCAwIDJweCAjMjJjNTVlMDB9fUBrZXlmcmFtZXMgYmxpbmstcmVkLWZhZGV7MCUsNTAle2JveC1zaGFkb3c6MCAwIDAgMnB4ICNlZjQ0NDR9dG97Ym94LXNoYWRvdzowIDAgMCAycHggI2VmNDQ0NDAwfX1AcHJvcGVydHkgLS1jaGF0LWdyYWQtYmctYmctY29sb3J7c3ludGF4OiBcIjxjb2xvcj5cIjsgaW5oZXJpdHM6IHRydWU7IGluaXRpYWwtdmFsdWU6ICMwZDI1M2Y7fUBwcm9wZXJ0eSAtLWNoYXQtZ3JhZC1iZy1jMXtzeW50YXg6IFwiPGNvbG9yPlwiOyBpbmhlcml0czogdHJ1ZTsgaW5pdGlhbC12YWx1ZTogIzFlNDBhZjt9QHByb3BlcnR5IC0tY2hhdC1ncmFkLWJnLWMye3N5bnRheDogXCI8Y29sb3I+XCI7IGluaGVyaXRzOiB0cnVlOyBpbml0aWFsLXZhbHVlOiAjMjU2M2ViO31AcHJvcGVydHkgLS1jaGF0LWdyYWQtYmctYzN7c3ludGF4OiBcIjxjb2xvcj5cIjsgaW5oZXJpdHM6IHRydWU7IGluaXRpYWwtdmFsdWU6ICMzYjgyZjY7fUBwcm9wZXJ0eSAtLWNoYXQtZ3JhZC1iZy1jNHtzeW50YXg6IFwiPGNvbG9yPlwiOyBpbmhlcml0czogdHJ1ZTsgaW5pdGlhbC12YWx1ZTogIzYwYTVmYTt9QHByb3BlcnR5IC0tY2hhdC1ncmFkLWJnLW9wYWNpdHktc2xvd3tzeW50YXg6IFwiPG51bWJlcj5cIjsgaW5oZXJpdHM6IHRydWU7IGluaXRpYWwtdmFsdWU6IDE7fUBwcm9wZXJ0eSAtLWNoYXQtZ3JhZC1iZy1vcGFjaXR5LW1lZGl1bXtzeW50YXg6IFwiPG51bWJlcj5cIjsgaW5oZXJpdHM6IHRydWU7IGluaXRpYWwtdmFsdWU6IDA7fUBwcm9wZXJ0eSAtLWNoYXQtZ3JhZC1iZy1vcGFjaXR5LWZhc3R7c3ludGF4OiBcIjxudW1iZXI+XCI7IGluaGVyaXRzOiB0cnVlOyBpbml0aWFsLXZhbHVlOiAwO31AcHJvcGVydHkgLS1jaGF0LWdyYWQtYmctb3ZlcmFsbC1vcGFjaXR5e3N5bnRheDogXCI8bnVtYmVyPlwiOyBpbmhlcml0czogdHJ1ZTsgaW5pdGlhbC12YWx1ZTogMTt9QGtleWZyYW1lcyBjaGF0LWdyYWQtYmctbW92ZXswJXt0cmFuc2Zvcm06dHJhbnNsYXRlKDApfTIwJXt0cmFuc2Zvcm06dHJhbnNsYXRlKDE1dncsLTEwdmgpc2NhbGUoMS4xKX00MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtMTB2dywxNXZoKXNjYWxlKC45KX02MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZSgxMHZ3LDEwdmgpc2NhbGUoMS4yKX04MCV7dHJhbnNmb3JtOnRyYW5zbGF0ZSg1dncsLTE1dmgpc2NhbGUoMSl9dG97dHJhbnNmb3JtOnRyYW5zbGF0ZSgwKX19LnNoYXBlLWFuaW17dHJhbnNpdGlvbjpmaWxsIDFzIGVhc2UtaW4tb3V0O2FuaW1hdGlvbi1uYW1lOmNoYXQtZ3JhZC1iZy1tb3ZlO2FuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbi1vdXQ7YW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudDppbmZpbml0ZX0uZy1zbG93e29wYWNpdHk6dmFyKC0tY2hhdC1ncmFkLWJnLW9wYWNpdHktc2xvdyk7dHJhbnNpdGlvbjpvcGFjaXR5IDFzIGVhc2UtaW4tb3V0fS5nLW1lZGl1bXtvcGFjaXR5OnZhcigtLWNoYXQtZ3JhZC1iZy1vcGFjaXR5LW1lZGl1bSk7dHJhbnNpdGlvbjpvcGFjaXR5IDFzIGVhc2UtaW4tb3V0fS5nLWZhc3R7b3BhY2l0eTp2YXIoLS1jaGF0LWdyYWQtYmctb3BhY2l0eS1mYXN0KTt0cmFuc2l0aW9uOm9wYWNpdHkgMXMgZWFzZS1pbi1vdXR9fUBsYXllciB1dGlsaXRpZXN7LnBvaW50ZXItZXZlbnRzLWF1dG97cG9pbnRlci1ldmVudHM6YXV0b30ucG9pbnRlci1ldmVudHMtbm9uZXtwb2ludGVyLWV2ZW50czpub25lfS52aXNpYmxle3Zpc2liaWxpdHk6dmlzaWJsZX0uYWJzb2x1dGV7cG9zaXRpb246YWJzb2x1dGV9LmZpeGVke3Bvc2l0aW9uOmZpeGVkfS5yZWxhdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZX0uLWluc2V0LVxcXFxcXFxcWzI1XFxcXFxcXFwlXFxcXFxcXFxde3RvcDotMjUlO3JpZ2h0Oi0yNSU7Ym90dG9tOi0yNSU7bGVmdDotMjUlfS5pbnNldC0we2luc2V0OmNhbGModmFyKC0tc3BhY2luZykqMCl9Lmluc2V0LTR7aW5zZXQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSo0KX0udG9wLTB7dG9wOmNhbGModmFyKC0tc3BhY2luZykqMCl9LnRvcC0wXFxcXFxcXFwuNXt0b3A6Y2FsYyh2YXIoLS1zcGFjaW5nKSouNSl9LnRvcC1cXFxcXFxcXFsyNVxcXFxcXFxcJVxcXFxcXFxcXXt0b3A6MjUlfS5yaWdodC0we3JpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMCl9LnJpZ2h0LTEye3JpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMTIpfS5ib3R0b20tMHtib3R0b206Y2FsYyh2YXIoLS1zcGFjaW5nKSowKX0uYm90dG9tLTN7Ym90dG9tOmNhbGModmFyKC0tc3BhY2luZykqMyl9LmxlZnQtMHtsZWZ0OmNhbGModmFyKC0tc3BhY2luZykqMCl9LmxlZnQtMFxcXFxcXFxcLjV7bGVmdDpjYWxjKHZhcigtLXNwYWNpbmcpKi41KX0ubGVmdC0ze2xlZnQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSozKX0ubGVmdC0xMntsZWZ0OmNhbGModmFyKC0tc3BhY2luZykqMTIpfS5sZWZ0LVxcXFxcXFxcWzI1XFxcXFxcXFwlXFxcXFxcXFxde2xlZnQ6MjUlfS4tei0xMHt6LWluZGV4Oi0xMH0uei0we3otaW5kZXg6MH0uei0xMHt6LWluZGV4OjEwfS56LTUwe3otaW5kZXg6NTB9LmNvbnRhaW5lcnt3aWR0aDoxMDAlfUBtZWRpYSAobWluLXdpZHRoOjQwcmVtKXsuY29udGFpbmVye21heC13aWR0aDo0MHJlbX19QG1lZGlhIChtaW4td2lkdGg6NDhyZW0pey5jb250YWluZXJ7bWF4LXdpZHRoOjQ4cmVtfX1AbWVkaWEgKG1pbi13aWR0aDo2NHJlbSl7LmNvbnRhaW5lcnttYXgtd2lkdGg6NjRyZW19fUBtZWRpYSAobWluLXdpZHRoOjgwcmVtKXsuY29udGFpbmVye21heC13aWR0aDo4MHJlbX19QG1lZGlhIChtaW4td2lkdGg6OTZyZW0pey5jb250YWluZXJ7bWF4LXdpZHRoOjk2cmVtfX0ubS0xe21hcmdpbjpjYWxjKHZhcigtLXNwYWNpbmcpKjEpfS5tdC0we21hcmdpbi10b3A6Y2FsYyh2YXIoLS1zcGFjaW5nKSowKX0ubXQtMnttYXJnaW4tdG9wOmNhbGModmFyKC0tc3BhY2luZykqMil9Lm10LTN7bWFyZ2luLXRvcDpjYWxjKHZhcigtLXNwYWNpbmcpKjMpfS5tci0ye21hcmdpbi1yaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjIpfS5tci1weHttYXJnaW4tcmlnaHQ6MXB4fS5tYi0we21hcmdpbi1ib3R0b206Y2FsYyh2YXIoLS1zcGFjaW5nKSowKX0ubWItMVxcXFxcXFxcLjV7bWFyZ2luLWJvdHRvbTpjYWxjKHZhcigtLXNwYWNpbmcpKjEuNSl9Lm1iLTJ7bWFyZ2luLWJvdHRvbTpjYWxjKHZhcigtLXNwYWNpbmcpKjIpfS5tYi0ze21hcmdpbi1ib3R0b206Y2FsYyh2YXIoLS1zcGFjaW5nKSozKX0ubWItcHh7bWFyZ2luLWJvdHRvbToxcHh9Lm1sLTJ7bWFyZ2luLWxlZnQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSoyKX0uc2Nyb2xsYmFyLXRoaW46Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNre2JhY2tncm91bmQtY29sb3I6dmFyKC0tc2Nyb2xsYmFyLXRyYWNrKTtib3JkZXItcmFkaXVzOnZhcigtLXNjcm9sbGJhci10cmFjay1yYWRpdXMpfS5zY3JvbGxiYXItdGhpbjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1zY3JvbGxiYXItdGh1bWIpO2JvcmRlci1yYWRpdXM6dmFyKC0tc2Nyb2xsYmFyLXRodW1iLXJhZGl1cyl9LnNjcm9sbGJhci10aGluOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJ7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1zY3JvbGxiYXItY29ybmVyKTtib3JkZXItcmFkaXVzOnZhcigtLXNjcm9sbGJhci1jb3JuZXItcmFkaXVzKX0uc2Nyb2xsYmFyLXRoaW57c2Nyb2xsYmFyLXdpZHRoOnRoaW47c2Nyb2xsYmFyLWNvbG9yOnZhcigtLXNjcm9sbGJhci10aHVtYixpbml0aWFsKXZhcigtLXNjcm9sbGJhci10cmFjayxpbml0aWFsKX0uc2Nyb2xsYmFyLXRoaW46Oi13ZWJraXQtc2Nyb2xsYmFye3dpZHRoOjhweDtoZWlnaHQ6OHB4O2Rpc3BsYXk6YmxvY2t9LmJsb2Nre2Rpc3BsYXk6YmxvY2t9LmNvbnRlbnRze2Rpc3BsYXk6Y29udGVudHN9LmZsZXh7ZGlzcGxheTpmbGV4fS5oaWRkZW57ZGlzcGxheTpub25lfS5pbmxpbmV7ZGlzcGxheTppbmxpbmV9LmFzcGVjdC1zcXVhcmV7YXNwZWN0LXJhdGlvOjF9LnNpemUtMHt3aWR0aDpjYWxjKHZhcigtLXNwYWNpbmcpKjApO2hlaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjApfS5zaXplLTFcXFxcXFxcXC41e3dpZHRoOmNhbGModmFyKC0tc3BhY2luZykqMS41KTtoZWlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSoxLjUpfS5zaXplLTFcXFxcXFxcXC8ye3dpZHRoOjUwJTtoZWlnaHQ6NTAlfS5zaXplLTJcXFxcXFxcXC8ze3dpZHRoOjY2LjY2NjclO2hlaWdodDo2Ni42NjY3JX0uc2l6ZS0ze3dpZHRoOmNhbGModmFyKC0tc3BhY2luZykqMyk7aGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMyl9LnNpemUtNHt3aWR0aDpjYWxjKHZhcigtLXNwYWNpbmcpKjQpO2hlaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjQpfS5zaXplLTV7d2lkdGg6Y2FsYyh2YXIoLS1zcGFjaW5nKSo1KTtoZWlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSo1KX0uc2l6ZS02e3dpZHRoOmNhbGModmFyKC0tc3BhY2luZykqNik7aGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqNil9LnNpemUtOHt3aWR0aDpjYWxjKHZhcigtLXNwYWNpbmcpKjgpO2hlaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjgpfS5zaXplLTEwe3dpZHRoOmNhbGModmFyKC0tc3BhY2luZykqMTApO2hlaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjEwKX0uc2l6ZS0xMnt3aWR0aDpjYWxjKHZhcigtLXNwYWNpbmcpKjEyKTtoZWlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSoxMil9LnNpemUtYXV0b3t3aWR0aDphdXRvO2hlaWdodDphdXRvfS5zaXplLWZ1bGx7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uXFxcXFxcXFwhaC1cXFxcXFxcXFtjYWxjLXNpemVcXFxcXFxcXChhdXRvXFxcXFxcXFwsc2l6ZVxcXFxcXFxcKVxcXFxcXFxcXXtoZWlnaHQ6Y2FsYy1zaXplKGF1dG8sc2l6ZSkhaW1wb3J0YW50fS5oLTB7aGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMCl9LmgtM3toZWlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSozKX0uaC01e2hlaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjUpfS5oLTh7aGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqOCl9LmgtMTJ7aGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMTIpfS5oLTE2e2hlaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjE2KX0uaC0yNHtoZWlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSoyNCl9LmgtMzZ7aGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMzYpfS5oLVxcXFxcXFxcWzFcXFxcXFxcXC4yZW1cXFxcXFxcXF17aGVpZ2h0OjEuMmVtfS5oLVxcXFxcXFxcWzM1dmhcXFxcXFxcXF17aGVpZ2h0OjM1dmh9LmgtXFxcXFxcXFxbNTBcXFxcXFxcXCVcXFxcXFxcXF17aGVpZ2h0OjUwJX0uaC1cXFxcXFxcXFsxNTBcXFxcXFxcXCVcXFxcXFxcXF17aGVpZ2h0OjE1MCV9LmgtXFxcXFxcXFxbY2FsYy1zaXplXFxcXFxcXFwoYXV0b1xcXFxcXFxcLHNpemVcXFxcXFxcXClcXFxcXFxcXF17aGVpZ2h0OmNhbGMtc2l6ZShhdXRvLHNpemUpfS5oLWF1dG97aGVpZ2h0OmF1dG99LmgtZnVsbHtoZWlnaHQ6MTAwJX0uaC1weHtoZWlnaHQ6MXB4fS5oLXNjcmVlbntoZWlnaHQ6MTAwdmh9Lm1heC1oLVxcXFxcXFxcWzUwdmhcXFxcXFxcXF17bWF4LWhlaWdodDo1MHZofS5tYXgtaC1mdWxse21heC1oZWlnaHQ6MTAwJX0ubWluLWgtMHttaW4taGVpZ2h0OmNhbGModmFyKC0tc3BhY2luZykqMCl9Lm1pbi1oLTQ4e21pbi1oZWlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSo0OCl9Lm1pbi1oLVxcXFxcXFxcWzIwdmhcXFxcXFxcXF17bWluLWhlaWdodDoyMHZofS53LTk2e3dpZHRoOmNhbGModmFyKC0tc3BhY2luZykqOTYpfS53LVxcXFxcXFxcWzUwXFxcXFxcXFwlXFxcXFxcXFxde3dpZHRoOjUwJX0udy1cXFxcXFxcXFsxNTBcXFxcXFxcXCVcXFxcXFxcXF17d2lkdGg6MTUwJX0udy1hdXRve3dpZHRoOmF1dG99LnctZml0e3dpZHRoOi1tb3otZml0LWNvbnRlbnQ7d2lkdGg6Zml0LWNvbnRlbnR9LnctZnVsbHt3aWR0aDoxMDAlfS53LW1heHt3aWR0aDotbW96LW1heC1jb250ZW50O3dpZHRoOm1heC1jb250ZW50fS53LXNjcmVlbnt3aWR0aDoxMDB2d30ubWF4LXctOHttYXgtd2lkdGg6Y2FsYyh2YXIoLS1zcGFjaW5nKSo4KX0ubWF4LXctMjR7bWF4LXdpZHRoOmNhbGModmFyKC0tc3BhY2luZykqMjQpfS5tYXgtdy05MHttYXgtd2lkdGg6Y2FsYyh2YXIoLS1zcGFjaW5nKSo5MCl9Lm1heC13LVxcXFxcXFxcW2NhbGNcXFxcXFxcXCgxMDBcXFxcXFxcXCUtNDhweFxcXFxcXFxcKVxcXFxcXFxcXXttYXgtd2lkdGg6Y2FsYygxMDAlIC0gNDhweCl9Lm1heC13LWZ1bGx7bWF4LXdpZHRoOjEwMCV9Lm1pbi13LTB7bWluLXdpZHRoOmNhbGModmFyKC0tc3BhY2luZykqMCl9Lm1pbi13LTN7bWluLXdpZHRoOmNhbGModmFyKC0tc3BhY2luZykqMyl9Lm1pbi13LTI0e21pbi13aWR0aDpjYWxjKHZhcigtLXNwYWNpbmcpKjI0KX0ubWluLXctNDh7bWluLXdpZHRoOmNhbGModmFyKC0tc3BhY2luZykqNDgpfS5taW4tdy1maXR7bWluLXdpZHRoOi1tb3otZml0LWNvbnRlbnQ7bWluLXdpZHRoOmZpdC1jb250ZW50fS5mbGV4LTF7ZmxleDoxfS5zaHJpbmstMHtmbGV4LXNocmluazowfS5iYXNpcy1cXFxcXFxcXFtpbml0aWFsXFxcXFxcXFxde2ZsZXgtYmFzaXM6aW5pdGlhbH0ub3JpZ2luLWJvdHRvbXt0cmFuc2Zvcm0tb3JpZ2luOmJvdHRvbX0ub3JpZ2luLWNlbnRlcnt0cmFuc2Zvcm0tb3JpZ2luOjUwJX0ub3JpZ2luLWxlZnR7dHJhbnNmb3JtLW9yaWdpbjowfS5vcmlnaW4tcmlnaHR7dHJhbnNmb3JtLW9yaWdpbjoxMDAlfS5vcmlnaW4tdG9we3RyYW5zZm9ybS1vcmlnaW46dG9wfS4tdHJhbnNsYXRlLXktMnstLXR3LXRyYW5zbGF0ZS15OmNhbGModmFyKC0tc3BhY2luZykqLTIpO3RyYW5zbGF0ZTp2YXIoLS10dy10cmFuc2xhdGUteCl2YXIoLS10dy10cmFuc2xhdGUteSl9LnRyYW5zbGF0ZS15LTB7LS10dy10cmFuc2xhdGUteTpjYWxjKHZhcigtLXNwYWNpbmcpKjApO3RyYW5zbGF0ZTp2YXIoLS10dy10cmFuc2xhdGUteCl2YXIoLS10dy10cmFuc2xhdGUteSl9LnRyYW5zbGF0ZS15LTJ7LS10dy10cmFuc2xhdGUteTpjYWxjKHZhcigtLXNwYWNpbmcpKjIpO3RyYW5zbGF0ZTp2YXIoLS10dy10cmFuc2xhdGUteCl2YXIoLS10dy10cmFuc2xhdGUteSl9LnNjYWxlLTB7LS10dy1zY2FsZS14OjAlOy0tdHctc2NhbGUteTowJTstLXR3LXNjYWxlLXo6MCU7c2NhbGU6dmFyKC0tdHctc2NhbGUteCl2YXIoLS10dy1zY2FsZS15KX0uc2NhbGUtMjV7LS10dy1zY2FsZS14OjI1JTstLXR3LXNjYWxlLXk6MjUlOy0tdHctc2NhbGUtejoyNSU7c2NhbGU6dmFyKC0tdHctc2NhbGUteCl2YXIoLS10dy1zY2FsZS15KX0uc2NhbGUtNTB7LS10dy1zY2FsZS14OjUwJTstLXR3LXNjYWxlLXk6NTAlOy0tdHctc2NhbGUtejo1MCU7c2NhbGU6dmFyKC0tdHctc2NhbGUteCl2YXIoLS10dy1zY2FsZS15KX0uc2NhbGUtOTV7LS10dy1zY2FsZS14Ojk1JTstLXR3LXNjYWxlLXk6OTUlOy0tdHctc2NhbGUtejo5NSU7c2NhbGU6dmFyKC0tdHctc2NhbGUteCl2YXIoLS10dy1zY2FsZS15KX0uc2NhbGUtMTAwey0tdHctc2NhbGUteDoxMDAlOy0tdHctc2NhbGUteToxMDAlOy0tdHctc2NhbGUtejoxMDAlO3NjYWxlOnZhcigtLXR3LXNjYWxlLXgpdmFyKC0tdHctc2NhbGUteSl9LnNjYWxlLTExMHstLXR3LXNjYWxlLXg6MTEwJTstLXR3LXNjYWxlLXk6MTEwJTstLXR3LXNjYWxlLXo6MTEwJTtzY2FsZTp2YXIoLS10dy1zY2FsZS14KXZhcigtLXR3LXNjYWxlLXkpfS5zY2FsZS14LTc1ey0tdHctc2NhbGUteDo3NSU7c2NhbGU6dmFyKC0tdHctc2NhbGUteCl2YXIoLS10dy1zY2FsZS15KX0uc2NhbGUteS0wey0tdHctc2NhbGUteTowJTtzY2FsZTp2YXIoLS10dy1zY2FsZS14KXZhcigtLXR3LXNjYWxlLXkpfS50cmFuc2Zvcm17dHJhbnNmb3JtOnZhcigtLXR3LXJvdGF0ZS14LCl2YXIoLS10dy1yb3RhdGUteSwpdmFyKC0tdHctcm90YXRlLXosKXZhcigtLXR3LXNrZXcteCwpdmFyKC0tdHctc2tldy15LCl9LmFuaW1hdGUtcHVsc2V7YW5pbWF0aW9uOnZhcigtLWFuaW1hdGUtcHVsc2UpfS5hbmltYXRlLXNwaW57YW5pbWF0aW9uOnZhcigtLWFuaW1hdGUtc3Bpbil9LmN1cnNvci1jb3B5e2N1cnNvcjpjb3B5fS5jdXJzb3ItZGVmYXVsdHtjdXJzb3I6ZGVmYXVsdH0uY3Vyc29yLW5vdC1hbGxvd2Vke2N1cnNvcjpub3QtYWxsb3dlZH0uY3Vyc29yLXBvaW50ZXJ7Y3Vyc29yOnBvaW50ZXJ9LnJlc2l6ZXtyZXNpemU6Ym90aH0ucmVzaXplLW5vbmV7cmVzaXplOm5vbmV9LnNuYXAtc3RhcnR7c2Nyb2xsLXNuYXAtYWxpZ246c3RhcnR9Lmxpc3QtaW5zaWRle2xpc3Qtc3R5bGUtcG9zaXRpb246aW5zaWRlfS5saXN0LWRlY2ltYWx7bGlzdC1zdHlsZS10eXBlOmRlY2ltYWx9LmZsZXgtY29se2ZsZXgtZGlyZWN0aW9uOmNvbHVtbn0uZmxleC1jb2wtcmV2ZXJzZXtmbGV4LWRpcmVjdGlvbjpjb2x1bW4tcmV2ZXJzZX0uZmxleC1yb3d7ZmxleC1kaXJlY3Rpb246cm93fS5mbGV4LXJvdy1yZXZlcnNle2ZsZXgtZGlyZWN0aW9uOnJvdy1yZXZlcnNlfS5pdGVtcy1jZW50ZXJ7YWxpZ24taXRlbXM6Y2VudGVyfS5pdGVtcy1lbmR7YWxpZ24taXRlbXM6ZmxleC1lbmR9Lml0ZW1zLXN0YXJ0e2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9Lml0ZW1zLXN0cmV0Y2h7YWxpZ24taXRlbXM6c3RyZXRjaH0uanVzdGlmeS1iZXR3ZWVue2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVufS5qdXN0aWZ5LWNlbnRlcntqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS5qdXN0aWZ5LWVuZHtqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9Lmp1c3RpZnktc3RhcnR7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnR9LmdhcC0we2dhcDpjYWxjKHZhcigtLXNwYWNpbmcpKjApfS5nYXAtMFxcXFxcXFxcLjV7Z2FwOmNhbGModmFyKC0tc3BhY2luZykqLjUpfS5nYXAtMXtnYXA6Y2FsYyh2YXIoLS1zcGFjaW5nKSoxKX0uZ2FwLTJ7Z2FwOmNhbGModmFyKC0tc3BhY2luZykqMil9OndoZXJlKC5zcGFjZS15LTE+Om5vdCg6bGFzdC1jaGlsZCkpey0tdHctc3BhY2UteS1yZXZlcnNlOjA7bWFyZ2luLWJsb2NrLXN0YXJ0OmNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSoxKSp2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTttYXJnaW4tYmxvY2stZW5kOmNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSoxKSpjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSl9OndoZXJlKC5zcGFjZS15LTI+Om5vdCg6bGFzdC1jaGlsZCkpey0tdHctc3BhY2UteS1yZXZlcnNlOjA7bWFyZ2luLWJsb2NrLXN0YXJ0OmNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSoyKSp2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTttYXJnaW4tYmxvY2stZW5kOmNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSoyKSpjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSl9OndoZXJlKC5zcGFjZS15LTM+Om5vdCg6bGFzdC1jaGlsZCkpey0tdHctc3BhY2UteS1yZXZlcnNlOjA7bWFyZ2luLWJsb2NrLXN0YXJ0OmNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSozKSp2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTttYXJnaW4tYmxvY2stZW5kOmNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSozKSpjYWxjKDEgLSB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKSl9OndoZXJlKC5zcGFjZS14LTI+Om5vdCg6bGFzdC1jaGlsZCkpey0tdHctc3BhY2UteC1yZXZlcnNlOjA7bWFyZ2luLWlubGluZS1zdGFydDpjYWxjKGNhbGModmFyKC0tc3BhY2luZykqMikqdmFyKC0tdHctc3BhY2UteC1yZXZlcnNlKSk7bWFyZ2luLWlubGluZS1lbmQ6Y2FsYyhjYWxjKHZhcigtLXNwYWNpbmcpKjIpKmNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXgtcmV2ZXJzZSkpKX06d2hlcmUoLmRpdmlkZS15Pjpub3QoOmxhc3QtY2hpbGQpKXstLXR3LWRpdmlkZS15LXJldmVyc2U6MDtib3JkZXItYm90dG9tLXN0eWxlOnZhcigtLXR3LWJvcmRlci1zdHlsZSk7Ym9yZGVyLXRvcC1zdHlsZTp2YXIoLS10dy1ib3JkZXItc3R5bGUpO2JvcmRlci10b3Atd2lkdGg6Y2FsYygxcHgqdmFyKC0tdHctZGl2aWRlLXktcmV2ZXJzZSkpO2JvcmRlci1ib3R0b20td2lkdGg6Y2FsYygxcHgqY2FsYygxIC0gdmFyKC0tdHctZGl2aWRlLXktcmV2ZXJzZSkpKX06d2hlcmUoLmRpdmlkZS15LXJldmVyc2U+Om5vdCg6bGFzdC1jaGlsZCkpey0tdHctZGl2aWRlLXktcmV2ZXJzZToxfTp3aGVyZSguZGl2aWRlLWJvcmRlclxcXFxcXFxcLzIwPjpub3QoOmxhc3QtY2hpbGQpKXtib3JkZXItY29sb3I6IzcxNzE3YjMzfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7OndoZXJlKC5kaXZpZGUtYm9yZGVyXFxcXFxcXFwvMjA+Om5vdCg6bGFzdC1jaGlsZCkpe2JvcmRlci1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItYm9yZGVyKTIwJSx0cmFuc3BhcmVudCl9fS50cnVuY2F0ZXt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzO3doaXRlLXNwYWNlOm5vd3JhcDtvdmVyZmxvdzpoaWRkZW59Lm92ZXJmbG93LWhpZGRlbntvdmVyZmxvdzpoaWRkZW59Lm92ZXJmbG93LXZpc2libGV7b3ZlcmZsb3c6dmlzaWJsZX0ub3ZlcmZsb3cteC1hdXRve292ZXJmbG93LXg6YXV0b30ub3ZlcmZsb3cteS1hdXRve292ZXJmbG93LXk6YXV0b30ub3ZlcmZsb3cteS1zY3JvbGx7b3ZlcmZsb3cteTpzY3JvbGx9Lm92ZXJzY3JvbGwtY29udGFpbntvdmVyc2Nyb2xsLWJlaGF2aW9yOmNvbnRhaW59LnJvdW5kZWQtM3hse2JvcmRlci1yYWRpdXM6dmFyKC0tcmFkaXVzLTN4bCl9LnJvdW5kZWQtXFxcXFxcXFxbaW5oZXJpdFxcXFxcXFxcXXtib3JkZXItcmFkaXVzOmluaGVyaXR9LnJvdW5kZWQtZnVsbHtib3JkZXItcmFkaXVzOjMuNDAyODJlMzhweH0ucm91bmRlZC1sZ3tib3JkZXItcmFkaXVzOnZhcigtLXJhZGl1cy1sZyl9LnJvdW5kZWQtbWR7Ym9yZGVyLXJhZGl1czp2YXIoLS1yYWRpdXMtbWQpfS5yb3VuZGVkLXNte2JvcmRlci1yYWRpdXM6dmFyKC0tcmFkaXVzLXNtKX0ucm91bmRlZC14bHtib3JkZXItcmFkaXVzOnZhcigtLXJhZGl1cy14bCl9LnJvdW5kZWQtdC0zeGx7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1yYWRpdXMtM3hsKTtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czp2YXIoLS1yYWRpdXMtM3hsKX0ucm91bmRlZC10LVxcXFxcXFxcW2luaGVyaXRcXFxcXFxcXF17Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czppbmhlcml0O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOmluaGVyaXR9LnJvdW5kZWQtdC1sZ3tib3JkZXItdG9wLWxlZnQtcmFkaXVzOnZhcigtLXJhZGl1cy1sZyk7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tcmFkaXVzLWxnKX0ucm91bmRlZC10LW5vbmV7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9LnJvdW5kZWQtYi0zeGx7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tcmFkaXVzLTN4bCk7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1yYWRpdXMtM3hsKX0ucm91bmRlZC1iLVxcXFxcXFxcW2luaGVyaXRcXFxcXFxcXF17Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6aW5oZXJpdDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOmluaGVyaXR9LnJvdW5kZWQtYi1sZ3tib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czp2YXIoLS1yYWRpdXMtbGcpO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tcmFkaXVzLWxnKX0uYm9yZGVye2JvcmRlci1zdHlsZTp2YXIoLS10dy1ib3JkZXItc3R5bGUpO2JvcmRlci13aWR0aDoxcHh9LmJvcmRlci0ye2JvcmRlci1zdHlsZTp2YXIoLS10dy1ib3JkZXItc3R5bGUpO2JvcmRlci13aWR0aDoycHh9LmJvcmRlci10e2JvcmRlci10b3Atc3R5bGU6dmFyKC0tdHctYm9yZGVyLXN0eWxlKTtib3JkZXItdG9wLXdpZHRoOjFweH0uYm9yZGVyLWJ7Ym9yZGVyLWJvdHRvbS1zdHlsZTp2YXIoLS10dy1ib3JkZXItc3R5bGUpO2JvcmRlci1ib3R0b20td2lkdGg6MXB4fS5ib3JkZXItZG90dGVkey0tdHctYm9yZGVyLXN0eWxlOmRvdHRlZDtib3JkZXItc3R5bGU6ZG90dGVkfS5ib3JkZXItYmxhY2tcXFxcXFxcXC8xMHtib3JkZXItY29sb3I6IzAwMDAwMDFhfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJvcmRlci1ibGFja1xcXFxcXFxcLzEwe2JvcmRlci1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItYmxhY2spMTAlLHRyYW5zcGFyZW50KX19LmJvcmRlci1ibGFja1xcXFxcXFxcLzE1e2JvcmRlci1jb2xvcjojMDAwMDAwMjZ9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYm9yZGVyLWJsYWNrXFxcXFxcXFwvMTV7Ym9yZGVyLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1ibGFjaykxNSUsdHJhbnNwYXJlbnQpfX0uYm9yZGVyLWJsdWUtNTAwe2JvcmRlci1jb2xvcjp2YXIoLS1jb2xvci1ibHVlLTUwMCl9LmJvcmRlci1ibHVlLTYwMFxcXFxcXFxcLzcwe2JvcmRlci1jb2xvcjojMTU1ZGZjYjN9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYm9yZGVyLWJsdWUtNjAwXFxcXFxcXFwvNzB7Ym9yZGVyLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1ibHVlLTYwMCk3MCUsdHJhbnNwYXJlbnQpfX0uYm9yZGVyLWJvcmRlclxcXFxcXFxcLzIwe2JvcmRlci1jb2xvcjojNzE3MTdiMzN9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYm9yZGVyLWJvcmRlclxcXFxcXFxcLzIwe2JvcmRlci1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItYm9yZGVyKTIwJSx0cmFuc3BhcmVudCl9fS5ib3JkZXItZ3JlZW4tNTAwe2JvcmRlci1jb2xvcjp2YXIoLS1jb2xvci1ncmVlbi01MDApfS5ib3JkZXItb3JhbmdlLTUwMHtib3JkZXItY29sb3I6dmFyKC0tY29sb3Itb3JhbmdlLTUwMCl9LmJvcmRlci1waW5rLTUwMHtib3JkZXItY29sb3I6dmFyKC0tY29sb3ItcGluay01MDApfS5ib3JkZXItcHVycGxlLTUwMHtib3JkZXItY29sb3I6dmFyKC0tY29sb3ItcHVycGxlLTUwMCl9LmJvcmRlci1yZWQtNTAwe2JvcmRlci1jb2xvcjp2YXIoLS1jb2xvci1yZWQtNTAwKX0uYm9yZGVyLXRyYW5zcGFyZW50e2JvcmRlci1jb2xvcjojMDAwMH0uYm9yZGVyLXllbGxvdy01MDB7Ym9yZGVyLWNvbG9yOnZhcigtLWNvbG9yLXllbGxvdy01MDApfS5ib3JkZXItemluYy01MDB7Ym9yZGVyLWNvbG9yOnZhcigtLWNvbG9yLXppbmMtNTAwKX0uYm9yZGVyLXppbmMtNTAwXFxcXFxcXFwvMTV7Ym9yZGVyLWNvbG9yOiM3MTcxN2IyNn1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5ib3JkZXItemluYy01MDBcXFxcXFxcXC8xNXtib3JkZXItY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXppbmMtNTAwKTE1JSx0cmFuc3BhcmVudCl9fS5ib3JkZXItemluYy01MDBcXFxcXFxcXC8yMHtib3JkZXItY29sb3I6IzcxNzE3YjMzfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJvcmRlci16aW5jLTUwMFxcXFxcXFxcLzIwe2JvcmRlci1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItemluYy01MDApMjAlLHRyYW5zcGFyZW50KX19LmJvcmRlci16aW5jLTYwMFxcXFxcXFxcLzcwe2JvcmRlci1jb2xvcjojNTI1MjVjYjN9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYm9yZGVyLXppbmMtNjAwXFxcXFxcXFwvNzB7Ym9yZGVyLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTYwMCk3MCUsdHJhbnNwYXJlbnQpfX0uYm9yZGVyLXppbmMtOTUwXFxcXFxcXFwvMTB7Ym9yZGVyLWNvbG9yOiMwOTA5MGIxYX1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5ib3JkZXItemluYy05NTBcXFxcXFxcXC8xMHtib3JkZXItY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXppbmMtOTUwKTEwJSx0cmFuc3BhcmVudCl9fS5iZy1ibGFja1xcXFxcXFxcLzV7YmFja2dyb3VuZC1jb2xvcjojMDAwMDAwMGR9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYmctYmxhY2tcXFxcXFxcXC81e2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWJsYWNrKTUlLHRyYW5zcGFyZW50KX19LmJnLWJsdWUtNDAwXFxcXFxcXFwvMTB7YmFja2dyb3VuZC1jb2xvcjojNTRhMmZmMWF9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYmctYmx1ZS00MDBcXFxcXFxcXC8xMHtiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1ibHVlLTQwMCkxMCUsdHJhbnNwYXJlbnQpfX0uYmctYmx1ZS01MDB7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1ibHVlLTUwMCl9LmJnLWJsdWUtNjAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3ItYmx1ZS02MDApfS5iZy1ibHVlLTYwMFxcXFxcXFxcLzV7YmFja2dyb3VuZC1jb2xvcjojMTU1ZGZjMGR9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYmctYmx1ZS02MDBcXFxcXFxcXC81e2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWJsdWUtNjAwKTUlLHRyYW5zcGFyZW50KX19LmJnLWJsdWUtOTUwXFxcXFxcXFwvODB7YmFja2dyb3VuZC1jb2xvcjojMTYyNDU2Y2N9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYmctYmx1ZS05NTBcXFxcXFxcXC84MHtiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1ibHVlLTk1MCk4MCUsdHJhbnNwYXJlbnQpfX0uYmctZ3JlZW4tNTAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3ItZ3JlZW4tNTAwKX0uYmctb3JhbmdlLTIwMFxcXFxcXFxcLzUwe2JhY2tncm91bmQtY29sb3I6I2ZmZDdhODgwfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJnLW9yYW5nZS0yMDBcXFxcXFxcXC81MHtiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1vcmFuZ2UtMjAwKTUwJSx0cmFuc3BhcmVudCl9fS5iZy1vcmFuZ2UtNTAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3Itb3JhbmdlLTUwMCl9LmJnLXBpbmstNTAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3ItcGluay01MDApfS5iZy1wdXJwbGUtNTAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3ItcHVycGxlLTUwMCl9LmJnLXJlZC01MDB7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1yZWQtNTAwKX0uYmctcm9zZS02MDB7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci1yb3NlLTYwMCl9LmJnLXNreS0xMDBcXFxcXFxcXC82MHtiYWNrZ3JvdW5kLWNvbG9yOiNkZmYyZmU5OX1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5iZy1za3ktMTAwXFxcXFxcXFwvNjB7YmFja2dyb3VuZC1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3Itc2t5LTEwMCk2MCUsdHJhbnNwYXJlbnQpfX0uYmctdHJhbnNwYXJlbnR7YmFja2dyb3VuZC1jb2xvcjojMDAwMH0uYmctd2hpdGV7YmFja2dyb3VuZC1jb2xvcjp2YXIoLS1jb2xvci13aGl0ZSl9LmJnLXdoaXRlXFxcXFxcXFwvNXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYwZH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5iZy13aGl0ZVxcXFxcXFxcLzV7YmFja2dyb3VuZC1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3Itd2hpdGUpNSUsdHJhbnNwYXJlbnQpfX0uYmctd2hpdGVcXFxcXFxcXC8xMHtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZmZmYxYX1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5iZy13aGl0ZVxcXFxcXFxcLzEwe2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTEwJSx0cmFuc3BhcmVudCl9fS5iZy15ZWxsb3ctNTAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3IteWVsbG93LTUwMCl9LmJnLXppbmMtNTAwe2JhY2tncm91bmQtY29sb3I6dmFyKC0tY29sb3ItemluYy01MDApfS5iZy16aW5jLTUwMFxcXFxcXFxcLzEwe2JhY2tncm91bmQtY29sb3I6IzcxNzE3YjFhfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJnLXppbmMtNTAwXFxcXFxcXFwvMTB7YmFja2dyb3VuZC1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItemluYy01MDApMTAlLHRyYW5zcGFyZW50KX19LmJnLXppbmMtNzAwXFxcXFxcXFwvODB7YmFja2dyb3VuZC1jb2xvcjojM2YzZjQ2Y2N9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYmctemluYy03MDBcXFxcXFxcXC84MHtiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTcwMCk4MCUsdHJhbnNwYXJlbnQpfX0uYmctemluYy05NTBcXFxcXFxcXC81e2JhY2tncm91bmQtY29sb3I6IzA5MDkwYjBkfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJnLXppbmMtOTUwXFxcXFxcXFwvNXtiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTk1MCk1JSx0cmFuc3BhcmVudCl9fS5iZy1ncmFkaWVudC10by1iey0tdHctZ3JhZGllbnQtcG9zaXRpb246dG8gYm90dG9tIGluIG9rbGFiO2JhY2tncm91bmQtaW1hZ2U6bGluZWFyLWdyYWRpZW50KHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSl9LmJnLWdyYWRpZW50LXRvLXJ7LS10dy1ncmFkaWVudC1wb3NpdGlvbjp0byByaWdodCBpbiBva2xhYjtiYWNrZ3JvdW5kLWltYWdlOmxpbmVhci1ncmFkaWVudCh2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpfS5iZy1yYWRpYWx7LS10dy1ncmFkaWVudC1wb3NpdGlvbjppbiBva2xhYjtiYWNrZ3JvdW5kLWltYWdlOnJhZGlhbC1ncmFkaWVudCh2YXIoLS10dy1ncmFkaWVudC1zdG9wcykpfS5iZy1cXFxcXFxcXFtpbWFnZVxcXFxcXFxcOnZhclxcXFxcXFxcKC0tZ2xhc3MtdGV4dHVyZVxcXFxcXFxcKVxcXFxcXFxcXXtiYWNrZ3JvdW5kLWltYWdlOnZhcigtLWdsYXNzLXRleHR1cmUpfS5iZy1cXFxcXFxcXFtpbWFnZVxcXFxcXFxcOnZhclxcXFxcXFxcKC0tZ3JhZGllbnRcXFxcXFxcXClcXFxcXFxcXF17YmFja2dyb3VuZC1pbWFnZTp2YXIoLS1ncmFkaWVudCl9LmZyb20tdHJhbnNwYXJlbnR7LS10dy1ncmFkaWVudC1mcm9tOnRyYW5zcGFyZW50Oy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9LmZyb20td2hpdGVcXFxcXFxcXC8xMHstLXR3LWdyYWRpZW50LWZyb206I2ZmZmZmZjFhfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmZyb20td2hpdGVcXFxcXFxcXC8xMHstLXR3LWdyYWRpZW50LWZyb206Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTEwJSx0cmFuc3BhcmVudCl9fS5mcm9tLXdoaXRlXFxcXFxcXFwvMTB7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LWZyb20pdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKX0uZnJvbS16aW5jLTEwMFxcXFxcXFxcLzEwey0tdHctZ3JhZGllbnQtZnJvbTojZjRmNGY1MWF9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuZnJvbS16aW5jLTEwMFxcXFxcXFxcLzEwey0tdHctZ3JhZGllbnQtZnJvbTpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItemluYy0xMDApMTAlLHRyYW5zcGFyZW50KX19LmZyb20temluYy0xMDBcXFxcXFxcXC8xMHstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyx2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtZnJvbSl2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC10byl2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpfS5mcm9tLXppbmMtMTAwXFxcXFxcXFwvNjB7LS10dy1ncmFkaWVudC1mcm9tOiNmNGY0ZjU5OX1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5mcm9tLXppbmMtMTAwXFxcXFxcXFwvNjB7LS10dy1ncmFkaWVudC1mcm9tOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTEwMCk2MCUsdHJhbnNwYXJlbnQpfX0uZnJvbS16aW5jLTEwMFxcXFxcXFxcLzYwey0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9LmZyb20tMzBcXFxcXFxcXCV7LS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOjMwJX0udmlhLXRyYW5zcGFyZW50ey0tdHctZ3JhZGllbnQtdmlhOnRyYW5zcGFyZW50Oy0tdHctZ3JhZGllbnQtdmlhLXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXZpYSl2YXIoLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyl9LnZpYS13aGl0ZVxcXFxcXFxcLzMwey0tdHctZ3JhZGllbnQtdmlhOiNmZmZmZmY0ZH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey52aWEtd2hpdGVcXFxcXFxcXC8zMHstLXR3LWdyYWRpZW50LXZpYTpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3Itd2hpdGUpMzAlLHRyYW5zcGFyZW50KX19LnZpYS13aGl0ZVxcXFxcXFxcLzMwey0tdHctZ3JhZGllbnQtdmlhLXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXZpYSl2YXIoLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyl9LnZpYS16aW5jLTEwMFxcXFxcXFxcLzMwey0tdHctZ3JhZGllbnQtdmlhOiNmNGY0ZjU0ZH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey52aWEtemluYy0xMDBcXFxcXFxcXC8zMHstLXR3LWdyYWRpZW50LXZpYTpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItemluYy0xMDApMzAlLHRyYW5zcGFyZW50KX19LnZpYS16aW5jLTEwMFxcXFxcXFxcLzMwey0tdHctZ3JhZGllbnQtdmlhLXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXZpYSl2YXIoLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKTstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyl9LnRvLXRyYW5zcGFyZW50ey0tdHctZ3JhZGllbnQtdG86dHJhbnNwYXJlbnQ7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LWZyb20pdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKX0udG8td2hpdGVcXFxcXFxcXC81ey0tdHctZ3JhZGllbnQtdG86I2ZmZmZmZjBkfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LnRvLXdoaXRlXFxcXFxcXFwvNXstLXR3LWdyYWRpZW50LXRvOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci13aGl0ZSk1JSx0cmFuc3BhcmVudCl9fS50by13aGl0ZVxcXFxcXFxcLzV7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LWZyb20pdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKX0udG8td2hpdGVcXFxcXFxcXC8xMHstLXR3LWdyYWRpZW50LXRvOiNmZmZmZmYxYX1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey50by13aGl0ZVxcXFxcXFxcLzEwey0tdHctZ3JhZGllbnQtdG86Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTEwJSx0cmFuc3BhcmVudCl9fS50by13aGl0ZVxcXFxcXFxcLzEwey0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9LnRvLXppbmMtMTAwXFxcXFxcXFwvMHstLXR3LWdyYWRpZW50LXRvOiMwMDAwfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LnRvLXppbmMtMTAwXFxcXFxcXFwvMHstLXR3LWdyYWRpZW50LXRvOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTEwMCkwJSx0cmFuc3BhcmVudCl9fS50by16aW5jLTEwMFxcXFxcXFxcLzB7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LWZyb20pdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKX0udG8temluYy0xMDBcXFxcXFxcXC8xMHstLXR3LWdyYWRpZW50LXRvOiNmNGY0ZjUxYX1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey50by16aW5jLTEwMFxcXFxcXFxcLzEwey0tdHctZ3JhZGllbnQtdG86Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXppbmMtMTAwKTEwJSx0cmFuc3BhcmVudCl9fS50by16aW5jLTEwMFxcXFxcXFxcLzEwey0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9LnRvLTc1XFxcXFxcXFwley0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246NzUlfS5tYXNrLVxcXFxcXFxcW2xpbmVhci1ncmFkaWVudFxcXFxcXFxcKHRvX2JvdHRvbVxcXFxcXFxcLHRyYW5zcGFyZW50XzBcXFxcXFxcXCVcXFxcXFxcXCxibGFja181XFxcXFxcXFwlXFxcXFxcXFwsYmxhY2tfOTVcXFxcXFxcXCVcXFxcXFxcXCx0cmFuc3BhcmVudF8xMDBcXFxcXFxcXCVcXFxcXFxcXClcXFxcXFxcXF17LXdlYmtpdC1tYXNrLWltYWdlOmxpbmVhci1ncmFkaWVudCgjMDAwMCAwJSwjMDAwIDUlIDk1JSwjMDAwMCAxMDAlKTttYXNrLWltYWdlOmxpbmVhci1ncmFkaWVudCgjMDAwMCwjMDAwIDUlLCMwMDAgOTUlLCMwMDAwKX0uYmctY292ZXJ7YmFja2dyb3VuZC1zaXplOmNvdmVyfS5iZy1jZW50ZXJ7YmFja2dyb3VuZC1wb3NpdGlvbjo1MCV9LmJnLW5vLXJlcGVhdHtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXR9Lm1hc2stYWxwaGF7LXdlYmtpdC1tYXNrLXNvdXJjZS10eXBlOmFscGhhO21hc2stbW9kZTphbHBoYX0uZmlsbC1cXFxcXFxcXFt2YXJcXFxcXFxcXCgtLWFjdGl2ZVxcXFxcXFxcKVxcXFxcXFxcXXtmaWxsOnZhcigtLWFjdGl2ZSl9LmZpbGwtY3VycmVudHtmaWxsOmN1cnJlbnRDb2xvcn0uZmlsbC13aGl0ZXtmaWxsOnZhcigtLWNvbG9yLXdoaXRlKX0uZmlsbC16aW5jLTUwMFxcXFxcXFxcLzUwe2ZpbGw6IzcxNzE3YjgwfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmZpbGwtemluYy01MDBcXFxcXFxcXC81MHtmaWxsOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTUwMCk1MCUsdHJhbnNwYXJlbnQpfX0uZmlsbC16aW5jLTk1MHtmaWxsOnZhcigtLWNvbG9yLXppbmMtOTUwKX0uc3Ryb2tlLVxcXFxcXFxcW3ZhclxcXFxcXFxcKC0tYWN0aXZlXFxcXFxcXFwpXFxcXFxcXFxde3N0cm9rZTp2YXIoLS1hY3RpdmUpfS5zdHJva2UtXFxcXFxcXFxbdmFyXFxcXFxcXFwoLS1wcmltYXJ5XFxcXFxcXFwpXFxcXFxcXFxde3N0cm9rZTp2YXIoLS1wcmltYXJ5KX0uc3Ryb2tlLWJsYWNrXFxcXFxcXFwvMzB7c3Ryb2tlOiMwMDAwMDA0ZH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5zdHJva2UtYmxhY2tcXFxcXFxcXC8zMHtzdHJva2U6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWJsYWNrKTMwJSx0cmFuc3BhcmVudCl9fS5zdHJva2UtYmx1ZS02MDB7c3Ryb2tlOnZhcigtLWNvbG9yLWJsdWUtNjAwKX0uc3Ryb2tlLWZ1Y2hzaWEtNzAwe3N0cm9rZTp2YXIoLS1jb2xvci1mdWNoc2lhLTcwMCl9LnN0cm9rZS1ncmVlbi02MDB7c3Ryb2tlOnZhcigtLWNvbG9yLWdyZWVuLTYwMCl9LnN0cm9rZS1ub25le3N0cm9rZTpub25lfS5zdHJva2Utcm9zZS02MDB7c3Ryb2tlOnZhcigtLWNvbG9yLXJvc2UtNjAwKX0uc3Ryb2tlLXZpb2xldC02MDB7c3Ryb2tlOnZhcigtLWNvbG9yLXZpb2xldC02MDApfS5zdHJva2Utd2hpdGV7c3Ryb2tlOnZhcigtLWNvbG9yLXdoaXRlKX0uc3Ryb2tlLTF7c3Ryb2tlLXdpZHRoOjFweH0uc3Ryb2tlLTN7c3Ryb2tlLXdpZHRoOjNweH0ucC0we3BhZGRpbmc6Y2FsYyh2YXIoLS1zcGFjaW5nKSowKX0ucC0wXFxcXFxcXFwuNXtwYWRkaW5nOmNhbGModmFyKC0tc3BhY2luZykqLjUpfS5wLTF7cGFkZGluZzpjYWxjKHZhcigtLXNwYWNpbmcpKjEpfS5wLTJ7cGFkZGluZzpjYWxjKHZhcigtLXNwYWNpbmcpKjIpfS5wLTN7cGFkZGluZzpjYWxjKHZhcigtLXNwYWNpbmcpKjMpfS5weC0wXFxcXFxcXFwuNXtwYWRkaW5nLWlubGluZTpjYWxjKHZhcigtLXNwYWNpbmcpKi41KX0ucHgtMXtwYWRkaW5nLWlubGluZTpjYWxjKHZhcigtLXNwYWNpbmcpKjEpfS5weC0ye3BhZGRpbmctaW5saW5lOmNhbGModmFyKC0tc3BhY2luZykqMil9LnB4LTN7cGFkZGluZy1pbmxpbmU6Y2FsYyh2YXIoLS1zcGFjaW5nKSozKX0ucHgtNHtwYWRkaW5nLWlubGluZTpjYWxjKHZhcigtLXNwYWNpbmcpKjQpfS5weS0we3BhZGRpbmctYmxvY2s6Y2FsYyh2YXIoLS1zcGFjaW5nKSowKX0ucHktMFxcXFxcXFxcLjV7cGFkZGluZy1ibG9jazpjYWxjKHZhcigtLXNwYWNpbmcpKi41KX0ucHktMXtwYWRkaW5nLWJsb2NrOmNhbGModmFyKC0tc3BhY2luZykqMSl9LnB5LTFcXFxcXFxcXC41e3BhZGRpbmctYmxvY2s6Y2FsYyh2YXIoLS1zcGFjaW5nKSoxLjUpfS5weS0ye3BhZGRpbmctYmxvY2s6Y2FsYyh2YXIoLS1zcGFjaW5nKSoyKX0ucHktNHtwYWRkaW5nLWJsb2NrOmNhbGModmFyKC0tc3BhY2luZykqNCl9LnB0LTF7cGFkZGluZy10b3A6Y2FsYyh2YXIoLS1zcGFjaW5nKSoxKX0ucHQtMntwYWRkaW5nLXRvcDpjYWxjKHZhcigtLXNwYWNpbmcpKjIpfS5wdC0ze3BhZGRpbmctdG9wOmNhbGModmFyKC0tc3BhY2luZykqMyl9LnByLTN7cGFkZGluZy1yaWdodDpjYWxjKHZhcigtLXNwYWNpbmcpKjMpfS5wci02e3BhZGRpbmctcmlnaHQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSo2KX0ucGItMXtwYWRkaW5nLWJvdHRvbTpjYWxjKHZhcigtLXNwYWNpbmcpKjEpfS5wYi0ye3BhZGRpbmctYm90dG9tOmNhbGModmFyKC0tc3BhY2luZykqMil9LnBiLTN7cGFkZGluZy1ib3R0b206Y2FsYyh2YXIoLS1zcGFjaW5nKSozKX0ucGwtMntwYWRkaW5nLWxlZnQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSoyKX0ucGwtM3twYWRkaW5nLWxlZnQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSozKX0ucGwtNHtwYWRkaW5nLWxlZnQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSo0KX0udGV4dC1iYXNle2ZvbnQtc2l6ZTp2YXIoLS10ZXh0LWJhc2UpO2xpbmUtaGVpZ2h0OnZhcigtLXR3LWxlYWRpbmcsdmFyKC0tdGV4dC1iYXNlLS1saW5lLWhlaWdodCkpfS50ZXh0LWxne2ZvbnQtc2l6ZTp2YXIoLS10ZXh0LWxnKTtsaW5lLWhlaWdodDp2YXIoLS10dy1sZWFkaW5nLHZhcigtLXRleHQtbGctLWxpbmUtaGVpZ2h0KSl9LnRleHQtc217Zm9udC1zaXplOnZhcigtLXRleHQtc20pO2xpbmUtaGVpZ2h0OnZhcigtLXR3LWxlYWRpbmcsdmFyKC0tdGV4dC1zbS0tbGluZS1oZWlnaHQpKX0udGV4dC14c3tmb250LXNpemU6dmFyKC0tdGV4dC14cyk7bGluZS1oZWlnaHQ6dmFyKC0tdHctbGVhZGluZyx2YXIoLS10ZXh0LXhzLS1saW5lLWhlaWdodCkpfS50ZXh0LVxcXFxcXFxcWzBcXFxcXFxcXC41ZW1cXFxcXFxcXF17Zm9udC1zaXplOi41ZW19LmZvbnQtYm9sZHstLXR3LWZvbnQtd2VpZ2h0OnZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpfS5mb250LW1lZGl1bXstLXR3LWZvbnQtd2VpZ2h0OnZhcigtLWZvbnQtd2VpZ2h0LW1lZGl1bSk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC13ZWlnaHQtbWVkaXVtKX0uZm9udC1ub3JtYWx7LS10dy1mb250LXdlaWdodDp2YXIoLS1mb250LXdlaWdodC1ub3JtYWwpO2ZvbnQtd2VpZ2h0OnZhcigtLWZvbnQtd2VpZ2h0LW5vcm1hbCl9LmZvbnQtc2VtaWJvbGR7LS10dy1mb250LXdlaWdodDp2YXIoLS1mb250LXdlaWdodC1zZW1pYm9sZCk7Zm9udC13ZWlnaHQ6dmFyKC0tZm9udC13ZWlnaHQtc2VtaWJvbGQpfS53aGl0ZXNwYWNlLXByZS13cmFwe3doaXRlLXNwYWNlOnByZS13cmFwfS50ZXh0LVxcXFxcXFxcW3ZhclxcXFxcXFxcKC0tYWN0aXZlXFxcXFxcXFwpXFxcXFxcXFxde2NvbG9yOnZhcigtLWFjdGl2ZSl9LnRleHQtXFxcXFxcXFxbdmFyXFxcXFxcXFwoLS1wcmltYXJ5XFxcXFxcXFwpXFxcXFxcXFxde2NvbG9yOnZhcigtLXByaW1hcnkpfS50ZXh0LWJsdWUtNTAwe2NvbG9yOnZhcigtLWNvbG9yLWJsdWUtNTAwKX0udGV4dC1jdXJyZW50e2NvbG9yOmN1cnJlbnRDb2xvcn0udGV4dC1mb3JlZ3JvdW5ke2NvbG9yOnZhcigtLWNvbG9yLWZvcmVncm91bmQpfS50ZXh0LWZvcmVncm91bmRcXFxcXFxcXC80MHtjb2xvcjojMDkwOTBiNjZ9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsudGV4dC1mb3JlZ3JvdW5kXFxcXFxcXFwvNDB7Y29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWZvcmVncm91bmQpNDAlLHRyYW5zcGFyZW50KX19LnRleHQtZm9yZWdyb3VuZFxcXFxcXFxcLzcwe2NvbG9yOiMwOTA5MGJiM31Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey50ZXh0LWZvcmVncm91bmRcXFxcXFxcXC83MHtjb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItZm9yZWdyb3VuZCk3MCUsdHJhbnNwYXJlbnQpfX0udGV4dC1mb3JlZ3JvdW5kXFxcXFxcXFwvODB7Y29sb3I6IzA5MDkwYmNjfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LnRleHQtZm9yZWdyb3VuZFxcXFxcXFxcLzgwe2NvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1mb3JlZ3JvdW5kKTgwJSx0cmFuc3BhcmVudCl9fS50ZXh0LW11dGVkLWZvcmVncm91bmR7Y29sb3I6dmFyKC0tY29sb3ItbXV0ZWQtZm9yZWdyb3VuZCl9LnRleHQtd2hpdGV7Y29sb3I6dmFyKC0tY29sb3Itd2hpdGUpfS50ZXh0LXppbmMtOTUwe2NvbG9yOnZhcigtLWNvbG9yLXppbmMtOTUwKX0udGV4dC16aW5jLTk1MFxcXFxcXFxcLzcwe2NvbG9yOiMwOTA5MGJiM31Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey50ZXh0LXppbmMtOTUwXFxcXFxcXFwvNzB7Y29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXppbmMtOTUwKTcwJSx0cmFuc3BhcmVudCl9fS5vcGFjaXR5LTB7b3BhY2l0eTowfS5vcGFjaXR5LTMwe29wYWNpdHk6LjN9Lm9wYWNpdHktNTB7b3BhY2l0eTouNX0ub3BhY2l0eS04MHtvcGFjaXR5Oi44fS5vcGFjaXR5LTEwMHtvcGFjaXR5OjF9LnNoYWRvdy0yeHN7LS10dy1zaGFkb3c6MCAxcHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCMwMDAwMDAwZCk7Ym94LXNoYWRvdzp2YXIoLS10dy1pbnNldC1zaGFkb3cpLHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSx2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLHZhcigtLXR3LXJpbmctc2hhZG93KSx2YXIoLS10dy1zaGFkb3cpfS5zaGFkb3ctbGd7LS10dy1zaGFkb3c6MCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKSwwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKTtib3gtc2hhZG93OnZhcigtLXR3LWluc2V0LXNoYWRvdyksdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksdmFyKC0tdHctcmluZy1zaGFkb3cpLHZhcigtLXR3LXNoYWRvdyl9LnNoYWRvdy1tZHstLXR3LXNoYWRvdzowIDRweCA2cHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKSwwIDJweCA0cHggLTJweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKTtib3gtc2hhZG93OnZhcigtLXR3LWluc2V0LXNoYWRvdyksdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksdmFyKC0tdHctcmluZy1zaGFkb3cpLHZhcigtLXR3LXNoYWRvdyl9LnNoYWRvdy1zbXstLXR3LXNoYWRvdzowIDFweCAzcHggMCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKSwwIDFweCAycHggLTFweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKTtib3gtc2hhZG93OnZhcigtLXR3LWluc2V0LXNoYWRvdyksdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksdmFyKC0tdHctcmluZy1zaGFkb3cpLHZhcigtLXR3LXNoYWRvdyl9LnJpbmctMXstLXR3LXJpbmctc2hhZG93OnZhcigtLXR3LXJpbmctaW5zZXQsKTAgMCAwIGNhbGMoMXB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKXZhcigtLXR3LXJpbmctY29sb3IsY3VycmVudGNvbG9yKTtib3gtc2hhZG93OnZhcigtLXR3LWluc2V0LXNoYWRvdyksdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksdmFyKC0tdHctcmluZy1zaGFkb3cpLHZhcigtLXR3LXNoYWRvdyl9LnNoYWRvdy1ibGFja1xcXFxcXFxcLzUwey0tdHctc2hhZG93LWNvbG9yOiMwMDAwMDA4MH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5zaGFkb3ctYmxhY2tcXFxcXFxcXC81MHstLXR3LXNoYWRvdy1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsY29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWJsYWNrKTUwJSx0cmFuc3BhcmVudCl2YXIoLS10dy1zaGFkb3ctYWxwaGEpLHRyYW5zcGFyZW50KX19LnNoYWRvdy1za3ktNTAwXFxcXFxcXFwvMTB7LS10dy1zaGFkb3ctY29sb3I6IzAwYTVlZjFhfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LnNoYWRvdy1za3ktNTAwXFxcXFxcXFwvMTB7LS10dy1zaGFkb3ctY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLGNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1za3ktNTAwKTEwJSx0cmFuc3BhcmVudCl2YXIoLS10dy1zaGFkb3ctYWxwaGEpLHRyYW5zcGFyZW50KX19LnJpbmctd2hpdGVcXFxcXFxcXC8yMHstLXR3LXJpbmctY29sb3I6I2ZmZjN9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsucmluZy13aGl0ZVxcXFxcXFxcLzIwey0tdHctcmluZy1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3Itd2hpdGUpMjAlLHRyYW5zcGFyZW50KX19Lm91dGxpbmV7b3V0bGluZS1zdHlsZTp2YXIoLS10dy1vdXRsaW5lLXN0eWxlKTtvdXRsaW5lLXdpZHRoOjFweH0uYmx1cnstLXR3LWJsdXI6Ymx1cig4cHgpO2ZpbHRlcjp2YXIoLS10dy1ibHVyLCl2YXIoLS10dy1icmlnaHRuZXNzLCl2YXIoLS10dy1jb250cmFzdCwpdmFyKC0tdHctZ3JheXNjYWxlLCl2YXIoLS10dy1odWUtcm90YXRlLCl2YXIoLS10dy1pbnZlcnQsKXZhcigtLXR3LXNhdHVyYXRlLCl2YXIoLS10dy1zZXBpYSwpdmFyKC0tdHctZHJvcC1zaGFkb3csKX0uYmx1ci1cXFxcXFxcXFswXFxcXFxcXFwuMnB4XFxcXFxcXFxdey0tdHctYmx1cjpibHVyKC4ycHgpO2ZpbHRlcjp2YXIoLS10dy1ibHVyLCl2YXIoLS10dy1icmlnaHRuZXNzLCl2YXIoLS10dy1jb250cmFzdCwpdmFyKC0tdHctZ3JheXNjYWxlLCl2YXIoLS10dy1odWUtcm90YXRlLCl2YXIoLS10dy1pbnZlcnQsKXZhcigtLXR3LXNhdHVyYXRlLCl2YXIoLS10dy1zZXBpYSwpdmFyKC0tdHctZHJvcC1zaGFkb3csKX0uYmx1ci1tZHstLXR3LWJsdXI6Ymx1cih2YXIoLS1ibHVyLW1kKSk7ZmlsdGVyOnZhcigtLXR3LWJsdXIsKXZhcigtLXR3LWJyaWdodG5lc3MsKXZhcigtLXR3LWNvbnRyYXN0LCl2YXIoLS10dy1ncmF5c2NhbGUsKXZhcigtLXR3LWh1ZS1yb3RhdGUsKXZhcigtLXR3LWludmVydCwpdmFyKC0tdHctc2F0dXJhdGUsKXZhcigtLXR3LXNlcGlhLCl2YXIoLS10dy1kcm9wLXNoYWRvdywpfS5ibHVyLW5vbmV7LS10dy1ibHVyOiA7ZmlsdGVyOnZhcigtLXR3LWJsdXIsKXZhcigtLXR3LWJyaWdodG5lc3MsKXZhcigtLXR3LWNvbnRyYXN0LCl2YXIoLS10dy1ncmF5c2NhbGUsKXZhcigtLXR3LWh1ZS1yb3RhdGUsKXZhcigtLXR3LWludmVydCwpdmFyKC0tdHctc2F0dXJhdGUsKXZhcigtLXR3LXNlcGlhLCl2YXIoLS10dy1kcm9wLXNoYWRvdywpfS5ibHVyLXNtey0tdHctYmx1cjpibHVyKHZhcigtLWJsdXItc20pKTtmaWx0ZXI6dmFyKC0tdHctYmx1ciwpdmFyKC0tdHctYnJpZ2h0bmVzcywpdmFyKC0tdHctY29udHJhc3QsKXZhcigtLXR3LWdyYXlzY2FsZSwpdmFyKC0tdHctaHVlLXJvdGF0ZSwpdmFyKC0tdHctaW52ZXJ0LCl2YXIoLS10dy1zYXR1cmF0ZSwpdmFyKC0tdHctc2VwaWEsKXZhcigtLXR3LWRyb3Atc2hhZG93LCl9LmJyaWdodG5lc3MtNzV7LS10dy1icmlnaHRuZXNzOmJyaWdodG5lc3MoNzUlKTtmaWx0ZXI6dmFyKC0tdHctYmx1ciwpdmFyKC0tdHctYnJpZ2h0bmVzcywpdmFyKC0tdHctY29udHJhc3QsKXZhcigtLXR3LWdyYXlzY2FsZSwpdmFyKC0tdHctaHVlLXJvdGF0ZSwpdmFyKC0tdHctaW52ZXJ0LCl2YXIoLS10dy1zYXR1cmF0ZSwpdmFyKC0tdHctc2VwaWEsKXZhcigtLXR3LWRyb3Atc2hhZG93LCl9LmJyaWdodG5lc3MtOTB7LS10dy1icmlnaHRuZXNzOmJyaWdodG5lc3MoOTAlKTtmaWx0ZXI6dmFyKC0tdHctYmx1ciwpdmFyKC0tdHctYnJpZ2h0bmVzcywpdmFyKC0tdHctY29udHJhc3QsKXZhcigtLXR3LWdyYXlzY2FsZSwpdmFyKC0tdHctaHVlLXJvdGF0ZSwpdmFyKC0tdHctaW52ZXJ0LCl2YXIoLS10dy1zYXR1cmF0ZSwpdmFyKC0tdHctc2VwaWEsKXZhcigtLXR3LWRyb3Atc2hhZG93LCl9LmRyb3Atc2hhZG93LXhsey0tdHctZHJvcC1zaGFkb3ctc2l6ZTpkcm9wLXNoYWRvdygwIDlweCA3cHggdmFyKC0tdHctZHJvcC1zaGFkb3ctY29sb3IsIzAwMDAwMDFhKSk7LS10dy1kcm9wLXNoYWRvdzpkcm9wLXNoYWRvdyh2YXIoLS1kcm9wLXNoYWRvdy14bCkpO2ZpbHRlcjp2YXIoLS10dy1ibHVyLCl2YXIoLS10dy1icmlnaHRuZXNzLCl2YXIoLS10dy1jb250cmFzdCwpdmFyKC0tdHctZ3JheXNjYWxlLCl2YXIoLS10dy1odWUtcm90YXRlLCl2YXIoLS10dy1pbnZlcnQsKXZhcigtLXR3LXNhdHVyYXRlLCl2YXIoLS10dy1zZXBpYSwpdmFyKC0tdHctZHJvcC1zaGFkb3csKX0uZmlsdGVye2ZpbHRlcjp2YXIoLS10dy1ibHVyLCl2YXIoLS10dy1icmlnaHRuZXNzLCl2YXIoLS10dy1jb250cmFzdCwpdmFyKC0tdHctZ3JheXNjYWxlLCl2YXIoLS10dy1odWUtcm90YXRlLCl2YXIoLS10dy1pbnZlcnQsKXZhcigtLXR3LXNhdHVyYXRlLCl2YXIoLS10dy1zZXBpYSwpdmFyKC0tdHctZHJvcC1zaGFkb3csKX0uYmFja2Ryb3Atc2F0dXJhdGUtMTUwey0tdHctYmFja2Ryb3Atc2F0dXJhdGU6c2F0dXJhdGUoMTUwJSk7LXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6dmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKXZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCl2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCl2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKTtiYWNrZHJvcC1maWx0ZXI6dmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKXZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCl2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCl2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKX0udHJhbnNpdGlvbnt0cmFuc2l0aW9uLXByb3BlcnR5OmNvbG9yLGJhY2tncm91bmQtY29sb3IsYm9yZGVyLWNvbG9yLG91dGxpbmUtY29sb3IsdGV4dC1kZWNvcmF0aW9uLWNvbG9yLGZpbGwsc3Ryb2tlLC0tdHctZ3JhZGllbnQtZnJvbSwtLXR3LWdyYWRpZW50LXZpYSwtLXR3LWdyYWRpZW50LXRvLG9wYWNpdHksYm94LXNoYWRvdyx0cmFuc2Zvcm0sdHJhbnNsYXRlLHNjYWxlLHJvdGF0ZSxmaWx0ZXIsLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXIsYmFja2Ryb3AtZmlsdGVyLGRpc3BsYXksdmlzaWJpbGl0eSxjb250ZW50LXZpc2liaWxpdHksb3ZlcmxheSxwb2ludGVyLWV2ZW50czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjp2YXIoLS10dy1lYXNlLHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pKTt0cmFuc2l0aW9uLWR1cmF0aW9uOnZhcigtLXR3LWR1cmF0aW9uLHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpfS50cmFuc2l0aW9uLWFsbHt0cmFuc2l0aW9uLXByb3BlcnR5OmFsbDt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjp2YXIoLS10dy1lYXNlLHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pKTt0cmFuc2l0aW9uLWR1cmF0aW9uOnZhcigtLXR3LWR1cmF0aW9uLHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpfS50cmFuc2l0aW9uLWNvbG9yc3t0cmFuc2l0aW9uLXByb3BlcnR5OmNvbG9yLGJhY2tncm91bmQtY29sb3IsYm9yZGVyLWNvbG9yLG91dGxpbmUtY29sb3IsdGV4dC1kZWNvcmF0aW9uLWNvbG9yLGZpbGwsc3Ryb2tlLC0tdHctZ3JhZGllbnQtZnJvbSwtLXR3LWdyYWRpZW50LXZpYSwtLXR3LWdyYWRpZW50LXRvO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOnZhcigtLXR3LWVhc2UsdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbikpO3RyYW5zaXRpb24tZHVyYXRpb246dmFyKC0tdHctZHVyYXRpb24sdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uKSl9LnRyYW5zaXRpb24tdHJhbnNmb3Jte3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtLHRyYW5zbGF0ZSxzY2FsZSxyb3RhdGU7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246dmFyKC0tdHctZWFzZSx2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSk7dHJhbnNpdGlvbi1kdXJhdGlvbjp2YXIoLS10dy1kdXJhdGlvbix2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb24pKX0uZHVyYXRpb24tMTAwey0tdHctZHVyYXRpb246LjFzO3RyYW5zaXRpb24tZHVyYXRpb246LjFzfS5kdXJhdGlvbi0xNTB7LS10dy1kdXJhdGlvbjouMTVzO3RyYW5zaXRpb24tZHVyYXRpb246LjE1c30uZHVyYXRpb24tMzAwey0tdHctZHVyYXRpb246LjNzO3RyYW5zaXRpb24tZHVyYXRpb246LjNzfS5kdXJhdGlvbi01MDB7LS10dy1kdXJhdGlvbjouNXM7dHJhbnNpdGlvbi1kdXJhdGlvbjouNXN9LmR1cmF0aW9uLTEwMDB7LS10dy1kdXJhdGlvbjoxczt0cmFuc2l0aW9uLWR1cmF0aW9uOjFzfS5lYXNlLWluLW91dHstLXR3LWVhc2U6dmFyKC0tZWFzZS1pbi1vdXQpO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOnZhcigtLWVhc2UtaW4tb3V0KX0uZWFzZS1vdXR7LS10dy1lYXNlOnZhcigtLWVhc2Utb3V0KTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjp2YXIoLS1lYXNlLW91dCl9LmVhc2Utc3ByaW5ney0tdHctZWFzZTp2YXIoLS1lYXNlLXNwcmluZyk7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246dmFyKC0tZWFzZS1zcHJpbmcpfS5lYXNlLXNwcmluZy1zb2Z0ey0tdHctZWFzZTp2YXIoLS1lYXNlLXNwcmluZy1zb2Z0KTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjp2YXIoLS1lYXNlLXNwcmluZy1zb2Z0KX0ub3V0bGluZS1ub25ley0tdHctb3V0bGluZS1zdHlsZTpub25lO291dGxpbmUtc3R5bGU6bm9uZX0uc2VsZWN0LW5vbmV7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5cXFxcXFxcXFstLWFjdGl2ZS1zZWNvbmRhcnlcXFxcXFxcXDp2YXJcXFxcXFxcXCgtLWNvbG9yLWJsdWUtMTAwXFxcXFxcXFwpXFxcXFxcXFxdey0tYWN0aXZlLXNlY29uZGFyeTp2YXIoLS1jb2xvci1ibHVlLTEwMCl9LlxcXFxcXFxcWy0tYWN0aXZlLXNlY29uZGFyeVxcXFxcXFxcOnZhclxcXFxcXFxcKC0tY29sb3Itb3JhbmdlLTEwMFxcXFxcXFxcKVxcXFxcXFxcXXstLWFjdGl2ZS1zZWNvbmRhcnk6dmFyKC0tY29sb3Itb3JhbmdlLTEwMCl9LlxcXFxcXFxcWy0tYWN0aXZlXFxcXFxcXFw6dmFyXFxcXFxcXFwoLS1jb2xvci1ibHVlLTYwMFxcXFxcXFxcKVxcXFxcXFxcXXstLWFjdGl2ZTp2YXIoLS1jb2xvci1ibHVlLTYwMCl9LlxcXFxcXFxcWy0tYWN0aXZlXFxcXFxcXFw6dmFyXFxcXFxcXFwoLS1jb2xvci1vcmFuZ2UtNjAwXFxcXFxcXFwpXFxcXFxcXFxdey0tYWN0aXZlOnZhcigtLWNvbG9yLW9yYW5nZS02MDApfS5cXFxcXFxcXFstLWNvbG9yLWZvcmVncm91bmRcXFxcXFxcXDp2YXJcXFxcXFxcXCgtLWNvbG9yLW9yYW5nZS03MDBcXFxcXFxcXClcXFxcXFxcXF17LS1jb2xvci1mb3JlZ3JvdW5kOnZhcigtLWNvbG9yLW9yYW5nZS03MDApfS5cXFxcXFxcXFstLWNvbG9yLW11dGVkLWZvcmVncm91bmRcXFxcXFxcXDp2YXJcXFxcXFxcXCgtLWNvbG9yLW9yYW5nZS02MDBcXFxcXFxcXClcXFxcXFxcXF17LS1jb2xvci1tdXRlZC1mb3JlZ3JvdW5kOnZhcigtLWNvbG9yLW9yYW5nZS02MDApfS5cXFxcXFxcXFstLXByaW1hcnlcXFxcXFxcXDp2YXJcXFxcXFxcXCgtLWNvbG9yLW9yYW5nZS05MDBcXFxcXFxcXClcXFxcXFxcXF17LS1wcmltYXJ5OnZhcigtLWNvbG9yLW9yYW5nZS05MDApfS5cXFxcXFxcXFstLXByaW1hcnlcXFxcXFxcXDp2YXJcXFxcXFxcXCgtLWNvbG9yLXppbmMtOTUwXFxcXFxcXFwpXFxcXFxcXFxdey0tcHJpbWFyeTp2YXIoLS1jb2xvci16aW5jLTk1MCl9LlxcXFxcXFxcWy0tc2Vjb25kYXJ5XFxcXFxcXFw6dmFyXFxcXFxcXFwoLS1jb2xvci1vcmFuZ2UtMTAwXFxcXFxcXFwpXFxcXFxcXFxdey0tc2Vjb25kYXJ5OnZhcigtLWNvbG9yLW9yYW5nZS0xMDApfS5cXFxcXFxcXFstLXNlY29uZGFyeVxcXFxcXFxcOnZhclxcXFxcXFxcKC0tY29sb3ItemluYy00MDBcXFxcXFxcXClcXFxcXFxcXF17LS1zZWNvbmRhcnk6dmFyKC0tY29sb3ItemluYy00MDApfTppcyguXFxcXFxcXFwqXFxcXFxcXFw6c2l6ZS1mdWxsPiope3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmJlZm9yZVxcXFxcXFxcOmFic29sdXRlOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO3Bvc2l0aW9uOmFic29sdXRlfS5iZWZvcmVcXFxcXFxcXDppbnNldC0wOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2luc2V0OmNhbGModmFyKC0tc3BhY2luZykqMCl9LmJlZm9yZVxcXFxcXFxcOi16LTIwOmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO3otaW5kZXg6LTIwfS5iZWZvcmVcXFxcXFxcXDpzaXplLWZ1bGw6YmVmb3Jle2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uYmVmb3JlXFxcXFxcXFw6Y29udGVudC1ub3JtYWw6YmVmb3Jle2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7YWxpZ24tY29udGVudDpub3JtYWx9LmJlZm9yZVxcXFxcXFxcOnJvdW5kZWQtXFxcXFxcXFxbaW5oZXJpdFxcXFxcXFxcXTpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtib3JkZXItcmFkaXVzOmluaGVyaXR9LmJlZm9yZVxcXFxcXFxcOmJvcmRlcjpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtib3JkZXItc3R5bGU6dmFyKC0tdHctYm9yZGVyLXN0eWxlKTtib3JkZXItd2lkdGg6MXB4fS5iZWZvcmVcXFxcXFxcXDpib3JkZXItemluYy05NTBcXFxcXFxcXC8yMDpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtib3JkZXItY29sb3I6IzA5MDkwYjMzfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJlZm9yZVxcXFxcXFxcOmJvcmRlci16aW5jLTk1MFxcXFxcXFxcLzIwOmJlZm9yZXtib3JkZXItY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXppbmMtOTUwKTIwJSx0cmFuc3BhcmVudCl9fS5iZWZvcmVcXFxcXFxcXDpiZy1vcmFuZ2UtNTBcXFxcXFxcXC84MDpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY3ZWRjY31Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5iZWZvcmVcXFxcXFxcXDpiZy1vcmFuZ2UtNTBcXFxcXFxcXC84MDpiZWZvcmV7YmFja2dyb3VuZC1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3Itb3JhbmdlLTUwKTgwJSx0cmFuc3BhcmVudCl9fS5iZWZvcmVcXFxcXFxcXDpiZy13aGl0ZVxcXFxcXFxcLzg1OmJlZm9yZXtjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2JhY2tncm91bmQtY29sb3I6I2ZmZmZmZmQ5fUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJlZm9yZVxcXFxcXFxcOmJnLXdoaXRlXFxcXFxcXFwvODU6YmVmb3Jle2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTg1JSx0cmFuc3BhcmVudCl9fS5iZWZvcmVcXFxcXFxcXDpyaW5nLVxcXFxcXFxcWzFcXFxcXFxcXC41cHhcXFxcXFxcXF06YmVmb3Jle2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1yaW5nLXNoYWRvdzp2YXIoLS10dy1yaW5nLWluc2V0LCkwIDAgMCBjYWxjKDEuNXB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKXZhcigtLXR3LXJpbmctY29sb3IsY3VycmVudGNvbG9yKTtib3gtc2hhZG93OnZhcigtLXR3LWluc2V0LXNoYWRvdyksdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksdmFyKC0tdHctcmluZy1zaGFkb3cpLHZhcigtLXR3LXNoYWRvdyl9LmJlZm9yZVxcXFxcXFxcOnJpbmctd2hpdGVcXFxcXFxcXC8zMDpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LXJpbmctY29sb3I6I2ZmZmZmZjRkfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmJlZm9yZVxcXFxcXFxcOnJpbmctd2hpdGVcXFxcXFxcXC8zMDpiZWZvcmV7LS10dy1yaW5nLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci13aGl0ZSkzMCUsdHJhbnNwYXJlbnQpfX0uYmVmb3JlXFxcXFxcXFw6YmFja2Ryb3AtYmx1ci1zbTpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LWJhY2tkcm9wLWJsdXI6Ymx1cih2YXIoLS1ibHVyLXNtKSk7LXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6dmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKXZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCl2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCl2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKTtiYWNrZHJvcC1maWx0ZXI6dmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKXZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCl2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCl2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKX0uYmVmb3JlXFxcXFxcXFw6cmluZy1pbnNldDpiZWZvcmV7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LXJpbmctaW5zZXQ6aW5zZXR9LmFmdGVyXFxcXFxcXFw6cG9pbnRlci1ldmVudHMtbm9uZTphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO3BvaW50ZXItZXZlbnRzOm5vbmV9LmFmdGVyXFxcXFxcXFw6YWJzb2x1dGU6YWZ0ZXJ7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTtwb3NpdGlvbjphYnNvbHV0ZX0uYWZ0ZXJcXFxcXFxcXDppbnNldC0wOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7aW5zZXQ6Y2FsYyh2YXIoLS1zcGFjaW5nKSowKX0uYWZ0ZXJcXFxcXFxcXDpibG9jazphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2Rpc3BsYXk6YmxvY2t9LmFmdGVyXFxcXFxcXFw6c2l6ZS1mdWxsOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uYWZ0ZXJcXFxcXFxcXDpjb250ZW50LW5vcm1hbDphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2FsaWduLWNvbnRlbnQ6bm9ybWFsfS5hZnRlclxcXFxcXFxcOnJvdW5kZWQtXFxcXFxcXFxbaW5oZXJpdFxcXFxcXFxcXTphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO2JvcmRlci1yYWRpdXM6aW5oZXJpdH0uYWZ0ZXJcXFxcXFxcXDpiZy1ncmFkaWVudC10by1iOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1ncmFkaWVudC1wb3NpdGlvbjp0byBib3R0b20gaW4gb2tsYWI7YmFja2dyb3VuZC1pbWFnZTpsaW5lYXItZ3JhZGllbnQodmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKX0uYWZ0ZXJcXFxcXFxcXDpmcm9tLXdoaXRlXFxcXFxcXFwvNTphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpOy0tdHctZ3JhZGllbnQtZnJvbTojZmZmZmZmMGR9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuYWZ0ZXJcXFxcXFxcXDpmcm9tLXdoaXRlXFxcXFxcXFwvNTphZnRlcnstLXR3LWdyYWRpZW50LWZyb206Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTUlLHRyYW5zcGFyZW50KX19LmFmdGVyXFxcXFxcXFw6ZnJvbS13aGl0ZVxcXFxcXFxcLzU6YWZ0ZXJ7LS10dy1ncmFkaWVudC1zdG9wczp2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LWZyb20pdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtdG8pdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKX0uYWZ0ZXJcXFxcXFxcXDp0by13aGl0ZVxcXFxcXFxcLzA6YWZ0ZXJ7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LWdyYWRpZW50LXRvOiMwMDAwfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmFmdGVyXFxcXFxcXFw6dG8td2hpdGVcXFxcXFxcXC8wOmFmdGVyey0tdHctZ3JhZGllbnQtdG86Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTAlLHRyYW5zcGFyZW50KX19LmFmdGVyXFxcXFxcXFw6dG8td2hpdGVcXFxcXFxcXC8wOmFmdGVyey0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9LmFmdGVyXFxcXFxcXFw6c2hhZG93LWdsYXNzOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1zaGFkb3c6dmFyKC0tc2hhZG93LWxnKSwwcHggLTQ4cHggNDhweCAtNDhweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIzAwMDAwMDBkKWluc2V0LDAgNXB4IDQycHggLTVweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsI2ZmZmZmZjQwKWluc2V0O2JveC1zaGFkb3c6dmFyKC0tdHctaW5zZXQtc2hhZG93KSx2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSx2YXIoLS10dy1yaW5nLXNoYWRvdyksdmFyKC0tdHctc2hhZG93KX0uYWZ0ZXJcXFxcXFxcXDp0cmFuc2l0aW9uLWNvbG9yczphZnRlcntjb250ZW50OnZhcigtLXR3LWNvbnRlbnQpO3RyYW5zaXRpb24tcHJvcGVydHk6Y29sb3IsYmFja2dyb3VuZC1jb2xvcixib3JkZXItY29sb3Isb3V0bGluZS1jb2xvcix0ZXh0LWRlY29yYXRpb24tY29sb3IsZmlsbCxzdHJva2UsLS10dy1ncmFkaWVudC1mcm9tLC0tdHctZ3JhZGllbnQtdmlhLC0tdHctZ3JhZGllbnQtdG87dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246dmFyKC0tdHctZWFzZSx2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSk7dHJhbnNpdGlvbi1kdXJhdGlvbjp2YXIoLS10dy1kdXJhdGlvbix2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb24pKX0uYWZ0ZXJcXFxcXFxcXDpkdXJhdGlvbi0xNTA6YWZ0ZXJ7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LWR1cmF0aW9uOi4xNXM7dHJhbnNpdGlvbi1kdXJhdGlvbjouMTVzfS5hZnRlclxcXFxcXFxcOmVhc2Utb3V0OmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1lYXNlOnZhcigtLWVhc2Utb3V0KTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjp2YXIoLS1lYXNlLW91dCl9LmZvY3VzLXdpdGhpblxcXFxcXFxcOm91dGxpbmUtbm9uZTpmb2N1cy13aXRoaW57LS10dy1vdXRsaW5lLXN0eWxlOm5vbmU7b3V0bGluZS1zdHlsZTpub25lfUBtZWRpYSAoaG92ZXI6aG92ZXIpey5ob3ZlclxcXFxcXFxcOmJvcmRlci1ibGFja1xcXFxcXFxcLzU6aG92ZXJ7Ym9yZGVyLWNvbG9yOiMwMDAwMDAwZH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5ob3ZlclxcXFxcXFxcOmJvcmRlci1ibGFja1xcXFxcXFxcLzU6aG92ZXJ7Ym9yZGVyLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1ibGFjayk1JSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOmJvcmRlci1ib3JkZXJcXFxcXFxcXC80MDpob3Zlcntib3JkZXItY29sb3I6IzcxNzE3YjY2fUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmhvdmVyXFxcXFxcXFw6Ym9yZGVyLWJvcmRlclxcXFxcXFxcLzQwOmhvdmVye2JvcmRlci1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItYm9yZGVyKTQwJSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOmJvcmRlci1yb3NlLTYwMFxcXFxcXFxcLzcwOmhvdmVye2JvcmRlci1jb2xvcjojZTcwMDQ0YjN9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuaG92ZXJcXFxcXFxcXDpib3JkZXItcm9zZS02MDBcXFxcXFxcXC83MDpob3Zlcntib3JkZXItY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXJvc2UtNjAwKTcwJSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOmJnLXJvc2UtNjAwXFxcXFxcXFwvNTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlNzAwNDQwZH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5ob3ZlclxcXFxcXFxcOmJnLXJvc2UtNjAwXFxcXFxcXFwvNTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1yb3NlLTYwMCk1JSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOmJnLXdoaXRlXFxcXFxcXFwvMDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMwMDAwfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmhvdmVyXFxcXFxcXFw6Ymctd2hpdGVcXFxcXFxcXC8wOmhvdmVye2JhY2tncm91bmQtY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXdoaXRlKTAlLHRyYW5zcGFyZW50KX19LmhvdmVyXFxcXFxcXFw6Ymctd2hpdGVcXFxcXFxcXC8yMDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmYzfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmhvdmVyXFxcXFxcXFw6Ymctd2hpdGVcXFxcXFxcXC8yMDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci13aGl0ZSkyMCUsdHJhbnNwYXJlbnQpfX0uaG92ZXJcXFxcXFxcXDpiZy16aW5jLTk1MFxcXFxcXFxcLzEwOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzA5MDkwYjFhfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmhvdmVyXFxcXFxcXFw6YmctemluYy05NTBcXFxcXFxcXC8xMDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTk1MCkxMCUsdHJhbnNwYXJlbnQpfX0uaG92ZXJcXFxcXFxcXDpmcm9tLXppbmMtMTAwXFxcXFxcXFwvNDA6aG92ZXJ7LS10dy1ncmFkaWVudC1mcm9tOiNmNGY0ZjU2Nn1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5ob3ZlclxcXFxcXFxcOmZyb20temluYy0xMDBcXFxcXFxcXC80MDpob3ZlcnstLXR3LWdyYWRpZW50LWZyb206Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLXppbmMtMTAwKTQwJSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOmZyb20temluYy0xMDBcXFxcXFxcXC80MDpob3ZlcnstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyx2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtZnJvbSl2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC10byl2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpfS5ob3ZlclxcXFxcXFxcOmZyb20tMjBcXFxcXFxcXCU6aG92ZXJ7LS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uOjIwJX0uaG92ZXJcXFxcXFxcXDp0by16aW5jLTEwMFxcXFxcXFxcLzA6aG92ZXJ7LS10dy1ncmFkaWVudC10bzojMDAwMH1Ac3VwcG9ydHMgKGNvbG9yOmNvbG9yLW1peChpbiBsYWIscmVkLHJlZCkpey5ob3ZlclxcXFxcXFxcOnRvLXppbmMtMTAwXFxcXFxcXFwvMDpob3ZlcnstLXR3LWdyYWRpZW50LXRvOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci16aW5jLTEwMCkwJSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOnRvLXppbmMtMTAwXFxcXFxcXFwvMDpob3ZlcnstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyx2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtZnJvbSl2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC10byl2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpfS5ob3ZlclxcXFxcXFxcOnRvLTc1XFxcXFxcXFwlOmhvdmVyey0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb246NzUlfS5ob3ZlclxcXFxcXFxcOnRleHQtcmVkLTUwMDpob3Zlcntjb2xvcjp2YXIoLS1jb2xvci1yZWQtNTAwKX0uaG92ZXJcXFxcXFxcXDpvcGFjaXR5LTkwOmhvdmVye29wYWNpdHk6Ljl9LmhvdmVyXFxcXFxcXFw6b3BhY2l0eS0xMDA6aG92ZXJ7b3BhY2l0eToxfS5ob3ZlclxcXFxcXFxcOnNoYWRvdy1sZzpob3ZlcnstLXR3LXNoYWRvdzowIDEwcHggMTVweCAtM3B4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwjMDAwMDAwMWEpLDAgNHB4IDZweCAtNHB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwjMDAwMDAwMWEpO2JveC1zaGFkb3c6dmFyKC0tdHctaW5zZXQtc2hhZG93KSx2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSx2YXIoLS10dy1yaW5nLXNoYWRvdyksdmFyKC0tdHctc2hhZG93KX0uaG92ZXJcXFxcXFxcXDpzaGFkb3cteHM6aG92ZXJ7LS10dy1zaGFkb3c6MCAxcHggMnB4IDAgdmFyKC0tdHctc2hhZG93LWNvbG9yLCMwMDAwMDAwZCk7Ym94LXNoYWRvdzp2YXIoLS10dy1pbnNldC1zaGFkb3cpLHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSx2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLHZhcigtLXR3LXJpbmctc2hhZG93KSx2YXIoLS10dy1zaGFkb3cpfS5ob3ZlclxcXFxcXFxcOmFmdGVyXFxcXFxcXFw6ZnJvbS1ibHVlLTUwXFxcXFxcXFwvMjA6aG92ZXI6YWZ0ZXJ7Y29udGVudDp2YXIoLS10dy1jb250ZW50KTstLXR3LWdyYWRpZW50LWZyb206I2VmZjZmZjMzfUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmhvdmVyXFxcXFxcXFw6YWZ0ZXJcXFxcXFxcXDpmcm9tLWJsdWUtNTBcXFxcXFxcXC8yMDpob3ZlcjphZnRlcnstLXR3LWdyYWRpZW50LWZyb206Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWJsdWUtNTApMjAlLHRyYW5zcGFyZW50KX19LmhvdmVyXFxcXFxcXFw6YWZ0ZXJcXFxcXFxcXDpmcm9tLWJsdWUtNTBcXFxcXFxcXC8yMDpob3ZlcjphZnRlcnstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyx2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtZnJvbSl2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC10byl2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpfS5ob3ZlclxcXFxcXFxcOmFmdGVyXFxcXFxcXFw6dG8tYmx1ZS01MFxcXFxcXFxcLzE1OmhvdmVyOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1ncmFkaWVudC10bzojZWZmNmZmMjZ9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuaG92ZXJcXFxcXFxcXDphZnRlclxcXFxcXFxcOnRvLWJsdWUtNTBcXFxcXFxcXC8xNTpob3ZlcjphZnRlcnstLXR3LWdyYWRpZW50LXRvOmNvbG9yLW1peChpbiBva2xhYix2YXIoLS1jb2xvci1ibHVlLTUwKTE1JSx0cmFuc3BhcmVudCl9fS5ob3ZlclxcXFxcXFxcOmFmdGVyXFxcXFxcXFw6dG8tYmx1ZS01MFxcXFxcXFxcLzE1OmhvdmVyOmFmdGVyey0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9fS5mb2N1c1xcXFxcXFxcOmJvcmRlci16aW5jLTUwMDpmb2N1c3tib3JkZXItY29sb3I6dmFyKC0tY29sb3ItemluYy01MDApfS5mb2N1c1xcXFxcXFxcOnRleHQtemluYy05MDA6Zm9jdXN7Y29sb3I6dmFyKC0tY29sb3ItemluYy05MDApfS5mb2N1c1xcXFxcXFxcOm91dGxpbmUtbm9uZTpmb2N1c3stLXR3LW91dGxpbmUtc3R5bGU6bm9uZTtvdXRsaW5lLXN0eWxlOm5vbmV9LmFjdGl2ZVxcXFxcXFxcOnNjYWxlLVxcXFxcXFxcWzk4XFxcXFxcXFwlXFxcXFxcXFxdOmFjdGl2ZXtzY2FsZTo5OCV9LmFjdGl2ZVxcXFxcXFxcOmJvcmRlci1ibGFja1xcXFxcXFxcLzE1OmFjdGl2ZXtib3JkZXItY29sb3I6IzAwMDAwMDI2fUBzdXBwb3J0cyAoY29sb3I6Y29sb3ItbWl4KGluIGxhYixyZWQscmVkKSl7LmFjdGl2ZVxcXFxcXFxcOmJvcmRlci1ibGFja1xcXFxcXFxcLzE1OmFjdGl2ZXtib3JkZXItY29sb3I6Y29sb3ItbWl4KGluIG9rbGFiLHZhcigtLWNvbG9yLWJsYWNrKTE1JSx0cmFuc3BhcmVudCl9fS5hY3RpdmVcXFxcXFxcXDphZnRlclxcXFxcXFxcOmZyb20tdHJhbnNwYXJlbnQ6YWN0aXZlOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1ncmFkaWVudC1mcm9tOnRyYW5zcGFyZW50Oy0tdHctZ3JhZGllbnQtc3RvcHM6dmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC1mcm9tKXZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLHZhcigtLXR3LWdyYWRpZW50LXRvKXZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSl9LmFjdGl2ZVxcXFxcXFxcOmFmdGVyXFxcXFxcXFw6dG8tdHJhbnNwYXJlbnQ6YWN0aXZlOmFmdGVye2NvbnRlbnQ6dmFyKC0tdHctY29udGVudCk7LS10dy1ncmFkaWVudC10bzp0cmFuc3BhcmVudDstLXR3LWdyYWRpZW50LXN0b3BzOnZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcyx2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksdmFyKC0tdHctZ3JhZGllbnQtZnJvbSl2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSx2YXIoLS10dy1ncmFkaWVudC10byl2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpfS5kaXNhYmxlZFxcXFxcXFxcOnBvaW50ZXItZXZlbnRzLW5vbmU6ZGlzYWJsZWR7cG9pbnRlci1ldmVudHM6bm9uZX0uZGlzYWJsZWRcXFxcXFxcXDpiZy1ibGFja1xcXFxcXFxcLzU6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojMDAwMDAwMGR9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuZGlzYWJsZWRcXFxcXFxcXDpiZy1ibGFja1xcXFxcXFxcLzU6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItYmxhY2spNSUsdHJhbnNwYXJlbnQpfX0uZGlzYWJsZWRcXFxcXFxcXDp0ZXh0LWZvcmVncm91bmRcXFxcXFxcXC82MDpkaXNhYmxlZHtjb2xvcjojMDkwOTBiOTl9QHN1cHBvcnRzIChjb2xvcjpjb2xvci1taXgoaW4gbGFiLHJlZCxyZWQpKXsuZGlzYWJsZWRcXFxcXFxcXDp0ZXh0LWZvcmVncm91bmRcXFxcXFxcXC82MDpkaXNhYmxlZHtjb2xvcjpjb2xvci1taXgoaW4gb2tsYWIsdmFyKC0tY29sb3ItZm9yZWdyb3VuZCk2MCUsdHJhbnNwYXJlbnQpfX0uZGlzYWJsZWRcXFxcXFxcXDpvcGFjaXR5LTMwOmRpc2FibGVke29wYWNpdHk6LjN9LmRhdGEtZm9jdXNcXFxcXFxcXDpvdXRsaW5lLW5vbmVbZGF0YS1mb2N1c117LS10dy1vdXRsaW5lLXN0eWxlOm5vbmU7b3V0bGluZS1zdHlsZTpub25lfS5hbmltYXRlLXNoYWtle2FuaW1hdGlvbjouNXMgZWFzZS1pbi1vdXQgMiBzaGFrZX19OnJvb3R7Y29sb3Itc2NoZW1lOm5vcm1hbDtmb250LWZlYXR1cmUtc2V0dGluZ3M6XCJsaWdhXCIgMSxcImNhbHRcIiAxO2JhY2tncm91bmQtY29sb3I6IzAwMDB9Ym9keXtiYWNrZ3JvdW5kLWNvbG9yOiMwMDAwfUBrZXlmcmFtZXMgc2hha2V7MCUsdG97dHJhbnNmb3JtOnRyYW5zbGF0ZSgwKX0xMCUsMzAlLDUwJSw3MCUsOTAle3RyYW5zZm9ybTp0cmFuc2xhdGUoLTJweCl9MjAlLDQwJSw2MCUsODAle3RyYW5zZm9ybTp0cmFuc2xhdGUoMnB4KX19QGtleWZyYW1lcyBncmFkaWVudC1hbmltYXRpb257MCV7YmFja2dyb3VuZC1wb3NpdGlvbjowJX01MCV7YmFja2dyb3VuZC1wb3NpdGlvbjoxMDAlfXRve2JhY2tncm91bmQtcG9zaXRpb246MCV9fSNoZWFkbGVzc3VpLXBvcnRhbC1yb290e3otaW5kZXg6NTA7d2lkdGg6MTAwdnc7aGVpZ2h0OjEwMHZoO3Bvc2l0aW9uOmZpeGVkfSNoZWFkbGVzc3VpLXBvcnRhbC1yb290Pip7cG9pbnRlci1ldmVudHM6YXV0b31AcHJvcGVydHkgLS10dy10cmFuc2xhdGUteHtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTowfUBwcm9wZXJ0eSAtLXR3LXRyYW5zbGF0ZS15e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjB9QHByb3BlcnR5IC0tdHctdHJhbnNsYXRlLXp7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6MH1AcHJvcGVydHkgLS10dy1zY2FsZS14e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjF9QHByb3BlcnR5IC0tdHctc2NhbGUteXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZToxfUBwcm9wZXJ0eSAtLXR3LXNjYWxlLXp7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6MX1AcHJvcGVydHkgLS10dy1yb3RhdGUteHtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctcm90YXRlLXl7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LXJvdGF0ZS16e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1za2V3LXh7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LXNrZXcteXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctc3BhY2UteS1yZXZlcnNle3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjB9QHByb3BlcnR5IC0tdHctc3BhY2UteC1yZXZlcnNle3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjB9QHByb3BlcnR5IC0tdHctZGl2aWRlLXktcmV2ZXJzZXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTowfUBwcm9wZXJ0eSAtLXR3LWJvcmRlci1zdHlsZXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTpzb2xpZH1AcHJvcGVydHkgLS10dy1ncmFkaWVudC1wb3NpdGlvbntzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctZ3JhZGllbnQtZnJvbXtzeW50YXg6XCI8Y29sb3I+XCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTojMDAwMH1AcHJvcGVydHkgLS10dy1ncmFkaWVudC12aWF7c3ludGF4OlwiPGNvbG9yPlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6IzAwMDB9QHByb3BlcnR5IC0tdHctZ3JhZGllbnQtdG97c3ludGF4OlwiPGNvbG9yPlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6IzAwMDB9QHByb3BlcnR5IC0tdHctZ3JhZGllbnQtc3RvcHN7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXZpYS1zdG9wc3tzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbntzeW50YXg6XCI8bGVuZ3RoLXBlcmNlbnRhZ2U+XCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTowJX1AcHJvcGVydHkgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb257c3ludGF4OlwiPGxlbmd0aC1wZXJjZW50YWdlPlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6NTAlfUBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9ue3N5bnRheDpcIjxsZW5ndGgtcGVyY2VudGFnZT5cIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjEwMCV9QHByb3BlcnR5IC0tdHctZm9udC13ZWlnaHR7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LXNoYWRvd3tzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTowIDAgIzAwMDB9QHByb3BlcnR5IC0tdHctc2hhZG93LWNvbG9ye3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1zaGFkb3ctYWxwaGF7c3ludGF4OlwiPHBlcmNlbnRhZ2U+XCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZToxMDAlfUBwcm9wZXJ0eSAtLXR3LWluc2V0LXNoYWRvd3tzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTowIDAgIzAwMDB9QHByb3BlcnR5IC0tdHctaW5zZXQtc2hhZG93LWNvbG9ye3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1pbnNldC1zaGFkb3ctYWxwaGF7c3ludGF4OlwiPHBlcmNlbnRhZ2U+XCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZToxMDAlfUBwcm9wZXJ0eSAtLXR3LXJpbmctY29sb3J7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LXJpbmctc2hhZG93e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjAgMCAjMDAwMH1AcHJvcGVydHkgLS10dy1pbnNldC1yaW5nLWNvbG9ye3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1pbnNldC1yaW5nLXNoYWRvd3tzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTowIDAgIzAwMDB9QHByb3BlcnR5IC0tdHctcmluZy1pbnNldHtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctcmluZy1vZmZzZXQtd2lkdGh7c3ludGF4OlwiPGxlbmd0aD5cIjtpbmhlcml0czpmYWxzZTtpbml0aWFsLXZhbHVlOjB9QHByb3BlcnR5IC0tdHctcmluZy1vZmZzZXQtY29sb3J7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6I2ZmZn1AcHJvcGVydHkgLS10dy1yaW5nLW9mZnNldC1zaGFkb3d7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6MCAwICMwMDAwfUBwcm9wZXJ0eSAtLXR3LW91dGxpbmUtc3R5bGV7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlO2luaXRpYWwtdmFsdWU6c29saWR9QHByb3BlcnR5IC0tdHctYmx1cntzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctYnJpZ2h0bmVzc3tzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctY29udHJhc3R7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWdyYXlzY2FsZXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctaHVlLXJvdGF0ZXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctaW52ZXJ0e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1vcGFjaXR5e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1zYXR1cmF0ZXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctc2VwaWF7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWRyb3Atc2hhZG93e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1kcm9wLXNoYWRvdy1jb2xvcntzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctZHJvcC1zaGFkb3ctYWxwaGF7c3ludGF4OlwiPHBlcmNlbnRhZ2U+XCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZToxMDAlfUBwcm9wZXJ0eSAtLXR3LWRyb3Atc2hhZG93LXNpemV7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWJsdXJ7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3N7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0e3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGV7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGV7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWludmVydHtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctYmFja2Ryb3Atb3BhY2l0eXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctYmFja2Ryb3Atc2F0dXJhdGV7c3ludGF4OlwiKlwiO2luaGVyaXRzOmZhbHNlfUBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLXNlcGlhe3N5bnRheDpcIipcIjtpbmhlcml0czpmYWxzZX1AcHJvcGVydHkgLS10dy1kdXJhdGlvbntzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctZWFzZXtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2V9QHByb3BlcnR5IC0tdHctY29udGVudHtzeW50YXg6XCIqXCI7aW5oZXJpdHM6ZmFsc2U7aW5pdGlhbC12YWx1ZTpcIlwifUBrZXlmcmFtZXMgc3Bpbnt0b3t0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgcHVsc2V7NTAle29wYWNpdHk6LjV9fScsIGZhbGxiYWNrU3RhdGUgPSB7XG4gIHN0YXRlOiBBZ2VudFN0YXRlVHlwZS5JRExFXG59LCBhZ2VudFN0YXRlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsbGJhY2tTdGF0ZSk7XG5mdW5jdGlvbiBBZ2VudFN0YXRlUHJvdmlkZXIoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IGFnZW50ID0gdXNlQWdlbnRzKCkuY29ubmVjdGVkLCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKGZhbGxiYWNrU3RhdGUpO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWdlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFnZW50LmFnZW50LnN0YXRlLmdldFN0YXRlLnN1YnNjcmliZSh2b2lkIDAsIHtcbiAgICAgICAgb25EYXRhOiAodmFsdWUpID0+IHtcbiAgICAgICAgICBzZXRTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6ICgpID0+IHtcbiAgICAgICAgICBzZXRTdGF0ZShmYWxsYmFja1N0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgICAgICBjb25zb2xlLmRlYnVnKFxuICAgICAgICAgICAgXCJbQWdlbnRTdGF0ZVByb3ZpZGVyXSBFcnJvciB1bnN1YnNjcmliaW5nIGZyb20gYWdlbnQgc3RhdGU6XCIsXG4gICAgICAgICAgICBlcnJvcjJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgc2V0U3RhdGUoZmFsbGJhY2tTdGF0ZSk7XG4gIH0sIFthZ2VudF0pLCAvKiBAX19QVVJFX18gKi8ganN4KGFnZW50U3RhdGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzdGF0ZSwgY2hpbGRyZW4gfSk7XG59XG5jb25zdCB1c2VBZ2VudFN0YXRlID0gKCkgPT4gdXNlQ29udGV4dChhZ2VudFN0YXRlQ29udGV4dCksIENoYXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gIGNoYXRJbnB1dDogXCJcIixcbiAgc2V0Q2hhdElucHV0OiAoKSA9PiB7XG4gIH0sXG4gIGRvbUNvbnRleHRFbGVtZW50czogW10sXG4gIGFkZENoYXREb21Db250ZXh0OiAoKSA9PiB7XG4gIH0sXG4gIHJlbW92ZUNoYXREb21Db250ZXh0OiAoKSA9PiB7XG4gIH0sXG4gIHNlbmRNZXNzYWdlOiAoKSA9PiB7XG4gIH0sXG4gIGlzUHJvbXB0Q3JlYXRpb25BY3RpdmU6ICExLFxuICBzdGFydFByb21wdENyZWF0aW9uOiAoKSA9PiB7XG4gIH0sXG4gIHN0b3BQcm9tcHRDcmVhdGlvbjogKCkgPT4ge1xuICB9LFxuICBpc1NlbmRpbmc6ICExXG59KSwgQ2hhdFN0YXRlUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IFtjaGF0SW5wdXQsIHNldENoYXRJbnB1dF0gPSB1c2VTdGF0ZShcIlwiKSwgW2lzUHJvbXB0Q3JlYXRpb25Nb2RlLCBzZXRJc1Byb21wdENyZWF0aW9uTW9kZV0gPSB1c2VTdGF0ZSghMSksIFtpc1NlbmRpbmcsIHNldElzU2VuZGluZ10gPSB1c2VTdGF0ZSghMSksIFtkb21Db250ZXh0RWxlbWVudHMsIHNldERvbUNvbnRleHRFbGVtZW50c10gPSB1c2VTdGF0ZShbXSksIHsgbWluaW1pemVkIH0gPSB1c2VBcHBTdGF0ZSgpLCB7IHBsdWdpbnMgfSA9IHVzZVBsdWdpbnMoKSwgeyBzZW5kTWVzc2FnZTogc2VuZEFnZW50TWVzc2FnZSB9ID0gdXNlQWdlbnRNZXNzYWdpbmcoKSwgeyBpc0NoYXRPcGVuIH0gPSB1c2VQYW5lbHMoKSwgYWdlbnRTdGF0ZSA9IHVzZUFnZW50U3RhdGUoKSwgc3RhcnRQcm9tcHRDcmVhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc1Byb21wdENyZWF0aW9uTW9kZSghMCksIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBwbHVnaW4ub25Qcm9tcHRpbmdTdGFydCkgPT0gbnVsbCB8fCBfYS5jYWxsKHBsdWdpbik7XG4gICAgfSk7XG4gIH0sIFtwbHVnaW5zXSksIHN0b3BQcm9tcHRDcmVhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc1Byb21wdENyZWF0aW9uTW9kZSghMSksIHNldERvbUNvbnRleHRFbGVtZW50cyhbXSksIHBsdWdpbnMuZm9yRWFjaCgocGx1Z2luKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSBwbHVnaW4ub25Qcm9tcHRpbmdBYm9ydCkgPT0gbnVsbCB8fCBfYS5jYWxsKHBsdWdpbik7XG4gICAgfSk7XG4gIH0sIFtwbHVnaW5zXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNDaGF0T3BlbiB8fCBzdG9wUHJvbXB0Q3JlYXRpb24oKTtcbiAgfSwgW2lzQ2hhdE9wZW4sIHN0b3BQcm9tcHRDcmVhdGlvbl0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1pbmltaXplZCAmJiBzdG9wUHJvbXB0Q3JlYXRpb24oKTtcbiAgfSwgW21pbmltaXplZF0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGFsbG93ZWRTdGF0ZXMgPSBbXG4gICAgICBBZ2VudFN0YXRlVHlwZS5JRExFLFxuICAgICAgQWdlbnRTdGF0ZVR5cGUuV0FJVElOR19GT1JfVVNFUl9SRVNQT05TRVxuICAgIF07XG4gICAgaXNQcm9tcHRDcmVhdGlvbk1vZGUgJiYgYWdlbnRTdGF0ZS5zdGF0ZSAmJiAhYWxsb3dlZFN0YXRlcy5pbmNsdWRlcyhhZ2VudFN0YXRlLnN0YXRlKSAmJiBzdG9wUHJvbXB0Q3JlYXRpb24oKTtcbiAgfSwgW2FnZW50U3RhdGUuc3RhdGUsIGlzUHJvbXB0Q3JlYXRpb25Nb2RlLCBzdG9wUHJvbXB0Q3JlYXRpb25dKTtcbiAgY29uc3QgYWRkQ2hhdERvbUNvbnRleHQgPSB1c2VDYWxsYmFjayhcbiAgICAoZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgcGx1Z2luc1dpdGhDb250ZXh0R2V0dGVycyA9IHBsdWdpbnMuZmlsdGVyKFxuICAgICAgICAocGx1Z2luKSA9PiBwbHVnaW4ub25Db250ZXh0RWxlbWVudFNlbGVjdFxuICAgICAgKTtcbiAgICAgIHNldERvbUNvbnRleHRFbGVtZW50cygocHJldikgPT4gW1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBwbHVnaW5Db250ZXh0OiBwbHVnaW5zV2l0aENvbnRleHRHZXR0ZXJzLm1hcCgocGx1Z2luKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBwbHVnaW5OYW1lOiBwbHVnaW4ucGx1Z2luTmFtZSxcbiAgICAgICAgICAgICAgY29udGV4dDogKF9hID0gcGx1Z2luLm9uQ29udGV4dEVsZW1lbnRTZWxlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHBsdWdpbiwgZWxlbWVudClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgXSk7XG4gICAgfSxcbiAgICBbcGx1Z2luc11cbiAgKSwgcmVtb3ZlQ2hhdERvbUNvbnRleHQgPSB1c2VDYWxsYmFjaygoZWxlbWVudCkgPT4ge1xuICAgIHNldERvbUNvbnRleHRFbGVtZW50cyhcbiAgICAgIChwcmV2KSA9PiBwcmV2LmZpbHRlcigoaXRlbSkgPT4gaXRlbS5lbGVtZW50ICE9PSBlbGVtZW50KVxuICAgICk7XG4gIH0sIFtdKSwgc2VuZE1lc3NhZ2UgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgaWYgKGNoYXRJbnB1dC50cmltKCkpIHtcbiAgICAgIHNldElzU2VuZGluZyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBiYXNlVXNlck1lc3NhZ2UgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgIGNvbnRlbnRJdGVtczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogY2hhdElucHV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBtZXRhZGF0YTogY29sbGVjdFVzZXJNZXNzYWdlTWV0YWRhdGEoXG4gICAgICAgICAgICBkb21Db250ZXh0RWxlbWVudHMubWFwKFxuICAgICAgICAgICAgICAoaXRlbSkgPT4gZ2V0U2VsZWN0ZWRFbGVtZW50SW5mbyhpdGVtLmVsZW1lbnQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSxcbiAgICAgICAgICBwbHVnaW5Db250ZW50OiB7fSxcbiAgICAgICAgICBzZW50QnlQbHVnaW46ICExXG4gICAgICAgIH0sIHBsdWdpblByb2Nlc3NpbmdQcm9taXNlcyA9IHBsdWdpbnMubWFwKGFzeW5jIChwbHVnaW4pID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgaGFuZGxlclJlc3VsdCA9IGF3YWl0ICgoX2EgPSBwbHVnaW4ub25Qcm9tcHRTZW5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChwbHVnaW4sIGJhc2VVc2VyTWVzc2FnZSkpO1xuICAgICAgICAgIGlmICghaGFuZGxlclJlc3VsdCB8fCAhaGFuZGxlclJlc3VsdC5jb250ZXh0U25pcHBldHMgfHwgaGFuZGxlclJlc3VsdC5jb250ZXh0U25pcHBldHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgY29uc3Qgc25pcHBldFByb21pc2VzID0gaGFuZGxlclJlc3VsdC5jb250ZXh0U25pcHBldHMubWFwKFxuICAgICAgICAgICAgYXN5bmMgKHNuaXBwZXQpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRDb250ZW50ID0gdHlwZW9mIHNuaXBwZXQuY29udGVudCA9PSBcInN0cmluZ1wiID8gc25pcHBldC5jb250ZW50IDogYXdhaXQgc25pcHBldC5jb250ZW50KCk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJvbXB0Q29udGV4dE5hbWU6IHNuaXBwZXQucHJvbXB0Q29udGV4dE5hbWUsXG4gICAgICAgICAgICAgICAgY29udGVudDogcmVzb2x2ZWRDb250ZW50XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSwgcmVzb2x2ZWRTbmlwcGV0cyA9IGF3YWl0IFByb21pc2UuYWxsKHNuaXBwZXRQcm9taXNlcyk7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmVkU25pcHBldHMubGVuZ3RoID4gMCA/IHtcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6IHBsdWdpbi5wbHVnaW5OYW1lLFxuICAgICAgICAgICAgY29udGV4dFNuaXBwZXRzOiByZXNvbHZlZFNuaXBwZXRzXG4gICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgIH0pLCBhbGxQbHVnaW5Db250ZXh0cyA9IGF3YWl0IFByb21pc2UuYWxsKHBsdWdpblByb2Nlc3NpbmdQcm9taXNlcyksIHBsdWdpbkNvbnRlbnQgPSB7fTtcbiAgICAgICAgYWxsUGx1Z2luQ29udGV4dHMuZm9yRWFjaCgoY29udGV4dCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQgJiYgKHBsdWdpbkNvbnRlbnRbY29udGV4dC5wbHVnaW5OYW1lXSA9IHt9LCBjb250ZXh0LmNvbnRleHRTbmlwcGV0cy5mb3JFYWNoKChzbmlwcGV0KSA9PiB7XG4gICAgICAgICAgICBwbHVnaW5Db250ZW50W2NvbnRleHQucGx1Z2luTmFtZV1bc25pcHBldC5wcm9tcHRDb250ZXh0TmFtZV0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBcXGBcXCR7c25pcHBldC5jb250ZW50fVxcYFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1c2VyTWVzc2FnZUlucHV0ID0ge1xuICAgICAgICAgIC4uLmJhc2VVc2VyTWVzc2FnZSxcbiAgICAgICAgICBwbHVnaW5Db250ZW50XG4gICAgICAgIH07XG4gICAgICAgIHNlbmRBZ2VudE1lc3NhZ2UodXNlck1lc3NhZ2VJbnB1dCksIHNldENoYXRJbnB1dChcIlwiKSwgc2V0RG9tQ29udGV4dEVsZW1lbnRzKFtdKSwgc2V0SXNQcm9tcHRDcmVhdGlvbk1vZGUoITEpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTZW5kaW5nKCExKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjaGF0SW5wdXQsIGRvbUNvbnRleHRFbGVtZW50cywgcGx1Z2lucywgc2VuZEFnZW50TWVzc2FnZV0pLCB2YWx1ZSA9IHtcbiAgICBjaGF0SW5wdXQsXG4gICAgc2V0Q2hhdElucHV0LFxuICAgIGRvbUNvbnRleHRFbGVtZW50cyxcbiAgICBhZGRDaGF0RG9tQ29udGV4dCxcbiAgICByZW1vdmVDaGF0RG9tQ29udGV4dCxcbiAgICBzZW5kTWVzc2FnZSxcbiAgICBpc1Byb21wdENyZWF0aW9uQWN0aXZlOiBpc1Byb21wdENyZWF0aW9uTW9kZSxcbiAgICBzdGFydFByb21wdENyZWF0aW9uLFxuICAgIHN0b3BQcm9tcHRDcmVhdGlvbixcbiAgICBpc1NlbmRpbmdcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ2hhdENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWUsIGNoaWxkcmVuIH0pO1xufTtcbmZ1bmN0aW9uIHVzZUNoYXRTdGF0ZSgpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoQ2hhdENvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlQ2hhdFN0YXRlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBDaGF0U3RhdGVQcm92aWRlclwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBDb250ZXh0UHJvdmlkZXJzKHtcbiAgY2hpbGRyZW4sXG4gIGNvbmZpZzogY29uZmlnMlxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChDb25maWdQcm92aWRlciwgeyBjb25maWc6IGNvbmZpZzIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEFnZW50UHJvdmlkZXIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQWdlbnRBdmFpbGFiaWxpdHlQcm92aWRlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChBZ2VudFN0YXRlUHJvdmlkZXIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQWdlbnRNZXNzYWdpbmdQcm92aWRlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQYW5lbHNQcm92aWRlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChQbHVnaW5Qcm92aWRlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChDaGF0U3RhdGVQcm92aWRlciwgeyBjaGlsZHJlbiB9KSB9KSB9KSB9KSB9KSB9KSB9KSB9KTtcbn1cbmZ1bmN0aW9uIHVzZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zLCBlbGVtZW50ID0gd2luZG93KSB7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCEodHlwZW9mIHdpbmRvdyA+IFwidVwiKSAmJiBlbGVtZW50KVxuICAgICAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpLCAoKSA9PiBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgfSwgW2V2ZW50TmFtZSwgaGFuZGxlciwgZWxlbWVudCwgb3B0aW9uc10pO1xufVxuZnVuY3Rpb24gSG90a2V5TGlzdGVuZXIoKSB7XG4gIGNvbnN0IHsgc3RhcnRQcm9tcHRDcmVhdGlvbiwgc3RvcFByb21wdENyZWF0aW9uLCBpc1Byb21wdENyZWF0aW9uQWN0aXZlIH0gPSB1c2VDaGF0U3RhdGUoKSwgeyBpc0NoYXRPcGVuLCBjbG9zZUNoYXQgfSA9IHVzZVBhbmVscygpLCBob3RLZXlIYW5kbGVyTWFwID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgLy8gRnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgcHJvcGFnYXRpb24gb2YgdGhlIGV2ZW50LlxuICAgICAgW0hvdGtleUFjdGlvbnMuQ1RSTF9BTFRfQ106ICgpID0+IGlzUHJvbXB0Q3JlYXRpb25BY3RpdmUgPyAhMSA6IChzdGFydFByb21wdENyZWF0aW9uKCksICEwKSxcbiAgICAgIFtIb3RrZXlBY3Rpb25zLkVTQ106ICgpID0+IGlzUHJvbXB0Q3JlYXRpb25BY3RpdmUgPyAoc3RvcFByb21wdENyZWF0aW9uKCksICEwKSA6IGlzQ2hhdE9wZW4gPyAoY2xvc2VDaGF0KCksICEwKSA6ICExXG4gICAgfSksXG4gICAgW1xuICAgICAgc3RhcnRQcm9tcHRDcmVhdGlvbixcbiAgICAgIHN0b3BQcm9tcHRDcmVhdGlvbixcbiAgICAgIGlzUHJvbXB0Q3JlYXRpb25BY3RpdmUsXG4gICAgICBpc0NoYXRPcGVuLFxuICAgICAgY2xvc2VDaGF0XG4gICAgXVxuICApLCBob3RLZXlMaXN0ZW5lciA9IHVzZUNhbGxiYWNrKFxuICAgIChldikgPT4ge1xuICAgICAgZm9yIChjb25zdCBbYWN0aW9uLCBkZWZpbml0aW9uXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgaG90a2V5QWN0aW9uRGVmaW5pdGlvbnNcbiAgICAgICkpXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmlzRXZlbnRNYXRjaGluZyhldikpIHtcbiAgICAgICAgICBob3RLZXlIYW5kbGVyTWFwW2FjdGlvbl0oKSAmJiAoZXYucHJldmVudERlZmF1bHQoKSwgZXYuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBbaG90S2V5SGFuZGxlck1hcF1cbiAgKTtcbiAgcmV0dXJuIHVzZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhvdEtleUxpc3RlbmVyLCB7XG4gICAgY2FwdHVyZTogITBcbiAgfSksIG51bGw7XG59XG5mdW5jdGlvbiB1c2VXaW5kb3dTaXplKCkge1xuICBjb25zdCBbc2l6ZTIsIHNldFNpemVdID0gdXNlU3RhdGUoe1xuICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICB9KSwgaGFuZGxlUmVzaXplID0gdXNlQ2FsbGJhY2soXG4gICAgKCkgPT4gc2V0U2l6ZSh7XG4gICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIH0pLFxuICAgIFtdXG4gICk7XG4gIHJldHVybiB1c2VFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSksIHNpemUyO1xufVxuZnVuY3Rpb24gdXNlQ3ljbGljVXBkYXRlKGZ1bmMsIGZyYW1lUmF0ZSkge1xuICBjb25zdCBhbmltYXRpb25GcmFtZUhhbmRsZSA9IHVzZVJlZih2b2lkIDApLCB0aW1lQmV0d2VlbkZyYW1lcyA9IHVzZU1lbW8oXG4gICAgKCkgPT4gMWUzIC8gZnJhbWVSYXRlLFxuICAgIFtmcmFtZVJhdGVdXG4gICksIGxhc3RDYWxsRnJhbWVUaW1lID0gdXNlUmVmKDApLCB1cGRhdGUgPSB1c2VDYWxsYmFjayhcbiAgICAoZnJhbWVUaW1lKSA9PiB7XG4gICAgICBmcmFtZVRpbWUgLSBsYXN0Q2FsbEZyYW1lVGltZS5jdXJyZW50ID49IHRpbWVCZXR3ZWVuRnJhbWVzICYmIChmdW5jKCksIGxhc3RDYWxsRnJhbWVUaW1lLmN1cnJlbnQgPSBmcmFtZVRpbWUpLCBhbmltYXRpb25GcmFtZUhhbmRsZS5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSk7XG4gICAgfSxcbiAgICBbZnVuYywgdGltZUJldHdlZW5GcmFtZXNdXG4gICk7XG4gIHVzZUVmZmVjdCgoKSA9PiAoYW5pbWF0aW9uRnJhbWVIYW5kbGUuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpLCAoKSA9PiB7XG4gICAgYW5pbWF0aW9uRnJhbWVIYW5kbGUuY3VycmVudCAmJiAoY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVIYW5kbGUuY3VycmVudCksIGFuaW1hdGlvbkZyYW1lSGFuZGxlLmN1cnJlbnQgPSB2b2lkIDApO1xuICB9KSwgW2ZyYW1lUmF0ZSwgdXBkYXRlXSk7XG59XG5mdW5jdGlvbiBIb3ZlcmVkSXRlbSh7IHJlZkVsZW1lbnQsIC4uLnByb3BzIH0pIHtcbiAgY29uc3QgYm94UmVmID0gdXNlUmVmKG51bGwpLCB3aW5kb3dTaXplID0gdXNlV2luZG93U2l6ZSgpLCB7IHBsdWdpbnMgfSA9IHVzZVBsdWdpbnMoKSwgaG92ZXJlZEVsZW1lbnRQbHVnaW5Db250ZXh0ID0gdXNlTWVtbygoKSA9PiByZWZFbGVtZW50ID8gcGx1Z2lucy5maWx0ZXIoXG4gICAgKHBsdWdpbikgPT4gcGx1Z2luLm9uQ29udGV4dEVsZW1lbnRTZWxlY3RcbiAgKS5tYXAoKHBsdWdpbikgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4ge1xuICAgICAgcGx1Z2luTmFtZTogcGx1Z2luLnBsdWdpbk5hbWUsXG4gICAgICBjb250ZXh0OiAoX2EgPSBwbHVnaW4ub25Db250ZXh0RWxlbWVudFNlbGVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocGx1Z2luLCByZWZFbGVtZW50KVxuICAgIH07XG4gIH0pIDogW10sIFtyZWZFbGVtZW50XSksIHVwZGF0ZUJveFBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChib3hSZWYuY3VycmVudCAmJiByZWZFbGVtZW50KSB7XG4gICAgICBjb25zdCByZWZlcmVuY2VSZWN0ID0gcmVmRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJveFJlZi5jdXJyZW50LnN0eWxlLnRvcCA9IFxcYFxcJHtyZWZlcmVuY2VSZWN0LnRvcCAtIDJ9cHhcXGAsIGJveFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBcXGBcXCR7cmVmZXJlbmNlUmVjdC5sZWZ0IC0gMn1weFxcYCwgYm94UmVmLmN1cnJlbnQuc3R5bGUud2lkdGggPSBcXGBcXCR7cmVmZXJlbmNlUmVjdC53aWR0aCArIDR9cHhcXGAsIGJveFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IFxcYFxcJHtyZWZlcmVuY2VSZWN0LmhlaWdodCArIDR9cHhcXGAsIGJveFJlZi5jdXJyZW50LnN0eWxlLmRpc3BsYXkgPSB2b2lkIDA7XG4gICAgfSBlbHNlXG4gICAgICBib3hSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBcIjBweFwiLCBib3hSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IFwiMHB4XCIsIGJveFJlZi5jdXJyZW50LnN0eWxlLnRvcCA9IFxcYFxcJHt3aW5kb3dTaXplLmhlaWdodCAvIDJ9cHhcXGAsIGJveFJlZi5jdXJyZW50LnN0eWxlLmxlZnQgPSBcXGBcXCR7d2luZG93U2l6ZS53aWR0aCAvIDJ9cHhcXGAsIGJveFJlZi5jdXJyZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgfSwgW3JlZkVsZW1lbnQsIHdpbmRvd1NpemUuaGVpZ2h0LCB3aW5kb3dTaXplLndpZHRoXSk7XG4gIHJldHVybiB1c2VDeWNsaWNVcGRhdGUodXBkYXRlQm94UG9zaXRpb24sIDMwKSwgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgXCJmaXhlZCB6LTEwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtc20gYm9yZGVyLTIgYm9yZGVyLWJsdWUtNjAwLzcwIGJvcmRlci1kb3R0ZWQgYmctYmx1ZS02MDAvNSB0ZXh0LXdoaXRlIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTEwMFwiXG4gICAgICApLFxuICAgICAgcmVmOiBib3hSZWYsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiYWJzb2x1dGUgdG9wLTAuNSBsZWZ0LTAuNSBmbGV4IHctZnVsbCBmbGV4LXJvdyBpdGVtcy1zdGFydCBqdXN0aWZ5LXN0YXJ0IGdhcC0xXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZ2FwLTAuNSBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1tZCBiZy16aW5jLTcwMC84MCBweC0xIHB5LTAgZm9udC1tZWRpdW0gdGV4dC13aGl0ZSB0ZXh0LXhzXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJ0cnVuY2F0ZVwiLCBjaGlsZHJlbjogcmVmRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgfSkgfSksXG4gICAgICAgIGhvdmVyZWRFbGVtZW50UGx1Z2luQ29udGV4dC5maWx0ZXIoKHBsdWdpbikgPT4gcGx1Z2luLmNvbnRleHQuYW5ub3RhdGlvbikubWFwKChwbHVnaW4pID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGdhcC0wLjUgb3ZlcmZsb3ctaGlkZGVuIHJvdW5kZWQtbWQgYmctemluYy03MDAvODAgcHgtMSBweS0wIGZvbnQtbWVkaXVtIHRleHQtd2hpdGUgdGV4dC14c1wiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInNpemUtMyBzaHJpbmstMCBzdHJva2Utd2hpdGUgdGV4dC13aGl0ZSAqOnNpemUtZnVsbFwiLCBjaGlsZHJlbjogKF9hID0gcGx1Z2lucy5maW5kKChwMikgPT4gcDIucGx1Z2luTmFtZSA9PT0gcGx1Z2luLnBsdWdpbk5hbWUpKSA9PSBudWxsID8gdm9pZCAwIDogX2EuaWNvblN2ZyB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJ0cnVuY2F0ZVwiLCBjaGlsZHJlbjogcGx1Z2luLmNvbnRleHQuYW5ub3RhdGlvbiB9KVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGx1Z2luLnBsdWdpbk5hbWVcbiAgICAgICAgICApO1xuICAgICAgICB9KVxuICAgICAgXSB9KVxuICAgIH1cbiAgKTtcbn1cbmNvbnN0IENvbnRleHRDaGlwSG92ZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh2b2lkIDApO1xuZnVuY3Rpb24gQ29udGV4dENoaXBIb3ZlclByb3ZpZGVyKHtcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgW2hvdmVyZWRFbGVtZW50LCBzZXRIb3ZlcmVkRWxlbWVudF0gPSB1c2VTdGF0ZShcbiAgICBudWxsXG4gICksIHsgZG9tQ29udGV4dEVsZW1lbnRzIH0gPSB1c2VDaGF0U3RhdGUoKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaG92ZXJlZEVsZW1lbnQgJiYgKGRvbUNvbnRleHRFbGVtZW50cy5zb21lKFxuICAgICAgKGNvbnRleHRFbCkgPT4gY29udGV4dEVsLmVsZW1lbnQgPT09IGhvdmVyZWRFbGVtZW50XG4gICAgKSB8fCBzZXRIb3ZlcmVkRWxlbWVudChudWxsKSk7XG4gIH0sIFtob3ZlcmVkRWxlbWVudCwgZG9tQ29udGV4dEVsZW1lbnRzXSksIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgQ29udGV4dENoaXBIb3ZlckNvbnRleHQuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IHsgaG92ZXJlZEVsZW1lbnQsIHNldEhvdmVyZWRFbGVtZW50IH0sXG4gICAgICBjaGlsZHJlblxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHVzZUNvbnRleHRDaGlwSG92ZXIoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENvbnRleHRDaGlwSG92ZXJDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInVzZUNvbnRleHRDaGlwSG92ZXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIENvbnRleHRDaGlwSG92ZXJQcm92aWRlclwiXG4gICAgKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBTZWxlY3RlZEl0ZW0oe1xuICByZWZFbGVtZW50LFxuICBpc0NoaXBIb3ZlcmVkLFxuICAuLi5wcm9wc1xufSkge1xuICBjb25zdCBib3hSZWYgPSB1c2VSZWYobnVsbCksIHdpbmRvd1NpemUgPSB1c2VXaW5kb3dTaXplKCksIHVwZGF0ZUJveFBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChib3hSZWYuY3VycmVudClcbiAgICAgIGlmIChyZWZFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZVJlY3QgPSByZWZFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBib3hSZWYuY3VycmVudC5zdHlsZS50b3AgPSBcXGBcXCR7cmVmZXJlbmNlUmVjdC50b3AgLSAyfXB4XFxgLCBib3hSZWYuY3VycmVudC5zdHlsZS5sZWZ0ID0gXFxgXFwke3JlZmVyZW5jZVJlY3QubGVmdCAtIDJ9cHhcXGAsIGJveFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gXFxgXFwke3JlZmVyZW5jZVJlY3Qud2lkdGggKyA0fXB4XFxgLCBib3hSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBcXGBcXCR7cmVmZXJlbmNlUmVjdC5oZWlnaHQgKyA0fXB4XFxgLCBib3hSZWYuY3VycmVudC5zdHlsZS5kaXNwbGF5ID0gdm9pZCAwO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGJveFJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IFwiMHB4XCIsIGJveFJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gXCIwcHhcIiwgYm94UmVmLmN1cnJlbnQuc3R5bGUudG9wID0gXFxgXFwke3dpbmRvd1NpemUuaGVpZ2h0IC8gMn1weFxcYCwgYm94UmVmLmN1cnJlbnQuc3R5bGUubGVmdCA9IFxcYFxcJHt3aW5kb3dTaXplLndpZHRoIC8gMn1weFxcYCwgYm94UmVmLmN1cnJlbnQuc3R5bGUub3BhY2l0eSA9IFwibm9uZVwiO1xuICB9LCBbcmVmRWxlbWVudCwgd2luZG93U2l6ZS5oZWlnaHQsIHdpbmRvd1NpemUud2lkdGhdKTtcbiAgcmV0dXJuIHVzZUN5Y2xpY1VwZGF0ZSh1cGRhdGVCb3hQb3NpdGlvbiwgMzApLCAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwiYnV0dG9uXCIsXG4gICAge1xuICAgICAgLi4ucHJvcHMsXG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBcInBvaW50ZXItZXZlbnRzLWF1dG8gZml4ZWQgZmxleCBjdXJzb3Itbm90LWFsbG93ZWQgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtc20gYm9yZGVyLTIgYm9yZGVyLXppbmMtNjAwLzcwIGJvcmRlci1kb3R0ZWQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMTAwIGhvdmVyOmJvcmRlci1yb3NlLTYwMC83MCBob3ZlcjpiZy1yb3NlLTYwMC81XCIsXG4gICAgICAgIGlzQ2hpcEhvdmVyZWQgJiYgXCJib3JkZXItYmx1ZS02MDAvNzAgYmctYmx1ZS02MDAvNVwiXG4gICAgICApLFxuICAgICAgb25DbGljazogcHJvcHMub25SZW1vdmVDbGljayxcbiAgICAgIHJlZjogYm94UmVmXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gRE9NQ29udGV4dFNlbGVjdG9yKCkge1xuICBjb25zdCB7XG4gICAgZG9tQ29udGV4dEVsZW1lbnRzLFxuICAgIGFkZENoYXREb21Db250ZXh0LFxuICAgIGlzUHJvbXB0Q3JlYXRpb25BY3RpdmUsXG4gICAgcmVtb3ZlQ2hhdERvbUNvbnRleHRcbiAgfSA9IHVzZUNoYXRTdGF0ZSgpLCBzaG91bGRTaG93ID0gaXNQcm9tcHRDcmVhdGlvbkFjdGl2ZSwgW2hvdmVyZWRFbGVtZW50LCBzZXRIb3ZlcmVkRWxlbWVudF0gPSB1c2VTdGF0ZShcbiAgICBudWxsXG4gICksIHsgaG92ZXJlZEVsZW1lbnQ6IGNoaXBIb3ZlcmVkRWxlbWVudCB9ID0gdXNlQ29udGV4dENoaXBIb3ZlcigpLCBoYW5kbGVFbGVtZW50U2VsZWN0ZWQgPSB1c2VDYWxsYmFjayhcbiAgICAoZWwpID0+IHtcbiAgICAgIGRvbUNvbnRleHRFbGVtZW50cy5maW5kKFxuICAgICAgICAoY29udGV4dEVsKSA9PiBjb250ZXh0RWwuZWxlbWVudCA9PT0gZWxcbiAgICAgICkgfHwgYWRkQ2hhdERvbUNvbnRleHQoZWwpO1xuICAgIH0sXG4gICAgW2FkZENoYXREb21Db250ZXh0LCBkb21Db250ZXh0RWxlbWVudHNdXG4gICksIGhvdmVyZWRTZWxlY3RlZEVsZW1lbnQgPSBob3ZlcmVkRWxlbWVudCA/IGRvbUNvbnRleHRFbGVtZW50cy5maW5kKChlbCkgPT4gZWwuZWxlbWVudCA9PT0gaG92ZXJlZEVsZW1lbnQpIDogbnVsbCwgc2VsZWN0ZWRJdGVtcyA9IHVzZU1lbW8oKCkgPT4gZG9tQ29udGV4dEVsZW1lbnRzLm1hcCgoZWwpID0+IGVsLmVsZW1lbnQpLCBbZG9tQ29udGV4dEVsZW1lbnRzXSksIGxhc3RIb3ZlcmVkRWxlbWVudCA9IHVzZVJlZihudWxsKSwgbW91c2VTdGF0ZSA9IHVzZVJlZihudWxsKSwgbmV4dFVwZGF0ZVRpbWVvdXQgPSB1c2VSZWYobnVsbCksIFtob3ZlcnNBZGRhYmxlLCBzZXRIb3ZlcnNBZGRhYmxlXSA9IHVzZVN0YXRlKCExKSwgdXBkYXRlSG92ZXJlZEVsZW1lbnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFtb3VzZVN0YXRlLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCByZWZFbGVtZW50ID0gZ2V0RWxlbWVudEF0UG9pbnQoXG4gICAgICBtb3VzZVN0YXRlLmN1cnJlbnQubGFzdFgsXG4gICAgICBtb3VzZVN0YXRlLmN1cnJlbnQubGFzdFlcbiAgICApO1xuICAgIGlmIChzZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKHJlZkVsZW1lbnQpKSB7XG4gICAgICBzZXRIb3ZlcnNBZGRhYmxlKCExKSwgbGFzdEhvdmVyZWRFbGVtZW50LmN1cnJlbnQgPSBudWxsLCBzZXRIb3ZlcmVkRWxlbWVudChudWxsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGFzdEhvdmVyZWRFbGVtZW50LmN1cnJlbnQgIT09IHJlZkVsZW1lbnQgJiYgKGxhc3RIb3ZlcmVkRWxlbWVudC5jdXJyZW50ID0gcmVmRWxlbWVudCwgc2V0SG92ZXJlZEVsZW1lbnQocmVmRWxlbWVudCksIHNldEhvdmVyc0FkZGFibGUoITApKTtcbiAgfSwgW3NlbGVjdGVkSXRlbXNdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB1cGRhdGVIb3ZlcmVkRWxlbWVudCgpO1xuICB9LCBbdXBkYXRlSG92ZXJlZEVsZW1lbnRdKTtcbiAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50KSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKSwgZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtICgoKF9hID0gbW91c2VTdGF0ZS5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EubGFzdFgpID8/IGV2ZW50LmNsaWVudFgpLCBkZWx0YVkgPSBldmVudC5jbGllbnRZIC0gKCgoX2IgPSBtb3VzZVN0YXRlLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5sYXN0WSkgPz8gZXZlbnQuY2xpZW50WSksIGRlbHRhVGltZSA9IGN1cnJlbnRUaW1lc3RhbXAgLSAoKChfYyA9IG1vdXNlU3RhdGUuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmxhc3RUaW1lc3RhbXApID8/IGN1cnJlbnRUaW1lc3RhbXApLCBkaXN0YW5jZSA9IE1hdGguaHlwb3QoZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgbW91c2VTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgICBsYXN0WDogZGVsdGFUaW1lID4gMCA/IGV2ZW50LmNsaWVudFggOiAoX2QgPSBtb3VzZVN0YXRlLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZC5sYXN0WCxcbiAgICAgICAgbGFzdFk6IGRlbHRhVGltZSA+IDAgPyBldmVudC5jbGllbnRZIDogKF9lID0gbW91c2VTdGF0ZS5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2UubGFzdFksXG4gICAgICAgIHZlbG9jaXR5OiBkZWx0YVRpbWUgPiAwID8gZGlzdGFuY2UgLyBkZWx0YVRpbWUgKiAxZTMgOiAwLFxuICAgICAgICBsYXN0VGltZXN0YW1wOiBjdXJyZW50VGltZXN0YW1wXG4gICAgICB9LCAoKF9mID0gbW91c2VTdGF0ZS5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2YudmVsb2NpdHkpID4gMzAgPyAobmV4dFVwZGF0ZVRpbWVvdXQuY3VycmVudCAmJiBjbGVhclRpbWVvdXQobmV4dFVwZGF0ZVRpbWVvdXQuY3VycmVudCksIG5leHRVcGRhdGVUaW1lb3V0LmN1cnJlbnQgPSBzZXRUaW1lb3V0KHVwZGF0ZUhvdmVyZWRFbGVtZW50LCAxZTMgLyAyOCkpIDogbmV4dFVwZGF0ZVRpbWVvdXQuY3VycmVudCB8fCAobmV4dFVwZGF0ZVRpbWVvdXQuY3VycmVudCA9IHNldFRpbWVvdXQodXBkYXRlSG92ZXJlZEVsZW1lbnQsIDFlMyAvIDI4KSk7XG4gICAgfSxcbiAgICBbdXBkYXRlSG92ZXJlZEVsZW1lbnRdXG4gICksIGhhbmRsZU1vdXNlTGVhdmUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KG5leHRVcGRhdGVUaW1lb3V0LmN1cnJlbnQpLCBsYXN0SG92ZXJlZEVsZW1lbnQuY3VycmVudCA9IG51bGwsIHNldEhvdmVyZWRFbGVtZW50KG51bGwpO1xuICB9LCBbXSksIGhhbmRsZU1vdXNlQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQpID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCksIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLCBsYXN0SG92ZXJlZEVsZW1lbnQuY3VycmVudCAmJiAoc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhsYXN0SG92ZXJlZEVsZW1lbnQuY3VycmVudCkgfHwgaGFuZGxlRWxlbWVudFNlbGVjdGVkKGxhc3RIb3ZlcmVkRWxlbWVudC5jdXJyZW50KSk7XG4gICAgfSxcbiAgICBbaGFuZGxlRWxlbWVudFNlbGVjdGVkLCBzZWxlY3RlZEl0ZW1zXVxuICApO1xuICByZXR1cm4gc2hvdWxkU2hvdyA/IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50cy1hdXRvIGZpeGVkIGluc2V0LTAgaC1zY3JlZW4gdy1zY3JlZW5cIixcbiAgICAgICAgaG92ZXJzQWRkYWJsZSA/IFwiY3Vyc29yLWNvcHlcIiA6IFwiY3Vyc29yLWRlZmF1bHRcIlxuICAgICAgKSxcbiAgICAgIGlkOiBcImVsZW1lbnQtc2VsZWN0b3JcIixcbiAgICAgIG9uTW91c2VNb3ZlOiBoYW5kbGVNb3VzZU1vdmUsXG4gICAgICBvbk1vdXNlTGVhdmU6IGhhbmRsZU1vdXNlTGVhdmUsXG4gICAgICBvbkNsaWNrOiBoYW5kbGVNb3VzZUNsaWNrLFxuICAgICAgcm9sZTogXCJidXR0b25cIixcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgaG92ZXJlZEVsZW1lbnQgJiYgIWhvdmVyZWRTZWxlY3RlZEVsZW1lbnQgJiYgLyogQF9fUFVSRV9fICovIGpzeChIb3ZlcmVkSXRlbSwgeyByZWZFbGVtZW50OiBob3ZlcmVkRWxlbWVudCB9KSxcbiAgICAgICAgZG9tQ29udGV4dEVsZW1lbnRzLm1hcCgoZWwpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgU2VsZWN0ZWRJdGVtLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJlZkVsZW1lbnQ6IGVsLmVsZW1lbnQsXG4gICAgICAgICAgICBpc0NoaXBIb3ZlcmVkOiBjaGlwSG92ZXJlZEVsZW1lbnQgPT09IGVsLmVsZW1lbnQsXG4gICAgICAgICAgICBvblJlbW92ZUNsaWNrOiAoKSA9PiByZW1vdmVDaGF0RG9tQ29udGV4dChlbC5lbGVtZW50KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0WFBhdGhGb3JFbGVtZW50KGVsLmVsZW1lbnQsICEwKVxuICAgICAgICApKVxuICAgICAgXVxuICAgIH1cbiAgKSA6IG51bGw7XG59XG5jb25zdCBEcmFnZ2FibGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgbnVsbFxuKSwgRHJhZ2dhYmxlUHJvdmlkZXIgPSAoe1xuICBjb250YWluZXJSZWYsXG4gIGNoaWxkcmVuLFxuICBzbmFwQXJlYXMsXG4gIG9uRHJhZ1N0YXJ0LFxuICBvbkRyYWdFbmRcbn0pID0+IHtcbiAgY29uc3QgW2JvcmRlckxvY2F0aW9uLCBzZXRCb3JkZXJMb2NhdGlvbl0gPSB1c2VTdGF0ZSh7XG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwXG4gIH0pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY29udGFpbmVyUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBjb25zdCB1cGRhdGVCb3JkZXJMb2NhdGlvbiA9ICgpID0+IHtcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyUmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHNldEJvcmRlckxvY2F0aW9uKHtcbiAgICAgICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgICByaWdodDogcmVjdC5yaWdodCxcbiAgICAgICAgICBib3R0b206IHJlY3QuYm90dG9tXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdXBkYXRlQm9yZGVyTG9jYXRpb24oKTtcbiAgICBjb25zdCByZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcih1cGRhdGVCb3JkZXJMb2NhdGlvbik7XG4gICAgcmV0dXJuIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyUmVmLmN1cnJlbnQpLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1cGRhdGVCb3JkZXJMb2NhdGlvbiksICgpID0+IHtcbiAgICAgIGNvbnRhaW5lclJlZi5jdXJyZW50ICYmIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShjb250YWluZXJSZWYuY3VycmVudCksIHJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlQm9yZGVyTG9jYXRpb24pO1xuICAgIH07XG4gIH0sIFtjb250YWluZXJSZWZdKTtcbiAgY29uc3QgZHJhZ1N0YXJ0TGlzdGVuZXJzID0gdXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLCBkcmFnRW5kTGlzdGVuZXJzID0gdXNlUmVmKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLCByZWdpc3RlckRyYWdTdGFydCA9IHVzZUNhbGxiYWNrKChjYikgPT4gKGRyYWdTdGFydExpc3RlbmVycy5jdXJyZW50LmFkZChjYiksICgpID0+IGRyYWdTdGFydExpc3RlbmVycy5jdXJyZW50LmRlbGV0ZShjYikpLCBbXSksIHJlZ2lzdGVyRHJhZ0VuZCA9IHVzZUNhbGxiYWNrKChjYikgPT4gKGRyYWdFbmRMaXN0ZW5lcnMuY3VycmVudC5hZGQoY2IpLCAoKSA9PiBkcmFnRW5kTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGNiKSksIFtdKSwgZW1pdERyYWdTdGFydCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBvbkRyYWdTdGFydCAmJiBvbkRyYWdTdGFydCgpLCBkcmFnU3RhcnRMaXN0ZW5lcnMuY3VycmVudC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH0sIFtvbkRyYWdTdGFydF0pLCBlbWl0RHJhZ0VuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBvbkRyYWdFbmQgJiYgb25EcmFnRW5kKCksIGRyYWdFbmRMaXN0ZW5lcnMuY3VycmVudC5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH0sIFtvbkRyYWdFbmRdKSwgY29udGV4dFZhbHVlID0ge1xuICAgIGJvcmRlckxvY2F0aW9uLFxuICAgIHNuYXBBcmVhcyxcbiAgICByZWdpc3RlckRyYWdTdGFydCxcbiAgICByZWdpc3RlckRyYWdFbmQsXG4gICAgZW1pdERyYWdTdGFydCxcbiAgICBlbWl0RHJhZ0VuZFxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChEcmFnZ2FibGVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBjb250ZXh0VmFsdWUuYm9yZGVyTG9jYXRpb24ucmlnaHQgLSBjb250ZXh0VmFsdWUuYm9yZGVyTG9jYXRpb24ubGVmdCA+IDAgJiYgY29udGV4dFZhbHVlLmJvcmRlckxvY2F0aW9uLmJvdHRvbSAtIGNvbnRleHRWYWx1ZS5ib3JkZXJMb2NhdGlvbi50b3AgPiAwICYmIGNoaWxkcmVuIH0pO1xufTtcbmZ1bmN0aW9uIHVzZURyYWdnYWJsZShjb25maWcyKSB7XG4gIGNvbnN0IHByb3ZpZGVyRGF0YSA9IHVzZUNvbnRleHQoRHJhZ2dhYmxlQ29udGV4dCksIGxhdGVzdFByb3ZpZGVyRGF0YVJlZiA9IHVzZVJlZihwcm92aWRlckRhdGEpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxhdGVzdFByb3ZpZGVyRGF0YVJlZi5jdXJyZW50ID0gcHJvdmlkZXJEYXRhO1xuICB9LCBbcHJvdmlkZXJEYXRhXSk7XG4gIGNvbnN0IG1vdmluZ0VsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCksIGRyYWdJbml0aWF0b3JSZWYgPSB1c2VSZWYobnVsbCksIFttb3ZpbmdFbGVtZW50Tm9kZSwgc2V0TW92aW5nRWxlbWVudE5vZGVdID0gdXNlU3RhdGUobnVsbCksIFtkcmFnSW5pdGlhdG9yTm9kZSwgc2V0RHJhZ0luaXRpYXRvck5vZGVdID0gdXNlU3RhdGUobnVsbCksIG1vdXNlVG9EcmFnZ2FibGVDZW50ZXJPZmZzZXRSZWYgPSB1c2VSZWYobnVsbCksIG1vdXNlRG93blBvc1JlZiA9IHVzZVJlZihudWxsKSwgY3VycmVudE1vdXNlUG9zUmVmID0gdXNlUmVmKG51bGwpLCBpc0RyYWdnaW5nUmVmID0gdXNlUmVmKCExKSwgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gdXNlU3RhdGUoITEpLCBwZXJzaXN0ZWRSZWxhdGl2ZUNlbnRlclJlZiA9IHVzZVJlZihjb25maWcyLmluaXRpYWxSZWxhdGl2ZUNlbnRlciksIFtjdXJyZW50U25hcEFyZWEsIHNldEN1cnJlbnRTbmFwQXJlYV0gPSB1c2VTdGF0ZShudWxsKSwge1xuICAgIHN0YXJ0VGhyZXNob2xkID0gMyxcbiAgICBhcmVhU25hcFRocmVzaG9sZCA9IDYwLFxuICAgIC8vIHB4LCBkZWZhdWx0IHRocmVzaG9sZCBmb3Igc25hcHBpbmdcbiAgICBvbkRyYWdTdGFydCxcbiAgICBvbkRyYWdFbmQsXG4gICAgaW5pdGlhbFNuYXBBcmVhLFxuICAgIHNwcmluZ1N0aWZmbmVzcyA9IDAuMixcbiAgICAvLyBEZWZhdWx0IHNwcmluZyBzdGlmZm5lc3NcbiAgICBzcHJpbmdEYW1wbmVzcyA9IDAuNTVcbiAgICAvLyBEZWZhdWx0IHNwcmluZyBkYW1wbmVzc1xuICAgIC8vIGluaXRpYWxSZWxhdGl2ZUNlbnRlciBpcyB1c2VkIHRvIGluaXRpYWxpemUgcGVyc2lzdGVkUmVsYXRpdmVDZW50ZXJSZWZcbiAgfSA9IGNvbmZpZzIsIGFuaW1hdGVkUG9zaXRpb25SZWYgPSB1c2VSZWYobnVsbCksIHZlbG9jaXR5UmVmID0gdXNlUmVmKHsgeDogMCwgeTogMCB9KSwgaGFzQW5pbWF0ZWRPbmNlUmVmID0gdXNlUmVmKCExKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhbFNuYXBBcmVhICYmIHByb3ZpZGVyRGF0YSAmJiBwcm92aWRlckRhdGEuYm9yZGVyTG9jYXRpb24gJiYgcHJvdmlkZXJEYXRhLnNuYXBBcmVhcyAmJiBwcm92aWRlckRhdGEuc25hcEFyZWFzW2luaXRpYWxTbmFwQXJlYV0gJiYgIWlzRHJhZ2dpbmdSZWYuY3VycmVudCkge1xuICAgICAgY29uc3QgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSA9IHByb3ZpZGVyRGF0YS5ib3JkZXJMb2NhdGlvbiwgd2lkdGggPSByaWdodCAtIGxlZnQsIGhlaWdodCA9IGJvdHRvbSAtIHRvcCwgY2VudGVyID0ge1xuICAgICAgICB0b3BMZWZ0OiB7IHg6IGxlZnQsIHk6IHRvcCB9LFxuICAgICAgICB0b3BSaWdodDogeyB4OiByaWdodCwgeTogdG9wIH0sXG4gICAgICAgIGJvdHRvbUxlZnQ6IHsgeDogbGVmdCwgeTogYm90dG9tIH0sXG4gICAgICAgIGJvdHRvbVJpZ2h0OiB7IHg6IHJpZ2h0LCB5OiBib3R0b20gfVxuICAgICAgfVtpbml0aWFsU25hcEFyZWFdO1xuICAgICAgaWYgKGNlbnRlciAmJiB3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xuICAgICAgICBjb25zdCByZWxYID0gKGNlbnRlci54IC0gbGVmdCkgLyB3aWR0aCwgcmVsWSA9IChjZW50ZXIueSAtIHRvcCkgLyBoZWlnaHQ7XG4gICAgICAgIHBlcnNpc3RlZFJlbGF0aXZlQ2VudGVyUmVmLmN1cnJlbnQgPSB7IHg6IHJlbFgsIHk6IHJlbFkgfTtcbiAgICAgIH0gZWxzZSBjZW50ZXIgJiYgY29uc29sZS53YXJuKFxuICAgICAgICBcInVzZURyYWdnYWJsZTogQ29udGFpbmVyIGZvciBpbml0aWFsU25hcEFyZWEgaGFzIHplcm8gd2lkdGggb3IgaGVpZ2h0LiBDYW5ub3QgY2FsY3VsYXRlIHJlbGF0aXZlIGNlbnRlciBmcm9tIHNuYXAgYXJlYS4gRmFsbGluZyBiYWNrIHRvIGluaXRpYWxSZWxhdGl2ZUNlbnRlciBvciB1bmRlZmluZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9LCBbaW5pdGlhbFNuYXBBcmVhLCBwcm92aWRlckRhdGFdKTtcbiAgZnVuY3Rpb24gZ2V0U25hcEFyZWFDZW50ZXJzKGJvcmRlckxvY2F0aW9uKSB7XG4gICAgY29uc3QgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSA9IGJvcmRlckxvY2F0aW9uLCBjZW50ZXJYID0gKGxlZnQgKyByaWdodCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB0b3BMZWZ0OiB7IHg6IGxlZnQsIHk6IHRvcCB9LFxuICAgICAgdG9wQ2VudGVyOiB7IHg6IGNlbnRlclgsIHk6IHRvcCB9LFxuICAgICAgdG9wUmlnaHQ6IHsgeDogcmlnaHQsIHk6IHRvcCB9LFxuICAgICAgYm90dG9tTGVmdDogeyB4OiBsZWZ0LCB5OiBib3R0b20gfSxcbiAgICAgIGJvdHRvbUNlbnRlcjogeyB4OiBjZW50ZXJYLCB5OiBib3R0b20gfSxcbiAgICAgIGJvdHRvbVJpZ2h0OiB7IHg6IHJpZ2h0LCB5OiBib3R0b20gfVxuICAgIH07XG4gIH1cbiAgY29uc3QgdXBkYXRlRHJhZ2dhYmxlUG9zaXRpb24gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkcmFnZ2FibGVFbCA9IG1vdmluZ0VsZW1lbnRSZWYuY3VycmVudDtcbiAgICBpZiAoIWRyYWdnYWJsZUVsKSByZXR1cm47XG4gICAgY29uc3QgZHJhZ2dhYmxlV2lkdGggPSBkcmFnZ2FibGVFbC5vZmZzZXRXaWR0aCwgZHJhZ2dhYmxlSGVpZ2h0ID0gZHJhZ2dhYmxlRWwub2Zmc2V0SGVpZ2h0LCBvZmZzZXRQYXJlbnQgPSBkcmFnZ2FibGVFbC5vZmZzZXRQYXJlbnQ7XG4gICAgbGV0IHBhcmVudFZpZXdwb3J0TGVmdCA9IDAsIHBhcmVudFZpZXdwb3J0VG9wID0gMCwgcGFyZW50V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCwgcGFyZW50SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGNvbnN0IG9wUmVjdCA9IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHBhcmVudFZpZXdwb3J0TGVmdCA9IG9wUmVjdC5sZWZ0LCBwYXJlbnRWaWV3cG9ydFRvcCA9IG9wUmVjdC50b3AsIHBhcmVudFdpZHRoID0gb2Zmc2V0UGFyZW50Lm9mZnNldFdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoLCBwYXJlbnRIZWlnaHQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0SGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgbGV0IHRhcmdldFZpZXdwb3J0Q2VudGVyWCA9IG51bGwsIHRhcmdldFZpZXdwb3J0Q2VudGVyWSA9IG51bGw7XG4gICAgY29uc3QgY3VycmVudERlc2lyZWRSZWxhdGl2ZUNlbnRlciA9IHBlcnNpc3RlZFJlbGF0aXZlQ2VudGVyUmVmLmN1cnJlbnQ7XG4gICAgbGV0IHNuYXBBcmVhID0gbnVsbCwgc25hcFRhcmdldCA9IG51bGw7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBsYXRlc3RQcm92aWRlckRhdGFSZWYuY3VycmVudDtcbiAgICBsZXQgaXNUb3BIYWxmID0gITAsIGlzTGVmdEhhbGYgPSAhMDtcbiAgICBpZiAoaXNEcmFnZ2luZ1JlZi5jdXJyZW50ICYmIG1vdXNlVG9EcmFnZ2FibGVDZW50ZXJPZmZzZXRSZWYuY3VycmVudCAmJiBjdXJyZW50TW91c2VQb3NSZWYuY3VycmVudCAmJiBwcm92aWRlciAmJiBwcm92aWRlci5ib3JkZXJMb2NhdGlvbiAmJiBwcm92aWRlci5zbmFwQXJlYXMpIHtcbiAgICAgIGNvbnN0IGRyYWdDZW50ZXIgPSB7XG4gICAgICAgIHg6IGN1cnJlbnRNb3VzZVBvc1JlZi5jdXJyZW50LnggLSBtb3VzZVRvRHJhZ2dhYmxlQ2VudGVyT2Zmc2V0UmVmLmN1cnJlbnQueCxcbiAgICAgICAgeTogY3VycmVudE1vdXNlUG9zUmVmLmN1cnJlbnQueSAtIG1vdXNlVG9EcmFnZ2FibGVDZW50ZXJPZmZzZXRSZWYuY3VycmVudC55XG4gICAgICB9LCBhcmVhQ2VudGVycyA9IGdldFNuYXBBcmVhQ2VudGVycyhwcm92aWRlci5ib3JkZXJMb2NhdGlvbik7XG4gICAgICBsZXQgbWluRGlzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgY2xvc2VzdEFyZWEgPSBudWxsLCBjbG9zZXN0Q2VudGVyID0gbnVsbDtcbiAgICAgIGZvciAoY29uc3QgYXJlYSBpbiBwcm92aWRlci5zbmFwQXJlYXMpXG4gICAgICAgIGlmIChwcm92aWRlci5zbmFwQXJlYXNbYXJlYV0pIHtcbiAgICAgICAgICBjb25zdCBjZW50ZXIgPSBhcmVhQ2VudGVyc1thcmVhXTtcbiAgICAgICAgICBpZiAoIWNlbnRlcikgY29udGludWU7XG4gICAgICAgICAgY29uc3QgZGlzdCA9IE1hdGguaHlwb3QoXG4gICAgICAgICAgICBjZW50ZXIueCAtIGRyYWdDZW50ZXIueCxcbiAgICAgICAgICAgIGNlbnRlci55IC0gZHJhZ0NlbnRlci55XG4gICAgICAgICAgKTtcbiAgICAgICAgICBkaXN0IDwgbWluRGlzdCAmJiAobWluRGlzdCA9IGRpc3QsIGNsb3Nlc3RBcmVhID0gYXJlYSwgY2xvc2VzdENlbnRlciA9IGNlbnRlcik7XG4gICAgICAgIH1cbiAgICAgIGNsb3Nlc3RBcmVhICYmIGNsb3Nlc3RDZW50ZXIgJiYgbWluRGlzdCA8PSBhcmVhU25hcFRocmVzaG9sZCAmJiAoc25hcEFyZWEgPSBjbG9zZXN0QXJlYSwgc25hcFRhcmdldCA9IGNsb3Nlc3RDZW50ZXIpLCBpc0xlZnRIYWxmID0gKGRyYWdDZW50ZXIueCAtIHBhcmVudFZpZXdwb3J0TGVmdCkgLyBwYXJlbnRXaWR0aCA8PSAwLjUsIGlzVG9wSGFsZiA9IChkcmFnQ2VudGVyLnkgLSBwYXJlbnRWaWV3cG9ydFRvcCkgLyBwYXJlbnRIZWlnaHQgPD0gMC41O1xuICAgIH1cbiAgICBpZiAoaXNEcmFnZ2luZ1JlZi5jdXJyZW50ICYmIHNuYXBUYXJnZXQpXG4gICAgICB0YXJnZXRWaWV3cG9ydENlbnRlclggPSBzbmFwVGFyZ2V0LngsIHRhcmdldFZpZXdwb3J0Q2VudGVyWSA9IHNuYXBUYXJnZXQueSwgc2V0Q3VycmVudFNuYXBBcmVhKHNuYXBBcmVhKSwgaXNMZWZ0SGFsZiA9IChzbmFwVGFyZ2V0LnggLSBwYXJlbnRWaWV3cG9ydExlZnQpIC8gcGFyZW50V2lkdGggPD0gMC41LCBpc1RvcEhhbGYgPSAoc25hcFRhcmdldC55IC0gcGFyZW50Vmlld3BvcnRUb3ApIC8gcGFyZW50SGVpZ2h0IDw9IDAuNTtcbiAgICBlbHNlIGlmIChpc0RyYWdnaW5nUmVmLmN1cnJlbnQgJiYgbW91c2VUb0RyYWdnYWJsZUNlbnRlck9mZnNldFJlZi5jdXJyZW50ICYmIGN1cnJlbnRNb3VzZVBvc1JlZi5jdXJyZW50KVxuICAgICAgdGFyZ2V0Vmlld3BvcnRDZW50ZXJYID0gY3VycmVudE1vdXNlUG9zUmVmLmN1cnJlbnQueCAtIG1vdXNlVG9EcmFnZ2FibGVDZW50ZXJPZmZzZXRSZWYuY3VycmVudC54LCB0YXJnZXRWaWV3cG9ydENlbnRlclkgPSBjdXJyZW50TW91c2VQb3NSZWYuY3VycmVudC55IC0gbW91c2VUb0RyYWdnYWJsZUNlbnRlck9mZnNldFJlZi5jdXJyZW50LnksIHNldEN1cnJlbnRTbmFwQXJlYShudWxsKSwgaXNMZWZ0SGFsZiA9ICh0YXJnZXRWaWV3cG9ydENlbnRlclggLSBwYXJlbnRWaWV3cG9ydExlZnQpIC8gcGFyZW50V2lkdGggPD0gMC41LCBpc1RvcEhhbGYgPSAodGFyZ2V0Vmlld3BvcnRDZW50ZXJZIC0gcGFyZW50Vmlld3BvcnRUb3ApIC8gcGFyZW50SGVpZ2h0IDw9IDAuNTtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50RGVzaXJlZFJlbGF0aXZlQ2VudGVyICYmIHBhcmVudFdpZHRoID4gMCAmJiBwYXJlbnRIZWlnaHQgPiAwKSB7XG4gICAgICAgIGlmIChpc1RvcEhhbGYgPSBjdXJyZW50RGVzaXJlZFJlbGF0aXZlQ2VudGVyLnkgPD0gMC41LCBpc0xlZnRIYWxmID0gY3VycmVudERlc2lyZWRSZWxhdGl2ZUNlbnRlci54IDw9IDAuNSwgaXNMZWZ0SGFsZikge1xuICAgICAgICAgIGNvbnN0IHRhcmdldENlbnRlclhJblBhcmVudCA9IHBhcmVudFdpZHRoICogY3VycmVudERlc2lyZWRSZWxhdGl2ZUNlbnRlci54O1xuICAgICAgICAgIHRhcmdldFZpZXdwb3J0Q2VudGVyWCA9IHBhcmVudFZpZXdwb3J0TGVmdCArIHRhcmdldENlbnRlclhJblBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXRDZW50ZXJYSW5QYXJlbnQgPSBwYXJlbnRXaWR0aCAqICgxIC0gY3VycmVudERlc2lyZWRSZWxhdGl2ZUNlbnRlci54KTtcbiAgICAgICAgICB0YXJnZXRWaWV3cG9ydENlbnRlclggPSBwYXJlbnRWaWV3cG9ydExlZnQgKyBwYXJlbnRXaWR0aCAtIHRhcmdldENlbnRlclhJblBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNUb3BIYWxmKSB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0Q2VudGVyWUluUGFyZW50ID0gcGFyZW50SGVpZ2h0ICogY3VycmVudERlc2lyZWRSZWxhdGl2ZUNlbnRlci55O1xuICAgICAgICAgIHRhcmdldFZpZXdwb3J0Q2VudGVyWSA9IHBhcmVudFZpZXdwb3J0VG9wICsgdGFyZ2V0Q2VudGVyWUluUGFyZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRhcmdldENlbnRlcllJblBhcmVudCA9IHBhcmVudEhlaWdodCAqICgxIC0gY3VycmVudERlc2lyZWRSZWxhdGl2ZUNlbnRlci55KTtcbiAgICAgICAgICB0YXJnZXRWaWV3cG9ydENlbnRlclkgPSBwYXJlbnRWaWV3cG9ydFRvcCArIHBhcmVudEhlaWdodCAtIHRhcmdldENlbnRlcllJblBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgISgoX2EgPSBtb3ZpbmdFbGVtZW50UmVmLmN1cnJlbnQpICE9IG51bGwgJiYgX2Euc3R5bGUubGVmdCkgJiYgISgoX2IgPSBtb3ZpbmdFbGVtZW50UmVmLmN1cnJlbnQpICE9IG51bGwgJiYgX2Iuc3R5bGUudG9wKSAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJ1c2VEcmFnZ2FibGU6IENhbm5vdCBkZXRlcm1pbmUgcG9zaXRpb24uIFBhcmVudCBoYXMgbm8gZGltZW5zaW9ucyBvciBpbml0aWFsUmVsYXRpdmVDZW50ZXIgd2FzIG5vdCBlZmZlY3RpdmVseSBzZXQuXCJcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0Q3VycmVudFNuYXBBcmVhKG51bGwpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Vmlld3BvcnRDZW50ZXJYID09PSBudWxsIHx8IHRhcmdldFZpZXdwb3J0Q2VudGVyWSA9PT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGJvcmRlckxvY2F0aW9uIH0gPSBsYXRlc3RQcm92aWRlckRhdGFSZWYuY3VycmVudCB8fCB7XG4gICAgICBib3JkZXJMb2NhdGlvbjogdm9pZCAwXG4gICAgfTtcbiAgICBpZiAoYm9yZGVyTG9jYXRpb24gJiYgZHJhZ2dhYmxlV2lkdGggPiAwICYmIGRyYWdnYWJsZUhlaWdodCA+IDApIHtcbiAgICAgIGNvbnN0IHByb3ZpZGVyUmVjdFdpZHRoID0gYm9yZGVyTG9jYXRpb24ucmlnaHQgLSBib3JkZXJMb2NhdGlvbi5sZWZ0LCBwcm92aWRlclJlY3RIZWlnaHQgPSBib3JkZXJMb2NhdGlvbi5ib3R0b20gLSBib3JkZXJMb2NhdGlvbi50b3A7XG4gICAgICBsZXQgY2xhbXBlZENlbnRlclggPSB0YXJnZXRWaWV3cG9ydENlbnRlclgsIGNsYW1wZWRDZW50ZXJZID0gdGFyZ2V0Vmlld3BvcnRDZW50ZXJZO1xuICAgICAgaWYgKGRyYWdnYWJsZVdpZHRoID49IHByb3ZpZGVyUmVjdFdpZHRoKVxuICAgICAgICBjbGFtcGVkQ2VudGVyWCA9IGJvcmRlckxvY2F0aW9uLmxlZnQgKyBwcm92aWRlclJlY3RXaWR0aCAvIDI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWluWCA9IGJvcmRlckxvY2F0aW9uLmxlZnQgKyBkcmFnZ2FibGVXaWR0aCAvIDIsIG1heFggPSBib3JkZXJMb2NhdGlvbi5yaWdodCAtIGRyYWdnYWJsZVdpZHRoIC8gMjtcbiAgICAgICAgY2xhbXBlZENlbnRlclggPSBNYXRoLm1heChtaW5YLCBNYXRoLm1pbihjbGFtcGVkQ2VudGVyWCwgbWF4WCkpO1xuICAgICAgfVxuICAgICAgaWYgKGRyYWdnYWJsZUhlaWdodCA+PSBwcm92aWRlclJlY3RIZWlnaHQpXG4gICAgICAgIGNsYW1wZWRDZW50ZXJZID0gYm9yZGVyTG9jYXRpb24udG9wICsgcHJvdmlkZXJSZWN0SGVpZ2h0IC8gMjtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtaW5ZID0gYm9yZGVyTG9jYXRpb24udG9wICsgZHJhZ2dhYmxlSGVpZ2h0IC8gMiwgbWF4WSA9IGJvcmRlckxvY2F0aW9uLmJvdHRvbSAtIGRyYWdnYWJsZUhlaWdodCAvIDI7XG4gICAgICAgIGNsYW1wZWRDZW50ZXJZID0gTWF0aC5tYXgobWluWSwgTWF0aC5taW4oY2xhbXBlZENlbnRlclksIG1heFkpKTtcbiAgICAgIH1cbiAgICAgIHRhcmdldFZpZXdwb3J0Q2VudGVyWCA9IGNsYW1wZWRDZW50ZXJYLCB0YXJnZXRWaWV3cG9ydENlbnRlclkgPSBjbGFtcGVkQ2VudGVyWTtcbiAgICB9XG4gICAgaWYgKCFhbmltYXRlZFBvc2l0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGFuaW1hdGVkUG9zaXRpb25SZWYuY3VycmVudCA9IHtcbiAgICAgICAgeDogdGFyZ2V0Vmlld3BvcnRDZW50ZXJYLFxuICAgICAgICB5OiB0YXJnZXRWaWV3cG9ydENlbnRlcllcbiAgICAgIH0sIHZlbG9jaXR5UmVmLmN1cnJlbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnRTdHlsZVgyID0gdGFyZ2V0Vmlld3BvcnRDZW50ZXJYIC0gZHJhZ2dhYmxlV2lkdGggLyAyLCB0YXJnZXRFbGVtZW50U3R5bGVZMiA9IHRhcmdldFZpZXdwb3J0Q2VudGVyWSAtIGRyYWdnYWJsZUhlaWdodCAvIDIsIGVsU3R5bGUyID0gZHJhZ2dhYmxlRWwuc3R5bGU7XG4gICAgICBpZiAoZWxTdHlsZTIucmlnaHQgPSBcIlwiLCBlbFN0eWxlMi5ib3R0b20gPSBcIlwiLCBlbFN0eWxlMi5sZWZ0ID0gXCJcIiwgZWxTdHlsZTIudG9wID0gXCJcIiwgaXNMZWZ0SGFsZikge1xuICAgICAgICBjb25zdCBzdHlsZUxlZnRQeCA9IHRhcmdldEVsZW1lbnRTdHlsZVgyIC0gcGFyZW50Vmlld3BvcnRMZWZ0O1xuICAgICAgICBlbFN0eWxlMi5sZWZ0ID0gcGFyZW50V2lkdGggPiAwID8gXFxgXFwkeyhzdHlsZUxlZnRQeCAvIHBhcmVudFdpZHRoICogMTAwKS50b0ZpeGVkKDIpfSVcXGAgOiBcIjBweFwiLCBlbFN0eWxlMi5yaWdodCA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHlsZVJpZ2h0UHggPSBwYXJlbnRWaWV3cG9ydExlZnQgKyBwYXJlbnRXaWR0aCAtICh0YXJnZXRFbGVtZW50U3R5bGVYMiArIGRyYWdnYWJsZVdpZHRoKTtcbiAgICAgICAgZWxTdHlsZTIucmlnaHQgPSBwYXJlbnRXaWR0aCA+IDAgPyBcXGBcXCR7KHN0eWxlUmlnaHRQeCAvIHBhcmVudFdpZHRoICogMTAwKS50b0ZpeGVkKDIpfSVcXGAgOiBcIjBweFwiLCBlbFN0eWxlMi5sZWZ0ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1RvcEhhbGYpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVUb3BQeCA9IHRhcmdldEVsZW1lbnRTdHlsZVkyIC0gcGFyZW50Vmlld3BvcnRUb3A7XG4gICAgICAgIGVsU3R5bGUyLnRvcCA9IHBhcmVudEhlaWdodCA+IDAgPyBcXGBcXCR7KHN0eWxlVG9wUHggLyBwYXJlbnRIZWlnaHQgKiAxMDApLnRvRml4ZWQoMil9JVxcYCA6IFwiMHB4XCIsIGVsU3R5bGUyLmJvdHRvbSA9IFwiXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHlsZUJvdHRvbVB4ID0gcGFyZW50Vmlld3BvcnRUb3AgKyBwYXJlbnRIZWlnaHQgLSAodGFyZ2V0RWxlbWVudFN0eWxlWTIgKyBkcmFnZ2FibGVIZWlnaHQpO1xuICAgICAgICBlbFN0eWxlMi5ib3R0b20gPSBwYXJlbnRIZWlnaHQgPiAwID8gXFxgXFwkeyhzdHlsZUJvdHRvbVB4IC8gcGFyZW50SGVpZ2h0ICogMTAwKS50b0ZpeGVkKDIpfSVcXGAgOiBcIjBweFwiLCBlbFN0eWxlMi50b3AgPSBcIlwiO1xuICAgICAgfVxuICAgICAgaGFzQW5pbWF0ZWRPbmNlUmVmLmN1cnJlbnQgPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFoYXNBbmltYXRlZE9uY2VSZWYuY3VycmVudCkge1xuICAgICAgaGFzQW5pbWF0ZWRPbmNlUmVmLmN1cnJlbnQgPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcG9zID0gYW5pbWF0ZWRQb3NpdGlvblJlZi5jdXJyZW50LCB2ZWwgPSB2ZWxvY2l0eVJlZi5jdXJyZW50LCBkeCA9IHRhcmdldFZpZXdwb3J0Q2VudGVyWCAtIHBvcy54LCBkeSA9IHRhcmdldFZpZXdwb3J0Q2VudGVyWSAtIHBvcy55LCBheCA9IHNwcmluZ1N0aWZmbmVzcyAqIGR4IC0gc3ByaW5nRGFtcG5lc3MgKiB2ZWwueCwgYXkgPSBzcHJpbmdTdGlmZm5lc3MgKiBkeSAtIHNwcmluZ0RhbXBuZXNzICogdmVsLnk7XG4gICAgdmVsLnggKz0gYXgsIHZlbC55ICs9IGF5LCBwb3MueCArPSB2ZWwueCwgcG9zLnkgKz0gdmVsLnk7XG4gICAgY29uc3QgdGhyZXNob2xkID0gMC41O1xuICAgIE1hdGguYWJzKGR4KSA8IHRocmVzaG9sZCAmJiBNYXRoLmFicyhkeSkgPCB0aHJlc2hvbGQgJiYgTWF0aC5hYnModmVsLngpIDwgdGhyZXNob2xkICYmIE1hdGguYWJzKHZlbC55KSA8IHRocmVzaG9sZCAmJiAocG9zLnggPSB0YXJnZXRWaWV3cG9ydENlbnRlclgsIHBvcy55ID0gdGFyZ2V0Vmlld3BvcnRDZW50ZXJZLCB2ZWwueCA9IDAsIHZlbC55ID0gMCksIGFuaW1hdGVkUG9zaXRpb25SZWYuY3VycmVudCA9IHsgLi4ucG9zIH0sIHZlbG9jaXR5UmVmLmN1cnJlbnQgPSB7IC4uLnZlbCB9O1xuICAgIGNvbnN0IHRhcmdldEVsZW1lbnRTdHlsZVggPSBwb3MueCAtIGRyYWdnYWJsZVdpZHRoIC8gMiwgdGFyZ2V0RWxlbWVudFN0eWxlWSA9IHBvcy55IC0gZHJhZ2dhYmxlSGVpZ2h0IC8gMiwgZWxTdHlsZSA9IGRyYWdnYWJsZUVsLnN0eWxlO1xuICAgIGlmIChlbFN0eWxlLnJpZ2h0ID0gXCJcIiwgZWxTdHlsZS5ib3R0b20gPSBcIlwiLCBlbFN0eWxlLmxlZnQgPSBcIlwiLCBlbFN0eWxlLnRvcCA9IFwiXCIsIGlzTGVmdEhhbGYpIHtcbiAgICAgIGNvbnN0IHN0eWxlTGVmdFB4ID0gdGFyZ2V0RWxlbWVudFN0eWxlWCAtIHBhcmVudFZpZXdwb3J0TGVmdDtcbiAgICAgIGVsU3R5bGUubGVmdCA9IHBhcmVudFdpZHRoID4gMCA/IFxcYFxcJHsoc3R5bGVMZWZ0UHggLyBwYXJlbnRXaWR0aCAqIDEwMCkudG9GaXhlZCgyKX0lXFxgIDogXCIwcHhcIiwgZWxTdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0eWxlUmlnaHRQeCA9IHBhcmVudFZpZXdwb3J0TGVmdCArIHBhcmVudFdpZHRoIC0gKHRhcmdldEVsZW1lbnRTdHlsZVggKyBkcmFnZ2FibGVXaWR0aCk7XG4gICAgICBlbFN0eWxlLnJpZ2h0ID0gcGFyZW50V2lkdGggPiAwID8gXFxgXFwkeyhzdHlsZVJpZ2h0UHggLyBwYXJlbnRXaWR0aCAqIDEwMCkudG9GaXhlZCgyKX0lXFxgIDogXCIwcHhcIiwgZWxTdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKGlzVG9wSGFsZikge1xuICAgICAgY29uc3Qgc3R5bGVUb3BQeCA9IHRhcmdldEVsZW1lbnRTdHlsZVkgLSBwYXJlbnRWaWV3cG9ydFRvcDtcbiAgICAgIGVsU3R5bGUudG9wID0gcGFyZW50SGVpZ2h0ID4gMCA/IFxcYFxcJHsoc3R5bGVUb3BQeCAvIHBhcmVudEhlaWdodCAqIDEwMCkudG9GaXhlZCgyKX0lXFxgIDogXCIwcHhcIiwgZWxTdHlsZS5ib3R0b20gPSBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdHlsZUJvdHRvbVB4ID0gcGFyZW50Vmlld3BvcnRUb3AgKyBwYXJlbnRIZWlnaHQgLSAodGFyZ2V0RWxlbWVudFN0eWxlWSArIGRyYWdnYWJsZUhlaWdodCk7XG4gICAgICBlbFN0eWxlLmJvdHRvbSA9IHBhcmVudEhlaWdodCA+IDAgPyBcXGBcXCR7KHN0eWxlQm90dG9tUHggLyBwYXJlbnRIZWlnaHQgKiAxMDApLnRvRml4ZWQoMil9JVxcYCA6IFwiMHB4XCIsIGVsU3R5bGUudG9wID0gXCJcIjtcbiAgICB9XG4gICAgKE1hdGguYWJzKHBvcy54IC0gdGFyZ2V0Vmlld3BvcnRDZW50ZXJYKSA+IHRocmVzaG9sZCB8fCBNYXRoLmFicyhwb3MueSAtIHRhcmdldFZpZXdwb3J0Q2VudGVyWSkgPiB0aHJlc2hvbGQgfHwgTWF0aC5hYnModmVsLngpID4gdGhyZXNob2xkIHx8IE1hdGguYWJzKHZlbC55KSA+IHRocmVzaG9sZCB8fCBpc0RyYWdnaW5nUmVmLmN1cnJlbnQpICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVEcmFnZ2FibGVQb3NpdGlvbik7XG4gIH0sIFthcmVhU25hcFRocmVzaG9sZCwgc3ByaW5nU3RpZmZuZXNzLCBzcHJpbmdEYW1wbmVzc10pLCBbd2FzRHJhZ2dlZCwgc2V0V2FzRHJhZ2dlZF0gPSB1c2VTdGF0ZSghMSksIG1vdXNlVXBIYW5kbGVyID0gdXNlQ2FsbGJhY2soXG4gICAgKF9lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBsZXQgZmluYWxTbmFwQXJlYSA9IG51bGw7XG4gICAgICBpZiAoaXNEcmFnZ2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHNldFdhc0RyYWdnZWQoITApLCBzZXRUaW1lb3V0KCgpID0+IHNldFdhc0RyYWdnZWQoITEpLCAyMCk7XG4gICAgICAgIGNvbnN0IGRyYWdnYWJsZUVsID0gbW92aW5nRWxlbWVudFJlZi5jdXJyZW50LCBwcm92aWRlciA9IGxhdGVzdFByb3ZpZGVyRGF0YVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoZHJhZ2dhYmxlRWwgJiYgcHJvdmlkZXIgJiYgcHJvdmlkZXIuYm9yZGVyTG9jYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBkcmFnZ2FibGVXaWR0aCA9IGRyYWdnYWJsZUVsLm9mZnNldFdpZHRoLCBkcmFnZ2FibGVIZWlnaHQgPSBkcmFnZ2FibGVFbC5vZmZzZXRIZWlnaHQsIG9mZnNldFBhcmVudCA9IGRyYWdnYWJsZUVsLm9mZnNldFBhcmVudDtcbiAgICAgICAgICBsZXQgcGFyZW50Vmlld3BvcnRMZWZ0ID0gMCwgcGFyZW50Vmlld3BvcnRUb3AgPSAwLCBwYXJlbnRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoLCBwYXJlbnRIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgICAgaWYgKG9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgY29uc3Qgb3BSZWN0ID0gb2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcGFyZW50Vmlld3BvcnRMZWZ0ID0gb3BSZWN0LmxlZnQsIHBhcmVudFZpZXdwb3J0VG9wID0gb3BSZWN0LnRvcCwgcGFyZW50V2lkdGggPSBvZmZzZXRQYXJlbnQub2Zmc2V0V2lkdGggfHwgd2luZG93LmlubmVyV2lkdGgsIHBhcmVudEhlaWdodCA9IG9mZnNldFBhcmVudC5vZmZzZXRIZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgcmVsZWFzZWRDZW50ZXJYID0gMCwgcmVsZWFzZWRDZW50ZXJZID0gMDtcbiAgICAgICAgICBjdXJyZW50TW91c2VQb3NSZWYuY3VycmVudCAmJiBtb3VzZVRvRHJhZ2dhYmxlQ2VudGVyT2Zmc2V0UmVmLmN1cnJlbnQgPyAocmVsZWFzZWRDZW50ZXJYID0gY3VycmVudE1vdXNlUG9zUmVmLmN1cnJlbnQueCAtIG1vdXNlVG9EcmFnZ2FibGVDZW50ZXJPZmZzZXRSZWYuY3VycmVudC54LCByZWxlYXNlZENlbnRlclkgPSBjdXJyZW50TW91c2VQb3NSZWYuY3VycmVudC55IC0gbW91c2VUb0RyYWdnYWJsZUNlbnRlck9mZnNldFJlZi5jdXJyZW50LnkpIDogYW5pbWF0ZWRQb3NpdGlvblJlZi5jdXJyZW50ICYmIChyZWxlYXNlZENlbnRlclggPSBhbmltYXRlZFBvc2l0aW9uUmVmLmN1cnJlbnQueCwgcmVsZWFzZWRDZW50ZXJZID0gYW5pbWF0ZWRQb3NpdGlvblJlZi5jdXJyZW50LnkpO1xuICAgICAgICAgIGNvbnN0IGJvcmRlckxvY2F0aW9uID0gcHJvdmlkZXIuYm9yZGVyTG9jYXRpb24sIG1pblggPSBib3JkZXJMb2NhdGlvbi5sZWZ0ICsgZHJhZ2dhYmxlV2lkdGggLyAyLCBtYXhYID0gYm9yZGVyTG9jYXRpb24ucmlnaHQgLSBkcmFnZ2FibGVXaWR0aCAvIDIsIG1pblkgPSBib3JkZXJMb2NhdGlvbi50b3AgKyBkcmFnZ2FibGVIZWlnaHQgLyAyLCBtYXhZID0gYm9yZGVyTG9jYXRpb24uYm90dG9tIC0gZHJhZ2dhYmxlSGVpZ2h0IC8gMjtcbiAgICAgICAgICByZWxlYXNlZENlbnRlclggPSBNYXRoLm1heChtaW5YLCBNYXRoLm1pbihyZWxlYXNlZENlbnRlclgsIG1heFgpKSwgcmVsZWFzZWRDZW50ZXJZID0gTWF0aC5tYXgobWluWSwgTWF0aC5taW4ocmVsZWFzZWRDZW50ZXJZLCBtYXhZKSk7XG4gICAgICAgICAgY29uc3QgYXJlYUNlbnRlcnMgPSBnZXRTbmFwQXJlYUNlbnRlcnMoYm9yZGVyTG9jYXRpb24pO1xuICAgICAgICAgIGxldCBtaW5EaXN0ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBjbG9zZXN0QXJlYSA9IG51bGwsIGNsb3Nlc3RDZW50ZXIgPSBudWxsO1xuICAgICAgICAgIGZvciAoY29uc3QgYXJlYSBpbiBwcm92aWRlci5zbmFwQXJlYXMpXG4gICAgICAgICAgICBpZiAocHJvdmlkZXIuc25hcEFyZWFzW2FyZWFdKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGFyZWFDZW50ZXJzW2FyZWFdO1xuICAgICAgICAgICAgICBpZiAoIWNlbnRlcikgY29udGludWU7XG4gICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBNYXRoLmh5cG90KFxuICAgICAgICAgICAgICAgIGNlbnRlci54IC0gcmVsZWFzZWRDZW50ZXJYLFxuICAgICAgICAgICAgICAgIGNlbnRlci55IC0gcmVsZWFzZWRDZW50ZXJZXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGRpc3QgPCBtaW5EaXN0ICYmIChtaW5EaXN0ID0gZGlzdCwgY2xvc2VzdEFyZWEgPSBhcmVhLCBjbG9zZXN0Q2VudGVyID0gY2VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2xvc2VzdEFyZWEgJiYgY2xvc2VzdENlbnRlcikge1xuICAgICAgICAgICAgZmluYWxTbmFwQXJlYSA9IGNsb3Nlc3RBcmVhLCBzZXRDdXJyZW50U25hcEFyZWEoY2xvc2VzdEFyZWEpO1xuICAgICAgICAgICAgY29uc3QgcmVsWCA9IChjbG9zZXN0Q2VudGVyLnggLSBwYXJlbnRWaWV3cG9ydExlZnQpIC8gcGFyZW50V2lkdGgsIHJlbFkgPSAoY2xvc2VzdENlbnRlci55IC0gcGFyZW50Vmlld3BvcnRUb3ApIC8gcGFyZW50SGVpZ2h0O1xuICAgICAgICAgICAgcGVyc2lzdGVkUmVsYXRpdmVDZW50ZXJSZWYuY3VycmVudCA9IHsgeDogcmVsWCwgeTogcmVsWSB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaW5hbFNuYXBBcmVhID0gbnVsbCwgc2V0Q3VycmVudFNuYXBBcmVhKG51bGwpO1xuICAgICAgICAgICAgY29uc3QgcmVsWCA9IChyZWxlYXNlZENlbnRlclggLSBwYXJlbnRWaWV3cG9ydExlZnQpIC8gcGFyZW50V2lkdGgsIHJlbFkgPSAocmVsZWFzZWRDZW50ZXJZIC0gcGFyZW50Vmlld3BvcnRUb3ApIC8gcGFyZW50SGVpZ2h0O1xuICAgICAgICAgICAgcGVyc2lzdGVkUmVsYXRpdmVDZW50ZXJSZWYuY3VycmVudCA9IHsgeDogcmVsWCwgeTogcmVsWSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbkRyYWdFbmQgJiYgb25EcmFnRW5kKGZpbmFsU25hcEFyZWEpLCAoX2EgPSBsYXRlc3RQcm92aWRlckRhdGFSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfYS5lbWl0RHJhZ0VuZCAmJiBsYXRlc3RQcm92aWRlckRhdGFSZWYuY3VycmVudC5lbWl0RHJhZ0VuZCgpO1xuICAgICAgfVxuICAgICAgbW91c2VEb3duUG9zUmVmLmN1cnJlbnQgPSBudWxsLCBpc0RyYWdnaW5nUmVmLmN1cnJlbnQgPSAhMSwgc2V0SXNEcmFnZ2luZyghMSksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIsIHtcbiAgICAgICAgY2FwdHVyZTogITBcbiAgICAgIH0pLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcEhhbmRsZXIsIHtcbiAgICAgICAgY2FwdHVyZTogITBcbiAgICAgIH0pLCBtb3ZpbmdFbGVtZW50UmVmLmN1cnJlbnQgJiYgKG1vdmluZ0VsZW1lbnRSZWYuY3VycmVudC5zdHlsZS51c2VyU2VsZWN0ID0gXCJcIiksIGRvY3VtZW50LmJvZHkuc3R5bGUudXNlclNlbGVjdCA9IFwiXCIsIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJcIjtcbiAgICB9LFxuICAgIFtvbkRyYWdFbmRdXG4gICksIG1vdXNlTW92ZUhhbmRsZXIgPSB1c2VDYWxsYmFjayhcbiAgICAoZTIpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghbW91c2VEb3duUG9zUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIE1hdGguaHlwb3QoXG4gICAgICAgIGUyLmNsaWVudFggLSBtb3VzZURvd25Qb3NSZWYuY3VycmVudC54LFxuICAgICAgICBlMi5jbGllbnRZIC0gbW91c2VEb3duUG9zUmVmLmN1cnJlbnQueVxuICAgICAgKSA+IHN0YXJ0VGhyZXNob2xkICYmICFpc0RyYWdnaW5nUmVmLmN1cnJlbnQgJiYgKGlzRHJhZ2dpbmdSZWYuY3VycmVudCA9ICEwLCBzZXRJc0RyYWdnaW5nKCEwKSwgbW92aW5nRWxlbWVudFJlZi5jdXJyZW50ICYmIChtb3ZpbmdFbGVtZW50UmVmLmN1cnJlbnQuc3R5bGUudXNlclNlbGVjdCA9IFwibm9uZVwiKSwgZG9jdW1lbnQuYm9keS5zdHlsZS51c2VyU2VsZWN0ID0gXCJub25lXCIsIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJncmFiYmluZ1wiLCBvbkRyYWdTdGFydCAmJiBvbkRyYWdTdGFydCgpLCAoX2EgPSBsYXRlc3RQcm92aWRlckRhdGFSZWYuY3VycmVudCkgIT0gbnVsbCAmJiBfYS5lbWl0RHJhZ1N0YXJ0ICYmIGxhdGVzdFByb3ZpZGVyRGF0YVJlZi5jdXJyZW50LmVtaXREcmFnU3RhcnQoKSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZURyYWdnYWJsZVBvc2l0aW9uKSksIGN1cnJlbnRNb3VzZVBvc1JlZi5jdXJyZW50ID0geyB4OiBlMi5jbGllbnRYLCB5OiBlMi5jbGllbnRZIH07XG4gICAgfSxcbiAgICBbc3RhcnRUaHJlc2hvbGQsIG9uRHJhZ1N0YXJ0LCB1cGRhdGVEcmFnZ2FibGVQb3NpdGlvbl1cbiAgKSwgbW91c2VEb3duSGFuZGxlciA9IHVzZUNhbGxiYWNrKFxuICAgIChlMikgPT4ge1xuICAgICAgaWYgKGUyLmJ1dHRvbiAhPT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaGFuZGxlTm9kZSA9IGRyYWdJbml0aWF0b3JSZWYuY3VycmVudCwgZHJhZ2dhYmxlSXRlbU5vZGUgPSBtb3ZpbmdFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoaGFuZGxlTm9kZSkge1xuICAgICAgICBpZiAoIWhhbmRsZU5vZGUuY29udGFpbnMoZTIudGFyZ2V0KSAmJiBlMi50YXJnZXQgIT09IGhhbmRsZU5vZGUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChkcmFnZ2FibGVJdGVtTm9kZSkge1xuICAgICAgICBpZiAoIWRyYWdnYWJsZUl0ZW1Ob2RlLmNvbnRhaW5zKGUyLnRhcmdldCkgJiYgZTIudGFyZ2V0ICE9PSBkcmFnZ2FibGVJdGVtTm9kZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiRHJhZ2dhYmxlIGVsZW1lbnQgb3IgaGFuZGxlIHJlZiBub3Qgc2V0IGluIG1vdXNlRG93bkhhbmRsZXJcIlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobW91c2VEb3duUG9zUmVmLmN1cnJlbnQgPSB7IHg6IGUyLmNsaWVudFgsIHk6IGUyLmNsaWVudFkgfSwgIW1vdmluZ0VsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRHJhZ2dhYmxlIGVsZW1lbnQgcmVmIG5vdCBzZXQgaW4gbW91c2VEb3duSGFuZGxlclwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVjdCA9IG1vdmluZ0VsZW1lbnRSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgY3VycmVudERyYWdnYWJsZUNlbnRlclggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiwgY3VycmVudERyYWdnYWJsZUNlbnRlclkgPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIG1vdXNlVG9EcmFnZ2FibGVDZW50ZXJPZmZzZXRSZWYuY3VycmVudCA9IHtcbiAgICAgICAgeDogZTIuY2xpZW50WCAtIGN1cnJlbnREcmFnZ2FibGVDZW50ZXJYLFxuICAgICAgICB5OiBlMi5jbGllbnRZIC0gY3VycmVudERyYWdnYWJsZUNlbnRlcllcbiAgICAgIH0sIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZUhhbmRsZXIsIHtcbiAgICAgICAgY2FwdHVyZTogITBcbiAgICAgIH0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcEhhbmRsZXIsIHtcbiAgICAgICAgY2FwdHVyZTogITBcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgW21vdXNlTW92ZUhhbmRsZXIsIG1vdXNlVXBIYW5kbGVyXVxuICApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnRUb0xpc3Rlbk9uID0gZHJhZ0luaXRpYXRvck5vZGUgfHwgbW92aW5nRWxlbWVudE5vZGU7XG4gICAgcmV0dXJuIGVsZW1lbnRUb0xpc3Rlbk9uICYmIGVsZW1lbnRUb0xpc3Rlbk9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VEb3duSGFuZGxlciksICgpID0+IHtcbiAgICAgIGVsZW1lbnRUb0xpc3Rlbk9uICYmIGVsZW1lbnRUb0xpc3Rlbk9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgbW91c2VEb3duSGFuZGxlciksIGlzRHJhZ2dpbmdSZWYuY3VycmVudCAmJiAob25EcmFnRW5kICYmIG9uRHJhZ0VuZChjdXJyZW50U25hcEFyZWEpLCBpc0RyYWdnaW5nUmVmLmN1cnJlbnQgPSAhMSwgc2V0SXNEcmFnZ2luZyghMSksIG1vdmluZ0VsZW1lbnROb2RlICYmIChtb3ZpbmdFbGVtZW50Tm9kZS5zdHlsZS51c2VyU2VsZWN0ID0gXCJcIiksIGRvY3VtZW50LmJvZHkuc3R5bGUudXNlclNlbGVjdCA9IFwiXCIsIGRvY3VtZW50LmJvZHkuc3R5bGUuY3Vyc29yID0gXCJcIik7XG4gICAgfTtcbiAgfSwgW1xuICAgIG1vdmluZ0VsZW1lbnROb2RlLFxuICAgIGRyYWdJbml0aWF0b3JOb2RlLFxuICAgIG1vdXNlRG93bkhhbmRsZXIsXG4gICAgb25EcmFnRW5kLFxuICAgIG1vdXNlTW92ZUhhbmRsZXIsXG4gICAgbW91c2VVcEhhbmRsZXIsXG4gICAgY3VycmVudFNuYXBBcmVhXG4gIF0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIG1vdmluZ0VsZW1lbnRSZWYuY3VycmVudCAmJiBwcm92aWRlckRhdGEgJiYgcHJvdmlkZXJEYXRhLmJvcmRlckxvY2F0aW9uICYmIC8vIE5lZWRlZCBmb3IgY2FsY3VsYXRpb25zIHdpdGhpbiB1cGRhdGVEcmFnZ2FibGVQb3NpdGlvblxuICAgIHBlcnNpc3RlZFJlbGF0aXZlQ2VudGVyUmVmLmN1cnJlbnQgJiYgLy8gRW5zdXJlIHdlIGhhdmUgYSBjZW50ZXIgdG8gcG9zaXRpb24gdG9cbiAgICAhaXNEcmFnZ2luZ1JlZi5jdXJyZW50ICYmIC8vIE5vdCBjdXJyZW50bHkgZHJhZ2dpbmdcbiAgICAhaGFzQW5pbWF0ZWRPbmNlUmVmLmN1cnJlbnQgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIG1vdmluZ0VsZW1lbnRSZWYuY3VycmVudCAmJiB1cGRhdGVEcmFnZ2FibGVQb3NpdGlvbigpO1xuICAgIH0pO1xuICB9LCBbXG4gICAgbW92aW5nRWxlbWVudE5vZGUsXG4gICAgLy8gUnVuIHdoZW4gZWxlbWVudCBpcyBhdmFpbGFibGUvY2hhbmdlc1xuICAgIHByb3ZpZGVyRGF0YSxcbiAgICAvLyBSdW4gaWYgcHJvdmlkZXIgY29udGV4dCBjaGFuZ2VzIChmb3IgYm9yZGVyTG9jYXRpb24pXG4gICAgY29uZmlnMi5pbml0aWFsUmVsYXRpdmVDZW50ZXIsXG4gICAgLy8gSWYgdGhpcyBjaGFuZ2VzLCBwZXJzaXN0ZWRSZWxhdGl2ZUNlbnRlclJlZiBtaWdodCBiZSByZS1pbml0aWFsaXplZFxuICAgIGluaXRpYWxTbmFwQXJlYSxcbiAgICAvLyBJZiB0aGlzIGNoYW5nZXMsIGFuIGVmZmVjdCB1cGRhdGVzIHBlcnNpc3RlZFJlbGF0aXZlQ2VudGVyUmVmXG4gICAgdXBkYXRlRHJhZ2dhYmxlUG9zaXRpb25cbiAgICAvLyBNZW1vaXplZCBjYWxsYmFjayBmb3IgcG9zaXRpb25pbmdcbiAgICAvLyBoYXNBbmltYXRlZE9uY2VSZWYgaXMgaW50ZW50aW9uYWxseSBub3QgYSBkZXAsIGl0cyBjdXJyZW50IHZhbHVlIGlzIGNoZWNrZWQgaW5zaWRlLlxuICBdKTtcbiAgY29uc3QgZHJhZ2dhYmxlUmVmQ2FsbGJhY2sgPSB1c2VDYWxsYmFjaygobm9kZSkgPT4ge1xuICAgIHNldE1vdmluZ0VsZW1lbnROb2RlKG5vZGUpLCBtb3ZpbmdFbGVtZW50UmVmLmN1cnJlbnQgPSBub2RlO1xuICB9LCBbXSksIGhhbmRsZVJlZkNhbGxiYWNrID0gdXNlQ2FsbGJhY2soKG5vZGUpID0+IHtcbiAgICBzZXREcmFnSW5pdGlhdG9yTm9kZShub2RlKSwgZHJhZ0luaXRpYXRvclJlZi5jdXJyZW50ID0gbm9kZTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGRyYWdnYWJsZVJlZjogZHJhZ2dhYmxlUmVmQ2FsbGJhY2ssXG4gICAgaGFuZGxlUmVmOiBoYW5kbGVSZWZDYWxsYmFjayxcbiAgICBwb3NpdGlvbjoge1xuICAgICAgc25hcEFyZWE6IGN1cnJlbnRTbmFwQXJlYSxcbiAgICAgIGlzVG9wSGFsZjogcGVyc2lzdGVkUmVsYXRpdmVDZW50ZXJSZWYuY3VycmVudCA/IHBlcnNpc3RlZFJlbGF0aXZlQ2VudGVyUmVmLmN1cnJlbnQueSA8PSAwLjUgOiAhMCxcbiAgICAgIGlzTGVmdEhhbGY6IHBlcnNpc3RlZFJlbGF0aXZlQ2VudGVyUmVmLmN1cnJlbnQgPyBwZXJzaXN0ZWRSZWxhdGl2ZUNlbnRlclJlZi5jdXJyZW50LnggPD0gMC41IDogITBcbiAgICB9LFxuICAgIHdhc0RyYWdnZWQsXG4gICAgaXNEcmFnZ2luZ1xuICB9O1xufVxuY29uc3QgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMgPSB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiA/IFJlYWN0X19kZWZhdWx0LnVzZUxheW91dEVmZmVjdCA6ICgpID0+IHtcbn07XG5mdW5jdGlvbiAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1Mihmbikge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHJldHVybiAkZjBhMDRjY2Q4ZGJkZDgzYiRleHBvcnQkZTVjNWE1ZjkxN2E1ODcxYygoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBmbjtcbiAgfSwgW1xuICAgIGZuXG4gIF0pLCB1c2VDYWxsYmFjaygoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGYyID0gcmVmLmN1cnJlbnQ7XG4gICAgcmV0dXJuIGYyID09IG51bGwgPyB2b2lkIDAgOiBmMiguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuY29uc3QgJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMgPSAoZWwpID0+IHtcbiAgdmFyIF9lbF9vd25lckRvY3VtZW50O1xuICByZXR1cm4gKF9lbF9vd25lckRvY3VtZW50ID0gZWwgPT0gbnVsbCA/IHZvaWQgMCA6IGVsLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9lbF9vd25lckRvY3VtZW50ICE9PSB2b2lkIDAgPyBfZWxfb3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufSwgJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGYyMWExZmZhZTI2MDE0NWEgPSAoZWwpID0+IGVsICYmIFwid2luZG93XCIgaW4gZWwgJiYgZWwud2luZG93ID09PSBlbCA/IGVsIDogJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMoZWwpLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbmZ1bmN0aW9uICQ0MzFmYmQ4NmNhN2RjMjE2JHZhciRpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIFwibm9kZVR5cGVcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubm9kZVR5cGUgPT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRhZjUxZjBmMDZjMGYzMjhhKG5vZGUpIHtcbiAgcmV0dXJuICQ0MzFmYmQ4NmNhN2RjMjE2JHZhciRpc05vZGUobm9kZSkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIFwiaG9zdFwiIGluIG5vZGU7XG59XG5sZXQgJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF9zaGFkb3dET00gPSAhMTtcbmZ1bmN0aW9uICRmNGUyZGY2YmQxNWY4NTY5JGV4cG9ydCQ5ODY1OGU4YzU5MTI1ZTZhKCkge1xuICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkdmFyJF9zaGFkb3dET007XG59XG5mdW5jdGlvbiAkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkNDI4MmY3MDc5ODA2NGZlMChub2RlLCBvdGhlck5vZGUpIHtcbiAgaWYgKCEkZjRlMmRmNmJkMTVmODU2OSRleHBvcnQkOTg2NThlOGM1OTEyNWU2YSgpKSByZXR1cm4gb3RoZXJOb2RlICYmIG5vZGUgPyBub2RlLmNvbnRhaW5zKG90aGVyTm9kZSkgOiAhMTtcbiAgaWYgKCFub2RlIHx8ICFvdGhlck5vZGUpIHJldHVybiAhMTtcbiAgbGV0IGN1cnJlbnROb2RlID0gb3RoZXJOb2RlO1xuICBmb3IgKDsgY3VycmVudE5vZGUgIT09IG51bGw7ICkge1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gbm9kZSkgcmV0dXJuICEwO1xuICAgIGN1cnJlbnROb2RlLnRhZ05hbWUgPT09IFwiU0xPVFwiICYmIGN1cnJlbnROb2RlLmFzc2lnbmVkU2xvdCA/IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuYXNzaWduZWRTbG90LnBhcmVudE5vZGUgOiAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYWY1MWYwZjA2YzBmMzI4YShjdXJyZW50Tm9kZSkgPyBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3QgOiBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuY29uc3QgJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGNkNGU1NTczZmJlMmI1NzYgPSAoZG9jID0gZG9jdW1lbnQpID0+IHtcbiAgdmFyIF9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3Q7XG4gIGlmICghJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDk4NjU4ZThjNTkxMjVlNmEoKSkgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50O1xuICBsZXQgYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICBmb3IgKDsgYWN0aXZlRWxlbWVudCAmJiBcInNoYWRvd1Jvb3RcIiBpbiBhY3RpdmVFbGVtZW50ICYmICghKChfYWN0aXZlRWxlbWVudF9zaGFkb3dSb290ID0gYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KSA9PT0gbnVsbCB8fCBfYWN0aXZlRWxlbWVudF9zaGFkb3dSb290ID09PSB2b2lkIDApICYmIF9hY3RpdmVFbGVtZW50X3NoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudCk7ICkgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn07XG5mdW5jdGlvbiAkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkZTU4ZjAyOWYwZmJmZGIyOShldmVudCkge1xuICByZXR1cm4gJGY0ZTJkZjZiZDE1Zjg1NjkkZXhwb3J0JDk4NjU4ZThjNTkxMjVlNmEoKSAmJiBldmVudC50YXJnZXQuc2hhZG93Um9vdCAmJiBldmVudC5jb21wb3NlZFBhdGggPyBldmVudC5jb21wb3NlZFBhdGgoKVswXSA6IGV2ZW50LnRhcmdldDtcbn1cbnZhciBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdCQ0ID0ge307XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudChyZSkge1xuICB2YXIgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YTtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPiBcInVcIiB8fCB3aW5kb3cubmF2aWdhdG9yID09IG51bGwgPyAhMSA6ICgoX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50RGF0YSkgPT09IG51bGwgfHwgX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3dpbmRvd19uYXZpZ2F0b3JfdXNlckFnZW50RGF0YS5icmFuZHMuc29tZSgoYnJhbmQpID0+IHJlLnRlc3QoYnJhbmQuYnJhbmQpKSkgfHwgcmUudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFBsYXRmb3JtKHJlKSB7XG4gIHZhciBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhO1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHdpbmRvdy5uYXZpZ2F0b3IgIT0gbnVsbCA/IHJlLnRlc3QoKChfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnREYXRhKSA9PT0gbnVsbCB8fCBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93X25hdmlnYXRvcl91c2VyQWdlbnREYXRhLnBsYXRmb3JtKSB8fCB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSA6ICExO1xufVxuZnVuY3Rpb24gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJGNhY2hlZChmbikge1xuICBpZiAoZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQkNC5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIpIHJldHVybiBmbjtcbiAgbGV0IHJlcyA9IG51bGw7XG4gIHJldHVybiAoKSA9PiAocmVzID09IG51bGwgJiYgKHJlcyA9IGZuKCkpLCByZXMpO1xufVxuY29uc3QgJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JDlhYzEwMGU0MDYxM2VhMTAgPSAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkY2FjaGVkKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gJGM4NzMxMTQyNGVhMzBhMDUkdmFyJHRlc3RQbGF0Zm9ybSgvXk1hYy9pKTtcbn0pLCAkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkYTExYjAwNTk5MDBjZWVjOCA9ICRjODczMTE0MjRlYTMwYTA1JHZhciRjYWNoZWQoZnVuY3Rpb24oKSB7XG4gIHJldHVybiAkYzg3MzExNDI0ZWEzMGEwNSR2YXIkdGVzdFVzZXJBZ2VudCgvQW5kcm9pZC9pKTtcbn0pO1xuZnVuY3Rpb24gJDAzZGViMjNmZjE0OTIwYzQkZXhwb3J0JDRlYWYwNGU1NGFhOGVlZDYoKSB7XG4gIGxldCBnbG9iYWxMaXN0ZW5lcnMgPSB1c2VSZWYoLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIGFkZEdsb2JhbExpc3RlbmVyID0gdXNlQ2FsbGJhY2soKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgIGxldCBmbiA9IG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLm9uY2UgPyAoLi4uYXJncykgPT4ge1xuICAgICAgZ2xvYmFsTGlzdGVuZXJzLmN1cnJlbnQuZGVsZXRlKGxpc3RlbmVyKSwgbGlzdGVuZXIoLi4uYXJncyk7XG4gICAgfSA6IGxpc3RlbmVyO1xuICAgIGdsb2JhbExpc3RlbmVycy5jdXJyZW50LnNldChsaXN0ZW5lciwge1xuICAgICAgdHlwZSxcbiAgICAgIGV2ZW50VGFyZ2V0LFxuICAgICAgZm4sXG4gICAgICBvcHRpb25zXG4gICAgfSksIGV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICB9LCBbXSksIHJlbW92ZUdsb2JhbExpc3RlbmVyID0gdXNlQ2FsbGJhY2soKGV2ZW50VGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfZ2xvYmFsTGlzdGVuZXJzX2N1cnJlbnRfZ2V0O1xuICAgIGxldCBmbiA9ICgoX2dsb2JhbExpc3RlbmVyc19jdXJyZW50X2dldCA9IGdsb2JhbExpc3RlbmVycy5jdXJyZW50LmdldChsaXN0ZW5lcikpID09PSBudWxsIHx8IF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nbG9iYWxMaXN0ZW5lcnNfY3VycmVudF9nZXQuZm4pIHx8IGxpc3RlbmVyO1xuICAgIGV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpLCBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5kZWxldGUobGlzdGVuZXIpO1xuICB9LCBbXSksIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBnbG9iYWxMaXN0ZW5lcnMuY3VycmVudC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZW1vdmVHbG9iYWxMaXN0ZW5lcih2YWx1ZS5ldmVudFRhcmdldCwgdmFsdWUudHlwZSwga2V5LCB2YWx1ZS5vcHRpb25zKTtcbiAgICB9KTtcbiAgfSwgW1xuICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyXG4gIF0pO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycywgW1xuICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICBdKSwge1xuICAgIGFkZEdsb2JhbExpc3RlbmVyLFxuICAgIHJlbW92ZUdsb2JhbExpc3RlbmVyLFxuICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICB9O1xufVxuZnVuY3Rpb24gJDZhN2RiODU0MzI0NDhmN2YkZXhwb3J0JDYwMjc4ODcxNDU3NjIyZGUoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCA/ICEwIDogJGM4NzMxMTQyNGVhMzBhMDUkZXhwb3J0JGExMWIwMDU5OTAwY2VlYzgoKSAmJiBldmVudC5wb2ludGVyVHlwZSA/IGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiAmJiBldmVudC5idXR0b25zID09PSAxIDogZXZlbnQuZGV0YWlsID09PSAwICYmICFldmVudC5wb2ludGVyVHlwZTtcbn1cbmZ1bmN0aW9uICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCQ1MjViYzQ5MjFkNTZkNGEobmF0aXZlRXZlbnQpIHtcbiAgbGV0IGV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gIHJldHVybiBldmVudC5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50LCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoKSA9PiBldmVudC5kZWZhdWx0UHJldmVudGVkLCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9ICgpID0+IGV2ZW50LmNhbmNlbEJ1YmJsZSwgZXZlbnQucGVyc2lzdCA9ICgpID0+IHtcbiAgfSwgZXZlbnQ7XG59XG5mdW5jdGlvbiAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkYzJiN2FiZTVkNjFlYzY5NihldmVudCwgdGFyZ2V0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgXCJ0YXJnZXRcIiwge1xuICAgIHZhbHVlOiB0YXJnZXRcbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShldmVudCwgXCJjdXJyZW50VGFyZ2V0XCIsIHtcbiAgICB2YWx1ZTogdGFyZ2V0XG4gIH0pO1xufVxuZnVuY3Rpb24gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2Mob25CbHVyKSB7XG4gIGxldCBzdGF0ZVJlZiA9IHVzZVJlZih7XG4gICAgaXNGb2N1c2VkOiAhMSxcbiAgICBvYnNlcnZlcjogbnVsbFxuICB9KTtcbiAgJGYwYTA0Y2NkOGRiZGQ4M2IkZXhwb3J0JGU1YzVhNWY5MTdhNTg3MWMoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVSZWYuY3VycmVudDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RhdGUub2JzZXJ2ZXIgJiYgKHN0YXRlLm9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgc3RhdGUub2JzZXJ2ZXIgPSBudWxsKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGxldCBkaXNwYXRjaEJsdXIgPSAkOGFlMDVlYWE1YzExNGU5YyRleHBvcnQkN2Y1NGZjMzE4MDUwOGE1MigoZTIpID0+IHtcbiAgICBvbkJsdXIgPT0gbnVsbCB8fCBvbkJsdXIoZTIpO1xuICB9KTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKChlMikgPT4ge1xuICAgIGlmIChlMi50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCB8fCBlMi50YXJnZXQgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50IHx8IGUyLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZTIudGFyZ2V0IGluc3RhbmNlb2YgSFRNTFNlbGVjdEVsZW1lbnQpIHtcbiAgICAgIHN0YXRlUmVmLmN1cnJlbnQuaXNGb2N1c2VkID0gITA7XG4gICAgICBsZXQgdGFyZ2V0ID0gZTIudGFyZ2V0LCBvbkJsdXJIYW5kbGVyID0gKGUzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZVJlZi5jdXJyZW50LmlzRm9jdXNlZCA9ICExLCB0YXJnZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICBsZXQgZXZlbnQgPSAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkNTI1YmM0OTIxZDU2ZDRhKGUzKTtcbiAgICAgICAgICBkaXNwYXRjaEJsdXIoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIgJiYgKHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyID0gbnVsbCk7XG4gICAgICB9O1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBvbkJsdXJIYW5kbGVyLCB7XG4gICAgICAgIG9uY2U6ICEwXG4gICAgICB9KSwgc3RhdGVSZWYuY3VycmVudC5vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQuaXNGb2N1c2VkICYmIHRhcmdldC5kaXNhYmxlZCkge1xuICAgICAgICAgIHZhciBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlcjtcbiAgICAgICAgICAoX3N0YXRlUmVmX2N1cnJlbnRfb2JzZXJ2ZXIgPSBzdGF0ZVJlZi5jdXJyZW50Lm9ic2VydmVyKSA9PT0gbnVsbCB8fCBfc3RhdGVSZWZfY3VycmVudF9vYnNlcnZlciA9PT0gdm9pZCAwIHx8IF9zdGF0ZVJlZl9jdXJyZW50X29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBsZXQgcmVsYXRlZFRhcmdldEVsID0gdGFyZ2V0ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID8gbnVsbCA6IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEZvY3VzRXZlbnQoXCJibHVyXCIsIHtcbiAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRFbFxuICAgICAgICAgIH0pKSwgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEZvY3VzRXZlbnQoXCJmb2N1c291dFwiLCB7XG4gICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRFbFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSksIHN0YXRlUmVmLmN1cnJlbnQub2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQsIHtcbiAgICAgICAgYXR0cmlidXRlczogITAsXG4gICAgICAgIGF0dHJpYnV0ZUZpbHRlcjogW1xuICAgICAgICAgIFwiZGlzYWJsZWRcIlxuICAgICAgICBdXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtcbiAgICBkaXNwYXRjaEJsdXJcbiAgXSk7XG59XG5sZXQgJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JGZkYTdkYTczYWI1ZDRjNDggPSAhMTtcbnZhciBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdCQzID0ge307XG5sZXQgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IG51bGwsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjaGFuZ2VIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRkOTAyNDNiNThkYWVjZGE3ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSAhMSwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSA9ICExO1xuY29uc3QgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJEZPQ1VTX1ZJU0lCTEVfSU5QVVRfS0VZUyA9IHtcbiAgVGFiOiAhMCxcbiAgRXNjYXBlOiAhMFxufTtcbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMobW9kYWxpdHksIGUyKSB7XG4gIGZvciAobGV0IGhhbmRsZXIgb2YgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzKSBoYW5kbGVyKG1vZGFsaXR5LCBlMik7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlMikge1xuICByZXR1cm4gIShlMi5tZXRhS2V5IHx8ICEkYzg3MzExNDI0ZWEzMGEwNSRleHBvcnQkOWFjMTAwZTQwNjEzZWExMCgpICYmIGUyLmFsdEtleSB8fCBlMi5jdHJsS2V5IHx8IGUyLmtleSA9PT0gXCJDb250cm9sXCIgfHwgZTIua2V5ID09PSBcIlNoaWZ0XCIgfHwgZTIua2V5ID09PSBcIk1ldGFcIik7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudChlMikge1xuICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9ICEwLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaXNWYWxpZEtleShlMikgJiYgKCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBcImtleWJvYXJkXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoXCJrZXlib2FyZFwiLCBlMikpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudChlMikge1xuICAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ID0gXCJwb2ludGVyXCIsIChlMi50eXBlID09PSBcIm1vdXNlZG93blwiIHx8IGUyLnR5cGUgPT09IFwicG9pbnRlcmRvd25cIikgJiYgKCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gITAsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0cmlnZ2VyQ2hhbmdlSGFuZGxlcnMoXCJwb2ludGVyXCIsIGUyKSk7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudChlMikge1xuICAkNmE3ZGI4NTQzMjQ0OGY3ZiRleHBvcnQkNjAyNzg4NzE0NTc2MjJkZShlMikgJiYgKCQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gITAsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRjdXJyZW50TW9kYWxpdHkgPSBcInZpcnR1YWxcIik7XG59XG5mdW5jdGlvbiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlRm9jdXNFdmVudChlMikge1xuICBlMi50YXJnZXQgPT09IHdpbmRvdyB8fCBlMi50YXJnZXQgPT09IGRvY3VtZW50IHx8ICQ4YTljYjI3OWRjODdlMTMwJGV4cG9ydCRmZGE3ZGE3M2FiNWQ0YzQ4IHx8ICFlMi5pc1RydXN0ZWQgfHwgKCEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyAmJiAhJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0JsdXJyZWRXaW5kb3dSZWNlbnRseSAmJiAoJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGN1cnJlbnRNb2RhbGl0eSA9IFwidmlydHVhbFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdHJpZ2dlckNoYW5nZUhhbmRsZXJzKFwidmlydHVhbFwiLCBlMikpLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzRXZlbnRCZWZvcmVGb2N1cyA9ICExLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFzQmx1cnJlZFdpbmRvd1JlY2VudGx5ID0gITEpO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVdpbmRvd0JsdXIoKSB7XG4gICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNFdmVudEJlZm9yZUZvY3VzID0gITEsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYXNCbHVycmVkV2luZG93UmVjZW50bHkgPSAhMDtcbn1cbmZ1bmN0aW9uICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRzZXR1cEdsb2JhbEZvY3VzRXZlbnRzKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIiB8fCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZDkwMjQzYjU4ZGFlY2RhNy5nZXQoJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGYyMWExZmZhZTI2MDE0NWEoZWxlbWVudCkpKSByZXR1cm47XG4gIGNvbnN0IHdpbmRvd09iamVjdCA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhKGVsZW1lbnQpLCBkb2N1bWVudE9iamVjdCA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjKGVsZW1lbnQpO1xuICBsZXQgZm9jdXMgPSB3aW5kb3dPYmplY3QuSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzO1xuICB3aW5kb3dPYmplY3QuSFRNTEVsZW1lbnQucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhc0V2ZW50QmVmb3JlRm9jdXMgPSAhMCwgZm9jdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSwgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQsICEwKSwgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVLZXlib2FyZEV2ZW50LCAhMCksIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlQ2xpY2tFdmVudCwgITApLCB3aW5kb3dPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVGb2N1c0V2ZW50LCAhMCksIHdpbmRvd09iamVjdC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlV2luZG93Qmx1ciwgITEpLCB0eXBlb2YgUG9pbnRlckV2ZW50IDwgXCJ1XCIgPyAoZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsICEwKSwgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsICEwKSwgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCAhMCkpIDogZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQkMy5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgJiYgKGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgITApLCBkb2N1bWVudE9iamVjdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsICEwKSwgZG9jdW1lbnRPYmplY3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgITApKSwgd2luZG93T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgKCkgPT4ge1xuICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciR0ZWFyRG93bldpbmRvd0ZvY3VzVHJhY2tpbmcoZWxlbWVudCk7XG4gIH0sIHtcbiAgICBvbmNlOiAhMFxuICB9KSwgJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGQ5MDI0M2I1OGRhZWNkYTcuc2V0KHdpbmRvd09iamVjdCwge1xuICAgIGZvY3VzXG4gIH0pO1xufVxuY29uc3QgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHRlYXJEb3duV2luZG93Rm9jdXNUcmFja2luZyA9IChlbGVtZW50LCBsb2FkTGlzdGVuZXIpID0+IHtcbiAgY29uc3Qgd2luZG93T2JqZWN0ID0gJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGYyMWExZmZhZTI2MDE0NWEoZWxlbWVudCksIGRvY3VtZW50T2JqZWN0ID0gJDQzMWZiZDg2Y2E3ZGMyMTYkZXhwb3J0JGIyMDRhZjE1ODA0MmZiYWMoZWxlbWVudCk7XG4gIGxvYWRMaXN0ZW5lciAmJiBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBsb2FkTGlzdGVuZXIpLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZDkwMjQzYjU4ZGFlY2RhNy5oYXMod2luZG93T2JqZWN0KSAmJiAod2luZG93T2JqZWN0LkhUTUxFbGVtZW50LnByb3RvdHlwZS5mb2N1cyA9ICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRkOTAyNDNiNThkYWVjZGE3LmdldCh3aW5kb3dPYmplY3QpLmZvY3VzLCBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlS2V5Ym9hcmRFdmVudCwgITApLCBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUtleWJvYXJkRXZlbnQsICEwKSwgZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVDbGlja0V2ZW50LCAhMCksIHdpbmRvd09iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZUZvY3VzRXZlbnQsICEwKSwgd2luZG93T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVXaW5kb3dCbHVyLCAhMSksIHR5cGVvZiBQb2ludGVyRXZlbnQgPCBcInVcIiA/IChkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgITApLCBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgITApLCBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRoYW5kbGVQb2ludGVyRXZlbnQsICEwKSkgOiBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdCQzLk5PREVfRU5WID09PSBcInRlc3RcIiAmJiAoZG9jdW1lbnRPYmplY3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCAhMCksIGRvY3VtZW50T2JqZWN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGhhbmRsZVBvaW50ZXJFdmVudCwgITApLCBkb2N1bWVudE9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkaGFuZGxlUG9pbnRlckV2ZW50LCAhMCkpLCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkZDkwMjQzYjU4ZGFlY2RhNy5kZWxldGUod2luZG93T2JqZWN0KSk7XG59O1xuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JDJmMTg4ODExMmY1NThhN2QoZWxlbWVudCkge1xuICBjb25zdCBkb2N1bWVudE9iamVjdCA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjKGVsZW1lbnQpO1xuICBsZXQgbG9hZExpc3RlbmVyO1xuICByZXR1cm4gZG9jdW1lbnRPYmplY3QucmVhZHlTdGF0ZSAhPT0gXCJsb2FkaW5nXCIgPyAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkc2V0dXBHbG9iYWxGb2N1c0V2ZW50cyhlbGVtZW50KSA6IChsb2FkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoZWxlbWVudCk7XG4gIH0sIGRvY3VtZW50T2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGxvYWRMaXN0ZW5lcikpLCAoKSA9PiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkdGVhckRvd25XaW5kb3dGb2N1c1RyYWNraW5nKGVsZW1lbnQsIGxvYWRMaXN0ZW5lcik7XG59XG50eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkMmYxODg4MTEyZjU1OGE3ZCgpO1xuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSB7XG4gIHJldHVybiAkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkY3VycmVudE1vZGFsaXR5ICE9PSBcInBvaW50ZXJcIjtcbn1cbmNvbnN0ICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRub25UZXh0SW5wdXRUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJjaGVja2JveFwiLFxuICBcInJhZGlvXCIsXG4gIFwicmFuZ2VcIixcbiAgXCJjb2xvclwiLFxuICBcImZpbGVcIixcbiAgXCJpbWFnZVwiLFxuICBcImJ1dHRvblwiLFxuICBcInN1Ym1pdFwiLFxuICBcInJlc2V0XCJcbl0pO1xuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGlzS2V5Ym9hcmRGb2N1c0V2ZW50KGlzVGV4dElucHV0LCBtb2RhbGl0eSwgZTIpIHtcbiAgbGV0IGRvY3VtZW50MSA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjKGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi50YXJnZXQpO1xuICBjb25zdCBJSFRNTElucHV0RWxlbWVudCA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhKGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi50YXJnZXQpLkhUTUxJbnB1dEVsZW1lbnQgOiBIVE1MSW5wdXRFbGVtZW50LCBJSFRNTFRleHRBcmVhRWxlbWVudCA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhKGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi50YXJnZXQpLkhUTUxUZXh0QXJlYUVsZW1lbnQgOiBIVE1MVGV4dEFyZWFFbGVtZW50LCBJSFRNTEVsZW1lbnQgPSB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkZjIxYTFmZmFlMjYwMTQ1YShlMiA9PSBudWxsID8gdm9pZCAwIDogZTIudGFyZ2V0KS5IVE1MRWxlbWVudCA6IEhUTUxFbGVtZW50LCBJS2V5Ym9hcmRFdmVudCA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRmMjFhMWZmYWUyNjAxNDVhKGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi50YXJnZXQpLktleWJvYXJkRXZlbnQgOiBLZXlib2FyZEV2ZW50O1xuICByZXR1cm4gaXNUZXh0SW5wdXQgPSBpc1RleHRJbnB1dCB8fCBkb2N1bWVudDEuYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIElIVE1MSW5wdXRFbGVtZW50ICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkbm9uVGV4dElucHV0VHlwZXMuaGFzKGRvY3VtZW50MS5hY3RpdmVFbGVtZW50LnR5cGUpIHx8IGRvY3VtZW50MS5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSUhUTUxUZXh0QXJlYUVsZW1lbnQgfHwgZG9jdW1lbnQxLmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBJSFRNTEVsZW1lbnQgJiYgZG9jdW1lbnQxLmFjdGl2ZUVsZW1lbnQuaXNDb250ZW50RWRpdGFibGUsICEoaXNUZXh0SW5wdXQgJiYgbW9kYWxpdHkgPT09IFwia2V5Ym9hcmRcIiAmJiBlMiBpbnN0YW5jZW9mIElLZXlib2FyZEV2ZW50ICYmICEkNTA3ZmFiZTEwZTcxYzZmYiR2YXIkRk9DVVNfVklTSUJMRV9JTlBVVF9LRVlTW2UyLmtleV0pO1xufVxuZnVuY3Rpb24gJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGVjNzFiNGI4M2FjMDhlYzMoZm4sIGRlcHMsIG9wdHMpIHtcbiAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJHNldHVwR2xvYmFsRm9jdXNFdmVudHMoKSwgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaGFuZGxlciA9IChtb2RhbGl0eSwgZTIpID0+IHtcbiAgICAgICQ1MDdmYWJlMTBlNzFjNmZiJHZhciRpc0tleWJvYXJkRm9jdXNFdmVudCghIShvcHRzICE9IG51bGwgJiYgb3B0cy5pc1RleHRJbnB1dCksIG1vZGFsaXR5LCBlMikgJiYgZm4oJDUwN2ZhYmUxMGU3MWM2ZmIkZXhwb3J0JGI5YjNkZmRkYWIxN2RiMjcoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmFkZChoYW5kbGVyKSwgKCkgPT4ge1xuICAgICAgJDUwN2ZhYmUxMGU3MWM2ZmIkdmFyJGNoYW5nZUhhbmRsZXJzLmRlbGV0ZShoYW5kbGVyKTtcbiAgICB9O1xuICB9LCBkZXBzKTtcbn1cbmZ1bmN0aW9uICRhMWVhNTlkNjgyNzBmMGRkJGV4cG9ydCRmODE2OGQ4ZGQ4ZmQ2NmU2KHByb3BzKSB7XG4gIGxldCB7IGlzRGlzYWJsZWQsIG9uRm9jdXM6IG9uRm9jdXNQcm9wLCBvbkJsdXI6IG9uQmx1clByb3AsIG9uRm9jdXNDaGFuZ2UgfSA9IHByb3BzO1xuICBjb25zdCBvbkJsdXIgPSB1c2VDYWxsYmFjaygoZTIpID0+IHtcbiAgICBpZiAoZTIudGFyZ2V0ID09PSBlMi5jdXJyZW50VGFyZ2V0KVxuICAgICAgcmV0dXJuIG9uQmx1clByb3AgJiYgb25CbHVyUHJvcChlMiksIG9uRm9jdXNDaGFuZ2UgJiYgb25Gb2N1c0NoYW5nZSghMSksICEwO1xuICB9LCBbXG4gICAgb25CbHVyUHJvcCxcbiAgICBvbkZvY3VzQ2hhbmdlXG4gIF0pLCBvblN5bnRoZXRpY0ZvY3VzID0gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2Mob25CbHVyKSwgb25Gb2N1cyA9IHVzZUNhbGxiYWNrKChlMikgPT4ge1xuICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSAkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyhlMi50YXJnZXQpLCBhY3RpdmVFbGVtZW50ID0gb3duZXJEb2N1bWVudCA/ICRkNGVlMTBkZTMwNmYyNTEwJGV4cG9ydCRjZDRlNTU3M2ZiZTJiNTc2KG93bmVyRG9jdW1lbnQpIDogJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGNkNGU1NTczZmJlMmI1NzYoKTtcbiAgICBlMi50YXJnZXQgPT09IGUyLmN1cnJlbnRUYXJnZXQgJiYgYWN0aXZlRWxlbWVudCA9PT0gJGQ0ZWUxMGRlMzA2ZjI1MTAkZXhwb3J0JGU1OGYwMjlmMGZiZmRiMjkoZTIubmF0aXZlRXZlbnQpICYmIChvbkZvY3VzUHJvcCAmJiBvbkZvY3VzUHJvcChlMiksIG9uRm9jdXNDaGFuZ2UgJiYgb25Gb2N1c0NoYW5nZSghMCksIG9uU3ludGhldGljRm9jdXMoZTIpKTtcbiAgfSwgW1xuICAgIG9uRm9jdXNDaGFuZ2UsXG4gICAgb25Gb2N1c1Byb3AsXG4gICAgb25TeW50aGV0aWNGb2N1c1xuICBdKTtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c1Byb3BzOiB7XG4gICAgICBvbkZvY3VzOiAhaXNEaXNhYmxlZCAmJiAob25Gb2N1c1Byb3AgfHwgb25Gb2N1c0NoYW5nZSB8fCBvbkJsdXJQcm9wKSA/IG9uRm9jdXMgOiB2b2lkIDAsXG4gICAgICBvbkJsdXI6ICFpc0Rpc2FibGVkICYmIChvbkJsdXJQcm9wIHx8IG9uRm9jdXNDaGFuZ2UpID8gb25CbHVyIDogdm9pZCAwXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gJDlhYjk0MjYyYmQwMDQ3YzckZXhwb3J0JDQyMGU2ODI3MzE2NWY0ZWMocHJvcHMpIHtcbiAgbGV0IHsgaXNEaXNhYmxlZCwgb25CbHVyV2l0aGluLCBvbkZvY3VzV2l0aGluLCBvbkZvY3VzV2l0aGluQ2hhbmdlIH0gPSBwcm9wcywgc3RhdGUgPSB1c2VSZWYoe1xuICAgIGlzRm9jdXNXaXRoaW46ICExXG4gIH0pLCB7IGFkZEdsb2JhbExpc3RlbmVyLCByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMgfSA9ICQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2KCksIG9uQmx1ciA9IHVzZUNhbGxiYWNrKChlMikgPT4ge1xuICAgIGUyLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZTIudGFyZ2V0KSAmJiBzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gJiYgIWUyLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZTIucmVsYXRlZFRhcmdldCkgJiYgKHN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiA9ICExLCByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMoKSwgb25CbHVyV2l0aGluICYmIG9uQmx1cldpdGhpbihlMiksIG9uRm9jdXNXaXRoaW5DaGFuZ2UgJiYgb25Gb2N1c1dpdGhpbkNoYW5nZSghMSkpO1xuICB9LCBbXG4gICAgb25CbHVyV2l0aGluLFxuICAgIG9uRm9jdXNXaXRoaW5DaGFuZ2UsXG4gICAgc3RhdGUsXG4gICAgcmVtb3ZlQWxsR2xvYmFsTGlzdGVuZXJzXG4gIF0pLCBvblN5bnRoZXRpY0ZvY3VzID0gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDcxNWM2ODJkMDlkNjM5Y2Mob25CbHVyKSwgb25Gb2N1cyA9IHVzZUNhbGxiYWNrKChlMikgPT4ge1xuICAgIGlmICghZTIuY3VycmVudFRhcmdldC5jb250YWlucyhlMi50YXJnZXQpKSByZXR1cm47XG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9ICQ0MzFmYmQ4NmNhN2RjMjE2JGV4cG9ydCRiMjA0YWYxNTgwNDJmYmFjKGUyLnRhcmdldCksIGFjdGl2ZUVsZW1lbnQgPSAkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkY2Q0ZTU1NzNmYmUyYjU3Nihvd25lckRvY3VtZW50KTtcbiAgICBpZiAoIXN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiAmJiBhY3RpdmVFbGVtZW50ID09PSAkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkZTU4ZjAyOWYwZmJmZGIyOShlMi5uYXRpdmVFdmVudCkpIHtcbiAgICAgIG9uRm9jdXNXaXRoaW4gJiYgb25Gb2N1c1dpdGhpbihlMiksIG9uRm9jdXNXaXRoaW5DaGFuZ2UgJiYgb25Gb2N1c1dpdGhpbkNoYW5nZSghMCksIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1dpdGhpbiA9ICEwLCBvblN5bnRoZXRpY0ZvY3VzKGUyKTtcbiAgICAgIGxldCBjdXJyZW50VGFyZ2V0ID0gZTIuY3VycmVudFRhcmdldDtcbiAgICAgIGFkZEdsb2JhbExpc3RlbmVyKG93bmVyRG9jdW1lbnQsIFwiZm9jdXNcIiwgKGUzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0ZS5jdXJyZW50LmlzRm9jdXNXaXRoaW4gJiYgISRkNGVlMTBkZTMwNmYyNTEwJGV4cG9ydCQ0MjgyZjcwNzk4MDY0ZmUwKGN1cnJlbnRUYXJnZXQsIGUzLnRhcmdldCkpIHtcbiAgICAgICAgICBsZXQgbmF0aXZlRXZlbnQgPSBuZXcgb3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5Gb2N1c0V2ZW50KFwiYmx1clwiLCB7XG4gICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBlMy50YXJnZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkOGE5Y2IyNzlkYzg3ZTEzMCRleHBvcnQkYzJiN2FiZTVkNjFlYzY5NihuYXRpdmVFdmVudCwgY3VycmVudFRhcmdldCk7XG4gICAgICAgICAgbGV0IGV2ZW50ID0gJDhhOWNiMjc5ZGM4N2UxMzAkZXhwb3J0JDUyNWJjNDkyMWQ1NmQ0YShuYXRpdmVFdmVudCk7XG4gICAgICAgICAgb25CbHVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbXG4gICAgb25Gb2N1c1dpdGhpbixcbiAgICBvbkZvY3VzV2l0aGluQ2hhbmdlLFxuICAgIG9uU3ludGhldGljRm9jdXMsXG4gICAgYWRkR2xvYmFsTGlzdGVuZXIsXG4gICAgb25CbHVyXG4gIF0pO1xuICByZXR1cm4gaXNEaXNhYmxlZCA/IHtcbiAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICAvLyBUaGVzZSBjYW5ub3QgYmUgbnVsbCwgdGhhdCB3b3VsZCBjb25mbGljdCBpbiBtZXJnZVByb3BzXG4gICAgICBvbkZvY3VzOiB2b2lkIDAsXG4gICAgICBvbkJsdXI6IHZvaWQgMFxuICAgIH1cbiAgfSA6IHtcbiAgICBmb2N1c1dpdGhpblByb3BzOiB7XG4gICAgICBvbkZvY3VzLFxuICAgICAgb25CbHVyXG4gICAgfVxuICB9O1xufVxudmFyIGRlZmluZV9wcm9jZXNzX2Vudl9kZWZhdWx0JDIgPSB7fTtcbmxldCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9ICExLCAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCA9IDA7XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0R2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cygpIHtcbiAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSAhMCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGdsb2JhbElnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgPSAhMTtcbiAgfSwgNTApO1xufVxuZnVuY3Rpb24gJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhhbmRsZUdsb2JhbFBvaW50ZXJFdmVudChlMikge1xuICBlMi5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiICYmICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKCk7XG59XG5mdW5jdGlvbiAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkc2V0dXBHbG9iYWxUb3VjaEV2ZW50cygpIHtcbiAgaWYgKCEodHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIpKVxuICAgIHJldHVybiB0eXBlb2YgUG9pbnRlckV2ZW50IDwgXCJ1XCIgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQpIDogZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQkMi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSwgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQrKywgKCkgPT4ge1xuICAgICAgJDYxNzliOTM2NzA1ZTc2ZDMkdmFyJGhvdmVyQ291bnQtLSwgISgkNjE3OWI5MzY3MDVlNzZkMyR2YXIkaG92ZXJDb3VudCA+IDApICYmICh0eXBlb2YgUG9pbnRlckV2ZW50IDwgXCJ1XCIgPyBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRoYW5kbGVHbG9iYWxQb2ludGVyRXZlbnQpIDogZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQkMi5OT0RFX0VOViA9PT0gXCJ0ZXN0XCIgJiYgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsICQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXRHbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzKSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uICQ2MTc5YjkzNjcwNWU3NmQzJGV4cG9ydCRhZTc4MGRhZjI5ZTZkNDU2KHByb3BzKSB7XG4gIGxldCB7IG9uSG92ZXJTdGFydCwgb25Ib3ZlckNoYW5nZSwgb25Ib3ZlckVuZCwgaXNEaXNhYmxlZCB9ID0gcHJvcHMsIFtpc0hvdmVyZWQsIHNldEhvdmVyZWRdID0gdXNlU3RhdGUoITEpLCBzdGF0ZSA9IHVzZVJlZih7XG4gICAgaXNIb3ZlcmVkOiAhMSxcbiAgICBpZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzOiAhMSxcbiAgICBwb2ludGVyVHlwZTogXCJcIixcbiAgICB0YXJnZXQ6IG51bGxcbiAgfSkuY3VycmVudDtcbiAgdXNlRWZmZWN0KCQ2MTc5YjkzNjcwNWU3NmQzJHZhciRzZXR1cEdsb2JhbFRvdWNoRXZlbnRzLCBbXSk7XG4gIGxldCB7IGFkZEdsb2JhbExpc3RlbmVyLCByZW1vdmVBbGxHbG9iYWxMaXN0ZW5lcnMgfSA9ICQwM2RlYjIzZmYxNDkyMGM0JGV4cG9ydCQ0ZWFmMDRlNTRhYThlZWQ2KCksIHsgaG92ZXJQcm9wcywgdHJpZ2dlckhvdmVyRW5kIH0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJpZ2dlckhvdmVyU3RhcnQgPSAoZXZlbnQsIHBvaW50ZXJUeXBlKSA9PiB7XG4gICAgICBpZiAoc3RhdGUucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZSwgaXNEaXNhYmxlZCB8fCBwb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8IHN0YXRlLmlzSG92ZXJlZCB8fCAhZXZlbnQuY3VycmVudFRhcmdldC5jb250YWlucyhldmVudC50YXJnZXQpKSByZXR1cm47XG4gICAgICBzdGF0ZS5pc0hvdmVyZWQgPSAhMDtcbiAgICAgIGxldCB0YXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgc3RhdGUudGFyZ2V0ID0gdGFyZ2V0LCBhZGRHbG9iYWxMaXN0ZW5lcigkNDMxZmJkODZjYTdkYzIxNiRleHBvcnQkYjIwNGFmMTU4MDQyZmJhYyhldmVudC50YXJnZXQpLCBcInBvaW50ZXJvdmVyXCIsIChlMikgPT4ge1xuICAgICAgICBzdGF0ZS5pc0hvdmVyZWQgJiYgc3RhdGUudGFyZ2V0ICYmICEkZDRlZTEwZGUzMDZmMjUxMCRleHBvcnQkNDI4MmY3MDc5ODA2NGZlMChzdGF0ZS50YXJnZXQsIGUyLnRhcmdldCkgJiYgdHJpZ2dlckhvdmVyRW5kMihlMiwgZTIucG9pbnRlclR5cGUpO1xuICAgICAgfSwge1xuICAgICAgICBjYXB0dXJlOiAhMFxuICAgICAgfSksIG9uSG92ZXJTdGFydCAmJiBvbkhvdmVyU3RhcnQoe1xuICAgICAgICB0eXBlOiBcImhvdmVyc3RhcnRcIixcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgfSksIG9uSG92ZXJDaGFuZ2UgJiYgb25Ib3ZlckNoYW5nZSghMCksIHNldEhvdmVyZWQoITApO1xuICAgIH0sIHRyaWdnZXJIb3ZlckVuZDIgPSAoZXZlbnQsIHBvaW50ZXJUeXBlKSA9PiB7XG4gICAgICBsZXQgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICAgICAgc3RhdGUucG9pbnRlclR5cGUgPSBcIlwiLCBzdGF0ZS50YXJnZXQgPSBudWxsLCAhKHBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgIXN0YXRlLmlzSG92ZXJlZCB8fCAhdGFyZ2V0KSAmJiAoc3RhdGUuaXNIb3ZlcmVkID0gITEsIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVycygpLCBvbkhvdmVyRW5kICYmIG9uSG92ZXJFbmQoe1xuICAgICAgICB0eXBlOiBcImhvdmVyZW5kXCIsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgcG9pbnRlclR5cGVcbiAgICAgIH0pLCBvbkhvdmVyQ2hhbmdlICYmIG9uSG92ZXJDaGFuZ2UoITEpLCBzZXRIb3ZlcmVkKCExKSk7XG4gICAgfSwgaG92ZXJQcm9wczIgPSB7fTtcbiAgICByZXR1cm4gdHlwZW9mIFBvaW50ZXJFdmVudCA8IFwidVwiID8gKGhvdmVyUHJvcHMyLm9uUG9pbnRlckVudGVyID0gKGUyKSA9PiB7XG4gICAgICAkNjE3OWI5MzY3MDVlNzZkMyR2YXIkZ2xvYmFsSWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyAmJiBlMi5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiIHx8IHRyaWdnZXJIb3ZlclN0YXJ0KGUyLCBlMi5wb2ludGVyVHlwZSk7XG4gICAgfSwgaG92ZXJQcm9wczIub25Qb2ludGVyTGVhdmUgPSAoZTIpID0+IHtcbiAgICAgICFpc0Rpc2FibGVkICYmIGUyLmN1cnJlbnRUYXJnZXQuY29udGFpbnMoZTIudGFyZ2V0KSAmJiB0cmlnZ2VySG92ZXJFbmQyKGUyLCBlMi5wb2ludGVyVHlwZSk7XG4gICAgfSkgOiBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdCQyLk5PREVfRU5WID09PSBcInRlc3RcIiAmJiAoaG92ZXJQcm9wczIub25Ub3VjaFN0YXJ0ID0gKCkgPT4ge1xuICAgICAgc3RhdGUuaWdub3JlRW11bGF0ZWRNb3VzZUV2ZW50cyA9ICEwO1xuICAgIH0sIGhvdmVyUHJvcHMyLm9uTW91c2VFbnRlciA9IChlMikgPT4ge1xuICAgICAgIXN0YXRlLmlnbm9yZUVtdWxhdGVkTW91c2VFdmVudHMgJiYgISQ2MTc5YjkzNjcwNWU3NmQzJHZhciRnbG9iYWxJZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzICYmIHRyaWdnZXJIb3ZlclN0YXJ0KGUyLCBcIm1vdXNlXCIpLCBzdGF0ZS5pZ25vcmVFbXVsYXRlZE1vdXNlRXZlbnRzID0gITE7XG4gICAgfSwgaG92ZXJQcm9wczIub25Nb3VzZUxlYXZlID0gKGUyKSA9PiB7XG4gICAgICAhaXNEaXNhYmxlZCAmJiBlMi5jdXJyZW50VGFyZ2V0LmNvbnRhaW5zKGUyLnRhcmdldCkgJiYgdHJpZ2dlckhvdmVyRW5kMihlMiwgXCJtb3VzZVwiKTtcbiAgICB9KSwge1xuICAgICAgaG92ZXJQcm9wczogaG92ZXJQcm9wczIsXG4gICAgICB0cmlnZ2VySG92ZXJFbmQ6IHRyaWdnZXJIb3ZlckVuZDJcbiAgICB9O1xuICB9LCBbXG4gICAgb25Ib3ZlclN0YXJ0LFxuICAgIG9uSG92ZXJDaGFuZ2UsXG4gICAgb25Ib3ZlckVuZCxcbiAgICBpc0Rpc2FibGVkLFxuICAgIHN0YXRlLFxuICAgIGFkZEdsb2JhbExpc3RlbmVyLFxuICAgIHJlbW92ZUFsbEdsb2JhbExpc3RlbmVyc1xuICBdKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaXNEaXNhYmxlZCAmJiB0cmlnZ2VySG92ZXJFbmQoe1xuICAgICAgY3VycmVudFRhcmdldDogc3RhdGUudGFyZ2V0XG4gICAgfSwgc3RhdGUucG9pbnRlclR5cGUpO1xuICB9LCBbXG4gICAgaXNEaXNhYmxlZFxuICBdKSwge1xuICAgIGhvdmVyUHJvcHMsXG4gICAgaXNIb3ZlcmVkXG4gIH07XG59XG5mdW5jdGlvbiAkZjdkY2VmZmM1YWQ3NzY4YiRleHBvcnQkNGUzMjhmNjFjNTM4Njg3Zihwcm9wcyA9IHt9KSB7XG4gIGxldCB7IGF1dG9Gb2N1cyA9ICExLCBpc1RleHRJbnB1dCwgd2l0aGluIH0gPSBwcm9wcywgc3RhdGUgPSB1c2VSZWYoe1xuICAgIGlzRm9jdXNlZDogITEsXG4gICAgaXNGb2N1c1Zpc2libGU6IGF1dG9Gb2N1cyB8fCAkNTA3ZmFiZTEwZTcxYzZmYiRleHBvcnQkYjliM2RmZGRhYjE3ZGIyNygpXG4gIH0pLCBbaXNGb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKCExKSwgW2lzRm9jdXNWaXNpYmxlU3RhdGUsIHNldEZvY3VzVmlzaWJsZV0gPSB1c2VTdGF0ZSgoKSA9PiBzdGF0ZS5jdXJyZW50LmlzRm9jdXNlZCAmJiBzdGF0ZS5jdXJyZW50LmlzRm9jdXNWaXNpYmxlKSwgdXBkYXRlU3RhdGUgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRGb2N1c1Zpc2libGUoc3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgJiYgc3RhdGUuY3VycmVudC5pc0ZvY3VzVmlzaWJsZSksIFtdKSwgb25Gb2N1c0NoYW5nZSA9IHVzZUNhbGxiYWNrKChpc0ZvY3VzZWQyKSA9PiB7XG4gICAgc3RhdGUuY3VycmVudC5pc0ZvY3VzZWQgPSBpc0ZvY3VzZWQyLCBzZXRGb2N1c2VkKGlzRm9jdXNlZDIpLCB1cGRhdGVTdGF0ZSgpO1xuICB9LCBbXG4gICAgdXBkYXRlU3RhdGVcbiAgXSk7XG4gICQ1MDdmYWJlMTBlNzFjNmZiJGV4cG9ydCRlYzcxYjRiODNhYzA4ZWMzKChpc0ZvY3VzVmlzaWJsZSkgPT4ge1xuICAgIHN0YXRlLmN1cnJlbnQuaXNGb2N1c1Zpc2libGUgPSBpc0ZvY3VzVmlzaWJsZSwgdXBkYXRlU3RhdGUoKTtcbiAgfSwgW10sIHtcbiAgICBpc1RleHRJbnB1dFxuICB9KTtcbiAgbGV0IHsgZm9jdXNQcm9wcyB9ID0gJGExZWE1OWQ2ODI3MGYwZGQkZXhwb3J0JGY4MTY4ZDhkZDhmZDY2ZTYoe1xuICAgIGlzRGlzYWJsZWQ6IHdpdGhpbixcbiAgICBvbkZvY3VzQ2hhbmdlXG4gIH0pLCB7IGZvY3VzV2l0aGluUHJvcHMgfSA9ICQ5YWI5NDI2MmJkMDA0N2M3JGV4cG9ydCQ0MjBlNjgyNzMxNjVmNGVjKHtcbiAgICBpc0Rpc2FibGVkOiAhd2l0aGluLFxuICAgIG9uRm9jdXNXaXRoaW5DaGFuZ2U6IG9uRm9jdXNDaGFuZ2VcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgaXNGb2N1c2VkLFxuICAgIGlzRm9jdXNWaXNpYmxlOiBpc0ZvY3VzVmlzaWJsZVN0YXRlLFxuICAgIGZvY3VzUHJvcHM6IHdpdGhpbiA/IGZvY3VzV2l0aGluUHJvcHMgOiBmb2N1c1Byb3BzXG4gIH07XG59XG52YXIgaSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBkJDMgPSAodDIsIGUyLCBuMikgPT4gZTIgaW4gdDIgPyBpJDYodDIsIGUyLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBuMiB9KSA6IHQyW2UyXSA9IG4yLCByJDIgPSAodDIsIGUyLCBuMikgPT4gKGQkMyh0MiwgdHlwZW9mIGUyICE9IFwic3ltYm9sXCIgPyBlMiArIFwiXCIgOiBlMiwgbjIpLCBuMik7XG5sZXQgbyQ3ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICByJDIodGhpcywgXCJjdXJyZW50XCIsIHRoaXMuZGV0ZWN0KCkpLCByJDIodGhpcywgXCJoYW5kb2ZmU3RhdGVcIiwgXCJwZW5kaW5nXCIpLCByJDIodGhpcywgXCJjdXJyZW50SWRcIiwgMCk7XG4gIH1cbiAgc2V0KGUyKSB7XG4gICAgdGhpcy5jdXJyZW50ICE9PSBlMiAmJiAodGhpcy5oYW5kb2ZmU3RhdGUgPSBcInBlbmRpbmdcIiwgdGhpcy5jdXJyZW50SWQgPSAwLCB0aGlzLmN1cnJlbnQgPSBlMik7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5kZXRlY3QoKSk7XG4gIH1cbiAgbmV4dElkKCkge1xuICAgIHJldHVybiArK3RoaXMuY3VycmVudElkO1xuICB9XG4gIGdldCBpc1NlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBcInNlcnZlclwiO1xuICB9XG4gIGdldCBpc0NsaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBcImNsaWVudFwiO1xuICB9XG4gIGRldGVjdCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8IHR5cGVvZiBkb2N1bWVudCA+IFwidVwiID8gXCJzZXJ2ZXJcIiA6IFwiY2xpZW50XCI7XG4gIH1cbiAgaGFuZG9mZigpIHtcbiAgICB0aGlzLmhhbmRvZmZTdGF0ZSA9PT0gXCJwZW5kaW5nXCIgJiYgKHRoaXMuaGFuZG9mZlN0YXRlID0gXCJjb21wbGV0ZVwiKTtcbiAgfVxuICBnZXQgaXNIYW5kb2ZmQ29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZG9mZlN0YXRlID09PSBcImNvbXBsZXRlXCI7XG4gIH1cbn0sIHMkNyA9IG5ldyBvJDcoKTtcbmZ1bmN0aW9uIG8kNihuMikge1xuICB2YXIgZTIsIHIyO1xuICByZXR1cm4gcyQ3LmlzU2VydmVyID8gbnVsbCA6IG4yID8gXCJvd25lckRvY3VtZW50XCIgaW4gbjIgPyBuMi5vd25lckRvY3VtZW50IDogXCJjdXJyZW50XCIgaW4gbjIgPyAocjIgPSAoZTIgPSBuMi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogZTIub3duZXJEb2N1bWVudCkgIT0gbnVsbCA/IHIyIDogZG9jdW1lbnQgOiBudWxsIDogZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiB0JDMoZTIpIHtcbiAgdHlwZW9mIHF1ZXVlTWljcm90YXNrID09IFwiZnVuY3Rpb25cIiA/IHF1ZXVlTWljcm90YXNrKGUyKSA6IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZTIpLmNhdGNoKChvMykgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdGhyb3cgbzM7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIG8kNSgpIHtcbiAgbGV0IG4yID0gW10sIHIyID0geyBhZGRFdmVudExpc3RlbmVyKGUyLCB0MiwgczIsIGEzKSB7XG4gICAgcmV0dXJuIGUyLmFkZEV2ZW50TGlzdGVuZXIodDIsIHMyLCBhMyksIHIyLmFkZCgoKSA9PiBlMi5yZW1vdmVFdmVudExpc3RlbmVyKHQyLCBzMiwgYTMpKTtcbiAgfSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLmUyKSB7XG4gICAgbGV0IHQyID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLmUyKTtcbiAgICByZXR1cm4gcjIuYWRkKCgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHQyKSk7XG4gIH0sIG5leHRGcmFtZSguLi5lMikge1xuICAgIHJldHVybiByMi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcjIucmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLmUyKSk7XG4gIH0sIHNldFRpbWVvdXQoLi4uZTIpIHtcbiAgICBsZXQgdDIgPSBzZXRUaW1lb3V0KC4uLmUyKTtcbiAgICByZXR1cm4gcjIuYWRkKCgpID0+IGNsZWFyVGltZW91dCh0MikpO1xuICB9LCBtaWNyb1Rhc2soLi4uZTIpIHtcbiAgICBsZXQgdDIgPSB7IGN1cnJlbnQ6ICEwIH07XG4gICAgcmV0dXJuIHQkMygoKSA9PiB7XG4gICAgICB0Mi5jdXJyZW50ICYmIGUyWzBdKCk7XG4gICAgfSksIHIyLmFkZCgoKSA9PiB7XG4gICAgICB0Mi5jdXJyZW50ID0gITE7XG4gICAgfSk7XG4gIH0sIHN0eWxlKGUyLCB0MiwgczIpIHtcbiAgICBsZXQgYTMgPSBlMi5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHQyKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihlMi5zdHlsZSwgeyBbdDJdOiBzMiB9KSwgdGhpcy5hZGQoKCkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihlMi5zdHlsZSwgeyBbdDJdOiBhMyB9KTtcbiAgICB9KTtcbiAgfSwgZ3JvdXAoZTIpIHtcbiAgICBsZXQgdDIgPSBvJDUoKTtcbiAgICByZXR1cm4gZTIodDIpLCB0aGlzLmFkZCgoKSA9PiB0Mi5kaXNwb3NlKCkpO1xuICB9LCBhZGQoZTIpIHtcbiAgICByZXR1cm4gbjIuaW5jbHVkZXMoZTIpIHx8IG4yLnB1c2goZTIpLCAoKSA9PiB7XG4gICAgICBsZXQgdDIgPSBuMi5pbmRleE9mKGUyKTtcbiAgICAgIGlmICh0MiA+PSAwKSBmb3IgKGxldCBzMiBvZiBuMi5zcGxpY2UodDIsIDEpKSBzMigpO1xuICAgIH07XG4gIH0sIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChsZXQgZTIgb2YgbjIuc3BsaWNlKDApKSBlMigpO1xuICB9IH07XG4gIHJldHVybiByMjtcbn1cbmZ1bmN0aW9uIHAkMigpIHtcbiAgbGV0IFtlMl0gPSB1c2VTdGF0ZShvJDUpO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+ICgpID0+IGUyLmRpc3Bvc2UoKSwgW2UyXSksIGUyO1xufVxubGV0IG4kMyA9IChlMiwgdDIpID0+IHtcbiAgcyQ3LmlzU2VydmVyID8gdXNlRWZmZWN0KGUyLCB0MikgOiB1c2VMYXlvdXRFZmZlY3QoZTIsIHQyKTtcbn07XG5mdW5jdGlvbiBzJDYoZTIpIHtcbiAgbGV0IHIyID0gdXNlUmVmKGUyKTtcbiAgcmV0dXJuIG4kMygoKSA9PiB7XG4gICAgcjIuY3VycmVudCA9IGUyO1xuICB9LCBbZTJdKSwgcjI7XG59XG5sZXQgbyQ0ID0gZnVuY3Rpb24odDIpIHtcbiAgbGV0IGUyID0gcyQ2KHQyKTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKCguLi5yMikgPT4gZTIuY3VycmVudCguLi5yMiksIFtlMl0pO1xufTtcbmZ1bmN0aW9uIEUkMShlMikge1xuICBsZXQgdDIgPSBlMi53aWR0aCAvIDIsIG4yID0gZTIuaGVpZ2h0IC8gMjtcbiAgcmV0dXJuIHsgdG9wOiBlMi5jbGllbnRZIC0gbjIsIHJpZ2h0OiBlMi5jbGllbnRYICsgdDIsIGJvdHRvbTogZTIuY2xpZW50WSArIG4yLCBsZWZ0OiBlMi5jbGllbnRYIC0gdDIgfTtcbn1cbmZ1bmN0aW9uIFAkMyhlMiwgdDIpIHtcbiAgcmV0dXJuICEoIWUyIHx8ICF0MiB8fCBlMi5yaWdodCA8IHQyLmxlZnQgfHwgZTIubGVmdCA+IHQyLnJpZ2h0IHx8IGUyLmJvdHRvbSA8IHQyLnRvcCB8fCBlMi50b3AgPiB0Mi5ib3R0b20pO1xufVxuZnVuY3Rpb24gdyQyKHsgZGlzYWJsZWQ6IGUyID0gITEgfSA9IHt9KSB7XG4gIGxldCB0MiA9IHVzZVJlZihudWxsKSwgW24yLCBsMl0gPSB1c2VTdGF0ZSghMSksIHIyID0gcCQyKCksIG8zID0gbyQ0KCgpID0+IHtcbiAgICB0Mi5jdXJyZW50ID0gbnVsbCwgbDIoITEpLCByMi5kaXNwb3NlKCk7XG4gIH0pLCBmMiA9IG8kNCgoczIpID0+IHtcbiAgICBpZiAocjIuZGlzcG9zZSgpLCB0Mi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0Mi5jdXJyZW50ID0gczIuY3VycmVudFRhcmdldCwgbDIoITApO1xuICAgICAge1xuICAgICAgICBsZXQgaTIgPSBvJDYoczIuY3VycmVudFRhcmdldCk7XG4gICAgICAgIHIyLmFkZEV2ZW50TGlzdGVuZXIoaTIsIFwicG9pbnRlcnVwXCIsIG8zLCAhMSksIHIyLmFkZEV2ZW50TGlzdGVuZXIoaTIsIFwicG9pbnRlcm1vdmVcIiwgKGMyKSA9PiB7XG4gICAgICAgICAgaWYgKHQyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxldCBwMiA9IEUkMShjMik7XG4gICAgICAgICAgICBsMihQJDMocDIsIHQyLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sICExKSwgcjIuYWRkRXZlbnRMaXN0ZW5lcihpMiwgXCJwb2ludGVyY2FuY2VsXCIsIG8zLCAhMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHsgcHJlc3NlZDogbjIsIHByZXNzUHJvcHM6IGUyID8ge30gOiB7IG9uUG9pbnRlckRvd246IGYyLCBvblBvaW50ZXJVcDogbzMsIG9uQ2xpY2s6IG8zIH0gfTtcbn1cbmxldCBlJDMgPSBjcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiBhJDkoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KGUkMyk7XG59XG5mdW5jdGlvbiB0JDIoLi4ucjIpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChyMi5mbGF0TWFwKChuMikgPT4gdHlwZW9mIG4yID09IFwic3RyaW5nXCIgPyBuMi5zcGxpdChcIiBcIikgOiBbXSkpKS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIik7XG59XG5mdW5jdGlvbiB1JDcocjIsIG4yLCAuLi5hMykge1xuICBpZiAocjIgaW4gbjIpIHtcbiAgICBsZXQgZTIgPSBuMltyMl07XG4gICAgcmV0dXJuIHR5cGVvZiBlMiA9PSBcImZ1bmN0aW9uXCIgPyBlMiguLi5hMykgOiBlMjtcbiAgfVxuICBsZXQgdDIgPSBuZXcgRXJyb3IoXFxgVHJpZWQgdG8gaGFuZGxlIFwiXFwke3IyfVwiIGJ1dCB0aGVyZSBpcyBubyBoYW5kbGVyIGRlZmluZWQuIE9ubHkgZGVmaW5lZCBoYW5kbGVycyBhcmU6IFxcJHtPYmplY3Qua2V5cyhuMikubWFwKChlMikgPT4gXFxgXCJcXCR7ZTJ9XCJcXGApLmpvaW4oXCIsIFwiKX0uXFxgKTtcbiAgdGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodDIsIHUkNyksIHQyO1xufVxudmFyIE8kMSA9ICgoYTMpID0+IChhM1thMy5Ob25lID0gMF0gPSBcIk5vbmVcIiwgYTNbYTMuUmVuZGVyU3RyYXRlZ3kgPSAxXSA9IFwiUmVuZGVyU3RyYXRlZ3lcIiwgYTNbYTMuU3RhdGljID0gMl0gPSBcIlN0YXRpY1wiLCBhMykpKE8kMSB8fCB7fSksIEEkMSA9ICgoZTIpID0+IChlMltlMi5Vbm1vdW50ID0gMF0gPSBcIlVubW91bnRcIiwgZTJbZTIuSGlkZGVuID0gMV0gPSBcIkhpZGRlblwiLCBlMikpKEEkMSB8fCB7fSk7XG5mdW5jdGlvbiBMJDIoKSB7XG4gIGxldCBuMiA9IFUkMigpO1xuICByZXR1cm4gdXNlQ2FsbGJhY2soKHIyKSA9PiBDJDIoeyBtZXJnZVJlZnM6IG4yLCAuLi5yMiB9KSwgW24yXSk7XG59XG5mdW5jdGlvbiBDJDIoeyBvdXJQcm9wczogbjIsIHRoZWlyUHJvcHM6IHIyLCBzbG90OiBlMiwgZGVmYXVsdFRhZzogYTMsIGZlYXR1cmVzOiBzMiwgdmlzaWJsZTogdDIgPSAhMCwgbmFtZTogbDIsIG1lcmdlUmVmczogaTIgfSkge1xuICBpMiA9IGkyID8/ICQ7XG4gIGxldCBvMyA9IFAkMihyMiwgbjIpO1xuICBpZiAodDIpIHJldHVybiBGJDMobzMsIGUyLCBhMywgbDIsIGkyKTtcbiAgbGV0IHkyID0gczIgPz8gMDtcbiAgaWYgKHkyICYgMikge1xuICAgIGxldCB7IHN0YXRpYzogZjIgPSAhMSwgLi4udTIgfSA9IG8zO1xuICAgIGlmIChmMikgcmV0dXJuIEYkMyh1MiwgZTIsIGEzLCBsMiwgaTIpO1xuICB9XG4gIGlmICh5MiAmIDEpIHtcbiAgICBsZXQgeyB1bm1vdW50OiBmMiA9ICEwLCAuLi51MiB9ID0gbzM7XG4gICAgcmV0dXJuIHUkNyhmMiA/IDAgOiAxLCB7IDAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCAxKCkge1xuICAgICAgcmV0dXJuIEYkMyh7IC4uLnUyLCBoaWRkZW46ICEwLCBzdHlsZTogeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH0sIGUyLCBhMywgbDIsIGkyKTtcbiAgICB9IH0pO1xuICB9XG4gIHJldHVybiBGJDMobzMsIGUyLCBhMywgbDIsIGkyKTtcbn1cbmZ1bmN0aW9uIEYkMyhuMiwgcjIgPSB7fSwgZTIsIGEzLCBzMikge1xuICBsZXQgeyBhczogdDIgPSBlMiwgY2hpbGRyZW46IGwyLCByZWZOYW1lOiBpMiA9IFwicmVmXCIsIC4uLm8zIH0gPSBoJDQobjIsIFtcInVubW91bnRcIiwgXCJzdGF0aWNcIl0pLCB5MiA9IG4yLnJlZiAhPT0gdm9pZCAwID8geyBbaTJdOiBuMi5yZWYgfSA6IHt9LCBmMiA9IHR5cGVvZiBsMiA9PSBcImZ1bmN0aW9uXCIgPyBsMihyMikgOiBsMjtcbiAgXCJjbGFzc05hbWVcIiBpbiBvMyAmJiBvMy5jbGFzc05hbWUgJiYgdHlwZW9mIG8zLmNsYXNzTmFtZSA9PSBcImZ1bmN0aW9uXCIgJiYgKG8zLmNsYXNzTmFtZSA9IG8zLmNsYXNzTmFtZShyMikpLCBvM1tcImFyaWEtbGFiZWxsZWRieVwiXSAmJiBvM1tcImFyaWEtbGFiZWxsZWRieVwiXSA9PT0gbzMuaWQgJiYgKG8zW1wiYXJpYS1sYWJlbGxlZGJ5XCJdID0gdm9pZCAwKTtcbiAgbGV0IHUyID0ge307XG4gIGlmIChyMikge1xuICAgIGxldCBkMiA9ICExLCBwMiA9IFtdO1xuICAgIGZvciAobGV0IFtjMiwgVDJdIG9mIE9iamVjdC5lbnRyaWVzKHIyKSkgdHlwZW9mIFQyID09IFwiYm9vbGVhblwiICYmIChkMiA9ICEwKSwgVDIgPT09ICEwICYmIHAyLnB1c2goYzIucmVwbGFjZSgvKFtBLVpdKS9nLCAoZzIpID0+IFxcYC1cXCR7ZzIudG9Mb3dlckNhc2UoKX1cXGApKTtcbiAgICBpZiAoZDIpIHtcbiAgICAgIHUyW1wiZGF0YS1oZWFkbGVzc3VpLXN0YXRlXCJdID0gcDIuam9pbihcIiBcIik7XG4gICAgICBmb3IgKGxldCBjMiBvZiBwMikgdTJbXFxgZGF0YS1cXCR7YzJ9XFxgXSA9IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmICh0MiA9PT0gRnJhZ21lbnQgJiYgKE9iamVjdC5rZXlzKG0kNChvMykpLmxlbmd0aCA+IDAgfHwgT2JqZWN0LmtleXMobSQ0KHUyKSkubGVuZ3RoID4gMCkpIGlmICghaXNWYWxpZEVsZW1lbnQoZjIpIHx8IEFycmF5LmlzQXJyYXkoZjIpICYmIGYyLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMobSQ0KG8zKSkubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKFsnUGFzc2luZyBwcm9wcyBvbiBcIkZyYWdtZW50XCIhJywgXCJcIiwgXFxgVGhlIGN1cnJlbnQgY29tcG9uZW50IDxcXCR7YTN9IC8+IGlzIHJlbmRlcmluZyBhIFwiRnJhZ21lbnRcIi5cXGAsIFwiSG93ZXZlciB3ZSBuZWVkIHRvIHBhc3N0aHJvdWdoIHRoZSBmb2xsb3dpbmcgcHJvcHM6XCIsIE9iamVjdC5rZXlzKG0kNChvMykpLmNvbmNhdChPYmplY3Qua2V5cyhtJDQodTIpKSkubWFwKChkMikgPT4gXFxgICAtIFxcJHtkMn1cXGApLmpvaW4oXFxgXG5cXGApLCBcIlwiLCBcIllvdSBjYW4gYXBwbHkgYSBmZXcgc29sdXRpb25zOlwiLCBbJ0FkZCBhbiBcXGBhcz1cIi4uLlwiXFxgIHByb3AsIHRvIGVuc3VyZSB0aGF0IHdlIHJlbmRlciBhbiBhY3R1YWwgZWxlbWVudCBpbnN0ZWFkIG9mIGEgXCJGcmFnbWVudFwiLicsIFwiUmVuZGVyIGEgc2luZ2xlIGVsZW1lbnQgYXMgdGhlIGNoaWxkIHNvIHRoYXQgd2UgY2FuIGZvcndhcmQgdGhlIHByb3BzIG9udG8gdGhhdCBlbGVtZW50LlwiXS5tYXAoKGQyKSA9PiBcXGAgIC0gXFwke2QyfVxcYCkuam9pbihcXGBcblxcYCldLmpvaW4oXFxgXG5cXGApKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgZDIgPSBmMi5wcm9wcywgcDIgPSBkMiA9PSBudWxsID8gdm9pZCAwIDogZDIuY2xhc3NOYW1lLCBjMiA9IHR5cGVvZiBwMiA9PSBcImZ1bmN0aW9uXCIgPyAoLi4uUjIpID0+IHQkMihwMiguLi5SMiksIG8zLmNsYXNzTmFtZSkgOiB0JDIocDIsIG8zLmNsYXNzTmFtZSksIFQyID0gYzIgPyB7IGNsYXNzTmFtZTogYzIgfSA6IHt9LCBnMiA9IFAkMihmMi5wcm9wcywgbSQ0KGgkNChvMywgW1wicmVmXCJdKSkpO1xuICAgIGZvciAobGV0IFIyIGluIHUyKSBSMiBpbiBnMiAmJiBkZWxldGUgdTJbUjJdO1xuICAgIHJldHVybiBjbG9uZUVsZW1lbnQoZjIsIE9iamVjdC5hc3NpZ24oe30sIGcyLCB1MiwgeTIsIHsgcmVmOiBzMihIJDUoZjIpLCB5Mi5yZWYpIH0sIFQyKSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodDIsIE9iamVjdC5hc3NpZ24oe30sIGgkNChvMywgW1wicmVmXCJdKSwgdDIgIT09IEZyYWdtZW50ICYmIHkyLCB0MiAhPT0gRnJhZ21lbnQgJiYgdTIpLCBmMik7XG59XG5mdW5jdGlvbiBVJDIoKSB7XG4gIGxldCBuMiA9IHVzZVJlZihbXSksIHIyID0gdXNlQ2FsbGJhY2soKGUyKSA9PiB7XG4gICAgZm9yIChsZXQgYTMgb2YgbjIuY3VycmVudCkgYTMgIT0gbnVsbCAmJiAodHlwZW9mIGEzID09IFwiZnVuY3Rpb25cIiA/IGEzKGUyKSA6IGEzLmN1cnJlbnQgPSBlMik7XG4gIH0sIFtdKTtcbiAgcmV0dXJuICguLi5lMikgPT4ge1xuICAgIGlmICghZTIuZXZlcnkoKGEzKSA9PiBhMyA9PSBudWxsKSkgcmV0dXJuIG4yLmN1cnJlbnQgPSBlMiwgcjI7XG4gIH07XG59XG5mdW5jdGlvbiAkKC4uLm4yKSB7XG4gIHJldHVybiBuMi5ldmVyeSgocjIpID0+IHIyID09IG51bGwpID8gdm9pZCAwIDogKHIyKSA9PiB7XG4gICAgZm9yIChsZXQgZTIgb2YgbjIpIGUyICE9IG51bGwgJiYgKHR5cGVvZiBlMiA9PSBcImZ1bmN0aW9uXCIgPyBlMihyMikgOiBlMi5jdXJyZW50ID0gcjIpO1xuICB9O1xufVxuZnVuY3Rpb24gUCQyKC4uLm4yKSB7XG4gIGlmIChuMi5sZW5ndGggPT09IDApIHJldHVybiB7fTtcbiAgaWYgKG4yLmxlbmd0aCA9PT0gMSkgcmV0dXJuIG4yWzBdO1xuICBsZXQgcjIgPSB7fSwgZTIgPSB7fTtcbiAgZm9yIChsZXQgczIgb2YgbjIpIGZvciAobGV0IHQyIGluIHMyKSB0Mi5zdGFydHNXaXRoKFwib25cIikgJiYgdHlwZW9mIHMyW3QyXSA9PSBcImZ1bmN0aW9uXCIgPyAoZTJbdDJdICE9IG51bGwgfHwgKGUyW3QyXSA9IFtdKSwgZTJbdDJdLnB1c2goczJbdDJdKSkgOiByMlt0Ml0gPSBzMlt0Ml07XG4gIGlmIChyMi5kaXNhYmxlZCB8fCByMltcImFyaWEtZGlzYWJsZWRcIl0pIGZvciAobGV0IHMyIGluIGUyKSAvXihvbig/OkNsaWNrfFBvaW50ZXJ8TW91c2V8S2V5KSg/OkRvd258VXB8UHJlc3MpPykkLy50ZXN0KHMyKSAmJiAoZTJbczJdID0gWyh0MikgPT4ge1xuICAgIHZhciBsMjtcbiAgICByZXR1cm4gKGwyID0gdDIgPT0gbnVsbCA/IHZvaWQgMCA6IHQyLnByZXZlbnREZWZhdWx0KSA9PSBudWxsID8gdm9pZCAwIDogbDIuY2FsbCh0Mik7XG4gIH1dKTtcbiAgZm9yIChsZXQgczIgaW4gZTIpIE9iamVjdC5hc3NpZ24ocjIsIHsgW3MyXSh0MiwgLi4ubDIpIHtcbiAgICBsZXQgaTIgPSBlMltzMl07XG4gICAgZm9yIChsZXQgbzMgb2YgaTIpIHtcbiAgICAgIGlmICgodDIgaW5zdGFuY2VvZiBFdmVudCB8fCAodDIgPT0gbnVsbCA/IHZvaWQgMCA6IHQyLm5hdGl2ZUV2ZW50KSBpbnN0YW5jZW9mIEV2ZW50KSAmJiB0Mi5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBvMyh0MiwgLi4ubDIpO1xuICAgIH1cbiAgfSB9KTtcbiAgcmV0dXJuIHIyO1xufVxuZnVuY3Rpb24gXyQyKC4uLm4yKSB7XG4gIGlmIChuMi5sZW5ndGggPT09IDApIHJldHVybiB7fTtcbiAgaWYgKG4yLmxlbmd0aCA9PT0gMSkgcmV0dXJuIG4yWzBdO1xuICBsZXQgcjIgPSB7fSwgZTIgPSB7fTtcbiAgZm9yIChsZXQgczIgb2YgbjIpIGZvciAobGV0IHQyIGluIHMyKSB0Mi5zdGFydHNXaXRoKFwib25cIikgJiYgdHlwZW9mIHMyW3QyXSA9PSBcImZ1bmN0aW9uXCIgPyAoZTJbdDJdICE9IG51bGwgfHwgKGUyW3QyXSA9IFtdKSwgZTJbdDJdLnB1c2goczJbdDJdKSkgOiByMlt0Ml0gPSBzMlt0Ml07XG4gIGZvciAobGV0IHMyIGluIGUyKSBPYmplY3QuYXNzaWduKHIyLCB7IFtzMl0oLi4udDIpIHtcbiAgICBsZXQgbDIgPSBlMltzMl07XG4gICAgZm9yIChsZXQgaTIgb2YgbDIpIGkyID09IG51bGwgfHwgaTIoLi4udDIpO1xuICB9IH0pO1xuICByZXR1cm4gcjI7XG59XG5mdW5jdGlvbiBLJDEobjIpIHtcbiAgdmFyIHIyO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihmb3J3YXJkUmVmKG4yKSwgeyBkaXNwbGF5TmFtZTogKHIyID0gbjIuZGlzcGxheU5hbWUpICE9IG51bGwgPyByMiA6IG4yLm5hbWUgfSk7XG59XG5mdW5jdGlvbiBtJDQobjIpIHtcbiAgbGV0IHIyID0gT2JqZWN0LmFzc2lnbih7fSwgbjIpO1xuICBmb3IgKGxldCBlMiBpbiByMikgcjJbZTJdID09PSB2b2lkIDAgJiYgZGVsZXRlIHIyW2UyXTtcbiAgcmV0dXJuIHIyO1xufVxuZnVuY3Rpb24gaCQ0KG4yLCByMiA9IFtdKSB7XG4gIGxldCBlMiA9IE9iamVjdC5hc3NpZ24oe30sIG4yKTtcbiAgZm9yIChsZXQgYTMgb2YgcjIpIGEzIGluIGUyICYmIGRlbGV0ZSBlMlthM107XG4gIHJldHVybiBlMjtcbn1cbmZ1bmN0aW9uIEgkNShuMikge1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQudmVyc2lvbi5zcGxpdChcIi5cIilbMF0gPj0gXCIxOVwiID8gbjIucHJvcHMucmVmIDogbjIucmVmO1xufVxubGV0IFIkMiA9IFwiYnV0dG9uXCI7XG5mdW5jdGlvbiB2JDEoYTMsIHUyKSB7XG4gIHZhciBwMjtcbiAgbGV0IGwyID0gYSQ5KCksIHsgZGlzYWJsZWQ6IGUyID0gbDIgfHwgITEsIGF1dG9Gb2N1czogdDIgPSAhMSwgLi4ubzMgfSA9IGEzLCB7IGlzRm9jdXNWaXNpYmxlOiByMiwgZm9jdXNQcm9wczogaTIgfSA9ICRmN2RjZWZmYzVhZDc3NjhiJGV4cG9ydCQ0ZTMyOGY2MWM1Mzg2ODdmKHsgYXV0b0ZvY3VzOiB0MiB9KSwgeyBpc0hvdmVyZWQ6IHMyLCBob3ZlclByb3BzOiBUMiB9ID0gJDYxNzliOTM2NzA1ZTc2ZDMkZXhwb3J0JGFlNzgwZGFmMjllNmQ0NTYoeyBpc0Rpc2FibGVkOiBlMiB9KSwgeyBwcmVzc2VkOiBuMiwgcHJlc3NQcm9wczogZDIgfSA9IHckMih7IGRpc2FibGVkOiBlMiB9KSwgZjIgPSBfJDIoeyByZWY6IHUyLCB0eXBlOiAocDIgPSBvMy50eXBlKSAhPSBudWxsID8gcDIgOiBcImJ1dHRvblwiLCBkaXNhYmxlZDogZTIgfHwgdm9pZCAwLCBhdXRvRm9jdXM6IHQyIH0sIGkyLCBUMiwgZDIpLCBtMiA9IHVzZU1lbW8oKCkgPT4gKHsgZGlzYWJsZWQ6IGUyLCBob3ZlcjogczIsIGZvY3VzOiByMiwgYWN0aXZlOiBuMiwgYXV0b2ZvY3VzOiB0MiB9KSwgW2UyLCBzMiwgcjIsIG4yLCB0Ml0pO1xuICByZXR1cm4gTCQyKCkoeyBvdXJQcm9wczogZjIsIHRoZWlyUHJvcHM6IG8zLCBzbG90OiBtMiwgZGVmYXVsdFRhZzogUiQyLCBuYW1lOiBcIkJ1dHRvblwiIH0pO1xufVxubGV0IEgkNCA9IEskMSh2JDEpLCBlJDIgPSBjcmVhdGVDb250ZXh0KHZvaWQgMCk7XG5mdW5jdGlvbiB1JDYoKSB7XG4gIHJldHVybiB1c2VDb250ZXh0KGUkMik7XG59XG5mdW5jdGlvbiByJDEobjIpIHtcbiAgbGV0IGUyID0gbjIucGFyZW50RWxlbWVudCwgbDIgPSBudWxsO1xuICBmb3IgKDsgZTIgJiYgIShlMiBpbnN0YW5jZW9mIEhUTUxGaWVsZFNldEVsZW1lbnQpOyApIGUyIGluc3RhbmNlb2YgSFRNTExlZ2VuZEVsZW1lbnQgJiYgKGwyID0gZTIpLCBlMiA9IGUyLnBhcmVudEVsZW1lbnQ7XG4gIGxldCB0MiA9IChlMiA9PSBudWxsID8gdm9pZCAwIDogZTIuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikpID09PSBcIlwiO1xuICByZXR1cm4gdDIgJiYgaSQ1KGwyKSA/ICExIDogdDI7XG59XG5mdW5jdGlvbiBpJDUobjIpIHtcbiAgaWYgKCFuMikgcmV0dXJuICExO1xuICBsZXQgZTIgPSBuMi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICBmb3IgKDsgZTIgIT09IG51bGw7ICkge1xuICAgIGlmIChlMiBpbnN0YW5jZW9mIEhUTUxMZWdlbmRFbGVtZW50KSByZXR1cm4gITE7XG4gICAgZTIgPSBlMi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmxldCB1JDUgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIFQkMyh0MiwgbjIgPSAhMCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih0MiwgeyBbdSQ1XTogbjIgfSk7XG59XG5mdW5jdGlvbiB5JDQoLi4udDIpIHtcbiAgbGV0IG4yID0gdXNlUmVmKHQyKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBuMi5jdXJyZW50ID0gdDI7XG4gIH0sIFt0Ml0pO1xuICBsZXQgYzIgPSBvJDQoKGUyKSA9PiB7XG4gICAgZm9yIChsZXQgbzMgb2YgbjIuY3VycmVudCkgbzMgIT0gbnVsbCAmJiAodHlwZW9mIG8zID09IFwiZnVuY3Rpb25cIiA/IG8zKGUyKSA6IG8zLmN1cnJlbnQgPSBlMik7XG4gIH0pO1xuICByZXR1cm4gdDIuZXZlcnkoKGUyKSA9PiBlMiA9PSBudWxsIHx8IChlMiA9PSBudWxsID8gdm9pZCAwIDogZTJbdSQ1XSkpID8gdm9pZCAwIDogYzI7XG59XG5sZXQgYSQ4ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmEkOC5kaXNwbGF5TmFtZSA9IFwiRGVzY3JpcHRpb25Db250ZXh0XCI7XG5mdW5jdGlvbiBmJDYoKSB7XG4gIGxldCByMiA9IHVzZUNvbnRleHQoYSQ4KTtcbiAgaWYgKHIyID09PSBudWxsKSB7XG4gICAgbGV0IGUyID0gbmV3IEVycm9yKFwiWW91IHVzZWQgYSA8RGVzY3JpcHRpb24gLz4gY29tcG9uZW50LCBidXQgaXQgaXMgbm90IGluc2lkZSBhIHJlbGV2YW50IHBhcmVudC5cIik7XG4gICAgdGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZTIsIGYkNiksIGUyO1xuICB9XG4gIHJldHVybiByMjtcbn1cbmZ1bmN0aW9uIFUkMSgpIHtcbiAgdmFyIHIyLCBlMjtcbiAgcmV0dXJuIChlMiA9IChyMiA9IHVzZUNvbnRleHQoYSQ4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIyLnZhbHVlKSAhPSBudWxsID8gZTIgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiB3JDEoKSB7XG4gIGxldCBbcjIsIGUyXSA9IHVzZVN0YXRlKFtdKTtcbiAgcmV0dXJuIFtyMi5sZW5ndGggPiAwID8gcjIuam9pbihcIiBcIikgOiB2b2lkIDAsIHVzZU1lbW8oKCkgPT4gZnVuY3Rpb24odDIpIHtcbiAgICBsZXQgaTIgPSBvJDQoKG4yKSA9PiAoZTIoKHMyKSA9PiBbLi4uczIsIG4yXSksICgpID0+IGUyKChzMikgPT4ge1xuICAgICAgbGV0IG8zID0gczIuc2xpY2UoKSwgcDIgPSBvMy5pbmRleE9mKG4yKTtcbiAgICAgIHJldHVybiBwMiAhPT0gLTEgJiYgbzMuc3BsaWNlKHAyLCAxKSwgbzM7XG4gICAgfSkpKSwgbDIgPSB1c2VNZW1vKCgpID0+ICh7IHJlZ2lzdGVyOiBpMiwgc2xvdDogdDIuc2xvdCwgbmFtZTogdDIubmFtZSwgcHJvcHM6IHQyLnByb3BzLCB2YWx1ZTogdDIudmFsdWUgfSksIFtpMiwgdDIuc2xvdCwgdDIubmFtZSwgdDIucHJvcHMsIHQyLnZhbHVlXSk7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYSQ4LlByb3ZpZGVyLCB7IHZhbHVlOiBsMiB9LCB0Mi5jaGlsZHJlbik7XG4gIH0sIFtlMl0pXTtcbn1cbmxldCBTJDQgPSBcInBcIjtcbmZ1bmN0aW9uIEMkMShyMiwgZTIpIHtcbiAgbGV0IGQyID0gdXNlSWQkMSgpLCB0MiA9IGEkOSgpLCB7IGlkOiBpMiA9IFxcYGhlYWRsZXNzdWktZGVzY3JpcHRpb24tXFwke2QyfVxcYCwgLi4ubDIgfSA9IHIyLCBuMiA9IGYkNigpLCBzMiA9IHkkNChlMik7XG4gIG4kMygoKSA9PiBuMi5yZWdpc3RlcihpMiksIFtpMiwgbjIucmVnaXN0ZXJdKTtcbiAgbGV0IG8zID0gdDIgfHwgITEsIHAyID0gdXNlTWVtbygoKSA9PiAoeyAuLi5uMi5zbG90LCBkaXNhYmxlZDogbzMgfSksIFtuMi5zbG90LCBvM10pLCBEMiA9IHsgcmVmOiBzMiwgLi4ubjIucHJvcHMsIGlkOiBpMiB9O1xuICByZXR1cm4gTCQyKCkoeyBvdXJQcm9wczogRDIsIHRoZWlyUHJvcHM6IGwyLCBzbG90OiBwMiwgZGVmYXVsdFRhZzogUyQ0LCBuYW1lOiBuMi5uYW1lIHx8IFwiRGVzY3JpcHRpb25cIiB9KTtcbn1cbmxldCBfJDEgPSBLJDEoQyQxKTtcbk9iamVjdC5hc3NpZ24oXyQxLCB7fSk7XG52YXIgbyQzID0gKChyMikgPT4gKHIyLlNwYWNlID0gXCIgXCIsIHIyLkVudGVyID0gXCJFbnRlclwiLCByMi5Fc2NhcGUgPSBcIkVzY2FwZVwiLCByMi5CYWNrc3BhY2UgPSBcIkJhY2tzcGFjZVwiLCByMi5EZWxldGUgPSBcIkRlbGV0ZVwiLCByMi5BcnJvd0xlZnQgPSBcIkFycm93TGVmdFwiLCByMi5BcnJvd1VwID0gXCJBcnJvd1VwXCIsIHIyLkFycm93UmlnaHQgPSBcIkFycm93UmlnaHRcIiwgcjIuQXJyb3dEb3duID0gXCJBcnJvd0Rvd25cIiwgcjIuSG9tZSA9IFwiSG9tZVwiLCByMi5FbmQgPSBcIkVuZFwiLCByMi5QYWdlVXAgPSBcIlBhZ2VVcFwiLCByMi5QYWdlRG93biA9IFwiUGFnZURvd25cIiwgcjIuVGFiID0gXCJUYWJcIiwgcjIpKShvJDMgfHwge30pO1xubGV0IGMkNSA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jJDUuZGlzcGxheU5hbWUgPSBcIkxhYmVsQ29udGV4dFwiO1xuZnVuY3Rpb24gUCQxKCkge1xuICBsZXQgcjIgPSB1c2VDb250ZXh0KGMkNSk7XG4gIGlmIChyMiA9PT0gbnVsbCkge1xuICAgIGxldCBsMiA9IG5ldyBFcnJvcihcIllvdSB1c2VkIGEgPExhYmVsIC8+IGNvbXBvbmVudCwgYnV0IGl0IGlzIG5vdCBpbnNpZGUgYSByZWxldmFudCBwYXJlbnQuXCIpO1xuICAgIHRocm93IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGwyLCBQJDEpLCBsMjtcbiAgfVxuICByZXR1cm4gcjI7XG59XG5mdW5jdGlvbiBJJDIocjIpIHtcbiAgdmFyIGEzLCBlMiwgbzM7XG4gIGxldCBsMiA9IChlMiA9IChhMyA9IHVzZUNvbnRleHQoYyQ1KSkgPT0gbnVsbCA/IHZvaWQgMCA6IGEzLnZhbHVlKSAhPSBudWxsID8gZTIgOiB2b2lkIDA7XG4gIHJldHVybiAoKG8zID0gdm9pZCAwKSAhPSBudWxsID8gbzMgOiAwKSA+IDAgPyBbbDIsIC4uLnIyXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBcIikgOiBsMjtcbn1cbmZ1bmN0aW9uIEsoeyBpbmhlcml0OiByMiA9ICExIH0gPSB7fSkge1xuICBsZXQgbDIgPSBJJDIoKSwgW2EzLCBlMl0gPSB1c2VTdGF0ZShbXSksIG8zID0gcjIgPyBbbDIsIC4uLmEzXS5maWx0ZXIoQm9vbGVhbikgOiBhMztcbiAgcmV0dXJuIFtvMy5sZW5ndGggPiAwID8gbzMuam9pbihcIiBcIikgOiB2b2lkIDAsIHVzZU1lbW8oKCkgPT4gZnVuY3Rpb24odDIpIHtcbiAgICBsZXQgczIgPSBvJDQoKGkyKSA9PiAoZTIoKHAyKSA9PiBbLi4ucDIsIGkyXSksICgpID0+IGUyKChwMikgPT4ge1xuICAgICAgbGV0IHUyID0gcDIuc2xpY2UoKSwgZDIgPSB1Mi5pbmRleE9mKGkyKTtcbiAgICAgIHJldHVybiBkMiAhPT0gLTEgJiYgdTIuc3BsaWNlKGQyLCAxKSwgdTI7XG4gICAgfSkpKSwgbTIgPSB1c2VNZW1vKCgpID0+ICh7IHJlZ2lzdGVyOiBzMiwgc2xvdDogdDIuc2xvdCwgbmFtZTogdDIubmFtZSwgcHJvcHM6IHQyLnByb3BzLCB2YWx1ZTogdDIudmFsdWUgfSksIFtzMiwgdDIuc2xvdCwgdDIubmFtZSwgdDIucHJvcHMsIHQyLnZhbHVlXSk7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoYyQ1LlByb3ZpZGVyLCB7IHZhbHVlOiBtMiB9LCB0Mi5jaGlsZHJlbik7XG4gIH0sIFtlMl0pXTtcbn1cbmxldCBOID0gXCJsYWJlbFwiO1xuZnVuY3Rpb24gRyQxKHIyLCBsMikge1xuICB2YXIgeTI7XG4gIGxldCBhMyA9IHVzZUlkJDEoKSwgZTIgPSBQJDEoKSwgbzMgPSB1JDYoKSwgZzIgPSBhJDkoKSwgeyBpZDogdDIgPSBcXGBoZWFkbGVzc3VpLWxhYmVsLVxcJHthM31cXGAsIGh0bWxGb3I6IHMyID0gbzMgPz8gKCh5MiA9IGUyLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogeTIuaHRtbEZvciksIHBhc3NpdmU6IG0yID0gITEsIC4uLmkyIH0gPSByMiwgcDIgPSB5JDQobDIpO1xuICBuJDMoKCkgPT4gZTIucmVnaXN0ZXIodDIpLCBbdDIsIGUyLnJlZ2lzdGVyXSk7XG4gIGxldCB1MiA9IG8kNCgoTDIpID0+IHtcbiAgICBsZXQgYjIgPSBMMi5jdXJyZW50VGFyZ2V0O1xuICAgIGlmIChiMiBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQgJiYgTDIucHJldmVudERlZmF1bHQoKSwgZTIucHJvcHMgJiYgXCJvbkNsaWNrXCIgaW4gZTIucHJvcHMgJiYgdHlwZW9mIGUyLnByb3BzLm9uQ2xpY2sgPT0gXCJmdW5jdGlvblwiICYmIGUyLnByb3BzLm9uQ2xpY2soTDIpLCBiMiBpbnN0YW5jZW9mIEhUTUxMYWJlbEVsZW1lbnQpIHtcbiAgICAgIGxldCBuMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGIyLmh0bWxGb3IpO1xuICAgICAgaWYgKG4yKSB7XG4gICAgICAgIGxldCBFMiA9IG4yLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgICAgICBpZiAoRTIgPT09IFwidHJ1ZVwiIHx8IEUyID09PSBcIlwiKSByZXR1cm47XG4gICAgICAgIGxldCB4MiA9IG4yLmdldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIik7XG4gICAgICAgIGlmICh4MiA9PT0gXCJ0cnVlXCIgfHwgeDIgPT09IFwiXCIpIHJldHVybjtcbiAgICAgICAgKG4yIGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJiAobjIudHlwZSA9PT0gXCJyYWRpb1wiIHx8IG4yLnR5cGUgPT09IFwiY2hlY2tib3hcIikgfHwgbjIucm9sZSA9PT0gXCJyYWRpb1wiIHx8IG4yLnJvbGUgPT09IFwiY2hlY2tib3hcIiB8fCBuMi5yb2xlID09PSBcInN3aXRjaFwiKSAmJiBuMi5jbGljaygpLCBuMi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEwIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSksIGQyID0gZzIgfHwgITEsIEMyID0gdXNlTWVtbygoKSA9PiAoeyAuLi5lMi5zbG90LCBkaXNhYmxlZDogZDIgfSksIFtlMi5zbG90LCBkMl0pLCBmMiA9IHsgcmVmOiBwMiwgLi4uZTIucHJvcHMsIGlkOiB0MiwgaHRtbEZvcjogczIsIG9uQ2xpY2s6IHUyIH07XG4gIHJldHVybiBtMiAmJiAoXCJvbkNsaWNrXCIgaW4gZjIgJiYgKGRlbGV0ZSBmMi5odG1sRm9yLCBkZWxldGUgZjIub25DbGljayksIFwib25DbGlja1wiIGluIGkyICYmIGRlbGV0ZSBpMi5vbkNsaWNrKSwgTCQyKCkoeyBvdXJQcm9wczogZjIsIHRoZWlyUHJvcHM6IGkyLCBzbG90OiBDMiwgZGVmYXVsdFRhZzogczIgPyBOIDogXCJkaXZcIiwgbmFtZTogZTIubmFtZSB8fCBcIkxhYmVsXCIgfSk7XG59XG5sZXQgVSA9IEskMShHJDEpO1xuT2JqZWN0LmFzc2lnbihVLCB7fSk7XG5mdW5jdGlvbiBmJDUoZTIpIHtcbiAgaWYgKGUyID09PSBudWxsKSByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIGxldCB7IHdpZHRoOiB0MiwgaGVpZ2h0OiByMiB9ID0gZTIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7IHdpZHRoOiB0MiwgaGVpZ2h0OiByMiB9O1xufVxuZnVuY3Rpb24gZCQyKGUyLCB0MiA9ICExKSB7XG4gIGxldCBbcjIsIHUyXSA9IHVzZVJlZHVjZXIoKCkgPT4gKHt9KSwge30pLCBpMiA9IHVzZU1lbW8oKCkgPT4gZiQ1KGUyKSwgW2UyLCByMl0pO1xuICByZXR1cm4gbiQzKCgpID0+IHtcbiAgICBpZiAoIWUyKSByZXR1cm47XG4gICAgbGV0IG4yID0gbmV3IFJlc2l6ZU9ic2VydmVyKHUyKTtcbiAgICByZXR1cm4gbjIub2JzZXJ2ZShlMiksICgpID0+IHtcbiAgICAgIG4yLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICB9LCBbZTJdKSwgdDIgPyB7IHdpZHRoOiBcXGBcXCR7aTIud2lkdGh9cHhcXGAsIGhlaWdodDogXFxgXFwke2kyLmhlaWdodH1weFxcYCB9IDogaTI7XG59XG5sZXQgYSQ3ID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBjb25zdHJ1Y3Rvcih0Mikge1xuICAgIHN1cGVyKCksIHRoaXMuZmFjdG9yeSA9IHQyO1xuICB9XG4gIGdldCh0Mikge1xuICAgIGxldCBlMiA9IHN1cGVyLmdldCh0Mik7XG4gICAgcmV0dXJuIGUyID09PSB2b2lkIDAgJiYgKGUyID0gdGhpcy5mYWN0b3J5KHQyKSwgdGhpcy5zZXQodDIsIGUyKSksIGUyO1xuICB9XG59O1xuZnVuY3Rpb24gYSQ2KG8zLCByMikge1xuICBsZXQgdDIgPSBvMygpLCBuMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiB7IGdldFNuYXBzaG90KCkge1xuICAgIHJldHVybiB0MjtcbiAgfSwgc3Vic2NyaWJlKGUyKSB7XG4gICAgcmV0dXJuIG4yLmFkZChlMiksICgpID0+IG4yLmRlbGV0ZShlMik7XG4gIH0sIGRpc3BhdGNoKGUyLCAuLi5zMikge1xuICAgIGxldCBpMiA9IHIyW2UyXS5jYWxsKHQyLCAuLi5zMik7XG4gICAgaTIgJiYgKHQyID0gaTIsIG4yLmZvckVhY2goKGMyKSA9PiBjMigpKSk7XG4gIH0gfTtcbn1cbmZ1bmN0aW9uIG8kMih0Mikge1xuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUodDIuc3Vic2NyaWJlLCB0Mi5nZXRTbmFwc2hvdCwgdDIuZ2V0U25hcHNob3QpO1xufVxubGV0IHAkMSA9IG5ldyBhJDcoKCkgPT4gYSQ2KCgpID0+IFtdLCB7IEFERChyMikge1xuICByZXR1cm4gdGhpcy5pbmNsdWRlcyhyMikgPyB0aGlzIDogWy4uLnRoaXMsIHIyXTtcbn0sIFJFTU9WRShyMikge1xuICBsZXQgZTIgPSB0aGlzLmluZGV4T2YocjIpO1xuICBpZiAoZTIgPT09IC0xKSByZXR1cm4gdGhpcztcbiAgbGV0IHQyID0gdGhpcy5zbGljZSgpO1xuICByZXR1cm4gdDIuc3BsaWNlKGUyLCAxKSwgdDI7XG59IH0pKTtcbmZ1bmN0aW9uIHgkMihyMiwgZTIpIHtcbiAgbGV0IHQyID0gcCQxLmdldChlMiksIGkyID0gdXNlSWQkMSgpLCBoMiA9IG8kMih0Mik7XG4gIGlmIChuJDMoKCkgPT4ge1xuICAgIGlmIChyMikgcmV0dXJuIHQyLmRpc3BhdGNoKFwiQUREXCIsIGkyKSwgKCkgPT4gdDIuZGlzcGF0Y2goXCJSRU1PVkVcIiwgaTIpO1xuICB9LCBbdDIsIHIyXSksICFyMikgcmV0dXJuICExO1xuICBsZXQgczIgPSBoMi5pbmRleE9mKGkyKSwgbzMgPSBoMi5sZW5ndGg7XG4gIHJldHVybiBzMiA9PT0gLTEgJiYgKHMyID0gbzMsIG8zICs9IDEpLCBzMiA9PT0gbzMgLSAxO1xufVxubGV0IGYkNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHUkNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBoJDModDIpIHtcbiAgdmFyIGUyO1xuICBsZXQgcjIgPSAoZTIgPSB1JDQuZ2V0KHQyKSkgIT0gbnVsbCA/IGUyIDogMDtcbiAgcmV0dXJuIHUkNC5zZXQodDIsIHIyICsgMSksIHIyICE9PSAwID8gKCkgPT4gbSQzKHQyKSA6IChmJDQuc2V0KHQyLCB7IFwiYXJpYS1oaWRkZW5cIjogdDIuZ2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiksIGluZXJ0OiB0Mi5pbmVydCB9KSwgdDIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCB0Mi5pbmVydCA9ICEwLCAoKSA9PiBtJDModDIpKTtcbn1cbmZ1bmN0aW9uIG0kMyh0Mikge1xuICB2YXIgaTI7XG4gIGxldCByMiA9IChpMiA9IHUkNC5nZXQodDIpKSAhPSBudWxsID8gaTIgOiAxO1xuICBpZiAocjIgPT09IDEgPyB1JDQuZGVsZXRlKHQyKSA6IHUkNC5zZXQodDIsIHIyIC0gMSksIHIyICE9PSAxKSByZXR1cm47XG4gIGxldCBlMiA9IGYkNC5nZXQodDIpO1xuICBlMiAmJiAoZTJbXCJhcmlhLWhpZGRlblwiXSA9PT0gbnVsbCA/IHQyLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpIDogdDIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgZTJbXCJhcmlhLWhpZGRlblwiXSksIHQyLmluZXJ0ID0gZTIuaW5lcnQsIGYkNC5kZWxldGUodDIpKTtcbn1cbmZ1bmN0aW9uIHkkMyh0MiwgeyBhbGxvd2VkOiByMiwgZGlzYWxsb3dlZDogZTIgfSA9IHt9KSB7XG4gIGxldCBpMiA9IHgkMih0MiwgXCJpbmVydC1vdGhlcnNcIik7XG4gIG4kMygoKSA9PiB7XG4gICAgdmFyIGQyLCBjMjtcbiAgICBpZiAoIWkyKSByZXR1cm47XG4gICAgbGV0IGEzID0gbyQ1KCk7XG4gICAgZm9yIChsZXQgbjIgb2YgKGQyID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyKCkpICE9IG51bGwgPyBkMiA6IFtdKSBuMiAmJiBhMy5hZGQoaCQzKG4yKSk7XG4gICAgbGV0IHMyID0gKGMyID0gcjIgPT0gbnVsbCA/IHZvaWQgMCA6IHIyKCkpICE9IG51bGwgPyBjMiA6IFtdO1xuICAgIGZvciAobGV0IG4yIG9mIHMyKSB7XG4gICAgICBpZiAoIW4yKSBjb250aW51ZTtcbiAgICAgIGxldCBsMiA9IG8kNihuMik7XG4gICAgICBpZiAoIWwyKSBjb250aW51ZTtcbiAgICAgIGxldCBvMyA9IG4yLnBhcmVudEVsZW1lbnQ7XG4gICAgICBmb3IgKDsgbzMgJiYgbzMgIT09IGwyLmJvZHk7ICkge1xuICAgICAgICBmb3IgKGxldCBwMiBvZiBvMy5jaGlsZHJlbikgczIuc29tZSgoRTIpID0+IHAyLmNvbnRhaW5zKEUyKSkgfHwgYTMuYWRkKGgkMyhwMikpO1xuICAgICAgICBvMyA9IG8zLnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhMy5kaXNwb3NlO1xuICB9LCBbaTIsIHIyLCBlMl0pO1xufVxuZnVuY3Rpb24gbSQyKHMyLCBuMiwgbDIpIHtcbiAgbGV0IGkyID0gcyQ2KCh0MikgPT4ge1xuICAgIGxldCBlMiA9IHQyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGUyLnggPT09IDAgJiYgZTIueSA9PT0gMCAmJiBlMi53aWR0aCA9PT0gMCAmJiBlMi5oZWlnaHQgPT09IDAgJiYgbDIoKTtcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzMikgcmV0dXJuO1xuICAgIGxldCB0MiA9IG4yID09PSBudWxsID8gbnVsbCA6IG4yIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBuMiA6IG4yLmN1cnJlbnQ7XG4gICAgaWYgKCF0MikgcmV0dXJuO1xuICAgIGxldCBlMiA9IG8kNSgpO1xuICAgIGlmICh0eXBlb2YgUmVzaXplT2JzZXJ2ZXIgPCBcInVcIikge1xuICAgICAgbGV0IHIyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IGkyLmN1cnJlbnQodDIpKTtcbiAgICAgIHIyLm9ic2VydmUodDIpLCBlMi5hZGQoKCkgPT4gcjIuZGlzY29ubmVjdCgpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA8IFwidVwiKSB7XG4gICAgICBsZXQgcjIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKCkgPT4gaTIuY3VycmVudCh0MikpO1xuICAgICAgcjIub2JzZXJ2ZSh0MiksIGUyLmFkZCgoKSA9PiByMi5kaXNjb25uZWN0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4gZTIuZGlzcG9zZSgpO1xuICB9LCBbbjIsIGkyLCBzMl0pO1xufVxubGV0IGYkMyA9IFtcIltjb250ZW50RWRpdGFibGU9dHJ1ZV1cIiwgXCJbdGFiaW5kZXhdXCIsIFwiYVtocmVmXVwiLCBcImFyZWFbaHJlZl1cIiwgXCJidXR0b246bm90KFtkaXNhYmxlZF0pXCIsIFwiaWZyYW1lXCIsIFwiaW5wdXQ6bm90KFtkaXNhYmxlZF0pXCIsIFwic2VsZWN0Om5vdChbZGlzYWJsZWRdKVwiLCBcInRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiXS5tYXAoKGUyKSA9PiBcXGBcXCR7ZTJ9Om5vdChbdGFiaW5kZXg9Jy0xJ10pXFxgKS5qb2luKFwiLFwiKSwgcCA9IFtcIltkYXRhLWF1dG9mb2N1c11cIl0ubWFwKChlMikgPT4gXFxgXFwke2UyfTpub3QoW3RhYmluZGV4PSctMSddKVxcYCkuam9pbihcIixcIik7XG52YXIgRiQyID0gKChuMikgPT4gKG4yW24yLkZpcnN0ID0gMV0gPSBcIkZpcnN0XCIsIG4yW24yLlByZXZpb3VzID0gMl0gPSBcIlByZXZpb3VzXCIsIG4yW24yLk5leHQgPSA0XSA9IFwiTmV4dFwiLCBuMltuMi5MYXN0ID0gOF0gPSBcIkxhc3RcIiwgbjJbbjIuV3JhcEFyb3VuZCA9IDE2XSA9IFwiV3JhcEFyb3VuZFwiLCBuMltuMi5Ob1Njcm9sbCA9IDMyXSA9IFwiTm9TY3JvbGxcIiwgbjJbbjIuQXV0b0ZvY3VzID0gNjRdID0gXCJBdXRvRm9jdXNcIiwgbjIpKShGJDIgfHwge30pLCBUJDIgPSAoKG8zKSA9PiAobzNbbzMuRXJyb3IgPSAwXSA9IFwiRXJyb3JcIiwgbzNbbzMuT3ZlcmZsb3cgPSAxXSA9IFwiT3ZlcmZsb3dcIiwgbzNbbzMuU3VjY2VzcyA9IDJdID0gXCJTdWNjZXNzXCIsIG8zW28zLlVuZGVyZmxvdyA9IDNdID0gXCJVbmRlcmZsb3dcIiwgbzMpKShUJDIgfHwge30pLCB5JDIgPSAoKHQyKSA9PiAodDJbdDIuUHJldmlvdXMgPSAtMV0gPSBcIlByZXZpb3VzXCIsIHQyW3QyLk5leHQgPSAxXSA9IFwiTmV4dFwiLCB0MikpKHkkMiB8fCB7fSk7XG5mdW5jdGlvbiBiJDIoZTIgPSBkb2N1bWVudC5ib2R5KSB7XG4gIHJldHVybiBlMiA9PSBudWxsID8gW10gOiBBcnJheS5mcm9tKGUyLnF1ZXJ5U2VsZWN0b3JBbGwoZiQzKSkuc29ydCgocjIsIHQyKSA9PiBNYXRoLnNpZ24oKHIyLnRhYkluZGV4IHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSAtICh0Mi50YWJJbmRleCB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpKTtcbn1cbmZ1bmN0aW9uIFMkMyhlMiA9IGRvY3VtZW50LmJvZHkpIHtcbiAgcmV0dXJuIGUyID09IG51bGwgPyBbXSA6IEFycmF5LmZyb20oZTIucXVlcnlTZWxlY3RvckFsbChwKSkuc29ydCgocjIsIHQyKSA9PiBNYXRoLnNpZ24oKHIyLnRhYkluZGV4IHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSAtICh0Mi50YWJJbmRleCB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpKTtcbn1cbnZhciBoJDIgPSAoKHQyKSA9PiAodDJbdDIuU3RyaWN0ID0gMF0gPSBcIlN0cmljdFwiLCB0Mlt0Mi5Mb29zZSA9IDFdID0gXCJMb29zZVwiLCB0MikpKGgkMiB8fCB7fSk7XG5mdW5jdGlvbiBBKGUyLCByMiA9IDApIHtcbiAgdmFyIHQyO1xuICByZXR1cm4gZTIgPT09ICgodDIgPSBvJDYoZTIpKSA9PSBudWxsID8gdm9pZCAwIDogdDIuYm9keSkgPyAhMSA6IHUkNyhyMiwgeyAwKCkge1xuICAgIHJldHVybiBlMi5tYXRjaGVzKGYkMyk7XG4gIH0sIDEoKSB7XG4gICAgbGV0IHUyID0gZTI7XG4gICAgZm9yICg7IHUyICE9PSBudWxsOyApIHtcbiAgICAgIGlmICh1Mi5tYXRjaGVzKGYkMykpIHJldHVybiAhMDtcbiAgICAgIHUyID0gdTIucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9IH0pO1xufVxuZnVuY3Rpb24gRyhlMikge1xuICBsZXQgcjIgPSBvJDYoZTIpO1xuICBvJDUoKS5uZXh0RnJhbWUoKCkgPT4ge1xuICAgIHIyICYmICFBKHIyLmFjdGl2ZUVsZW1lbnQsIDApICYmIEkkMShlMik7XG4gIH0pO1xufVxudmFyIEgkMyA9ICgodDIpID0+ICh0Mlt0Mi5LZXlib2FyZCA9IDBdID0gXCJLZXlib2FyZFwiLCB0Mlt0Mi5Nb3VzZSA9IDFdID0gXCJNb3VzZVwiLCB0MikpKEgkMyB8fCB7fSk7XG50eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgKGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIChlMikgPT4ge1xuICBlMi5tZXRhS2V5IHx8IGUyLmFsdEtleSB8fCBlMi5jdHJsS2V5IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldC5oZWFkbGVzc3VpRm9jdXNWaXNpYmxlID0gXCJcIik7XG59LCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZTIpID0+IHtcbiAgZTIuZGV0YWlsID09PSAxID8gZGVsZXRlIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0LmhlYWRsZXNzdWlGb2N1c1Zpc2libGUgOiBlMi5kZXRhaWwgPT09IDAgJiYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0LmhlYWRsZXNzdWlGb2N1c1Zpc2libGUgPSBcIlwiKTtcbn0sICEwKSk7XG5mdW5jdGlvbiBJJDEoZTIpIHtcbiAgZTIgPT0gbnVsbCB8fCBlMi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEwIH0pO1xufVxubGV0IHcgPSBbXCJ0ZXh0YXJlYVwiLCBcImlucHV0XCJdLmpvaW4oXCIsXCIpO1xuZnVuY3Rpb24gTyhlMikge1xuICB2YXIgcjIsIHQyO1xuICByZXR1cm4gKHQyID0gKHIyID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLm1hdGNoZXMpID09IG51bGwgPyB2b2lkIDAgOiByMi5jYWxsKGUyLCB3KSkgIT0gbnVsbCA/IHQyIDogITE7XG59XG5mdW5jdGlvbiBfKGUyLCByMiA9ICh0MikgPT4gdDIpIHtcbiAgcmV0dXJuIGUyLnNsaWNlKCkuc29ydCgodDIsIHUyKSA9PiB7XG4gICAgbGV0IG8zID0gcjIodDIpLCBjMiA9IHIyKHUyKTtcbiAgICBpZiAobzMgPT09IG51bGwgfHwgYzIgPT09IG51bGwpIHJldHVybiAwO1xuICAgIGxldCBsMiA9IG8zLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGMyKTtcbiAgICByZXR1cm4gbDIgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyA/IC0xIDogbDIgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyA/IDEgOiAwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGokMihlMiwgcjIpIHtcbiAgcmV0dXJuIFAoYiQyKCksIHIyLCB7IHJlbGF0aXZlVG86IGUyIH0pO1xufVxuZnVuY3Rpb24gUChlMiwgcjIsIHsgc29ydGVkOiB0MiA9ICEwLCByZWxhdGl2ZVRvOiB1MiA9IG51bGwsIHNraXBFbGVtZW50czogbzMgPSBbXSB9ID0ge30pIHtcbiAgbGV0IGMyID0gQXJyYXkuaXNBcnJheShlMikgPyBlMi5sZW5ndGggPiAwID8gZTJbMF0ub3duZXJEb2N1bWVudCA6IGRvY3VtZW50IDogZTIub3duZXJEb2N1bWVudCwgbDIgPSBBcnJheS5pc0FycmF5KGUyKSA/IHQyID8gXyhlMikgOiBlMiA6IHIyICYgNjQgPyBTJDMoZTIpIDogYiQyKGUyKTtcbiAgbzMubGVuZ3RoID4gMCAmJiBsMi5sZW5ndGggPiAxICYmIChsMiA9IGwyLmZpbHRlcigoczIpID0+ICFvMy5zb21lKChhMykgPT4gYTMgIT0gbnVsbCAmJiBcImN1cnJlbnRcIiBpbiBhMyA/IChhMyA9PSBudWxsID8gdm9pZCAwIDogYTMuY3VycmVudCkgPT09IHMyIDogYTMgPT09IHMyKSkpLCB1MiA9IHUyID8/IGMyLmFjdGl2ZUVsZW1lbnQ7XG4gIGxldCBuMiA9ICgoKSA9PiB7XG4gICAgaWYgKHIyICYgNSkgcmV0dXJuIDE7XG4gICAgaWYgKHIyICYgMTApIHJldHVybiAtMTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEZvY3VzLkZpcnN0LCBGb2N1cy5QcmV2aW91cywgRm9jdXMuTmV4dCBvciBGb2N1cy5MYXN0XCIpO1xuICB9KSgpLCB4MiA9ICgoKSA9PiB7XG4gICAgaWYgKHIyICYgMSkgcmV0dXJuIDA7XG4gICAgaWYgKHIyICYgMikgcmV0dXJuIE1hdGgubWF4KDAsIGwyLmluZGV4T2YodTIpKSAtIDE7XG4gICAgaWYgKHIyICYgNCkgcmV0dXJuIE1hdGgubWF4KDAsIGwyLmluZGV4T2YodTIpKSArIDE7XG4gICAgaWYgKHIyICYgOCkgcmV0dXJuIGwyLmxlbmd0aCAtIDE7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBGb2N1cy5GaXJzdCwgRm9jdXMuUHJldmlvdXMsIEZvY3VzLk5leHQgb3IgRm9jdXMuTGFzdFwiKTtcbiAgfSkoKSwgTTIgPSByMiAmIDMyID8geyBwcmV2ZW50U2Nyb2xsOiAhMCB9IDoge30sIG0yID0gMCwgZDIgPSBsMi5sZW5ndGgsIGkyO1xuICBkbyB7XG4gICAgaWYgKG0yID49IGQyIHx8IG0yICsgZDIgPD0gMCkgcmV0dXJuIDA7XG4gICAgbGV0IHMyID0geDIgKyBtMjtcbiAgICBpZiAocjIgJiAxNikgczIgPSAoczIgKyBkMikgJSBkMjtcbiAgICBlbHNlIHtcbiAgICAgIGlmIChzMiA8IDApIHJldHVybiAzO1xuICAgICAgaWYgKHMyID49IGQyKSByZXR1cm4gMTtcbiAgICB9XG4gICAgaTIgPSBsMltzMl0sIGkyID09IG51bGwgfHwgaTIuZm9jdXMoTTIpLCBtMiArPSBuMjtcbiAgfSB3aGlsZSAoaTIgIT09IGMyLmFjdGl2ZUVsZW1lbnQpO1xuICByZXR1cm4gcjIgJiA2ICYmIE8oaTIpICYmIGkyLnNlbGVjdCgpLCAyO1xufVxuZnVuY3Rpb24gdCQxKCkge1xuICByZXR1cm4gL2lQaG9uZS9naS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC9NYWMvZ2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcbn1cbmZ1bmN0aW9uIGkkNCgpIHtcbiAgcmV0dXJuIC9BbmRyb2lkL2dpLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuZnVuY3Rpb24gbiQyKCkge1xuICByZXR1cm4gdCQxKCkgfHwgaSQ0KCk7XG59XG5mdW5jdGlvbiBpJDModDIsIGUyLCBvMywgbjIpIHtcbiAgbGV0IHUyID0gcyQ2KG8zKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXQyKSByZXR1cm47XG4gICAgZnVuY3Rpb24gcjIobTIpIHtcbiAgICAgIHUyLmN1cnJlbnQobTIpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlMiwgcjIsIG4yKSwgKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlMiwgcjIsIG4yKTtcbiAgfSwgW3QyLCBlMiwgbjJdKTtcbn1cbmZ1bmN0aW9uIHMkNSh0MiwgZTIsIG8zLCBuMikge1xuICBsZXQgaTIgPSBzJDYobzMpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghdDIpIHJldHVybjtcbiAgICBmdW5jdGlvbiByMihkMikge1xuICAgICAgaTIuY3VycmVudChkMik7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihlMiwgcjIsIG4yKSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZTIsIHIyLCBuMik7XG4gIH0sIFt0MiwgZTIsIG4yXSk7XG59XG5jb25zdCBFID0gMzA7XG5mdW5jdGlvbiBSJDEocDIsIGYyLCBDMikge1xuICBsZXQgdTIgPSB4JDIocDIsIFwib3V0c2lkZS1jbGlja1wiKSwgbTIgPSBzJDYoQzIpLCBzMiA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uKGUyLCBuMikge1xuICAgIGlmIChlMi5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgbGV0IHIyID0gbjIoZTIpO1xuICAgIGlmIChyMiA9PT0gbnVsbCB8fCAhcjIuZ2V0Um9vdE5vZGUoKS5jb250YWlucyhyMikgfHwgIXIyLmlzQ29ubmVjdGVkKSByZXR1cm47XG4gICAgbGV0IGgyID0gZnVuY3Rpb24gbDIobzMpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgbzMgPT0gXCJmdW5jdGlvblwiID8gbDIobzMoKSkgOiBBcnJheS5pc0FycmF5KG8zKSB8fCBvMyBpbnN0YW5jZW9mIFNldCA/IG8zIDogW28zXTtcbiAgICB9KGYyKTtcbiAgICBmb3IgKGxldCBsMiBvZiBoMikgaWYgKGwyICE9PSBudWxsICYmIChsMi5jb250YWlucyhyMikgfHwgZTIuY29tcG9zZWQgJiYgZTIuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXMobDIpKSkgcmV0dXJuO1xuICAgIHJldHVybiAhQShyMiwgaCQyLkxvb3NlKSAmJiByMi50YWJJbmRleCAhPT0gLTEgJiYgZTIucHJldmVudERlZmF1bHQoKSwgbTIuY3VycmVudChlMiwgcjIpO1xuICB9LCBbbTIsIGYyXSksIGkyID0gdXNlUmVmKG51bGwpO1xuICBpJDModTIsIFwicG9pbnRlcmRvd25cIiwgKHQyKSA9PiB7XG4gICAgdmFyIGUyLCBuMjtcbiAgICBpMi5jdXJyZW50ID0gKChuMiA9IChlMiA9IHQyLmNvbXBvc2VkUGF0aCkgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLmNhbGwodDIpKSA9PSBudWxsID8gdm9pZCAwIDogbjJbMF0pIHx8IHQyLnRhcmdldDtcbiAgfSwgITApLCBpJDModTIsIFwibW91c2Vkb3duXCIsICh0MikgPT4ge1xuICAgIHZhciBlMiwgbjI7XG4gICAgaTIuY3VycmVudCA9ICgobjIgPSAoZTIgPSB0Mi5jb21wb3NlZFBhdGgpID09IG51bGwgPyB2b2lkIDAgOiBlMi5jYWxsKHQyKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4yWzBdKSB8fCB0Mi50YXJnZXQ7XG4gIH0sICEwKSwgaSQzKHUyLCBcImNsaWNrXCIsICh0MikgPT4ge1xuICAgIG4kMigpIHx8IGkyLmN1cnJlbnQgJiYgKHMyKHQyLCAoKSA9PiBpMi5jdXJyZW50KSwgaTIuY3VycmVudCA9IG51bGwpO1xuICB9LCAhMCk7XG4gIGxldCBhMyA9IHVzZVJlZih7IHg6IDAsIHk6IDAgfSk7XG4gIGkkMyh1MiwgXCJ0b3VjaHN0YXJ0XCIsICh0MikgPT4ge1xuICAgIGEzLmN1cnJlbnQueCA9IHQyLnRvdWNoZXNbMF0uY2xpZW50WCwgYTMuY3VycmVudC55ID0gdDIudG91Y2hlc1swXS5jbGllbnRZO1xuICB9LCAhMCksIGkkMyh1MiwgXCJ0b3VjaGVuZFwiLCAodDIpID0+IHtcbiAgICBsZXQgZTIgPSB7IHg6IHQyLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsIHk6IHQyLmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkgfTtcbiAgICBpZiAoIShNYXRoLmFicyhlMi54IC0gYTMuY3VycmVudC54KSA+PSBFIHx8IE1hdGguYWJzKGUyLnkgLSBhMy5jdXJyZW50LnkpID49IEUpKSByZXR1cm4gczIodDIsICgpID0+IHQyLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gdDIudGFyZ2V0IDogbnVsbCk7XG4gIH0sICEwKSwgcyQ1KHUyLCBcImJsdXJcIiwgKHQyKSA9PiBzMih0MiwgKCkgPT4gd2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCA/IHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50IDogbnVsbCksICEwKTtcbn1cbmZ1bmN0aW9uIG4kMSguLi5lMikge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBvJDYoLi4uZTIpLCBbLi4uZTJdKTtcbn1cbmZ1bmN0aW9uIGUkMSh0MiwgdTIpIHtcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIHZhciBuMjtcbiAgICBpZiAodDIudHlwZSkgcmV0dXJuIHQyLnR5cGU7XG4gICAgbGV0IHIyID0gKG4yID0gdDIuYXMpICE9IG51bGwgPyBuMiA6IFwiYnV0dG9uXCI7XG4gICAgaWYgKHR5cGVvZiByMiA9PSBcInN0cmluZ1wiICYmIHIyLnRvTG93ZXJDYXNlKCkgPT09IFwiYnV0dG9uXCIgfHwgKHUyID09IG51bGwgPyB2b2lkIDAgOiB1Mi50YWdOYW1lKSA9PT0gXCJCVVRUT05cIiAmJiAhdTIuaGFzQXR0cmlidXRlKFwidHlwZVwiKSkgcmV0dXJuIFwiYnV0dG9uXCI7XG4gIH0sIFt0Mi50eXBlLCB0Mi5hcywgdTJdKTtcbn1cbmZ1bmN0aW9uIGQkMSgpIHtcbiAgbGV0IHIyO1xuICByZXR1cm4geyBiZWZvcmUoeyBkb2M6IGUyIH0pIHtcbiAgICB2YXIgbDI7XG4gICAgbGV0IG8zID0gZTIuZG9jdW1lbnRFbGVtZW50LCB0MiA9IChsMiA9IGUyLmRlZmF1bHRWaWV3KSAhPSBudWxsID8gbDIgOiB3aW5kb3c7XG4gICAgcjIgPSBNYXRoLm1heCgwLCB0Mi5pbm5lcldpZHRoIC0gbzMuY2xpZW50V2lkdGgpO1xuICB9LCBhZnRlcih7IGRvYzogZTIsIGQ6IG8zIH0pIHtcbiAgICBsZXQgdDIgPSBlMi5kb2N1bWVudEVsZW1lbnQsIGwyID0gTWF0aC5tYXgoMCwgdDIuY2xpZW50V2lkdGggLSB0Mi5vZmZzZXRXaWR0aCksIG4yID0gTWF0aC5tYXgoMCwgcjIgLSBsMik7XG4gICAgbzMuc3R5bGUodDIsIFwicGFkZGluZ1JpZ2h0XCIsIFxcYFxcJHtuMn1weFxcYCk7XG4gIH0gfTtcbn1cbmZ1bmN0aW9uIGQoKSB7XG4gIHJldHVybiB0JDEoKSA/IHsgYmVmb3JlKHsgZG9jOiByMiwgZDogbjIsIG1ldGE6IGMyIH0pIHtcbiAgICBmdW5jdGlvbiBvMyhhMykge1xuICAgICAgcmV0dXJuIGMyLmNvbnRhaW5lcnMuZmxhdE1hcCgobDIpID0+IGwyKCkpLnNvbWUoKGwyKSA9PiBsMi5jb250YWlucyhhMykpO1xuICAgIH1cbiAgICBuMi5taWNyb1Rhc2soKCkgPT4ge1xuICAgICAgdmFyIHMyO1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHIyLmRvY3VtZW50RWxlbWVudCkuc2Nyb2xsQmVoYXZpb3IgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGxldCB0MiA9IG8kNSgpO1xuICAgICAgICB0Mi5zdHlsZShyMi5kb2N1bWVudEVsZW1lbnQsIFwic2Nyb2xsQmVoYXZpb3JcIiwgXCJhdXRvXCIpLCBuMi5hZGQoKCkgPT4gbjIubWljcm9UYXNrKCgpID0+IHQyLmRpc3Bvc2UoKSkpO1xuICAgICAgfVxuICAgICAgbGV0IGEzID0gKHMyID0gd2luZG93LnNjcm9sbFkpICE9IG51bGwgPyBzMiA6IHdpbmRvdy5wYWdlWU9mZnNldCwgbDIgPSBudWxsO1xuICAgICAgbjIuYWRkRXZlbnRMaXN0ZW5lcihyMiwgXCJjbGlja1wiLCAodDIpID0+IHtcbiAgICAgICAgaWYgKHQyLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB0cnkge1xuICAgICAgICAgIGxldCBlMiA9IHQyLnRhcmdldC5jbG9zZXN0KFwiYVwiKTtcbiAgICAgICAgICBpZiAoIWUyKSByZXR1cm47XG4gICAgICAgICAgbGV0IHsgaGFzaDogZjIgfSA9IG5ldyBVUkwoZTIuaHJlZiksIGkyID0gcjIucXVlcnlTZWxlY3RvcihmMik7XG4gICAgICAgICAgaTIgJiYgIW8zKGkyKSAmJiAobDIgPSBpMik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICB9LCAhMCksIG4yLmFkZEV2ZW50TGlzdGVuZXIocjIsIFwidG91Y2hzdGFydFwiLCAodDIpID0+IHtcbiAgICAgICAgaWYgKHQyLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSBpZiAobzModDIudGFyZ2V0KSkge1xuICAgICAgICAgIGxldCBlMiA9IHQyLnRhcmdldDtcbiAgICAgICAgICBmb3IgKDsgZTIucGFyZW50RWxlbWVudCAmJiBvMyhlMi5wYXJlbnRFbGVtZW50KTsgKSBlMiA9IGUyLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgbjIuc3R5bGUoZTIsIFwib3ZlcnNjcm9sbEJlaGF2aW9yXCIsIFwiY29udGFpblwiKTtcbiAgICAgICAgfSBlbHNlIG4yLnN0eWxlKHQyLnRhcmdldCwgXCJ0b3VjaEFjdGlvblwiLCBcIm5vbmVcIik7XG4gICAgICB9KSwgbjIuYWRkRXZlbnRMaXN0ZW5lcihyMiwgXCJ0b3VjaG1vdmVcIiwgKHQyKSA9PiB7XG4gICAgICAgIGlmICh0Mi50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgIGlmICh0Mi50YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSByZXR1cm47XG4gICAgICAgICAgaWYgKG8zKHQyLnRhcmdldCkpIHtcbiAgICAgICAgICAgIGxldCBlMiA9IHQyLnRhcmdldDtcbiAgICAgICAgICAgIGZvciAoOyBlMi5wYXJlbnRFbGVtZW50ICYmIGUyLmRhdGFzZXQuaGVhZGxlc3N1aVBvcnRhbCAhPT0gXCJcIiAmJiAhKGUyLnNjcm9sbEhlaWdodCA+IGUyLmNsaWVudEhlaWdodCB8fCBlMi5zY3JvbGxXaWR0aCA+IGUyLmNsaWVudFdpZHRoKTsgKSBlMiA9IGUyLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBlMi5kYXRhc2V0LmhlYWRsZXNzdWlQb3J0YWwgPT09IFwiXCIgJiYgdDIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2UgdDIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfSwgeyBwYXNzaXZlOiAhMSB9KSwgbjIuYWRkKCgpID0+IHtcbiAgICAgICAgdmFyIGUyO1xuICAgICAgICBsZXQgdDIgPSAoZTIgPSB3aW5kb3cuc2Nyb2xsWSkgIT0gbnVsbCA/IGUyIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICBhMyAhPT0gdDIgJiYgd2luZG93LnNjcm9sbFRvKDAsIGEzKSwgbDIgJiYgbDIuaXNDb25uZWN0ZWQgJiYgKGwyLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pLCBsMiA9IG51bGwpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gfSA6IHt9O1xufVxuZnVuY3Rpb24gcigpIHtcbiAgcmV0dXJuIHsgYmVmb3JlKHsgZG9jOiBlMiwgZDogbzMgfSkge1xuICAgIG8zLnN0eWxlKGUyLmRvY3VtZW50RWxlbWVudCwgXCJvdmVyZmxvd1wiLCBcImhpZGRlblwiKTtcbiAgfSB9O1xufVxuZnVuY3Rpb24gbSQxKGUyKSB7XG4gIGxldCBuMiA9IHt9O1xuICBmb3IgKGxldCB0MiBvZiBlMikgT2JqZWN0LmFzc2lnbihuMiwgdDIobjIpKTtcbiAgcmV0dXJuIG4yO1xufVxubGV0IGEkNSA9IGEkNigoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCB7IFBVU0goZTIsIG4yKSB7XG4gIHZhciBvMztcbiAgbGV0IHQyID0gKG8zID0gdGhpcy5nZXQoZTIpKSAhPSBudWxsID8gbzMgOiB7IGRvYzogZTIsIGNvdW50OiAwLCBkOiBvJDUoKSwgbWV0YTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSB9O1xuICByZXR1cm4gdDIuY291bnQrKywgdDIubWV0YS5hZGQobjIpLCB0aGlzLnNldChlMiwgdDIpLCB0aGlzO1xufSwgUE9QKGUyLCBuMikge1xuICBsZXQgdDIgPSB0aGlzLmdldChlMik7XG4gIHJldHVybiB0MiAmJiAodDIuY291bnQtLSwgdDIubWV0YS5kZWxldGUobjIpKSwgdGhpcztcbn0sIFNDUk9MTF9QUkVWRU5UKHsgZG9jOiBlMiwgZDogbjIsIG1ldGE6IHQyIH0pIHtcbiAgbGV0IG8zID0geyBkb2M6IGUyLCBkOiBuMiwgbWV0YTogbSQxKHQyKSB9LCBjMiA9IFtkKCksIGQkMSgpLCByKCldO1xuICBjMi5mb3JFYWNoKCh7IGJlZm9yZTogcjIgfSkgPT4gcjIgPT0gbnVsbCA/IHZvaWQgMCA6IHIyKG8zKSksIGMyLmZvckVhY2goKHsgYWZ0ZXI6IHIyIH0pID0+IHIyID09IG51bGwgPyB2b2lkIDAgOiByMihvMykpO1xufSwgU0NST0xMX0FMTE9XKHsgZDogZTIgfSkge1xuICBlMi5kaXNwb3NlKCk7XG59LCBURUFSRE9XTih7IGRvYzogZTIgfSkge1xuICB0aGlzLmRlbGV0ZShlMik7XG59IH0pO1xuYSQ1LnN1YnNjcmliZSgoKSA9PiB7XG4gIGxldCBlMiA9IGEkNS5nZXRTbmFwc2hvdCgpLCBuMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAobGV0IFt0Ml0gb2YgZTIpIG4yLnNldCh0MiwgdDIuZG9jdW1lbnRFbGVtZW50LnN0eWxlLm92ZXJmbG93KTtcbiAgZm9yIChsZXQgdDIgb2YgZTIudmFsdWVzKCkpIHtcbiAgICBsZXQgbzMgPSBuMi5nZXQodDIuZG9jKSA9PT0gXCJoaWRkZW5cIiwgYzIgPSB0Mi5jb3VudCAhPT0gMDtcbiAgICAoYzIgJiYgIW8zIHx8ICFjMiAmJiBvMykgJiYgYSQ1LmRpc3BhdGNoKHQyLmNvdW50ID4gMCA/IFwiU0NST0xMX1BSRVZFTlRcIiA6IFwiU0NST0xMX0FMTE9XXCIsIHQyKSwgdDIuY291bnQgPT09IDAgJiYgYSQ1LmRpc3BhdGNoKFwiVEVBUkRPV05cIiwgdDIpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGEkNChyMiwgZTIsIG4yID0gKCkgPT4gKHsgY29udGFpbmVyczogW10gfSkpIHtcbiAgbGV0IGYyID0gbyQyKGEkNSksIG8zID0gZTIgPyBmMi5nZXQoZTIpIDogdm9pZCAwLCBpMiA9IG8zID8gbzMuY291bnQgPiAwIDogITE7XG4gIHJldHVybiBuJDMoKCkgPT4ge1xuICAgIGlmICghKCFlMiB8fCAhcjIpKSByZXR1cm4gYSQ1LmRpc3BhdGNoKFwiUFVTSFwiLCBlMiwgbjIpLCAoKSA9PiBhJDUuZGlzcGF0Y2goXCJQT1BcIiwgZTIsIG4yKTtcbiAgfSwgW3IyLCBlMl0pLCBpMjtcbn1cbmZ1bmN0aW9uIGYkMihlMiwgYzIsIG4yID0gKCkgPT4gW2RvY3VtZW50LmJvZHldKSB7XG4gIGxldCByMiA9IHgkMihlMiwgXCJzY3JvbGwtbG9ja1wiKTtcbiAgYSQ0KHIyLCBjMiwgKHQyKSA9PiB7XG4gICAgdmFyIG8zO1xuICAgIHJldHVybiB7IGNvbnRhaW5lcnM6IFsuLi4obzMgPSB0Mi5jb250YWluZXJzKSAhPSBudWxsID8gbzMgOiBbXSwgbjJdIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gdChlMikge1xuICByZXR1cm4gW2UyLnNjcmVlblgsIGUyLnNjcmVlblldO1xufVxuZnVuY3Rpb24gdSQzKCkge1xuICBsZXQgZTIgPSB1c2VSZWYoWy0xLCAtMV0pO1xuICByZXR1cm4geyB3YXNNb3ZlZChyMikge1xuICAgIGxldCBuMiA9IHQocjIpO1xuICAgIHJldHVybiBlMi5jdXJyZW50WzBdID09PSBuMlswXSAmJiBlMi5jdXJyZW50WzFdID09PSBuMlsxXSA/ICExIDogKGUyLmN1cnJlbnQgPSBuMiwgITApO1xuICB9LCB1cGRhdGUocjIpIHtcbiAgICBlMi5jdXJyZW50ID0gdChyMik7XG4gIH0gfTtcbn1cbmZ1bmN0aW9uIGMkNCh1MiA9IDApIHtcbiAgbGV0IFt0MiwgbDJdID0gdXNlU3RhdGUodTIpLCBnMiA9IHVzZUNhbGxiYWNrKChlMikgPT4gbDIoZTIpLCBbdDJdKSwgczIgPSB1c2VDYWxsYmFjaygoZTIpID0+IGwyKChhMykgPT4gYTMgfCBlMiksIFt0Ml0pLCBtMiA9IHVzZUNhbGxiYWNrKChlMikgPT4gKHQyICYgZTIpID09PSBlMiwgW3QyXSksIG4yID0gdXNlQ2FsbGJhY2soKGUyKSA9PiBsMigoYTMpID0+IGEzICYgfmUyKSwgW2wyXSksIEYyID0gdXNlQ2FsbGJhY2soKGUyKSA9PiBsMigoYTMpID0+IGEzIF4gZTIpLCBbbDJdKTtcbiAgcmV0dXJuIHsgZmxhZ3M6IHQyLCBzZXRGbGFnOiBnMiwgYWRkRmxhZzogczIsIGhhc0ZsYWc6IG0yLCByZW1vdmVGbGFnOiBuMiwgdG9nZ2xlRmxhZzogRjIgfTtcbn1cbnZhciBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdCQxID0ge30sIFQkMSwgYiQxO1xudHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiICYmIHR5cGVvZiBFbGVtZW50IDwgXCJ1XCIgJiYgKChUJDEgPSBwcm9jZXNzID09IG51bGwgPyB2b2lkIDAgOiBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdCQxKSA9PSBudWxsID8gdm9pZCAwIDogVCQxLk5PREVfRU5WKSA9PT0gXCJ0ZXN0XCIgJiYgdHlwZW9mICgoYiQxID0gRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogRWxlbWVudC5wcm90b3R5cGUpID09IG51bGwgPyB2b2lkIDAgOiBiJDEuZ2V0QW5pbWF0aW9ucykgPiBcInVcIiAmJiAoRWxlbWVudC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gY29uc29sZS53YXJuKFtcIkhlYWRsZXNzIFVJIGhhcyBwb2x5ZmlsbGVkIFxcYEVsZW1lbnQucHJvdG90eXBlLmdldEFuaW1hdGlvbnNcXGAgZm9yIHlvdXIgdGVzdHMuXCIsIFwiUGxlYXNlIGluc3RhbGwgYSBwcm9wZXIgcG9seWZpbGwgZS5nLiBcXGBqc2RvbS10ZXN0aW5nLW1vY2tzXFxgLCB0byBzaWxlbmNlIHRoZXNlIHdhcm5pbmdzLlwiLCBcIlwiLCBcIkV4YW1wbGUgdXNhZ2U6XCIsIFwiXFxgXFxgXFxganNcIiwgXCJpbXBvcnQgeyBtb2NrQW5pbWF0aW9uc0FwaSB9IGZyb20gJ2pzZG9tLXRlc3RpbmctbW9ja3MnXCIsIFwibW9ja0FuaW1hdGlvbnNBcGkoKVwiLCBcIlxcYFxcYFxcYFwiXS5qb2luKFxcYFxuXFxgKSksIFtdO1xufSk7XG52YXIgTCQxID0gKChyMikgPT4gKHIyW3IyLk5vbmUgPSAwXSA9IFwiTm9uZVwiLCByMltyMi5DbG9zZWQgPSAxXSA9IFwiQ2xvc2VkXCIsIHIyW3IyLkVudGVyID0gMl0gPSBcIkVudGVyXCIsIHIyW3IyLkxlYXZlID0gNF0gPSBcIkxlYXZlXCIsIHIyKSkoTCQxIHx8IHt9KTtcbmZ1bmN0aW9uIFIodDIpIHtcbiAgbGV0IG4yID0ge307XG4gIGZvciAobGV0IGUyIGluIHQyKSB0MltlMl0gPT09ICEwICYmIChuMltcXGBkYXRhLVxcJHtlMn1cXGBdID0gXCJcIik7XG4gIHJldHVybiBuMjtcbn1cbmZ1bmN0aW9uIHgkMSh0MiwgbjIsIGUyLCBpMikge1xuICBsZXQgW3IyLCBvM10gPSB1c2VTdGF0ZShlMiksIHsgaGFzRmxhZzogczIsIGFkZEZsYWc6IGEzLCByZW1vdmVGbGFnOiBsMiB9ID0gYyQ0KHQyICYmIHIyID8gMyA6IDApLCB1MiA9IHVzZVJlZighMSksIGYyID0gdXNlUmVmKCExKSwgRTIgPSBwJDIoKTtcbiAgcmV0dXJuIG4kMygoKSA9PiB7XG4gICAgdmFyIGQyO1xuICAgIGlmICh0Mikge1xuICAgICAgaWYgKGUyICYmIG8zKCEwKSwgIW4yKSB7XG4gICAgICAgIGUyICYmIGEzKDMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gKGQyID0gdm9pZCAwKSA9PSBudWxsIHx8IGQyLmNhbGwoaTIsIGUyKSwgQyhuMiwgeyBpbkZsaWdodDogdTIsIHByZXBhcmUoKSB7XG4gICAgICAgIGYyLmN1cnJlbnQgPyBmMi5jdXJyZW50ID0gITEgOiBmMi5jdXJyZW50ID0gdTIuY3VycmVudCwgdTIuY3VycmVudCA9ICEwLCAhZjIuY3VycmVudCAmJiAoZTIgPyAoYTMoMyksIGwyKDQpKSA6IChhMyg0KSwgbDIoMikpKTtcbiAgICAgIH0sIHJ1bigpIHtcbiAgICAgICAgZjIuY3VycmVudCA/IGUyID8gKGwyKDMpLCBhMyg0KSkgOiAobDIoNCksIGEzKDMpKSA6IGUyID8gbDIoMSkgOiBhMygxKTtcbiAgICAgIH0sIGRvbmUoKSB7XG4gICAgICAgIHZhciBwMjtcbiAgICAgICAgZjIuY3VycmVudCAmJiB0eXBlb2YgbjIuZ2V0QW5pbWF0aW9ucyA9PSBcImZ1bmN0aW9uXCIgJiYgbjIuZ2V0QW5pbWF0aW9ucygpLmxlbmd0aCA+IDAgfHwgKHUyLmN1cnJlbnQgPSAhMSwgbDIoNyksIGUyIHx8IG8zKCExKSwgKHAyID0gdm9pZCAwKSA9PSBudWxsIHx8IHAyLmNhbGwoaTIsIGUyKSk7XG4gICAgICB9IH0pO1xuICAgIH1cbiAgfSwgW3QyLCBlMiwgbjIsIEUyXSksIHQyID8gW3IyLCB7IGNsb3NlZDogczIoMSksIGVudGVyOiBzMigyKSwgbGVhdmU6IHMyKDQpLCB0cmFuc2l0aW9uOiBzMigyKSB8fCBzMig0KSB9XSA6IFtlMiwgeyBjbG9zZWQ6IHZvaWQgMCwgZW50ZXI6IHZvaWQgMCwgbGVhdmU6IHZvaWQgMCwgdHJhbnNpdGlvbjogdm9pZCAwIH1dO1xufVxuZnVuY3Rpb24gQyh0MiwgeyBwcmVwYXJlOiBuMiwgcnVuOiBlMiwgZG9uZTogaTIsIGluRmxpZ2h0OiByMiB9KSB7XG4gIGxldCBvMyA9IG8kNSgpO1xuICByZXR1cm4gaiQxKHQyLCB7IHByZXBhcmU6IG4yLCBpbkZsaWdodDogcjIgfSksIG8zLm5leHRGcmFtZSgoKSA9PiB7XG4gICAgZTIoKSwgbzMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIG8zLmFkZChNJDIodDIsIGkyKSk7XG4gICAgfSk7XG4gIH0pLCBvMy5kaXNwb3NlO1xufVxuZnVuY3Rpb24gTSQyKHQyLCBuMikge1xuICB2YXIgbzMsIHMyO1xuICBsZXQgZTIgPSBvJDUoKTtcbiAgaWYgKCF0MikgcmV0dXJuIGUyLmRpc3Bvc2U7XG4gIGxldCBpMiA9ICExO1xuICBlMi5hZGQoKCkgPT4ge1xuICAgIGkyID0gITA7XG4gIH0pO1xuICBsZXQgcjIgPSAoczIgPSAobzMgPSB0Mi5nZXRBbmltYXRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogbzMuY2FsbCh0MikuZmlsdGVyKChhMykgPT4gYTMgaW5zdGFuY2VvZiBDU1NUcmFuc2l0aW9uKSkgIT0gbnVsbCA/IHMyIDogW107XG4gIHJldHVybiByMi5sZW5ndGggPT09IDAgPyAobjIoKSwgZTIuZGlzcG9zZSkgOiAoUHJvbWlzZS5hbGxTZXR0bGVkKHIyLm1hcCgoYTMpID0+IGEzLmZpbmlzaGVkKSkudGhlbigoKSA9PiB7XG4gICAgaTIgfHwgbjIoKTtcbiAgfSksIGUyLmRpc3Bvc2UpO1xufVxuZnVuY3Rpb24gaiQxKHQyLCB7IGluRmxpZ2h0OiBuMiwgcHJlcGFyZTogZTIgfSkge1xuICBpZiAobjIgIT0gbnVsbCAmJiBuMi5jdXJyZW50KSB7XG4gICAgZTIoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IGkyID0gdDIuc3R5bGUudHJhbnNpdGlvbjtcbiAgdDIuc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiLCBlMigpLCB0Mi5vZmZzZXRIZWlnaHQsIHQyLnN0eWxlLnRyYW5zaXRpb24gPSBpMjtcbn1cbmZ1bmN0aW9uIEYkMShjMiwgeyBjb250YWluZXI6IGUyLCBhY2NlcHQ6IHQyLCB3YWxrOiByMiB9KSB7XG4gIGxldCBvMyA9IHVzZVJlZih0MiksIGwyID0gdXNlUmVmKHIyKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBvMy5jdXJyZW50ID0gdDIsIGwyLmN1cnJlbnQgPSByMjtcbiAgfSwgW3QyLCByMl0pLCBuJDMoKCkgPT4ge1xuICAgIGlmICghZTIgfHwgIWMyKSByZXR1cm47XG4gICAgbGV0IG4yID0gbyQ2KGUyKTtcbiAgICBpZiAoIW4yKSByZXR1cm47XG4gICAgbGV0IGYyID0gbzMuY3VycmVudCwgcDIgPSBsMi5jdXJyZW50LCBpMiA9IE9iamVjdC5hc3NpZ24oKG0yKSA9PiBmMihtMiksIHsgYWNjZXB0Tm9kZTogZjIgfSksIHUyID0gbjIuY3JlYXRlVHJlZVdhbGtlcihlMiwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIGkyLCAhMSk7XG4gICAgZm9yICg7IHUyLm5leHROb2RlKCk7ICkgcDIodTIuY3VycmVudE5vZGUpO1xuICB9LCBbZTIsIGMyLCBvMywgbDJdKTtcbn1cbmZ1bmN0aW9uIGhhc1dpbmRvdyQxKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA8IFwidVwiO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93JDEobm9kZSkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIChub2RlID09IG51bGwgfHwgKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQkMSh2YWx1ZSkge1xuICByZXR1cm4gaGFzV2luZG93JDEoKSA/IHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudCB8fCB2YWx1ZSBpbnN0YW5jZW9mIGdldFdpbmRvdyQxKHZhbHVlKS5FbGVtZW50IDogITE7XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICByZXR1cm4gdWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykgPyB1YURhdGEuYnJhbmRzLm1hcCgoX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICBicmFuZCxcbiAgICAgIHZlcnNpb25cbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gYnJhbmQgKyBcIi9cIiArIHZlcnNpb247XG4gIH0pLmpvaW4oXCIgXCIpIDogbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmNvbnN0IG1pbiQxID0gTWF0aC5taW4sIG1heCQxID0gTWF0aC5tYXgsIHJvdW5kJDEgPSBNYXRoLnJvdW5kO1xuZnVuY3Rpb24gZXZhbHVhdGUkMSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZShwYXJhbSkgOiB2YWx1ZTtcbn1cbmNvbnN0IG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heCwgcm91bmQgPSBNYXRoLnJvdW5kLCBmbG9vciA9IE1hdGguZmxvb3IsIGNyZWF0ZUNvb3JkcyA9ICh2MikgPT4gKHtcbiAgeDogdjIsXG4gIHk6IHYyXG59KSwgb3Bwb3NpdGVTaWRlTWFwID0ge1xuICBsZWZ0OiBcInJpZ2h0XCIsXG4gIHJpZ2h0OiBcImxlZnRcIixcbiAgYm90dG9tOiBcInRvcFwiLFxuICB0b3A6IFwiYm90dG9tXCJcbn0sIG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogXCJlbmRcIixcbiAgZW5kOiBcInN0YXJ0XCJcbn07XG5mdW5jdGlvbiBjbGFtcChzdGFydCwgdmFsdWUsIGVuZCkge1xuICByZXR1cm4gbWF4KHN0YXJ0LCBtaW4odmFsdWUsIGVuZCkpO1xufVxuZnVuY3Rpb24gZXZhbHVhdGUodmFsdWUsIHBhcmFtKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiID8gdmFsdWUocGFyYW0pIDogdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KFwiLVwiKVswXTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdChcIi1cIilbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG59XG5jb25zdCB5QXhpc1NpZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widG9wXCIsIFwiYm90dG9tXCJdKTtcbmZ1bmN0aW9uIGdldFNpZGVBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4geUF4aXNTaWRlcy5oYXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/IFwieVwiIDogXCJ4XCI7XG59XG5mdW5jdGlvbiBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCkge1xuICByZXR1cm4gZ2V0T3Bwb3NpdGVBeGlzKGdldFNpZGVBeGlzKHBsYWNlbWVudCkpO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50U2lkZXMocGxhY2VtZW50LCByZWN0cywgcnRsKSB7XG4gIHJ0bCA9PT0gdm9pZCAwICYmIChydGwgPSAhMSk7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpLCBhbGlnbm1lbnRBeGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpLCBsZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpO1xuICBsZXQgbWFpbkFsaWdubWVudFNpZGUgPSBhbGlnbm1lbnRBeGlzID09PSBcInhcIiA/IGFsaWdubWVudCA9PT0gKHJ0bCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpID8gXCJyaWdodFwiIDogXCJsZWZ0XCIgOiBhbGlnbm1lbnQgPT09IFwic3RhcnRcIiA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICByZXR1cm4gcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdICYmIChtYWluQWxpZ25tZW50U2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5BbGlnbm1lbnRTaWRlKSksIFttYWluQWxpZ25tZW50U2lkZSwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIChhbGlnbm1lbnQpID0+IG9wcG9zaXRlQWxpZ25tZW50TWFwW2FsaWdubWVudF0pO1xufVxuY29uc3QgbHJQbGFjZW1lbnQgPSBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sIHJsUGxhY2VtZW50ID0gW1wicmlnaHRcIiwgXCJsZWZ0XCJdLCB0YlBsYWNlbWVudCA9IFtcInRvcFwiLCBcImJvdHRvbVwiXSwgYnRQbGFjZW1lbnQgPSBbXCJib3R0b21cIiwgXCJ0b3BcIl07XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgIHJldHVybiBydGwgPyBpc1N0YXJ0ID8gcmxQbGFjZW1lbnQgOiBsclBsYWNlbWVudCA6IGlzU3RhcnQgPyBsclBsYWNlbWVudCA6IHJsUGxhY2VtZW50O1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXR1cm4gaXNTdGFydCA/IHRiUGxhY2VtZW50IDogYnRQbGFjZW1lbnQ7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyhwbGFjZW1lbnQsIGZsaXBBbGlnbm1lbnQsIGRpcmVjdGlvbiwgcnRsKSB7XG4gIGNvbnN0IGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpO1xuICBsZXQgbGlzdCA9IGdldFNpZGVMaXN0KGdldFNpZGUocGxhY2VtZW50KSwgZGlyZWN0aW9uID09PSBcInN0YXJ0XCIsIHJ0bCk7XG4gIHJldHVybiBhbGlnbm1lbnQgJiYgKGxpc3QgPSBsaXN0Lm1hcCgoc2lkZSkgPT4gc2lkZSArIFwiLVwiICsgYWxpZ25tZW50KSwgZmxpcEFsaWdubWVudCAmJiAobGlzdCA9IGxpc3QuY29uY2F0KGxpc3QubWFwKGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KSkpKSwgbGlzdDtcbn1cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCAoc2lkZSkgPT4gb3Bwb3NpdGVTaWRlTWFwW3NpZGVdKTtcbn1cbmZ1bmN0aW9uIGV4cGFuZFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICAuLi5wYWRkaW5nXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBwYWRkaW5nICE9IFwibnVtYmVyXCIgPyBleHBhbmRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpIDoge1xuICAgIHRvcDogcGFkZGluZyxcbiAgICByaWdodDogcGFkZGluZyxcbiAgICBib3R0b206IHBhZGRpbmcsXG4gICAgbGVmdDogcGFkZGluZ1xuICB9O1xufVxuZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIGNvbnN0IHtcbiAgICB4OiB4MixcbiAgICB5OiB5MixcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHJlY3Q7XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHRvcDogeTIsXG4gICAgbGVmdDogeDIsXG4gICAgcmlnaHQ6IHgyICsgd2lkdGgsXG4gICAgYm90dG9tOiB5MiArIGhlaWdodCxcbiAgICB4OiB4MixcbiAgICB5OiB5MlxuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQoX3JlZiwgcGxhY2VtZW50LCBydGwpIHtcbiAgbGV0IHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmdcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IHNpZGVBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSwgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KSwgYWxpZ25MZW5ndGggPSBnZXRBeGlzTGVuZ3RoKGFsaWdubWVudEF4aXMpLCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpLCBpc1ZlcnRpY2FsID0gc2lkZUF4aXMgPT09IFwieVwiLCBjb21tb25YID0gcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGggLyAyIC0gZmxvYXRpbmcud2lkdGggLyAyLCBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGZsb2F0aW5nLmhlaWdodCAvIDIsIGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2FsaWduTGVuZ3RoXSAvIDIgLSBmbG9hdGluZ1thbGlnbkxlbmd0aF0gLyAyO1xuICBsZXQgY29vcmRzO1xuICBzd2l0Y2ggKHNpZGUpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gKz0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGNvb3Jkcztcbn1cbmNvbnN0IGNvbXB1dGVQb3NpdGlvbiQxID0gYXN5bmMgKHJlZmVyZW5jZSwgZmxvYXRpbmcsIGNvbmZpZzIpID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCIsXG4gICAgc3RyYXRlZ3kgPSBcImFic29sdXRlXCIsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybTJcbiAgfSA9IGNvbmZpZzIsIHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pLCBydGwgPSBhd2FpdCAocGxhdGZvcm0yLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNSVEwoZmxvYXRpbmcpKTtcbiAgbGV0IHJlY3RzID0gYXdhaXQgcGxhdGZvcm0yLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pLCB7XG4gICAgeDogeDIsXG4gICAgeTogeTJcbiAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBwbGFjZW1lbnQsIHJ0bCksIHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50LCBtaWRkbGV3YXJlRGF0YSA9IHt9LCByZXNldENvdW50ID0gMDtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lLFxuICAgICAgZm5cbiAgICB9ID0gdmFsaWRNaWRkbGV3YXJlW2kyXSwge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4OiB4MixcbiAgICAgIHk6IHkyLFxuICAgICAgaW5pdGlhbFBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50OiBzdGF0ZWZ1bFBsYWNlbWVudCxcbiAgICAgIHN0cmF0ZWd5LFxuICAgICAgbWlkZGxld2FyZURhdGEsXG4gICAgICByZWN0cyxcbiAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybTIsXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2UsXG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSk7XG4gICAgeDIgPSBuZXh0WCA/PyB4MiwgeTIgPSBuZXh0WSA/PyB5MiwgbWlkZGxld2FyZURhdGEgPSB7XG4gICAgICAuLi5taWRkbGV3YXJlRGF0YSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICAuLi5taWRkbGV3YXJlRGF0YVtuYW1lXSxcbiAgICAgICAgLi4uZGF0YVxuICAgICAgfVxuICAgIH0sIHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTAgJiYgKHJlc2V0Q291bnQrKywgdHlwZW9mIHJlc2V0ID09IFwib2JqZWN0XCIgJiYgKHJlc2V0LnBsYWNlbWVudCAmJiAoc3RhdGVmdWxQbGFjZW1lbnQgPSByZXNldC5wbGFjZW1lbnQpLCByZXNldC5yZWN0cyAmJiAocmVjdHMgPSByZXNldC5yZWN0cyA9PT0gITAgPyBhd2FpdCBwbGF0Zm9ybTIuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgIHJlZmVyZW5jZSxcbiAgICAgIGZsb2F0aW5nLFxuICAgICAgc3RyYXRlZ3lcbiAgICB9KSA6IHJlc2V0LnJlY3RzKSwge1xuICAgICAgeDogeDIsXG4gICAgICB5OiB5MlxuICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpLCBpMiA9IC0xKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHgyLFxuICAgIHk6IHkyLFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyQxKHN0YXRlLCBvcHRpb25zKSB7XG4gIHZhciBfYXdhaXQkcGxhdGZvcm0kaXNFbGU7XG4gIG9wdGlvbnMgPT09IHZvaWQgMCAmJiAob3B0aW9ucyA9IHt9KTtcbiAgY29uc3Qge1xuICAgIHg6IHgyLFxuICAgIHk6IHkyLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybTIsXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlLCB7XG4gICAgYm91bmRhcnkgPSBcImNsaXBwaW5nQW5jZXN0b3JzXCIsXG4gICAgcm9vdEJvdW5kYXJ5ID0gXCJ2aWV3cG9ydFwiLFxuICAgIGVsZW1lbnRDb250ZXh0ID0gXCJmbG9hdGluZ1wiLFxuICAgIGFsdEJvdW5kYXJ5ID0gITEsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSwgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyksIGVsZW1lbnQgPSBlbGVtZW50c1thbHRCb3VuZGFyeSA/IGVsZW1lbnRDb250ZXh0ID09PSBcImZsb2F0aW5nXCIgPyBcInJlZmVyZW5jZVwiIDogXCJmbG9hdGluZ1wiIDogZWxlbWVudENvbnRleHRdLCBjbGlwcGluZ0NsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KGF3YWl0IHBsYXRmb3JtMi5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6IChfYXdhaXQkcGxhdGZvcm0kaXNFbGUgPSBhd2FpdCAocGxhdGZvcm0yLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmlzRWxlbWVudChlbGVtZW50KSkpID09IG51bGwgfHwgX2F3YWl0JHBsYXRmb3JtJGlzRWxlID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgYXdhaXQgKHBsYXRmb3JtMi5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5nZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudHMuZmxvYXRpbmcpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpLCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09IFwiZmxvYXRpbmdcIiA/IHtcbiAgICB4OiB4MixcbiAgICB5OiB5MixcbiAgICB3aWR0aDogcmVjdHMuZmxvYXRpbmcud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0cy5mbG9hdGluZy5oZWlnaHRcbiAgfSA6IHJlY3RzLnJlZmVyZW5jZSwgb2Zmc2V0UGFyZW50ID0gYXdhaXQgKHBsYXRmb3JtMi5nZXRPZmZzZXRQYXJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKSwgb2Zmc2V0U2NhbGUgPSBhd2FpdCAocGxhdGZvcm0yLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmlzRWxlbWVudChvZmZzZXRQYXJlbnQpKSA/IGF3YWl0IChwbGF0Zm9ybTIuZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5nZXRTY2FsZShvZmZzZXRQYXJlbnQpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0sIGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybTIuY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QgPyBhd2FpdCBwbGF0Zm9ybTIuY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Qoe1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0pIDogcmVjdCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiAoY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wKSAvIG9mZnNldFNjYWxlLnksXG4gICAgYm90dG9tOiAoZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tKSAvIG9mZnNldFNjYWxlLnksXG4gICAgbGVmdDogKGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCkgLyBvZmZzZXRTY2FsZS54LFxuICAgIHJpZ2h0OiAoZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0KSAvIG9mZnNldFNjYWxlLnhcbiAgfTtcbn1cbmNvbnN0IGZsaXAkMiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT09IHZvaWQgMCAmJiAob3B0aW9ucyA9IHt9KSwge1xuICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXJyb3csIF9taWRkbGV3YXJlRGF0YSRmbGlwO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICByZWN0cyxcbiAgICAgICAgaW5pdGlhbFBsYWNlbWVudCxcbiAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtMixcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZSwge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9ICEwLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gITAsXG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50czogc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgICBmYWxsYmFja1N0cmF0ZWd5ID0gXCJiZXN0Rml0XCIsXG4gICAgICAgIGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBcIm5vbmVcIixcbiAgICAgICAgZmxpcEFsaWdubWVudCA9ICEwLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBpZiAoKF9taWRkbGV3YXJlRGF0YSRhcnJvdyA9IG1pZGRsZXdhcmVEYXRhLmFycm93KSAhPSBudWxsICYmIF9taWRkbGV3YXJlRGF0YSRhcnJvdy5hbGlnbm1lbnRPZmZzZXQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCksIGluaXRpYWxTaWRlQXhpcyA9IGdldFNpZGVBeGlzKGluaXRpYWxQbGFjZW1lbnQpLCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50LCBydGwgPSBhd2FpdCAocGxhdGZvcm0yLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSwgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKSwgaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9IGZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gIT09IFwibm9uZVwiO1xuICAgICAgIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICYmIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c10sIG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3ckMShzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKSwgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzICYmIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKSwgY2hlY2tDcm9zc0F4aXMpIHtcbiAgICAgICAgY29uc3Qgc2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhwbGFjZW1lbnQsIHJlY3RzLCBydGwpO1xuICAgICAgICBvdmVyZmxvd3MucHVzaChvdmVyZmxvd1tzaWRlc1swXV0sIG92ZXJmbG93W3NpZGVzWzFdXSk7XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmZsb3dzRGF0YSA9IFsuLi5vdmVyZmxvd3NEYXRhLCB7XG4gICAgICAgIHBsYWNlbWVudCxcbiAgICAgICAgb3ZlcmZsb3dzXG4gICAgICB9XSwgIW92ZXJmbG93cy5ldmVyeSgoc2lkZTIpID0+IHNpZGUyIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxLCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCAmJiAoIShjaGVja0Nyb3NzQXhpcyA9PT0gXCJhbGlnbm1lbnRcIiA/IGluaXRpYWxTaWRlQXhpcyAhPT0gZ2V0U2lkZUF4aXMobmV4dFBsYWNlbWVudCkgOiAhMSkgfHwgLy8gV2UgbGVhdmUgdGhlIGN1cnJlbnQgbWFpbiBheGlzIG9ubHkgaWYgZXZlcnkgcGxhY2VtZW50IG9uIHRoYXQgYXhpc1xuICAgICAgICAvLyBvdmVyZmxvd3MgdGhlIG1haW4gYXhpcy5cbiAgICAgICAgb3ZlcmZsb3dzRGF0YS5ldmVyeSgoZDIpID0+IGQyLm92ZXJmbG93c1swXSA+IDAgJiYgZ2V0U2lkZUF4aXMoZDIucGxhY2VtZW50KSA9PT0gaW5pdGlhbFNpZGVBeGlzKSkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBvdmVyZmxvd3NEYXRhXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgbGV0IHJlc2V0UGxhY2VtZW50ID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlciA9IG92ZXJmbG93c0RhdGEuZmlsdGVyKChkMikgPT4gZDIub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKGEzLCBiMikgPT4gYTMub3ZlcmZsb3dzWzFdIC0gYjIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG4gICAgICAgIGlmICghcmVzZXRQbGFjZW1lbnQpXG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlIFwiYmVzdEZpdFwiOiB7XG4gICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyO1xuICAgICAgICAgICAgICBjb25zdCBwbGFjZW1lbnQyID0gKF9vdmVyZmxvd3NEYXRhJGZpbHRlcjIgPSBvdmVyZmxvd3NEYXRhLmZpbHRlcigoZDIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoZDIucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2lkZUF4aXMgPT09IGluaXRpYWxTaWRlQXhpcyB8fCAvLyBDcmVhdGUgYSBiaWFzIHRvIHRoZSBcXGB5XFxgIHNpZGUgYXhpcyBkdWUgdG8gaG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgLy8gcmVhZGluZyBkaXJlY3Rpb25zIGZhdm9yaW5nIGdyZWF0ZXIgd2lkdGguXG4gICAgICAgICAgICAgICAgICBjdXJyZW50U2lkZUF4aXMgPT09IFwieVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICAgIH0pLm1hcCgoZDIpID0+IFtkMi5wbGFjZW1lbnQsIGQyLm92ZXJmbG93cy5maWx0ZXIoKG92ZXJmbG93MikgPT4gb3ZlcmZsb3cyID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93MikgPT4gYWNjICsgb3ZlcmZsb3cyLCAwKV0pLnNvcnQoKGEzLCBiMikgPT4gYTNbMV0gLSBiMlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyWzBdO1xuICAgICAgICAgICAgICBwbGFjZW1lbnQyICYmIChyZXNldFBsYWNlbWVudCA9IHBsYWNlbWVudDIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbml0aWFsUGxhY2VtZW50XCI6XG4gICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2VtZW50ICE9PSByZXNldFBsYWNlbWVudClcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiByZXNldFBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufSwgb3JpZ2luU2lkZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJsZWZ0XCIsIFwidG9wXCJdKTtcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRWYWx1ZVRvQ29vcmRzKHN0YXRlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQsXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtMixcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGUsIHJ0bCA9IGF3YWl0IChwbGF0Zm9ybTIuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtMi5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpLCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpLCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KSwgaXNWZXJ0aWNhbCA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09IFwieVwiLCBtYWluQXhpc011bHRpID0gb3JpZ2luU2lkZXMuaGFzKHNpZGUpID8gLTEgOiAxLCBjcm9zc0F4aXNNdWx0aSA9IHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxLCByYXdWYWx1ZSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09IFwibnVtYmVyXCIgPyB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLFxuICAgIGNyb3NzQXhpczogMCxcbiAgICBhbGlnbm1lbnRBeGlzOiBudWxsXG4gIH0gOiB7XG4gICAgbWFpbkF4aXM6IHJhd1ZhbHVlLm1haW5BeGlzIHx8IDAsXG4gICAgY3Jvc3NBeGlzOiByYXdWYWx1ZS5jcm9zc0F4aXMgfHwgMCxcbiAgICBhbGlnbm1lbnRBeGlzOiByYXdWYWx1ZS5hbGlnbm1lbnRBeGlzXG4gIH07XG4gIHJldHVybiBhbGlnbm1lbnQgJiYgdHlwZW9mIGFsaWdubWVudEF4aXMgPT0gXCJudW1iZXJcIiAmJiAoY3Jvc3NBeGlzID0gYWxpZ25tZW50ID09PSBcImVuZFwiID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcyksIGlzVmVydGljYWwgPyB7XG4gICAgeDogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGksXG4gICAgeTogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpXG4gIH0gOiB7XG4gICAgeDogbWFpbkF4aXMgKiBtYWluQXhpc011bHRpLFxuICAgIHk6IGNyb3NzQXhpcyAqIGNyb3NzQXhpc011bHRpXG4gIH07XG59XG5jb25zdCBvZmZzZXQkMiA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT09IHZvaWQgMCAmJiAob3B0aW9ucyA9IDApLCB7XG4gICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJG9mZnNlLCBfbWlkZGxld2FyZURhdGEkYXJyb3c7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IHgyLFxuICAgICAgICB5OiB5MixcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YVxuICAgICAgfSA9IHN0YXRlLCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCA/IHt9IDoge1xuICAgICAgICB4OiB4MiArIGRpZmZDb29yZHMueCxcbiAgICAgICAgeTogeTIgKyBkaWZmQ29vcmRzLnksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAuLi5kaWZmQ29vcmRzLFxuICAgICAgICAgIHBsYWNlbWVudFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn0sIHNoaWZ0JDIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID09PSB2b2lkIDAgJiYgKG9wdGlvbnMgPSB7fSksIHtcbiAgICBuYW1lOiBcInNoaWZ0XCIsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB4OiB4MixcbiAgICAgICAgeTogeTIsXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlLCB7XG4gICAgICAgIG1haW5BeGlzOiBjaGVja01haW5BeGlzID0gITAsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSAhMSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogKF9yZWYpID0+IHtcbiAgICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICAgIHg6IHgzLFxuICAgICAgICAgICAgICB5OiB5M1xuICAgICAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiB4MyxcbiAgICAgICAgICAgICAgeTogeTNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSksIGNvb3JkcyA9IHtcbiAgICAgICAgeDogeDIsXG4gICAgICAgIHk6IHkyXG4gICAgICB9LCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93JDEoc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyksIGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKGdldFNpZGUocGxhY2VtZW50KSksIG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc10sIGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gbWFpbkF4aXMgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiLCBtYXhTaWRlID0gbWFpbkF4aXMgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiwgbWluMiA9IG1haW5BeGlzQ29vcmQgKyBvdmVyZmxvd1ttaW5TaWRlXSwgbWF4MiA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbjIsIG1haW5BeGlzQ29vcmQsIG1heDIpO1xuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBjcm9zc0F4aXMgPT09IFwieVwiID8gXCJ0b3BcIiA6IFwibGVmdFwiLCBtYXhTaWRlID0gY3Jvc3NBeGlzID09PSBcInlcIiA/IFwiYm90dG9tXCIgOiBcInJpZ2h0XCIsIG1pbjIgPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdLCBtYXgyID0gY3Jvc3NBeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgY3Jvc3NBeGlzQ29vcmQgPSBjbGFtcChtaW4yLCBjcm9zc0F4aXNDb29yZCwgbWF4Mik7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgyLFxuICAgICAgICAgIHk6IGxpbWl0ZWRDb29yZHMueSAtIHkyLFxuICAgICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIFttYWluQXhpc106IGNoZWNrTWFpbkF4aXMsXG4gICAgICAgICAgICBbY3Jvc3NBeGlzXTogY2hlY2tDcm9zc0F4aXNcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufSwgc2l6ZSQyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA9PT0gdm9pZCAwICYmIChvcHRpb25zID0ge30pLCB7XG4gICAgbmFtZTogXCJzaXplXCIsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9zdGF0ZSRtaWRkbGV3YXJlRGF0YSwgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgcGxhdGZvcm06IHBsYXRmb3JtMixcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZSwge1xuICAgICAgICBhcHBseSA9ICgpID0+IHtcbiAgICAgICAgfSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpLCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93JDEoc3RhdGUsIGRldGVjdE92ZXJmbG93T3B0aW9ucyksIHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCksIGFsaWdubWVudCA9IGdldEFsaWdubWVudChwbGFjZW1lbnQpLCBpc1lBeGlzID0gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSA9PT0gXCJ5XCIsIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfSA9IHJlY3RzLmZsb2F0aW5nO1xuICAgICAgbGV0IGhlaWdodFNpZGUsIHdpZHRoU2lkZTtcbiAgICAgIHNpZGUgPT09IFwidG9wXCIgfHwgc2lkZSA9PT0gXCJib3R0b21cIiA/IChoZWlnaHRTaWRlID0gc2lkZSwgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoYXdhaXQgKHBsYXRmb3JtMi5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0yLmlzUlRMKGVsZW1lbnRzLmZsb2F0aW5nKSkgPyBcInN0YXJ0XCIgOiBcImVuZFwiKSA/IFwibGVmdFwiIDogXCJyaWdodFwiKSA6ICh3aWR0aFNpZGUgPSBzaWRlLCBoZWlnaHRTaWRlID0gYWxpZ25tZW50ID09PSBcImVuZFwiID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpO1xuICAgICAgY29uc3QgbWF4aW11bUNsaXBwaW5nSGVpZ2h0ID0gaGVpZ2h0IC0gb3ZlcmZsb3cudG9wIC0gb3ZlcmZsb3cuYm90dG9tLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCA9IHdpZHRoIC0gb3ZlcmZsb3cubGVmdCAtIG92ZXJmbG93LnJpZ2h0LCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KSwgb3ZlcmZsb3dBdmFpbGFibGVXaWR0aCA9IG1pbih3aWR0aCAtIG92ZXJmbG93W3dpZHRoU2lkZV0sIG1heGltdW1DbGlwcGluZ1dpZHRoKSwgbm9TaGlmdCA9ICFzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdDtcbiAgICAgIGxldCBhdmFpbGFibGVIZWlnaHQgPSBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCwgYXZhaWxhYmxlV2lkdGggPSBvdmVyZmxvd0F2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEuZW5hYmxlZC54ICYmIChhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoKSwgKF9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIgPSBzdGF0ZS5taWRkbGV3YXJlRGF0YS5zaGlmdCkgIT0gbnVsbCAmJiBfc3RhdGUkbWlkZGxld2FyZURhdGEyLmVuYWJsZWQueSAmJiAoYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0KSwgbm9TaGlmdCAmJiAhYWxpZ25tZW50KSB7XG4gICAgICAgIGNvbnN0IHhNaW4gPSBtYXgob3ZlcmZsb3cubGVmdCwgMCksIHhNYXggPSBtYXgob3ZlcmZsb3cucmlnaHQsIDApLCB5TWluID0gbWF4KG92ZXJmbG93LnRvcCwgMCksIHlNYXggPSBtYXgob3ZlcmZsb3cuYm90dG9tLCAwKTtcbiAgICAgICAgaXNZQXhpcyA/IGF2YWlsYWJsZVdpZHRoID0gd2lkdGggLSAyICogKHhNaW4gIT09IDAgfHwgeE1heCAhPT0gMCA/IHhNaW4gKyB4TWF4IDogbWF4KG92ZXJmbG93LmxlZnQsIG92ZXJmbG93LnJpZ2h0KSkgOiBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBhcHBseSh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG5leHREaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0yLmdldERpbWVuc2lvbnMoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgICAgcmV0dXJuIHdpZHRoICE9PSBuZXh0RGltZW5zaW9ucy53aWR0aCB8fCBoZWlnaHQgIT09IG5leHREaW1lbnNpb25zLmhlaWdodCA/IHtcbiAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICByZWN0czogITBcbiAgICAgICAgfVxuICAgICAgfSA6IHt9O1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBoYXNXaW5kb3coKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93IDwgXCJ1XCI7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIHJldHVybiBpc05vZGUobm9kZSkgPyAobm9kZS5ub2RlTmFtZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpIDogXCIjZG9jdW1lbnRcIjtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCB8fCAoX25vZGUkb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHx8IHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHZhciBfcmVmO1xuICByZXR1cm4gKF9yZWYgPSAoaXNOb2RlKG5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50IDogbm9kZS5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3JlZi5kb2N1bWVudEVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIGhhc1dpbmRvdygpID8gdmFsdWUgaW5zdGFuY2VvZiBOb2RlIHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlIDogITE7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIGhhc1dpbmRvdygpID8gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50IDogITE7XG59XG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiBoYXNXaW5kb3coKSA/IHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkhUTUxFbGVtZW50IDogITE7XG59XG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3QodmFsdWUpIHtcbiAgcmV0dXJuICFoYXNXaW5kb3coKSB8fCB0eXBlb2YgU2hhZG93Um9vdCA+IFwidVwiID8gITEgOiB2YWx1ZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLlNoYWRvd1Jvb3Q7XG59XG5jb25zdCBpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW5saW5lXCIsIFwiY29udGVudHNcIl0pO1xuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW58Y2xpcC8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkgJiYgIWludmFsaWRPdmVyZmxvd0Rpc3BsYXlWYWx1ZXMuaGFzKGRpc3BsYXkpO1xufVxuY29uc3QgdGFibGVFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXSk7XG5mdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRzLmhhcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5jb25zdCB0b3BMYXllclNlbGVjdG9ycyA9IFtcIjpwb3BvdmVyLW9wZW5cIiwgXCI6bW9kYWxcIl07XG5mdW5jdGlvbiBpc1RvcExheWVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRvcExheWVyU2VsZWN0b3JzLnNvbWUoKHNlbGVjdG9yKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0aWVzID0gW1widHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlXCIsIFwic2NhbGVcIiwgXCJyb3RhdGVcIiwgXCJwZXJzcGVjdGl2ZVwiXSwgd2lsbENoYW5nZVZhbHVlcyA9IFtcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZVwiLCBcInNjYWxlXCIsIFwicm90YXRlXCIsIFwicGVyc3BlY3RpdmVcIiwgXCJmaWx0ZXJcIl0sIGNvbnRhaW5WYWx1ZXMgPSBbXCJwYWludFwiLCBcImxheW91dFwiLCBcInN0cmljdFwiLCBcImNvbnRlbnRcIl07XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50T3JDc3MpIHtcbiAgY29uc3Qgd2Via2l0ID0gaXNXZWJLaXQoKSwgY3NzID0gaXNFbGVtZW50KGVsZW1lbnRPckNzcykgPyBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudE9yQ3NzKSA6IGVsZW1lbnRPckNzcztcbiAgcmV0dXJuIHRyYW5zZm9ybVByb3BlcnRpZXMuc29tZSgodmFsdWUpID0+IGNzc1t2YWx1ZV0gPyBjc3NbdmFsdWVdICE9PSBcIm5vbmVcIiA6ICExKSB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gXCJub3JtYWxcIiA6ICExKSB8fCAhd2Via2l0ICYmIChjc3MuYmFja2Ryb3BGaWx0ZXIgPyBjc3MuYmFja2Ryb3BGaWx0ZXIgIT09IFwibm9uZVwiIDogITEpIHx8ICF3ZWJraXQgJiYgKGNzcy5maWx0ZXIgPyBjc3MuZmlsdGVyICE9PSBcIm5vbmVcIiA6ICExKSB8fCB3aWxsQ2hhbmdlVmFsdWVzLnNvbWUoKHZhbHVlKSA9PiAoY3NzLndpbGxDaGFuZ2UgfHwgXCJcIikuaW5jbHVkZXModmFsdWUpKSB8fCBjb250YWluVmFsdWVzLnNvbWUoKHZhbHVlKSA9PiAoY3NzLmNvbnRhaW4gfHwgXCJcIikuaW5jbHVkZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGZvciAoOyBpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKGN1cnJlbnROb2RlKTsgKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSlcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICBpZiAoaXNUb3BMYXllcihjdXJyZW50Tm9kZSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXZWJLaXQoKSB7XG4gIHJldHVybiB0eXBlb2YgQ1NTID4gXCJ1XCIgfHwgIUNTUy5zdXBwb3J0cyA/ICExIDogQ1NTLnN1cHBvcnRzKFwiLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXJcIiwgXCJub25lXCIpO1xufVxuY29uc3QgbGFzdFRyYXZlcnNhYmxlTm9kZU5hbWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0pO1xuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGxhc3RUcmF2ZXJzYWJsZU5vZGVOYW1lcy5oYXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiBpc0VsZW1lbnQoZWxlbWVudCkgPyB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfSA6IHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbFgsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICBpZiAoZ2V0Tm9kZU5hbWUobm9kZSkgPT09IFwiaHRtbFwiKVxuICAgIHJldHVybiBub2RlO1xuICBjb25zdCByZXN1bHQgPSAoXG4gICAgLy8gU3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGUuXG4gICAgbm9kZS5hc3NpZ25lZFNsb3QgfHwgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gICAgbm9kZS5wYXJlbnROb2RlIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWQuXG4gICAgaXNTaGFkb3dSb290KG5vZGUpICYmIG5vZGUuaG9zdCB8fCAvLyBGYWxsYmFjay5cbiAgICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSlcbiAgKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICByZXR1cm4gaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpID8gbm9kZS5vd25lckRvY3VtZW50ID8gbm9kZS5vd25lckRvY3VtZW50LmJvZHkgOiBub2RlLmJvZHkgOiBpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpID8gcGFyZW50Tm9kZSA6IGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCwgdHJhdmVyc2VJZnJhbWVzKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50MjtcbiAgbGlzdCA9PT0gdm9pZCAwICYmIChsaXN0ID0gW10pLCB0cmF2ZXJzZUlmcmFtZXMgPT09IHZvaWQgMCAmJiAodHJhdmVyc2VJZnJhbWVzID0gITApO1xuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSwgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSksIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KHdpbik7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIGZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhmcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbikge1xuICByZXR1cm4gd2luLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yod2luLnBhcmVudCkgPyB3aW4uZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XG4gIGxldCB3aWR0aCA9IHBhcnNlRmxvYXQoY3NzLndpZHRoKSB8fCAwLCBoZWlnaHQgPSBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGhhc09mZnNldCA9IGlzSFRNTEVsZW1lbnQoZWxlbWVudCksIG9mZnNldFdpZHRoID0gaGFzT2Zmc2V0ID8gZWxlbWVudC5vZmZzZXRXaWR0aCA6IHdpZHRoLCBvZmZzZXRIZWlnaHQgPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldEhlaWdodCA6IGhlaWdodCwgc2hvdWxkRmFsbGJhY2sgPSByb3VuZCh3aWR0aCkgIT09IG9mZnNldFdpZHRoIHx8IHJvdW5kKGhlaWdodCkgIT09IG9mZnNldEhlaWdodDtcbiAgcmV0dXJuIHNob3VsZEZhbGxiYWNrICYmICh3aWR0aCA9IG9mZnNldFdpZHRoLCBoZWlnaHQgPSBvZmZzZXRIZWlnaHQpLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6IHNob3VsZEZhbGxiYWNrXG4gIH07XG59XG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKVxuICAgIHJldHVybiBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IHJlY3QgPSBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgICQ6ICQyXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeDIgPSAoJDIgPyByb3VuZChyZWN0LndpZHRoKSA6IHJlY3Qud2lkdGgpIC8gd2lkdGgsIHkyID0gKCQyID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuICByZXR1cm4gKCF4MiB8fCAhTnVtYmVyLmlzRmluaXRlKHgyKSkgJiYgKHgyID0gMSksICgheTIgfHwgIU51bWJlci5pc0Zpbml0ZSh5MikpICYmICh5MiA9IDEpLCB7XG4gICAgeDogeDIsXG4gICAgeTogeTJcbiAgfTtcbn1cbmNvbnN0IG5vT2Zmc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb29yZHMoMCk7XG5mdW5jdGlvbiBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICByZXR1cm4gIWlzV2ViS2l0KCkgfHwgIXdpbi52aXN1YWxWaWV3cG9ydCA/IG5vT2Zmc2V0cyA6IHtcbiAgICB4OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCxcbiAgICB5OiB3aW4udmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGVsZW1lbnQsIGlzRml4ZWQsIGZsb2F0aW5nT2Zmc2V0UGFyZW50KSB7XG4gIHJldHVybiBpc0ZpeGVkID09PSB2b2lkIDAgJiYgKGlzRml4ZWQgPSAhMSksICFmbG9hdGluZ09mZnNldFBhcmVudCB8fCBpc0ZpeGVkICYmIGZsb2F0aW5nT2Zmc2V0UGFyZW50ICE9PSBnZXRXaW5kb3coZWxlbWVudCkgPyAhMSA6IGlzRml4ZWQ7XG59XG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCAmJiAoaW5jbHVkZVNjYWxlID0gITEpLCBpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCAmJiAoaXNGaXhlZFN0cmF0ZWd5ID0gITEpO1xuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaW5jbHVkZVNjYWxlICYmIChvZmZzZXRQYXJlbnQgPyBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiAoc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpKSA6IHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCkpO1xuICBjb25zdCB2aXN1YWxPZmZzZXRzID0gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhkb21FbGVtZW50LCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkgPyBnZXRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDApO1xuICBsZXQgeDIgPSAoY2xpZW50UmVjdC5sZWZ0ICsgdmlzdWFsT2Zmc2V0cy54KSAvIHNjYWxlLngsIHkyID0gKGNsaWVudFJlY3QudG9wICsgdmlzdWFsT2Zmc2V0cy55KSAvIHNjYWxlLnksIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlLngsIGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCksIG9mZnNldFdpbiA9IG9mZnNldFBhcmVudCAmJiBpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSA/IGdldFdpbmRvdyhvZmZzZXRQYXJlbnQpIDogb2Zmc2V0UGFyZW50O1xuICAgIGxldCBjdXJyZW50V2luID0gd2luLCBjdXJyZW50SUZyYW1lID0gZ2V0RnJhbWVFbGVtZW50KGN1cnJlbnRXaW4pO1xuICAgIGZvciAoOyBjdXJyZW50SUZyYW1lICYmIG9mZnNldFBhcmVudCAmJiBvZmZzZXRXaW4gIT09IGN1cnJlbnRXaW47ICkge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKSwgaWZyYW1lUmVjdCA9IGN1cnJlbnRJRnJhbWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShjdXJyZW50SUZyYW1lKSwgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueCwgdG9wID0gaWZyYW1lUmVjdC50b3AgKyAoY3VycmVudElGcmFtZS5jbGllbnRUb3AgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nVG9wKSkgKiBpZnJhbWVTY2FsZS55O1xuICAgICAgeDIgKj0gaWZyYW1lU2NhbGUueCwgeTIgKj0gaWZyYW1lU2NhbGUueSwgd2lkdGggKj0gaWZyYW1lU2NhbGUueCwgaGVpZ2h0ICo9IGlmcmFtZVNjYWxlLnksIHgyICs9IGxlZnQsIHkyICs9IHRvcCwgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKSwgY3VycmVudElGcmFtZSA9IGdldEZyYW1lRWxlbWVudChjdXJyZW50V2luKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlY3RUb0NsaWVudFJlY3Qoe1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4OiB4MixcbiAgICB5OiB5MlxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICByZXR1cm4gcmVjdCA/IHJlY3QubGVmdCArIGxlZnRTY3JvbGwgOiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgbGVmdFNjcm9sbDtcbn1cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsIGlnbm9yZVNjcm9sbGJhclgpIHtcbiAgaWdub3JlU2Nyb2xsYmFyWCA9PT0gdm9pZCAwICYmIChpZ25vcmVTY3JvbGxiYXJYID0gITEpO1xuICBjb25zdCBodG1sUmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgeDIgPSBodG1sUmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSAoaWdub3JlU2Nyb2xsYmFyWCA/IDAgOiAoXG4gICAgLy8gUlRMIDxib2R5PiBzY3JvbGxiYXIuXG4gICAgZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQsIGh0bWxSZWN0KVxuICApKSwgeTIgPSBodG1sUmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4ge1xuICAgIHg6IHgyLFxuICAgIHk6IHkyXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudHMsXG4gICAgcmVjdCxcbiAgICBvZmZzZXRQYXJlbnQsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gXCJmaXhlZFwiLCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KSwgdG9wTGF5ZXIgPSBlbGVtZW50cyA/IGlzVG9wTGF5ZXIoZWxlbWVudHMuZmxvYXRpbmcpIDogITE7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCB8fCB0b3BMYXllciAmJiBpc0ZpeGVkKVxuICAgIHJldHVybiByZWN0O1xuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH0sIHNjYWxlID0gY3JlYXRlQ29vcmRzKDEpO1xuICBjb25zdCBvZmZzZXRzID0gY3JlYXRlQ29vcmRzKDApLCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgaWYgKChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpICYmICgoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gXCJib2R5XCIgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkgJiYgKHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KSksIGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkpIHtcbiAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpLCBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdCwgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwsICEwKSA6IGNyZWF0ZUNvb3JkcygwKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCAqIHNjYWxlLngsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAqIHNjYWxlLnksXG4gICAgeDogcmVjdC54ICogc2NhbGUueCAtIHNjcm9sbC5zY3JvbGxMZWZ0ICogc2NhbGUueCArIG9mZnNldHMueCArIGh0bWxPZmZzZXQueCxcbiAgICB5OiByZWN0LnkgKiBzY2FsZS55IC0gc2Nyb2xsLnNjcm9sbFRvcCAqIHNjYWxlLnkgKyBvZmZzZXRzLnkgKyBodG1sT2Zmc2V0LnlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RzKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5nZXRDbGllbnRSZWN0cygpKTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50UmVjdChlbGVtZW50KSB7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCksIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwoZWxlbWVudCksIGJvZHkgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keSwgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keS5zY3JvbGxXaWR0aCwgYm9keS5jbGllbnRXaWR0aCksIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkuc2Nyb2xsSGVpZ2h0LCBib2R5LmNsaWVudEhlaWdodCk7XG4gIGxldCB4MiA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkyID0gLXNjcm9sbC5zY3JvbGxUb3A7XG4gIHJldHVybiBnZXRDb21wdXRlZFN0eWxlJDEoYm9keSkuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmICh4MiArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aCksIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeDogeDIsXG4gICAgeTogeTJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCksIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCksIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoLCBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodCwgeDIgPSAwLCB5MiA9IDA7XG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGgsIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gXCJmaXhlZFwiKSAmJiAoeDIgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LCB5MiA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeDogeDIsXG4gICAgeTogeTJcbiAgfTtcbn1cbmNvbnN0IGFic29sdXRlT3JGaXhlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0pO1xuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3QgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCAhMCwgc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiksIHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3AsIGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQsIHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDogY3JlYXRlQ29vcmRzKDEpLCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54LCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnksIHgyID0gbGVmdCAqIHNjYWxlLngsIHkyID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeDogeDIsXG4gICAgeTogeTJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkge1xuICBsZXQgcmVjdDtcbiAgaWYgKGNsaXBwaW5nQW5jZXN0b3IgPT09IFwidmlld3BvcnRcIilcbiAgICByZWN0ID0gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KTtcbiAgZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gXCJkb2N1bWVudFwiKVxuICAgIHJlY3QgPSBnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgZWxzZSBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKVxuICAgIHJlY3QgPSBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpO1xuICAgIHJlY3QgPSB7XG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnksXG4gICAgICB3aWR0aDogY2xpcHBpbmdBbmNlc3Rvci53aWR0aCxcbiAgICAgIGhlaWdodDogY2xpcHBpbmdBbmNlc3Rvci5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICByZXR1cm4gcGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkgPyAhMSA6IGdldENvbXB1dGVkU3R5bGUkMShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiIHx8IGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihwYXJlbnROb2RlLCBzdG9wTm9kZSk7XG59XG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KVxuICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gIGxldCByZXN1bHQgPSBnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50LCBbXSwgITEpLmZpbHRlcigoZWwpID0+IGlzRWxlbWVudChlbCkgJiYgZ2V0Tm9kZU5hbWUoZWwpICE9PSBcImJvZHlcIiksIGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIjtcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgZm9yICg7IGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSk7ICkge1xuICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlJDEoY3VycmVudE5vZGUpLCBjdXJyZW50Tm9kZUlzQ29udGFpbmluZyA9IGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKTtcbiAgICAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiICYmIChjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGwpLCAoZWxlbWVudElzRml4ZWQgPyAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlIDogIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGNvbXB1dGVkU3R5bGUucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiYgISFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSAmJiBhYnNvbHV0ZU9yRml4ZWQuaGFzKGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlLnBvc2l0aW9uKSB8fCBpc092ZXJmbG93RWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmIGhhc0ZpeGVkUG9zaXRpb25BbmNlc3RvcihlbGVtZW50LCBjdXJyZW50Tm9kZSkpID8gcmVzdWx0ID0gcmVzdWx0LmZpbHRlcigoYW5jZXN0b3IpID0+IGFuY2VzdG9yICE9PSBjdXJyZW50Tm9kZSkgOiBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGUsIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlLnNldChlbGVtZW50LCByZXN1bHQpLCByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBjbGlwcGluZ0FuY2VzdG9ycyA9IFsuLi5ib3VuZGFyeSA9PT0gXCJjbGlwcGluZ0FuY2VzdG9yc1wiID8gaXNUb3BMYXllcihlbGVtZW50KSA/IFtdIDogZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIHRoaXMuX2MpIDogW10uY29uY2F0KGJvdW5kYXJ5KSwgcm9vdEJvdW5kYXJ5XSwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yID0gY2xpcHBpbmdBbmNlc3RvcnNbMF0sIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nQW5jZXN0b3JzLnJlZHVjZSgoYWNjUmVjdCwgY2xpcHBpbmdBbmNlc3RvcikgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICAgIHJldHVybiBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApLCBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpLCBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pLCBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpLCBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgZmlyc3RDbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICBoZWlnaHQ6IGNsaXBwaW5nUmVjdC5ib3R0b20gLSBjbGlwcGluZ1JlY3QudG9wLFxuICAgIHg6IGNsaXBwaW5nUmVjdC5sZWZ0LFxuICAgIHk6IGNsaXBwaW5nUmVjdC50b3BcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSwgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCksIGlzRml4ZWQgPSBzdHJhdGVneSA9PT0gXCJmaXhlZFwiLCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsICEwLCBpc0ZpeGVkLCBvZmZzZXRQYXJlbnQpO1xuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGNvbnN0IG9mZnNldHMgPSBjcmVhdGVDb29yZHMoMCk7XG4gIGZ1bmN0aW9uIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKSB7XG4gICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICB9XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpXG4gICAgaWYgKChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSBcImJvZHlcIiB8fCBpc092ZXJmbG93RWxlbWVudChkb2N1bWVudEVsZW1lbnQpKSAmJiAoc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpKSwgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IG9mZnNldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCAhMCwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0LCBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBkb2N1bWVudEVsZW1lbnQgJiYgc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpO1xuICBpc0ZpeGVkICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiBkb2N1bWVudEVsZW1lbnQgJiYgc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpO1xuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApLCB4MiA9IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54IC0gaHRtbE9mZnNldC54LCB5MiA9IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSAtIGh0bWxPZmZzZXQueTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MixcbiAgICB5OiB5MixcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiO1xufVxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChwb2x5ZmlsbClcbiAgICByZXR1cm4gcG9seWZpbGwoZWxlbWVudCk7XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgcmV0dXJuIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSA9PT0gcmF3T2Zmc2V0UGFyZW50ICYmIChyYXdPZmZzZXRQYXJlbnQgPSByYXdPZmZzZXRQYXJlbnQub3duZXJEb2N1bWVudC5ib2R5KSwgcmF3T2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKGlzVG9wTGF5ZXIoZWxlbWVudCkpXG4gICAgcmV0dXJuIHdpbjtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgbGV0IHN2Z09mZnNldFBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gICAgZm9yICg7IHN2Z09mZnNldFBhcmVudCAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKHN2Z09mZnNldFBhcmVudCk7ICkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSlcbiAgICAgICAgcmV0dXJuIHN2Z09mZnNldFBhcmVudDtcbiAgICAgIHN2Z09mZnNldFBhcmVudCA9IGdldFBhcmVudE5vZGUoc3ZnT2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBsZXQgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCk7XG4gIGZvciAoOyBvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc1N0YXRpY1Bvc2l0aW9uZWQob2Zmc2V0UGFyZW50KTsgKVxuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50LCBwb2x5ZmlsbCk7XG4gIHJldHVybiBvZmZzZXRQYXJlbnQgJiYgaXNMYXN0VHJhdmVyc2FibGVOb2RlKG9mZnNldFBhcmVudCkgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkgPyB3aW4gOiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbjtcbn1cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uKGRhdGEpIHtcbiAgY29uc3QgZ2V0T2Zmc2V0UGFyZW50Rm4gPSB0aGlzLmdldE9mZnNldFBhcmVudCB8fCBnZXRPZmZzZXRQYXJlbnQsIGdldERpbWVuc2lvbnNGbiA9IHRoaXMuZ2V0RGltZW5zaW9ucywgZmxvYXRpbmdEaW1lbnNpb25zID0gYXdhaXQgZ2V0RGltZW5zaW9uc0ZuKGRhdGEuZmxvYXRpbmcpO1xuICByZXR1cm4ge1xuICAgIHJlZmVyZW5jZTogZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZGF0YS5yZWZlcmVuY2UsIGF3YWl0IGdldE9mZnNldFBhcmVudEZuKGRhdGEuZmxvYXRpbmcpLCBkYXRhLnN0cmF0ZWd5KSxcbiAgICBmbG9hdGluZzoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZmxvYXRpbmdEaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBmbG9hdGluZ0RpbWVuc2lvbnMuaGVpZ2h0XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5kaXJlY3Rpb24gPT09IFwicnRsXCI7XG59XG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldEVsZW1lbnRSZWN0cyxcbiAgZ2V0Q2xpZW50UmVjdHMsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldFNjYWxlLFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMXG59O1xuZnVuY3Rpb24gcmVjdHNBcmVFcXVhbChhMywgYjIpIHtcbiAgcmV0dXJuIGEzLnggPT09IGIyLnggJiYgYTMueSA9PT0gYjIueSAmJiBhMy53aWR0aCA9PT0gYjIud2lkdGggJiYgYTMuaGVpZ2h0ID09PSBiMi5oZWlnaHQ7XG59XG5mdW5jdGlvbiBvYnNlcnZlTW92ZShlbGVtZW50LCBvbk1vdmUpIHtcbiAgbGV0IGlvID0gbnVsbCwgdGltZW91dElkO1xuICBjb25zdCByb290ID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHZhciBfaW87XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCksIChfaW8gPSBpbykgPT0gbnVsbCB8fCBfaW8uZGlzY29ubmVjdCgpLCBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBza2lwID09PSB2b2lkIDAgJiYgKHNraXAgPSAhMSksIHRocmVzaG9sZCA9PT0gdm9pZCAwICYmICh0aHJlc2hvbGQgPSAxKSwgY2xlYW51cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHtcbiAgICAgIGxlZnQsXG4gICAgICB0b3AsXG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBlbGVtZW50UmVjdEZvclJvb3RNYXJnaW47XG4gICAgaWYgKHNraXAgfHwgb25Nb3ZlKCksICF3aWR0aCB8fCAhaGVpZ2h0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGluc2V0VG9wID0gZmxvb3IodG9wKSwgaW5zZXRSaWdodCA9IGZsb29yKHJvb3QuY2xpZW50V2lkdGggLSAobGVmdCArIHdpZHRoKSksIGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSksIGluc2V0TGVmdCA9IGZsb29yKGxlZnQpLCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbjogLWluc2V0VG9wICsgXCJweCBcIiArIC1pbnNldFJpZ2h0ICsgXCJweCBcIiArIC1pbnNldEJvdHRvbSArIFwicHggXCIgKyAtaW5zZXRMZWZ0ICsgXCJweFwiLFxuICAgICAgdGhyZXNob2xkOiBtYXgoMCwgbWluKDEsIHRocmVzaG9sZCkpIHx8IDFcbiAgICB9O1xuICAgIGxldCBpc0ZpcnN0VXBkYXRlID0gITA7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpXG4gICAgICAgICAgcmV0dXJuIHJlZnJlc2goKTtcbiAgICAgICAgcmF0aW8gPyByZWZyZXNoKCExLCByYXRpbykgOiB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWZyZXNoKCExLCAxZS03KTtcbiAgICAgICAgfSwgMWUzKTtcbiAgICAgIH1cbiAgICAgIHJhdGlvID09PSAxICYmICFyZWN0c0FyZUVxdWFsKGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiwgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkgJiYgcmVmcmVzaCgpLCBpc0ZpcnN0VXBkYXRlID0gITE7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpbyA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihoYW5kbGVPYnNlcnZlLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIC8vIEhhbmRsZSA8aWZyYW1lPnNcbiAgICAgICAgcm9vdDogcm9vdC5vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJldHVybiByZWZyZXNoKCEwKSwgY2xlYW51cDtcbn1cbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPT09IHZvaWQgMCAmJiAob3B0aW9ucyA9IHt9KTtcbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsID0gITAsXG4gICAgYW5jZXN0b3JSZXNpemUgPSAhMCxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09IFwiZnVuY3Rpb25cIixcbiAgICBsYXlvdXRTaGlmdCA9IHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIsXG4gICAgYW5pbWF0aW9uRnJhbWUgPSAhMVxuICB9ID0gb3B0aW9ucywgcmVmZXJlbmNlRWwgPSB1bndyYXBFbGVtZW50KHJlZmVyZW5jZSksIGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLnJlZmVyZW5jZUVsID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlRWwpIDogW10sIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGUsIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlKTtcbiAgfSk7XG4gIGNvbnN0IGNsZWFudXBJbyA9IHJlZmVyZW5jZUVsICYmIGxheW91dFNoaWZ0ID8gb2JzZXJ2ZU1vdmUocmVmZXJlbmNlRWwsIHVwZGF0ZSkgOiBudWxsO1xuICBsZXQgcmVvYnNlcnZlRnJhbWUgPSAtMSwgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICBlbGVtZW50UmVzaXplICYmIChyZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoX3JlZikgPT4ge1xuICAgIGxldCBbZmlyc3RFbnRyeV0gPSBfcmVmO1xuICAgIGZpcnN0RW50cnkgJiYgZmlyc3RFbnRyeS50YXJnZXQgPT09IHJlZmVyZW5jZUVsICYmIHJlc2l6ZU9ic2VydmVyICYmIChyZXNpemVPYnNlcnZlci51bm9ic2VydmUoZmxvYXRpbmcpLCBjYW5jZWxBbmltYXRpb25GcmFtZShyZW9ic2VydmVGcmFtZSksIHJlb2JzZXJ2ZUZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAoX3Jlc2l6ZU9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpO1xuICAgIH0pKSwgdXBkYXRlKCk7XG4gIH0pLCByZWZlcmVuY2VFbCAmJiAhYW5pbWF0aW9uRnJhbWUgJiYgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2VFbCksIHJlc2l6ZU9ic2VydmVyLm9ic2VydmUoZmxvYXRpbmcpKTtcbiAgbGV0IGZyYW1lSWQsIHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGFuaW1hdGlvbkZyYW1lICYmIGZyYW1lTG9vcCgpO1xuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBwcmV2UmVmUmVjdCAmJiAhcmVjdHNBcmVFcXVhbChwcmV2UmVmUmVjdCwgbmV4dFJlZlJlY3QpICYmIHVwZGF0ZSgpLCBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0LCBmcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lTG9vcCk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZSgpLCAoKSA9PiB7XG4gICAgdmFyIF9yZXNpemVPYnNlcnZlcjI7XG4gICAgYW5jZXN0b3JzLmZvckVhY2goKGFuY2VzdG9yKSA9PiB7XG4gICAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSksIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlKTtcbiAgICB9KSwgY2xlYW51cElvID09IG51bGwgfHwgY2xlYW51cElvKCksIChfcmVzaXplT2JzZXJ2ZXIyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyMi5kaXNjb25uZWN0KCksIHJlc2l6ZU9ic2VydmVyID0gbnVsbCwgYW5pbWF0aW9uRnJhbWUgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gIH07XG59XG5jb25zdCBkZXRlY3RPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93JDEsIG9mZnNldCQxID0gb2Zmc2V0JDIsIHNoaWZ0JDEgPSBzaGlmdCQyLCBmbGlwJDEgPSBmbGlwJDIsIHNpemUkMSA9IHNpemUkMiwgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBtZXJnZWRPcHRpb25zID0ge1xuICAgIHBsYXRmb3JtLFxuICAgIC4uLm9wdGlvbnNcbiAgfSwgcGxhdGZvcm1XaXRoQ2FjaGUgPSB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucy5wbGF0Zm9ybSxcbiAgICBfYzogY2FjaGVcbiAgfTtcbiAgcmV0dXJuIGNvbXB1dGVQb3NpdGlvbiQxKHJlZmVyZW5jZSwgZmxvYXRpbmcsIHtcbiAgICAuLi5tZXJnZWRPcHRpb25zLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVdpdGhDYWNoZVxuICB9KTtcbn07XG52YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiwgbm9vcCA9IGZ1bmN0aW9uKCkge1xufSwgaW5kZXgkMSA9IGlzQ2xpZW50ID8gdXNlTGF5b3V0RWZmZWN0IDogbm9vcDtcbmZ1bmN0aW9uIGRlZXBFcXVhbChhMywgYjIpIHtcbiAgaWYgKGEzID09PSBiMilcbiAgICByZXR1cm4gITA7XG4gIGlmICh0eXBlb2YgYTMgIT0gdHlwZW9mIGIyKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHR5cGVvZiBhMyA9PSBcImZ1bmN0aW9uXCIgJiYgYTMudG9TdHJpbmcoKSA9PT0gYjIudG9TdHJpbmcoKSlcbiAgICByZXR1cm4gITA7XG4gIGxldCBsZW5ndGgsIGkyLCBrZXlzO1xuICBpZiAoYTMgJiYgYjIgJiYgdHlwZW9mIGEzID09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhMykpIHtcbiAgICAgIGlmIChsZW5ndGggPSBhMy5sZW5ndGgsIGxlbmd0aCAhPT0gYjIubGVuZ3RoKSByZXR1cm4gITE7XG4gICAgICBmb3IgKGkyID0gbGVuZ3RoOyBpMi0tICE9PSAwOyApXG4gICAgICAgIGlmICghZGVlcEVxdWFsKGEzW2kyXSwgYjJbaTJdKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIGlmIChrZXlzID0gT2JqZWN0LmtleXMoYTMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aCwgbGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiMikubGVuZ3RoKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoaTIgPSBsZW5ndGg7IGkyLS0gIT09IDA7IClcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiMiwga2V5c1tpMl0pKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgZm9yIChpMiA9IGxlbmd0aDsgaTItLSAhPT0gMDsgKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2kyXTtcbiAgICAgIGlmICghKGtleSA9PT0gXCJfb3duZXJcIiAmJiBhMy4kJHR5cGVvZikgJiYgIWRlZXBFcXVhbChhM1trZXldLCBiMltrZXldKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuIGEzICE9PSBhMyAmJiBiMiAhPT0gYjI7XG59XG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA+IFwidVwiID8gMSA6IChlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93KS5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5mdW5jdGlvbiByb3VuZEJ5RFBSKGVsZW1lbnQsIHZhbHVlKSB7XG4gIGNvbnN0IGRwciA9IGdldERQUihlbGVtZW50KTtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBkcHIpIC8gZHByO1xufVxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIHJldHVybiBpbmRleCQxKCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KSwgcmVmO1xufVxuZnVuY3Rpb24gdXNlRmxvYXRpbmckMShvcHRpb25zKSB7XG4gIG9wdGlvbnMgPT09IHZvaWQgMCAmJiAob3B0aW9ucyA9IHt9KTtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9IFwiYm90dG9tXCIsXG4gICAgc3RyYXRlZ3kgPSBcImFic29sdXRlXCIsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtOiBwbGF0Zm9ybTIsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSAhMCxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZCxcbiAgICBvcGVuXG4gIH0gPSBvcHRpb25zLCBbZGF0YSwgc2V0RGF0YV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0cmF0ZWd5LFxuICAgIHBsYWNlbWVudCxcbiAgICBtaWRkbGV3YXJlRGF0YToge30sXG4gICAgaXNQb3NpdGlvbmVkOiAhMVxuICB9KSwgW2xhdGVzdE1pZGRsZXdhcmUsIHNldExhdGVzdE1pZGRsZXdhcmVdID0gUmVhY3QudXNlU3RhdGUobWlkZGxld2FyZSk7XG4gIGRlZXBFcXVhbChsYXRlc3RNaWRkbGV3YXJlLCBtaWRkbGV3YXJlKSB8fCBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICBjb25zdCBbX3JlZmVyZW5jZSwgX3NldFJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKSwgW19mbG9hdGluZywgX3NldEZsb2F0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpLCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjaygobm9kZSkgPT4ge1xuICAgIG5vZGUgIT09IHJlZmVyZW5jZVJlZi5jdXJyZW50ICYmIChyZWZlcmVuY2VSZWYuY3VycmVudCA9IG5vZGUsIF9zZXRSZWZlcmVuY2Uobm9kZSkpO1xuICB9LCBbXSksIHNldEZsb2F0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2soKG5vZGUpID0+IHtcbiAgICBub2RlICE9PSBmbG9hdGluZ1JlZi5jdXJyZW50ICYmIChmbG9hdGluZ1JlZi5jdXJyZW50ID0gbm9kZSwgX3NldEZsb2F0aW5nKG5vZGUpKTtcbiAgfSwgW10pLCByZWZlcmVuY2VFbCA9IGV4dGVybmFsUmVmZXJlbmNlIHx8IF9yZWZlcmVuY2UsIGZsb2F0aW5nRWwgPSBleHRlcm5hbEZsb2F0aW5nIHx8IF9mbG9hdGluZywgcmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpLCBmbG9hdGluZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKSwgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZihkYXRhKSwgaGFzV2hpbGVFbGVtZW50c01vdW50ZWQgPSB3aGlsZUVsZW1lbnRzTW91bnRlZCAhPSBudWxsLCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiA9IHVzZUxhdGVzdFJlZih3aGlsZUVsZW1lbnRzTW91bnRlZCksIHBsYXRmb3JtUmVmID0gdXNlTGF0ZXN0UmVmKHBsYXRmb3JtMiksIG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYob3BlbiksIHVwZGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXJlZmVyZW5jZVJlZi5jdXJyZW50IHx8ICFmbG9hdGluZ1JlZi5jdXJyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbmZpZzIgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIHBsYXRmb3JtUmVmLmN1cnJlbnQgJiYgKGNvbmZpZzIucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50KSwgY29tcHV0ZVBvc2l0aW9uKHJlZmVyZW5jZVJlZi5jdXJyZW50LCBmbG9hdGluZ1JlZi5jdXJyZW50LCBjb25maWcyKS50aGVuKChkYXRhMikgPT4ge1xuICAgICAgY29uc3QgZnVsbERhdGEgPSB7XG4gICAgICAgIC4uLmRhdGEyLFxuICAgICAgICAvLyBUaGUgZmxvYXRpbmcgZWxlbWVudCdzIHBvc2l0aW9uIG1heSBiZSByZWNvbXB1dGVkIHdoaWxlIGl0J3MgY2xvc2VkXG4gICAgICAgIC8vIGJ1dCBzdGlsbCBtb3VudGVkIChzdWNoIGFzIHdoZW4gdHJhbnNpdGlvbmluZyBvdXQpLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gXFxgaXNQb3NpdGlvbmVkXFxgIHdpbGwgYmUgXFxgZmFsc2VcXGAgaW5pdGlhbGx5IG9uIHRoZSBuZXh0IG9wZW4sIGF2b2lkXG4gICAgICAgIC8vIHNldHRpbmcgaXQgdG8gXFxgdHJ1ZVxcYCB3aGVuIFxcYG9wZW4gPT09IGZhbHNlXFxgIChtdXN0IGJlIHNwZWNpZmllZCkuXG4gICAgICAgIGlzUG9zaXRpb25lZDogb3BlblJlZi5jdXJyZW50ICE9PSAhMVxuICAgICAgfTtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFkZWVwRXF1YWwoZGF0YVJlZi5jdXJyZW50LCBmdWxsRGF0YSkgJiYgKGRhdGFSZWYuY3VycmVudCA9IGZ1bGxEYXRhLCBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICBzZXREYXRhKGZ1bGxEYXRhKTtcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSwgW2xhdGVzdE1pZGRsZXdhcmUsIHBsYWNlbWVudCwgc3RyYXRlZ3ksIHBsYXRmb3JtUmVmLCBvcGVuUmVmXSk7XG4gIGluZGV4JDEoKCkgPT4ge1xuICAgIG9wZW4gPT09ICExICYmIGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgJiYgKGRhdGFSZWYuY3VycmVudC5pc1Bvc2l0aW9uZWQgPSAhMSwgc2V0RGF0YSgoZGF0YTIpID0+ICh7XG4gICAgICAuLi5kYXRhMixcbiAgICAgIGlzUG9zaXRpb25lZDogITFcbiAgICB9KSkpO1xuICB9LCBbb3Blbl0pO1xuICBjb25zdCBpc01vdW50ZWRSZWYgPSBSZWFjdC51c2VSZWYoITEpO1xuICBpbmRleCQxKCgpID0+IChpc01vdW50ZWRSZWYuY3VycmVudCA9ICEwLCAoKSA9PiB7XG4gICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSAhMTtcbiAgfSksIFtdKSwgaW5kZXgkMSgoKSA9PiB7XG4gICAgaWYgKHJlZmVyZW5jZUVsICYmIChyZWZlcmVuY2VSZWYuY3VycmVudCA9IHJlZmVyZW5jZUVsKSwgZmxvYXRpbmdFbCAmJiAoZmxvYXRpbmdSZWYuY3VycmVudCA9IGZsb2F0aW5nRWwpLCByZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudClcbiAgICAgICAgcmV0dXJuIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSk7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH0sIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlLCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiwgaGFzV2hpbGVFbGVtZW50c01vdW50ZWRdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZVJlZixcbiAgICBmbG9hdGluZzogZmxvYXRpbmdSZWYsXG4gICAgc2V0UmVmZXJlbmNlLFxuICAgIHNldEZsb2F0aW5nXG4gIH0pLCBbc2V0UmVmZXJlbmNlLCBzZXRGbG9hdGluZ10pLCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUVsLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ0VsXG4gIH0pLCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWxdKSwgZmxvYXRpbmdTdHlsZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgaWYgKCFlbGVtZW50cy5mbG9hdGluZylcbiAgICAgIHJldHVybiBpbml0aWFsU3R5bGVzO1xuICAgIGNvbnN0IHgyID0gcm91bmRCeURQUihlbGVtZW50cy5mbG9hdGluZywgZGF0YS54KSwgeTIgPSByb3VuZEJ5RFBSKGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLnkpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPyB7XG4gICAgICAuLi5pbml0aWFsU3R5bGVzLFxuICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHgyICsgXCJweCwgXCIgKyB5MiArIFwicHgpXCIsXG4gICAgICAuLi5nZXREUFIoZWxlbWVudHMuZmxvYXRpbmcpID49IDEuNSAmJiB7XG4gICAgICAgIHdpbGxDaGFuZ2U6IFwidHJhbnNmb3JtXCJcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeDIsXG4gICAgICB0b3A6IHkyXG4gICAgfTtcbiAgfSwgW3N0cmF0ZWd5LCB0cmFuc2Zvcm0sIGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngsIGRhdGEueV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLmRhdGEsXG4gICAgdXBkYXRlLFxuICAgIHJlZnMsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdTdHlsZXNcbiAgfSksIFtkYXRhLCB1cGRhdGUsIHJlZnMsIGVsZW1lbnRzLCBmbG9hdGluZ1N0eWxlc10pO1xufVxuY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLm9mZnNldCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pLCBzaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pLCBmbGlwID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmZsaXAkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KSwgc2l6ZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaXplJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG52YXIgZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQgPSB7fTtcbmNvbnN0IFNhZmVSZWFjdCA9IHtcbiAgLi4uUmVhY3Rcbn0sIHVzZUluc2VydGlvbkVmZmVjdCA9IFNhZmVSZWFjdC51c2VJbnNlcnRpb25FZmZlY3QsIHVzZVNhZmVJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3QgfHwgKChmbikgPT4gZm4oKSk7XG5mdW5jdGlvbiB1c2VFZmZlY3RFdmVudChjYWxsYmFjaykge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoKCkgPT4ge1xuICAgIGlmIChkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdC5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY2FsbCBhbiBldmVudCBoYW5kbGVyIHdoaWxlIHJlbmRlcmluZy5cIik7XG4gIH0pO1xuICByZXR1cm4gdXNlU2FmZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSBjYWxsYmFjaztcbiAgfSksIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKylcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxudmFyIGluZGV4ID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5sZXQgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gITEsIGNvdW50ID0gMDtcbmNvbnN0IGdlbklkID0gKCkgPT4gKFxuICAvLyBFbnN1cmUgdGhlIGlkIGlzIHVuaXF1ZSB3aXRoIG11bHRpcGxlIGluZGVwZW5kZW50IHZlcnNpb25zIG9mIEZsb2F0aW5nIFVJXG4gIC8vIG9uIDxSZWFjdCAxOFxuICBcImZsb2F0aW5nLXVpLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgNikgKyBjb3VudCsrXG4pO1xuZnVuY3Rpb24gdXNlRmxvYXRpbmdJZCgpIHtcbiAgY29uc3QgW2lkLCBzZXRJZF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPyBnZW5JZCgpIDogdm9pZCAwKTtcbiAgcmV0dXJuIGluZGV4KCgpID0+IHtcbiAgICBpZCA9PSBudWxsICYmIHNldElkKGdlbklkKCkpO1xuICB9LCBbXSksIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2VydmVySGFuZG9mZkNvbXBsZXRlID0gITA7XG4gIH0sIFtdKSwgaWQ7XG59XG5jb25zdCB1c2VSZWFjdElkID0gU2FmZVJlYWN0LnVzZUlkLCB1c2VJZCA9IHVzZVJlYWN0SWQgfHwgdXNlRmxvYXRpbmdJZDtcbmxldCBkZXZNZXNzYWdlU2V0O1xuZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChkZXZNZXNzYWdlU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG5mdW5jdGlvbiB3YXJuKCkge1xuICBmb3IgKHZhciBfZGV2TWVzc2FnZVNldCwgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2VzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKylcbiAgICBtZXNzYWdlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbihcIiBcIik7XG4gIGlmICghKChfZGV2TWVzc2FnZVNldCA9IGRldk1lc3NhZ2VTZXQpICE9IG51bGwgJiYgX2Rldk1lc3NhZ2VTZXQuaGFzKG1lc3NhZ2UpKSkge1xuICAgIHZhciBfZGV2TWVzc2FnZVNldDI7XG4gICAgKF9kZXZNZXNzYWdlU2V0MiA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQyLmFkZChtZXNzYWdlKSwgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgZm9yICh2YXIgX2Rldk1lc3NhZ2VTZXQzLCBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1lc3NhZ2VzID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKVxuICAgIG1lc3NhZ2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIGNvbnN0IG1lc3NhZ2UgPSBcIkZsb2F0aW5nIFVJOiBcIiArIG1lc3NhZ2VzLmpvaW4oXCIgXCIpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQzID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldDMuaGFzKG1lc3NhZ2UpKSkge1xuICAgIHZhciBfZGV2TWVzc2FnZVNldDQ7XG4gICAgKF9kZXZNZXNzYWdlU2V0NCA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQ0LmFkZChtZXNzYWdlKSwgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHViU3ViKCkge1xuICBjb25zdCBtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4ge1xuICAgIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9tYXAkZ2V0LmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIoZGF0YSkpO1xuICAgIH0sXG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICBtYXAuc2V0KGV2ZW50LCBbLi4ubWFwLmdldChldmVudCkgfHwgW10sIGxpc3RlbmVyXSk7XG4gICAgfSxcbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgbWFwLnNldChldmVudCwgKChfbWFwJGdldDIgPSBtYXAuZ2V0KGV2ZW50KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5maWx0ZXIoKGwyKSA9PiBsMiAhPT0gbGlzdGVuZXIpKSB8fCBbXSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpLCBGbG9hdGluZ1RyZWVDb250ZXh0ID0gLyogQF9fUFVSRV9fICovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCksIHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufSwgdXNlRmxvYXRpbmdUcmVlID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ1RyZWVDb250ZXh0KSwgRk9DVVNBQkxFX0FUVFJJQlVURSA9IFwiZGF0YS1mbG9hdGluZy11aS1mb2N1c2FibGVcIjtcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nUm9vdENvbnRleHQob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgb3BlbiA9ICExLFxuICAgIG9uT3BlbkNoYW5nZTogb25PcGVuQ2hhbmdlUHJvcCxcbiAgICBlbGVtZW50czogZWxlbWVudHNQcm9wXG4gIH0gPSBvcHRpb25zLCBmbG9hdGluZ0lkID0gdXNlSWQoKSwgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZih7fSksIFtldmVudHNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gY3JlYXRlUHViU3ViKCkpLCBuZXN0ZWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpICE9IG51bGw7XG4gIGlmIChkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdC5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBvcHRpb25Eb21SZWZlcmVuY2UgPSBlbGVtZW50c1Byb3AucmVmZXJlbmNlO1xuICAgIG9wdGlvbkRvbVJlZmVyZW5jZSAmJiAhaXNFbGVtZW50JDEob3B0aW9uRG9tUmVmZXJlbmNlKSAmJiBlcnJvcihcIkNhbm5vdCBwYXNzIGEgdmlydHVhbCBlbGVtZW50IHRvIHRoZSBcXGBlbGVtZW50cy5yZWZlcmVuY2VcXGAgb3B0aW9uLFwiLCBcImFzIGl0IG11c3QgYmUgYSByZWFsIERPTSBlbGVtZW50LiBVc2UgXFxgcmVmcy5zZXRQb3NpdGlvblJlZmVyZW5jZSgpXFxgXCIsIFwiaW5zdGVhZC5cIik7XG4gIH1cbiAgY29uc3QgW3Bvc2l0aW9uUmVmZXJlbmNlLCBzZXRQb3NpdGlvblJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShlbGVtZW50c1Byb3AucmVmZXJlbmNlKSwgb25PcGVuQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQoKG9wZW4yLCBldmVudCwgcmVhc29uKSA9PiB7XG4gICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IG9wZW4yID8gZXZlbnQgOiB2b2lkIDAsIGV2ZW50cy5lbWl0KFwib3BlbmNoYW5nZVwiLCB7XG4gICAgICBvcGVuOiBvcGVuMixcbiAgICAgIGV2ZW50LFxuICAgICAgcmVhc29uLFxuICAgICAgbmVzdGVkXG4gICAgfSksIG9uT3BlbkNoYW5nZVByb3AgPT0gbnVsbCB8fCBvbk9wZW5DaGFuZ2VQcm9wKG9wZW4yLCBldmVudCwgcmVhc29uKTtcbiAgfSksIHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgc2V0UG9zaXRpb25SZWZlcmVuY2VcbiAgfSksIFtdKSwgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgcmVmZXJlbmNlOiBwb3NpdGlvblJlZmVyZW5jZSB8fCBlbGVtZW50c1Byb3AucmVmZXJlbmNlIHx8IG51bGwsXG4gICAgZmxvYXRpbmc6IGVsZW1lbnRzUHJvcC5mbG9hdGluZyB8fCBudWxsLFxuICAgIGRvbVJlZmVyZW5jZTogZWxlbWVudHNQcm9wLnJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uUmVmZXJlbmNlLCBlbGVtZW50c1Byb3AucmVmZXJlbmNlLCBlbGVtZW50c1Byb3AuZmxvYXRpbmddKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBkYXRhUmVmLFxuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGVsZW1lbnRzLFxuICAgIGV2ZW50cyxcbiAgICBmbG9hdGluZ0lkLFxuICAgIHJlZnNcbiAgfSksIFtvcGVuLCBvbk9wZW5DaGFuZ2UsIGVsZW1lbnRzLCBldmVudHMsIGZsb2F0aW5nSWQsIHJlZnNdKTtcbn1cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nKG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9PT0gdm9pZCAwICYmIChvcHRpb25zID0ge30pO1xuICBjb25zdCB7XG4gICAgbm9kZUlkXG4gIH0gPSBvcHRpb25zLCBpbnRlcm5hbFJvb3RDb250ZXh0ID0gdXNlRmxvYXRpbmdSb290Q29udGV4dCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBlbGVtZW50czoge1xuICAgICAgcmVmZXJlbmNlOiBudWxsLFxuICAgICAgZmxvYXRpbmc6IG51bGwsXG4gICAgICAuLi5vcHRpb25zLmVsZW1lbnRzXG4gICAgfVxuICB9KSwgcm9vdENvbnRleHQgPSBvcHRpb25zLnJvb3RDb250ZXh0IHx8IGludGVybmFsUm9vdENvbnRleHQsIGNvbXB1dGVkRWxlbWVudHMgPSByb290Q29udGV4dC5lbGVtZW50cywgW19kb21SZWZlcmVuY2UsIHNldERvbVJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKSwgW3Bvc2l0aW9uUmVmZXJlbmNlLCBfc2V0UG9zaXRpb25SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUobnVsbCksIGRvbVJlZmVyZW5jZSA9IChjb21wdXRlZEVsZW1lbnRzID09IG51bGwgPyB2b2lkIDAgOiBjb21wdXRlZEVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgfHwgX2RvbVJlZmVyZW5jZSwgZG9tUmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpLCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBkb21SZWZlcmVuY2UgJiYgKGRvbVJlZmVyZW5jZVJlZi5jdXJyZW50ID0gZG9tUmVmZXJlbmNlKTtcbiAgfSwgW2RvbVJlZmVyZW5jZV0pO1xuICBjb25zdCBwb3NpdGlvbiA9IHVzZUZsb2F0aW5nJDEoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIC4uLmNvbXB1dGVkRWxlbWVudHMsXG4gICAgICAuLi5wb3NpdGlvblJlZmVyZW5jZSAmJiB7XG4gICAgICAgIHJlZmVyZW5jZTogcG9zaXRpb25SZWZlcmVuY2VcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKChub2RlKSA9PiB7XG4gICAgY29uc3QgY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSA9IGlzRWxlbWVudCQxKG5vZGUpID8ge1xuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiAoKSA9PiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICBfc2V0UG9zaXRpb25SZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSksIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKGNvbXB1dGVkUG9zaXRpb25SZWZlcmVuY2UpO1xuICB9LCBbcG9zaXRpb24ucmVmc10pLCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjaygobm9kZSkgPT4ge1xuICAgIChpc0VsZW1lbnQkMShub2RlKSB8fCBub2RlID09PSBudWxsKSAmJiAoZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlLCBzZXREb21SZWZlcmVuY2Uobm9kZSkpLCAoaXNFbGVtZW50JDEocG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCkgfHwgcG9zaXRpb24ucmVmcy5yZWZlcmVuY2UuY3VycmVudCA9PT0gbnVsbCB8fCAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIFxcYG51bGxcXGAgdG8gc3VwcG9ydCBcXGBwb3NpdGlvblJlZmVyZW5jZVxcYCArIGFuIHVuc3RhYmxlIFxcYHJlZmVyZW5jZVxcYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQkMShub2RlKSkgJiYgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2Uobm9kZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSksIHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24ucmVmcyxcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0UG9zaXRpb25SZWZlcmVuY2UsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VSZWZcbiAgfSksIFtwb3NpdGlvbi5yZWZzLCBzZXRSZWZlcmVuY2UsIHNldFBvc2l0aW9uUmVmZXJlbmNlXSksIGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLmVsZW1lbnRzLFxuICAgIGRvbVJlZmVyZW5jZVxuICB9KSwgW3Bvc2l0aW9uLmVsZW1lbnRzLCBkb21SZWZlcmVuY2VdKSwgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbixcbiAgICAuLi5yb290Q29udGV4dCxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIG5vZGVJZFxuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgbm9kZUlkLCByb290Q29udGV4dF0pO1xuICByZXR1cm4gaW5kZXgoKCkgPT4ge1xuICAgIHJvb3RDb250ZXh0LmRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQgPSBjb250ZXh0O1xuICAgIGNvbnN0IG5vZGUgPSB0cmVlID09IG51bGwgPyB2b2lkIDAgOiB0cmVlLm5vZGVzUmVmLmN1cnJlbnQuZmluZCgobm9kZTIpID0+IG5vZGUyLmlkID09PSBub2RlSWQpO1xuICAgIG5vZGUgJiYgKG5vZGUuY29udGV4dCA9IGNvbnRleHQpO1xuICB9KSwgUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIC4uLnBvc2l0aW9uLFxuICAgIGNvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50c1xuICB9KSwgW3Bvc2l0aW9uLCByZWZzLCBlbGVtZW50cywgY29udGV4dF0pO1xufVxuY29uc3QgQUNUSVZFX0tFWSA9IFwiYWN0aXZlXCIsIFNFTEVDVEVEX0tFWSA9IFwic2VsZWN0ZWRcIjtcbmZ1bmN0aW9uIG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsIGVsZW1lbnRLZXkpIHtcbiAgY29uc3QgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgaXNJdGVtID0gZWxlbWVudEtleSA9PT0gXCJpdGVtXCI7XG4gIGxldCBkb21Vc2VyUHJvcHMgPSB1c2VyUHJvcHM7XG4gIGlmIChpc0l0ZW0gJiYgdXNlclByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgW0FDVElWRV9LRVldOiBfMixcbiAgICAgIFtTRUxFQ1RFRF9LRVldOiBfXyxcbiAgICAgIC4uLnZhbGlkUHJvcHNcbiAgICB9ID0gdXNlclByb3BzO1xuICAgIGRvbVVzZXJQcm9wcyA9IHZhbGlkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi5lbGVtZW50S2V5ID09PSBcImZsb2F0aW5nXCIgJiYge1xuICAgICAgdGFiSW5kZXg6IC0xLFxuICAgICAgW0ZPQ1VTQUJMRV9BVFRSSUJVVEVdOiBcIlwiXG4gICAgfSxcbiAgICAuLi5kb21Vc2VyUHJvcHMsXG4gICAgLi4ucHJvcHNMaXN0Lm1hcCgodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzT3JHZXRQcm9wcyA9IHZhbHVlID8gdmFsdWVbZWxlbWVudEtleV0gOiBudWxsO1xuICAgICAgcmV0dXJuIHR5cGVvZiBwcm9wc09yR2V0UHJvcHMgPT0gXCJmdW5jdGlvblwiID8gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsIDogcHJvcHNPckdldFByb3BzO1xuICAgIH0pLmNvbmNhdCh1c2VyUHJvcHMpLnJlZHVjZSgoYWNjLCBwcm9wcykgPT4gKHByb3BzICYmIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKChfcmVmKSA9PiB7XG4gICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgIGlmICghKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSlcbiAgICAgICAgaWYgKGtleS5pbmRleE9mKFwib25cIikgPT09IDApIHtcbiAgICAgICAgICBpZiAobWFwLmhhcyhrZXkpIHx8IG1hcC5zZXQoa2V5LCBbXSksIHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhciBfbWFwJGdldDtcbiAgICAgICAgICAgIChfbWFwJGdldCA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCB8fCBfbWFwJGdldC5wdXNoKHZhbHVlKSwgYWNjW2tleV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX21hcCRnZXQyLCBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspXG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgcmV0dXJuIChfbWFwJGdldDIgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgPyB2b2lkIDAgOiBfbWFwJGdldDIubWFwKChmbikgPT4gZm4oLi4uYXJncykpLmZpbmQoKHZhbCkgPT4gdmFsICE9PSB2b2lkIDApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgfSksIGFjYyksIHt9KVxuICB9O1xufVxuZnVuY3Rpb24gdXNlSW50ZXJhY3Rpb25zKHByb3BzTGlzdCkge1xuICBwcm9wc0xpc3QgPT09IHZvaWQgMCAmJiAocHJvcHNMaXN0ID0gW10pO1xuICBjb25zdCByZWZlcmVuY2VEZXBzID0gcHJvcHNMaXN0Lm1hcCgoa2V5KSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5yZWZlcmVuY2UpLCBmbG9hdGluZ0RlcHMgPSBwcm9wc0xpc3QubWFwKChrZXkpID0+IGtleSA9PSBudWxsID8gdm9pZCAwIDoga2V5LmZsb2F0aW5nKSwgaXRlbURlcHMgPSBwcm9wc0xpc3QubWFwKChrZXkpID0+IGtleSA9PSBudWxsID8gdm9pZCAwIDoga2V5Lml0ZW0pLCBnZXRSZWZlcmVuY2VQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh1c2VyUHJvcHMpID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsIFwicmVmZXJlbmNlXCIpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICByZWZlcmVuY2VEZXBzXG4gICksIGdldEZsb2F0aW5nUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodXNlclByb3BzKSA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBcImZsb2F0aW5nXCIpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBmbG9hdGluZ0RlcHNcbiAgKSwgZ2V0SXRlbVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKHVzZXJQcm9wcykgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgXCJpdGVtXCIpLFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBpdGVtRGVwc1xuICApO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGdldFJlZmVyZW5jZVByb3BzLFxuICAgIGdldEZsb2F0aW5nUHJvcHMsXG4gICAgZ2V0SXRlbVByb3BzXG4gIH0pLCBbZ2V0UmVmZXJlbmNlUHJvcHMsIGdldEZsb2F0aW5nUHJvcHMsIGdldEl0ZW1Qcm9wc10pO1xufVxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGlubmVyID0gKHByb3BzKSA9PiAoe1xuICBuYW1lOiBcImlubmVyXCIsXG4gIG9wdGlvbnM6IHByb3BzLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4OiBpbmRleDIgPSAwLFxuICAgICAgbWluSXRlbXNWaXNpYmxlID0gNCxcbiAgICAgIHJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkID0gMCxcbiAgICAgIHNjcm9sbFJlZixcbiAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgIH0gPSBldmFsdWF0ZSQxKHByb3BzLCBzdGF0ZSksIHtcbiAgICAgIHJlY3RzLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9ID0gc3RhdGUsIGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXgyXSwgc2Nyb2xsRWwgPSAoc2Nyb2xsUmVmID09IG51bGwgPyB2b2lkIDAgOiBzY3JvbGxSZWYuY3VycmVudCkgfHwgZmxvYXRpbmcsIGNsaWVudFRvcCA9IGZsb2F0aW5nLmNsaWVudFRvcCB8fCBzY3JvbGxFbC5jbGllbnRUb3AsIGZsb2F0aW5nSXNCb3JkZXJlZCA9IGZsb2F0aW5nLmNsaWVudFRvcCAhPT0gMCwgc2Nyb2xsRWxJc0JvcmRlcmVkID0gc2Nyb2xsRWwuY2xpZW50VG9wICE9PSAwLCBmbG9hdGluZ0lzU2Nyb2xsRWwgPSBmbG9hdGluZyA9PT0gc2Nyb2xsRWw7XG4gICAgaWYgKGRlZmluZV9wcm9jZXNzX2Vudl9kZWZhdWx0Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoXCJib3R0b21cIikgfHwgd2FybignXFxgcGxhY2VtZW50XFxgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlIFxcYGlubmVyXFxgJywgXCJtaWRkbGV3YXJlLlwiKSksICFpdGVtKVxuICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi5hd2FpdCBvZmZzZXQoLWl0ZW0ub2Zmc2V0VG9wIC0gZmxvYXRpbmcuY2xpZW50VG9wIC0gcmVjdHMucmVmZXJlbmNlLmhlaWdodCAvIDIgLSBpdGVtLm9mZnNldEhlaWdodCAvIDIgLSBpbm5lck9mZnNldCkuZm4oc3RhdGUpXG4gICAgfSwgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhnZXRBcmdzV2l0aEN1c3RvbUZsb2F0aW5nSGVpZ2h0KG5leHRBcmdzLCBzY3JvbGxFbC5zY3JvbGxIZWlnaHQgKyBjbGllbnRUb3AgKyBmbG9hdGluZy5jbGllbnRUb3ApLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpLCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogXCJyZWZlcmVuY2VcIlxuICAgIH0pLCBkaWZmWSA9IG1heCQxKDAsIG92ZXJmbG93LnRvcCksIG5leHRZID0gbmV4dEFyZ3MueSArIGRpZmZZLCBtYXhIZWlnaHQgPSAoc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ID4gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0ID8gKHYyKSA9PiB2MiA6IHJvdW5kJDEpKG1heCQxKDAsIHNjcm9sbEVsLnNjcm9sbEhlaWdodCArIChmbG9hdGluZ0lzQm9yZGVyZWQgJiYgZmxvYXRpbmdJc1Njcm9sbEVsIHx8IHNjcm9sbEVsSXNCb3JkZXJlZCA/IGNsaWVudFRvcCAqIDIgOiAwKSAtIGRpZmZZIC0gbWF4JDEoMCwgb3ZlcmZsb3cuYm90dG9tKSkpO1xuICAgIGlmIChzY3JvbGxFbC5zdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCIsIHNjcm9sbEVsLnNjcm9sbFRvcCA9IGRpZmZZLCBvbkZhbGxiYWNrQ2hhbmdlKSB7XG4gICAgICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHNjcm9sbEVsLm9mZnNldEhlaWdodCA8IGl0ZW0ub2Zmc2V0SGVpZ2h0ICogbWluJDEobWluSXRlbXNWaXNpYmxlLCBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkO1xuICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uRmFsbGJhY2tDaGFuZ2Uoc2hvdWxkRmFsbGJhY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIG92ZXJmbG93UmVmICYmIChvdmVyZmxvd1JlZi5jdXJyZW50ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCh7XG4gICAgICAuLi5uZXh0QXJncyxcbiAgICAgIHk6IG5leHRZXG4gICAgfSwgc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKSksIHtcbiAgICAgIHk6IG5leHRZXG4gICAgfTtcbiAgfVxufSk7XG5mdW5jdGlvbiB1c2VJbm5lck9mZnNldChjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dCwge1xuICAgIGVuYWJsZWQgPSAhMCxcbiAgICBvdmVyZmxvd1JlZixcbiAgICBzY3JvbGxSZWYsXG4gICAgb25DaGFuZ2U6IHVuc3RhYmxlX29uQ2hhbmdlXG4gIH0gPSBwcm9wcywgb25DaGFuZ2UgPSB1c2VFZmZlY3RFdmVudCh1bnN0YWJsZV9vbkNoYW5nZSksIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYgPSBSZWFjdC51c2VSZWYoITEpLCBwcmV2U2Nyb2xsVG9wUmVmID0gUmVhY3QudXNlUmVmKG51bGwpLCBpbml0aWFsT3ZlcmZsb3dSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25XaGVlbChlMikge1xuICAgICAgaWYgKGUyLmN0cmxLZXkgfHwgIWVsIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZFkgPSBlMi5kZWx0YVksIGlzQXRUb3AgPSBvdmVyZmxvd1JlZi5jdXJyZW50LnRvcCA+PSAtMC41LCBpc0F0Qm90dG9tID0gb3ZlcmZsb3dSZWYuY3VycmVudC5ib3R0b20gPj0gLTAuNSwgcmVtYWluaW5nU2Nyb2xsID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0LCBzaWduID0gZFkgPCAwID8gLTEgOiAxLCBtZXRob2QgPSBkWSA8IDAgPyBcIm1heFwiIDogXCJtaW5cIjtcbiAgICAgIGVsLnNjcm9sbEhlaWdodCA8PSBlbC5jbGllbnRIZWlnaHQgfHwgKCFpc0F0VG9wICYmIGRZID4gMCB8fCAhaXNBdEJvdHRvbSAmJiBkWSA8IDAgPyAoZTIucHJldmVudERlZmF1bHQoKSwgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IHtcbiAgICAgICAgb25DaGFuZ2UoKGQyKSA9PiBkMiArIE1hdGhbbWV0aG9kXShkWSwgcmVtYWluaW5nU2Nyb2xsICogc2lnbikpO1xuICAgICAgfSkpIDogL2ZpcmVmb3gvaS50ZXN0KGdldFVzZXJBZ2VudCgpKSAmJiAoZWwuc2Nyb2xsVG9wICs9IGRZKSk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGlmIChvcGVuICYmIGVsKVxuICAgICAgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBvbldoZWVsKSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50ID0gZWwuc2Nyb2xsVG9wLCBvdmVyZmxvd1JlZi5jdXJyZW50ICE9IG51bGwgJiYgKGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0ge1xuICAgICAgICAgIC4uLm92ZXJmbG93UmVmLmN1cnJlbnRcbiAgICAgICAgfSk7XG4gICAgICB9KSwgKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBudWxsLCBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IG51bGwsIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBvbldoZWVsKTtcbiAgICAgIH07XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgb3ZlcmZsb3dSZWYsIHNjcm9sbFJlZiwgb25DaGFuZ2VdKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgb25LZXlEb3duKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gITA7XG4gICAgfSxcbiAgICBvbldoZWVsKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gITE7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gITE7XG4gICAgfSxcbiAgICBvblNjcm9sbCgpIHtcbiAgICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgaWYgKCEoIW92ZXJmbG93UmVmLmN1cnJlbnQgfHwgIWVsIHx8ICFjb250cm9sbGVkU2Nyb2xsaW5nUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBzY3JvbGxEaWZmID0gZWwuc2Nyb2xsVG9wIC0gcHJldlNjcm9sbFRvcFJlZi5jdXJyZW50O1xuICAgICAgICAgIChvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA8IC0wLjUgJiYgc2Nyb2xsRGlmZiA8IC0xIHx8IG92ZXJmbG93UmVmLmN1cnJlbnQudG9wIDwgLTAuNSAmJiBzY3JvbGxEaWZmID4gMSkgJiYgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKChkMikgPT4gZDIgKyBzY3JvbGxEaWZmKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSksIFtlbGVtZW50cy5mbG9hdGluZywgb25DaGFuZ2UsIG92ZXJmbG93UmVmLCBzY3JvbGxSZWZdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICBmbG9hdGluZ1xuICB9IDoge30sIFtlbmFibGVkLCBmbG9hdGluZ10pO1xufVxubGV0IHkkMSA9IGNyZWF0ZUNvbnRleHQoeyBzdHlsZXM6IHZvaWQgMCwgc2V0UmVmZXJlbmNlOiAoKSA9PiB7XG59LCBzZXRGbG9hdGluZzogKCkgPT4ge1xufSwgZ2V0UmVmZXJlbmNlUHJvcHM6ICgpID0+ICh7fSksIGdldEZsb2F0aW5nUHJvcHM6ICgpID0+ICh7fSksIHNsb3Q6IHt9IH0pO1xueSQxLmRpc3BsYXlOYW1lID0gXCJGbG9hdGluZ0NvbnRleHRcIjtcbmxldCBIJDIgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuSCQyLmRpc3BsYXlOYW1lID0gXCJQbGFjZW1lbnRDb250ZXh0XCI7XG5mdW5jdGlvbiB4ZShlMikge1xuICByZXR1cm4gdXNlTWVtbygoKSA9PiBlMiA/IHR5cGVvZiBlMiA9PSBcInN0cmluZ1wiID8geyB0bzogZTIgfSA6IGUyIDogbnVsbCwgW2UyXSk7XG59XG5mdW5jdGlvbiB5ZSgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoeSQxKS5zZXRSZWZlcmVuY2U7XG59XG5mdW5jdGlvbiBGZSgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoeSQxKS5nZXRSZWZlcmVuY2VQcm9wcztcbn1cbmZ1bmN0aW9uIGJlKCkge1xuICBsZXQgeyBnZXRGbG9hdGluZ1Byb3BzOiBlMiwgc2xvdDogdDIgfSA9IHVzZUNvbnRleHQoeSQxKTtcbiAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5uMikgPT4gT2JqZWN0LmFzc2lnbih7fSwgZTIoLi4ubjIpLCB7IFwiZGF0YS1hbmNob3JcIjogdDIuYW5jaG9yIH0pLCBbZTIsIHQyXSk7XG59XG5mdW5jdGlvbiBSZShlMiA9IG51bGwpIHtcbiAgZTIgPT09ICExICYmIChlMiA9IG51bGwpLCB0eXBlb2YgZTIgPT0gXCJzdHJpbmdcIiAmJiAoZTIgPSB7IHRvOiBlMiB9KTtcbiAgbGV0IHQyID0gdXNlQ29udGV4dChIJDIpLCBuMiA9IHVzZU1lbW8oKCkgPT4gZTIsIFtKU09OLnN0cmluZ2lmeShlMiwgKHIyLCBvMykgPT4ge1xuICAgIHZhciB1MjtcbiAgICByZXR1cm4gKHUyID0gbzMgPT0gbnVsbCA/IHZvaWQgMCA6IG8zLm91dGVySFRNTCkgIT0gbnVsbCA/IHUyIDogbzM7XG4gIH0pXSk7XG4gIG4kMygoKSA9PiB7XG4gICAgdDIgPT0gbnVsbCB8fCB0MihuMiA/PyBudWxsKTtcbiAgfSwgW3QyLCBuMl0pO1xuICBsZXQgbDIgPSB1c2VDb250ZXh0KHkkMSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IFtsMi5zZXRGbG9hdGluZywgZTIgPyBsMi5zdHlsZXMgOiB7fV0sIFtsMi5zZXRGbG9hdGluZywgZTIsIGwyLnN0eWxlc10pO1xufVxubGV0IHEgPSA0O1xuZnVuY3Rpb24gTWUoeyBjaGlsZHJlbjogZTIsIGVuYWJsZWQ6IHQyID0gITAgfSkge1xuICBsZXQgW24yLCBsMl0gPSB1c2VTdGF0ZShudWxsKSwgW3IyLCBvM10gPSB1c2VTdGF0ZSgwKSwgdTIgPSB1c2VSZWYobnVsbCksIFtmMiwgczJdID0gdXNlU3RhdGUobnVsbCk7XG4gIHBlKGYyKTtcbiAgbGV0IGkyID0gdDIgJiYgbjIgIT09IG51bGwgJiYgZjIgIT09IG51bGwsIHsgdG86IEYyID0gXCJib3R0b21cIiwgZ2FwOiBFMiA9IDAsIG9mZnNldDogdjIgPSAwLCBwYWRkaW5nOiBjMiA9IDAsIGlubmVyOiBQMiB9ID0gY2UobjIsIGYyKSwgW2EzLCBwMiA9IFwiY2VudGVyXCJdID0gRjIuc3BsaXQoXCIgXCIpO1xuICBuJDMoKCkgPT4ge1xuICAgIGkyICYmIG8zKDApO1xuICB9LCBbaTJdKTtcbiAgbGV0IHsgcmVmczogYjIsIGZsb2F0aW5nU3R5bGVzOiB3MiwgY29udGV4dDogZzIgfSA9IHVzZUZsb2F0aW5nKHsgb3BlbjogaTIsIHBsYWNlbWVudDogYTMgPT09IFwic2VsZWN0aW9uXCIgPyBwMiA9PT0gXCJjZW50ZXJcIiA/IFwiYm90dG9tXCIgOiBcXGBib3R0b20tXFwke3AyfVxcYCA6IHAyID09PSBcImNlbnRlclwiID8gXFxgXFwke2EzfVxcYCA6IFxcYFxcJHthM30tXFwke3AyfVxcYCwgc3RyYXRlZ3k6IFwiYWJzb2x1dGVcIiwgdHJhbnNmb3JtOiAhMSwgbWlkZGxld2FyZTogW29mZnNldCh7IG1haW5BeGlzOiBhMyA9PT0gXCJzZWxlY3Rpb25cIiA/IDAgOiBFMiwgY3Jvc3NBeGlzOiB2MiB9KSwgc2hpZnQoeyBwYWRkaW5nOiBjMiB9KSwgYTMgIT09IFwic2VsZWN0aW9uXCIgJiYgZmxpcCh7IHBhZGRpbmc6IGMyIH0pLCBhMyA9PT0gXCJzZWxlY3Rpb25cIiAmJiBQMiA/IGlubmVyKHsgLi4uUDIsIHBhZGRpbmc6IGMyLCBvdmVyZmxvd1JlZjogdTIsIG9mZnNldDogcjIsIG1pbkl0ZW1zVmlzaWJsZTogcSwgcmVmZXJlbmNlT3ZlcmZsb3dUaHJlc2hvbGQ6IGMyLCBvbkZhbGxiYWNrQ2hhbmdlKGgyKSB7XG4gICAgdmFyIE8yLCBXO1xuICAgIGlmICghaDIpIHJldHVybjtcbiAgICBsZXQgZDIgPSBnMi5lbGVtZW50cy5mbG9hdGluZztcbiAgICBpZiAoIWQyKSByZXR1cm47XG4gICAgbGV0IFQyID0gcGFyc2VGbG9hdChnZXRDb21wdXRlZFN0eWxlKGQyKS5zY3JvbGxQYWRkaW5nQm90dG9tKSB8fCAwLCAkMiA9IE1hdGgubWluKHEsIGQyLmNoaWxkRWxlbWVudENvdW50KSwgTDIgPSAwLCBOMiA9IDA7XG4gICAgZm9yIChsZXQgbTIgb2YgKFcgPSAoTzIgPSBnMi5lbGVtZW50cy5mbG9hdGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IE8yLmNoaWxkTm9kZXMpICE9IG51bGwgPyBXIDogW10pIGlmIChtMiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICBsZXQgeDIgPSBtMi5vZmZzZXRUb3AsIGsyID0geDIgKyBtMi5jbGllbnRIZWlnaHQgKyBUMiwgUzIgPSBkMi5zY3JvbGxUb3AsIFUyID0gUzIgKyBkMi5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAoeDIgPj0gUzIgJiYgazIgPD0gVTIpICQyLS07XG4gICAgICBlbHNlIHtcbiAgICAgICAgTjIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihrMiwgVTIpIC0gTWF0aC5tYXgoeDIsIFMyKSksIEwyID0gbTIuY2xpZW50SGVpZ2h0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgJDIgPj0gMSAmJiBvMygobTIpID0+IHtcbiAgICAgIGxldCB4MiA9IEwyICogJDIgLSBOMiArIFQyO1xuICAgICAgcmV0dXJuIG0yID49IHgyID8gbTIgOiB4MjtcbiAgICB9KTtcbiAgfSB9KSA6IG51bGwsIHNpemUoeyBwYWRkaW5nOiBjMiwgYXBwbHkoeyBhdmFpbGFibGVXaWR0aDogaDIsIGF2YWlsYWJsZUhlaWdodDogZDIsIGVsZW1lbnRzOiBUMiB9KSB7XG4gICAgT2JqZWN0LmFzc2lnbihUMi5mbG9hdGluZy5zdHlsZSwgeyBvdmVyZmxvdzogXCJhdXRvXCIsIG1heFdpZHRoOiBcXGBcXCR7aDJ9cHhcXGAsIG1heEhlaWdodDogXFxgbWluKHZhcigtLWFuY2hvci1tYXgtaGVpZ2h0LCAxMDB2aCksIFxcJHtkMn1weClcXGAgfSk7XG4gIH0gfSldLmZpbHRlcihCb29sZWFuKSwgd2hpbGVFbGVtZW50c01vdW50ZWQ6IGF1dG9VcGRhdGUgfSksIFtJMiA9IGEzLCBCMiA9IHAyXSA9IGcyLnBsYWNlbWVudC5zcGxpdChcIi1cIik7XG4gIGEzID09PSBcInNlbGVjdGlvblwiICYmIChJMiA9IFwic2VsZWN0aW9uXCIpO1xuICBsZXQgRzIgPSB1c2VNZW1vKCgpID0+ICh7IGFuY2hvcjogW0kyLCBCMl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpIH0pLCBbSTIsIEIyXSksIEsyID0gdXNlSW5uZXJPZmZzZXQoZzIsIHsgb3ZlcmZsb3dSZWY6IHUyLCBvbkNoYW5nZTogbzMgfSksIHsgZ2V0UmVmZXJlbmNlUHJvcHM6IFEsIGdldEZsb2F0aW5nUHJvcHM6IFgyIH0gPSB1c2VJbnRlcmFjdGlvbnMoW0syXSksIFkgPSBvJDQoKGgyKSA9PiB7XG4gICAgczIoaDIpLCBiMi5zZXRGbG9hdGluZyhoMik7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChIJDIuUHJvdmlkZXIsIHsgdmFsdWU6IGwyIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoeSQxLlByb3ZpZGVyLCB7IHZhbHVlOiB7IHNldEZsb2F0aW5nOiBZLCBzZXRSZWZlcmVuY2U6IGIyLnNldFJlZmVyZW5jZSwgc3R5bGVzOiB3MiwgZ2V0UmVmZXJlbmNlUHJvcHM6IFEsIGdldEZsb2F0aW5nUHJvcHM6IFgyLCBzbG90OiBHMiB9IH0sIGUyKSk7XG59XG5mdW5jdGlvbiBwZShlMikge1xuICBuJDMoKCkgPT4ge1xuICAgIGlmICghZTIpIHJldHVybjtcbiAgICBsZXQgdDIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICBsZXQgbjIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlMikubWF4SGVpZ2h0LCBsMiA9IHBhcnNlRmxvYXQobjIpO1xuICAgICAgaWYgKGlzTmFOKGwyKSkgcmV0dXJuO1xuICAgICAgbGV0IHIyID0gcGFyc2VJbnQobjIpO1xuICAgICAgaXNOYU4ocjIpIHx8IGwyICE9PSByMiAmJiAoZTIuc3R5bGUubWF4SGVpZ2h0ID0gXFxgXFwke01hdGguY2VpbChsMil9cHhcXGApO1xuICAgIH0pO1xuICAgIHJldHVybiB0Mi5vYnNlcnZlKGUyLCB7IGF0dHJpYnV0ZXM6ICEwLCBhdHRyaWJ1dGVGaWx0ZXI6IFtcInN0eWxlXCJdIH0pLCAoKSA9PiB7XG4gICAgICB0Mi5kaXNjb25uZWN0KCk7XG4gICAgfTtcbiAgfSwgW2UyXSk7XG59XG5mdW5jdGlvbiBjZShlMiwgdDIpIHtcbiAgdmFyIG8zLCB1MiwgZjI7XG4gIGxldCBuMiA9IFYoKG8zID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLmdhcCkgIT0gbnVsbCA/IG8zIDogXCJ2YXIoLS1hbmNob3ItZ2FwLCAwKVwiLCB0MiksIGwyID0gVigodTIgPSBlMiA9PSBudWxsID8gdm9pZCAwIDogZTIub2Zmc2V0KSAhPSBudWxsID8gdTIgOiBcInZhcigtLWFuY2hvci1vZmZzZXQsIDApXCIsIHQyKSwgcjIgPSBWKChmMiA9IGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi5wYWRkaW5nKSAhPSBudWxsID8gZjIgOiBcInZhcigtLWFuY2hvci1wYWRkaW5nLCAwKVwiLCB0Mik7XG4gIHJldHVybiB7IC4uLmUyLCBnYXA6IG4yLCBvZmZzZXQ6IGwyLCBwYWRkaW5nOiByMiB9O1xufVxuZnVuY3Rpb24gVihlMiwgdDIsIG4yID0gdm9pZCAwKSB7XG4gIGxldCBsMiA9IHAkMigpLCByMiA9IG8kNCgoczIsIGkyKSA9PiB7XG4gICAgaWYgKHMyID09IG51bGwpIHJldHVybiBbbjIsIG51bGxdO1xuICAgIGlmICh0eXBlb2YgczIgPT0gXCJudW1iZXJcIikgcmV0dXJuIFtzMiwgbnVsbF07XG4gICAgaWYgKHR5cGVvZiBzMiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoIWkyKSByZXR1cm4gW24yLCBudWxsXTtcbiAgICAgIGxldCBGMiA9IEokMihzMiwgaTIpO1xuICAgICAgcmV0dXJuIFtGMiwgKEUyKSA9PiB7XG4gICAgICAgIGxldCB2MiA9IEQkMShzMik7XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgYzIgPSB2Mi5tYXAoKFAyKSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpMikuZ2V0UHJvcGVydHlWYWx1ZShQMikpO1xuICAgICAgICAgIGwyLnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBQMigpIHtcbiAgICAgICAgICAgIGwyLm5leHRGcmFtZShQMik7XG4gICAgICAgICAgICBsZXQgYTMgPSAhMTtcbiAgICAgICAgICAgIGZvciAobGV0IFtiMiwgdzJdIG9mIHYyLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICBsZXQgZzIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpMikuZ2V0UHJvcGVydHlWYWx1ZSh3Mik7XG4gICAgICAgICAgICAgIGlmIChjMltiMl0gIT09IGcyKSB7XG4gICAgICAgICAgICAgICAgYzJbYjJdID0gZzIsIGEzID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYTMpIHJldHVybjtcbiAgICAgICAgICAgIGxldCBwMiA9IEokMihzMiwgaTIpO1xuICAgICAgICAgICAgRjIgIT09IHAyICYmIChFMihwMiksIEYyID0gcDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsMi5kaXNwb3NlO1xuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbbjIsIG51bGxdO1xuICB9KSwgbzMgPSB1c2VNZW1vKCgpID0+IHIyKGUyLCB0MilbMF0sIFtlMiwgdDJdKSwgW3UyID0gbzMsIGYyXSA9IHVzZVN0YXRlKCk7XG4gIHJldHVybiBuJDMoKCkgPT4ge1xuICAgIGxldCBbczIsIGkyXSA9IHIyKGUyLCB0Mik7XG4gICAgaWYgKGYyKHMyKSwgISFpMikgcmV0dXJuIGkyKGYyKTtcbiAgfSwgW2UyLCB0Ml0pLCB1Mjtcbn1cbmZ1bmN0aW9uIEQkMShlMikge1xuICBsZXQgdDIgPSAvdmFyXFxcXCgoLiopXFxcXCkvLmV4ZWMoZTIpO1xuICBpZiAodDIpIHtcbiAgICBsZXQgbjIgPSB0MlsxXS5pbmRleE9mKFwiLFwiKTtcbiAgICBpZiAobjIgPT09IC0xKSByZXR1cm4gW3QyWzFdXTtcbiAgICBsZXQgbDIgPSB0MlsxXS5zbGljZSgwLCBuMikudHJpbSgpLCByMiA9IHQyWzFdLnNsaWNlKG4yICsgMSkudHJpbSgpO1xuICAgIHJldHVybiByMiA/IFtsMiwgLi4uRCQxKHIyKV0gOiBbbDJdO1xuICB9XG4gIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIEokMihlMiwgdDIpIHtcbiAgbGV0IG4yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgdDIuYXBwZW5kQ2hpbGQobjIpLCBuMi5zdHlsZS5zZXRQcm9wZXJ0eShcIm1hcmdpbi10b3BcIiwgXCIwcHhcIiwgXCJpbXBvcnRhbnRcIiksIG4yLnN0eWxlLnNldFByb3BlcnR5KFwibWFyZ2luLXRvcFwiLCBlMiwgXCJpbXBvcnRhbnRcIik7XG4gIGxldCBsMiA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUobjIpLm1hcmdpblRvcCkgfHwgMDtcbiAgcmV0dXJuIHQyLnJlbW92ZUNoaWxkKG4yKSwgbDI7XG59XG5sZXQgbiA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5uLmRpc3BsYXlOYW1lID0gXCJPcGVuQ2xvc2VkQ29udGV4dFwiO1xudmFyIGkkMiA9ICgoZTIpID0+IChlMltlMi5PcGVuID0gMV0gPSBcIk9wZW5cIiwgZTJbZTIuQ2xvc2VkID0gMl0gPSBcIkNsb3NlZFwiLCBlMltlMi5DbG9zaW5nID0gNF0gPSBcIkNsb3NpbmdcIiwgZTJbZTIuT3BlbmluZyA9IDhdID0gXCJPcGVuaW5nXCIsIGUyKSkoaSQyIHx8IHt9KTtcbmZ1bmN0aW9uIHUkMigpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQobik7XG59XG5mdW5jdGlvbiBjJDMoeyB2YWx1ZTogbzMsIGNoaWxkcmVuOiB0MiB9KSB7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KG4uUHJvdmlkZXIsIHsgdmFsdWU6IG8zIH0sIHQyKTtcbn1cbnZhciB3aXRoU2VsZWN0b3IgPSB7IGV4cG9ydHM6IHt9IH0sIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb24gPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXdpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb247XG5mdW5jdGlvbiByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfcHJvZHVjdGlvbigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfcHJvZHVjdGlvbikgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb247XG4gIGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfcHJvZHVjdGlvbiA9IDE7XG4gIHZhciBSZWFjdDIgPSBSZWFjdF9fZGVmYXVsdDtcbiAgZnVuY3Rpb24gaXMoeDIsIHkyKSB7XG4gICAgcmV0dXJuIHgyID09PSB5MiAmJiAoeDIgIT09IDAgfHwgMSAvIHgyID09PSAxIC8geTIpIHx8IHgyICE9PSB4MiAmJiB5MiAhPT0geTI7XG4gIH1cbiAgdmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBpcywgdXNlU3luY0V4dGVybmFsU3RvcmUyID0gUmVhY3QyLnVzZVN5bmNFeHRlcm5hbFN0b3JlLCB1c2VSZWYyID0gUmVhY3QyLnVzZVJlZiwgdXNlRWZmZWN0MiA9IFJlYWN0Mi51c2VFZmZlY3QsIHVzZU1lbW8yID0gUmVhY3QyLnVzZU1lbW8sIHVzZURlYnVnVmFsdWUgPSBSZWFjdDIudXNlRGVidWdWYWx1ZTtcbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb24udXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICB2YXIgaW5zdFJlZiA9IHVzZVJlZjIobnVsbCk7XG4gICAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdmFyIGluc3QgPSB7IGhhc1ZhbHVlOiAhMSwgdmFsdWU6IG51bGwgfTtcbiAgICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG4gICAgfSBlbHNlIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG4gICAgaW5zdFJlZiA9IHVzZU1lbW8yKFxuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkU2VsZWN0b3IobmV4dFNuYXBzaG90KSB7XG4gICAgICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWVtbyA9ICEwLCBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90LCBuZXh0U25hcHNob3QgPSBzZWxlY3RvcihuZXh0U25hcHNob3QpLCBpc0VxdWFsICE9PSB2b2lkIDAgJiYgaW5zdC5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbiwgb2JqZWN0SXMobWVtb2l6ZWRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KSkgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgdmFyIG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgIHJldHVybiBpc0VxdWFsICE9PSB2b2lkIDAgJiYgaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKSA/IChtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90LCBjdXJyZW50U2VsZWN0aW9uKSA6IChtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90LCBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYXNNZW1vID0gITEsIG1lbW9pemVkU25hcHNob3QsIG1lbW9pemVkU2VsZWN0aW9uLCBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHZvaWQgMCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gbnVsbCA/IHZvaWQgMCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgW2dldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWxdXG4gICAgKTtcbiAgICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBpbnN0UmVmWzBdLCBpbnN0UmVmWzFdKTtcbiAgICByZXR1cm4gdXNlRWZmZWN0MihcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBpbnN0Lmhhc1ZhbHVlID0gITAsIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBbdmFsdWVdXG4gICAgKSwgdXNlRGVidWdWYWx1ZSh2YWx1ZSksIHZhbHVlO1xuICB9LCB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uO1xufVxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50ID0ge30sIGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQ7XG5mdW5jdGlvbiByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50KSByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQ7XG4gIGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgPSAxO1xuICB2YXIgZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQyID0ge307XG4gIC8qKlxuICAgKiBAbGljZW5zZSBSZWFjdFxuICAgKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS13aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gICAqXG4gICAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gICAqXG4gICAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICAgKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gICAqL1xuICByZXR1cm4gZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQyLk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBpcyh4MiwgeTIpIHtcbiAgICAgIHJldHVybiB4MiA9PT0geTIgJiYgKHgyICE9PSAwIHx8IDEgLyB4MiA9PT0gMSAvIHkyKSB8fCB4MiAhPT0geDIgJiYgeTIgIT09IHkyO1xuICAgIH1cbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIDwgXCJ1XCIgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT0gXCJmdW5jdGlvblwiICYmIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQoRXJyb3IoKSk7XG4gICAgdmFyIFJlYWN0MiA9IFJlYWN0X19kZWZhdWx0LCBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmlzIDogaXMsIHVzZVN5bmNFeHRlcm5hbFN0b3JlMiA9IFJlYWN0Mi51c2VTeW5jRXh0ZXJuYWxTdG9yZSwgdXNlUmVmMiA9IFJlYWN0Mi51c2VSZWYsIHVzZUVmZmVjdDIgPSBSZWFjdDIudXNlRWZmZWN0LCB1c2VNZW1vMiA9IFJlYWN0Mi51c2VNZW1vLCB1c2VEZWJ1Z1ZhbHVlID0gUmVhY3QyLnVzZURlYnVnVmFsdWU7XG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSBmdW5jdGlvbihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgICAgIHZhciBpbnN0UmVmID0gdXNlUmVmMihudWxsKTtcbiAgICAgIGlmIChpbnN0UmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIGluc3QgPSB7IGhhc1ZhbHVlOiAhMSwgdmFsdWU6IG51bGwgfTtcbiAgICAgICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgICAgIH0gZWxzZSBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICAgICAgaW5zdFJlZiA9IHVzZU1lbW8yKFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiBtZW1vaXplZFNlbGVjdG9yKG5leHRTbmFwc2hvdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNNZW1vID0gITAsIG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3QsIG5leHRTbmFwc2hvdCA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCksIGlzRXF1YWwgIT09IHZvaWQgMCAmJiBpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBpbnN0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTbmFwc2hvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb24sIG9iamVjdElzKG1lbW9pemVkU25hcHNob3QsIG5leHRTbmFwc2hvdCkpXG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgdmFyIG5leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwgIT09IHZvaWQgMCAmJiBpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pID8gKG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3QsIGN1cnJlbnRTZWxlY3Rpb24pIDogKG1lbW9pemVkU25hcHNob3QgPSBuZXh0U25hcHNob3QsIG1lbW9pemVkU2VsZWN0aW9uID0gbmV4dFNlbGVjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBoYXNNZW1vID0gITEsIG1lbW9pemVkU25hcHNob3QsIG1lbW9pemVkU2VsZWN0aW9uLCBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHZvaWQgMCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKGdldFNuYXBzaG90KCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB2b2lkIDAgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IobWF5YmVHZXRTZXJ2ZXJTbmFwc2hvdCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgICAgICBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF1cbiAgICAgICk7XG4gICAgICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZTIoc3Vic2NyaWJlLCBpbnN0UmVmWzBdLCBpbnN0UmVmWzFdKTtcbiAgICAgIHJldHVybiB1c2VFZmZlY3QyKFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpbnN0Lmhhc1ZhbHVlID0gITAsIGluc3QudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgW3ZhbHVlXVxuICAgICAgKSwgdXNlRGVidWdWYWx1ZSh2YWx1ZSksIHZhbHVlO1xuICAgIH0sIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPCBcInVcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09IFwiZnVuY3Rpb25cIiAmJiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AoRXJyb3IoKSk7XG4gIH0oKSwgdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQ7XG59XG52YXIgaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3I7XG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yKCkge1xuICBpZiAoaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3IpIHJldHVybiB3aXRoU2VsZWN0b3IuZXhwb3J0cztcbiAgaGFzUmVxdWlyZWRXaXRoU2VsZWN0b3IgPSAxO1xuICB2YXIgZGVmaW5lX3Byb2Nlc3NfZW52X2RlZmF1bHQyID0ge307XG4gIHJldHVybiBkZWZpbmVfcHJvY2Vzc19lbnZfZGVmYXVsdDIuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfcHJvZHVjdGlvbigpIDogd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQoKSwgd2l0aFNlbGVjdG9yLmV4cG9ydHM7XG59XG52YXIgd2l0aFNlbGVjdG9yRXhwb3J0cyA9IHJlcXVpcmVXaXRoU2VsZWN0b3IoKSwgZiQxID0gKHQyLCBlMiwgcjIpID0+IHtcbiAgaWYgKCFlMi5oYXModDIpKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyByMik7XG59LCBhJDMgPSAodDIsIGUyLCByMikgPT4gKGYkMSh0MiwgZTIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksIHIyID8gcjIuY2FsbCh0MikgOiBlMi5nZXQodDIpKSwgbCQyID0gKHQyLCBlMiwgcjIpID0+IHtcbiAgaWYgKGUyLmhhcyh0MikpIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIGUyIGluc3RhbmNlb2YgV2Vha1NldCA/IGUyLmFkZCh0MikgOiBlMi5zZXQodDIsIHIyKTtcbn0sIGMkMiA9ICh0MiwgZTIsIHIyLCBuMikgPT4gKGYkMSh0MiwgZTIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSwgZTIuc2V0KHQyLCByMiksIHIyKSwgaSQxLCBzJDQsIG8kMTtcbmNsYXNzIG0ge1xuICBjb25zdHJ1Y3RvcihlMikge1xuICAgIGwkMih0aGlzLCBpJDEsIHt9KSwgbCQyKHRoaXMsIHMkNCwgbmV3IGEkNygoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSksIGwkMih0aGlzLCBvJDEsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLCBjJDIodGhpcywgaSQxLCBlMik7XG4gIH1cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiBhJDModGhpcywgaSQxKTtcbiAgfVxuICBzdWJzY3JpYmUoZTIsIHIyKSB7XG4gICAgbGV0IG4yID0geyBzZWxlY3RvcjogZTIsIGNhbGxiYWNrOiByMiwgY3VycmVudDogZTIoYSQzKHRoaXMsIGkkMSkpIH07XG4gICAgcmV0dXJuIGEkMyh0aGlzLCBvJDEpLmFkZChuMiksICgpID0+IHtcbiAgICAgIGEkMyh0aGlzLCBvJDEpLmRlbGV0ZShuMik7XG4gICAgfTtcbiAgfVxuICBvbihlMiwgcjIpIHtcbiAgICByZXR1cm4gYSQzKHRoaXMsIHMkNCkuZ2V0KGUyKS5hZGQocjIpLCAoKSA9PiB7XG4gICAgICBhJDModGhpcywgcyQ0KS5nZXQoZTIpLmRlbGV0ZShyMik7XG4gICAgfTtcbiAgfVxuICBzZW5kKGUyKSB7XG4gICAgYyQyKHRoaXMsIGkkMSwgdGhpcy5yZWR1Y2UoYSQzKHRoaXMsIGkkMSksIGUyKSk7XG4gICAgZm9yIChsZXQgcjIgb2YgYSQzKHRoaXMsIG8kMSkpIHtcbiAgICAgIGxldCBuMiA9IHIyLnNlbGVjdG9yKGEkMyh0aGlzLCBpJDEpKTtcbiAgICAgIGgkMShyMi5jdXJyZW50LCBuMikgfHwgKHIyLmN1cnJlbnQgPSBuMiwgcjIuY2FsbGJhY2sobjIpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgcjIgb2YgYSQzKHRoaXMsIHMkNCkuZ2V0KGUyLnR5cGUpKSByMihhJDModGhpcywgaSQxKSwgZTIpO1xuICB9XG59XG5pJDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgcyQ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCksIG8kMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaCQxKHQyLCBlMikge1xuICByZXR1cm4gT2JqZWN0LmlzKHQyLCBlMikgPyAhMCA6IHR5cGVvZiB0MiAhPSBcIm9iamVjdFwiIHx8IHQyID09PSBudWxsIHx8IHR5cGVvZiBlMiAhPSBcIm9iamVjdFwiIHx8IGUyID09PSBudWxsID8gITEgOiBBcnJheS5pc0FycmF5KHQyKSAmJiBBcnJheS5pc0FycmF5KGUyKSA/IHQyLmxlbmd0aCAhPT0gZTIubGVuZ3RoID8gITEgOiB1JDEodDJbU3ltYm9sLml0ZXJhdG9yXSgpLCBlMltTeW1ib2wuaXRlcmF0b3JdKCkpIDogdDIgaW5zdGFuY2VvZiBNYXAgJiYgZTIgaW5zdGFuY2VvZiBNYXAgfHwgdDIgaW5zdGFuY2VvZiBTZXQgJiYgZTIgaW5zdGFuY2VvZiBTZXQgPyB0Mi5zaXplICE9PSBlMi5zaXplID8gITEgOiB1JDEodDIuZW50cmllcygpLCBlMi5lbnRyaWVzKCkpIDogUyQyKHQyKSAmJiBTJDIoZTIpID8gdSQxKE9iamVjdC5lbnRyaWVzKHQyKVtTeW1ib2wuaXRlcmF0b3JdKCksIE9iamVjdC5lbnRyaWVzKGUyKVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogITE7XG59XG5mdW5jdGlvbiB1JDEodDIsIGUyKSB7XG4gIGRvIHtcbiAgICBsZXQgcjIgPSB0Mi5uZXh0KCksIG4yID0gZTIubmV4dCgpO1xuICAgIGlmIChyMi5kb25lICYmIG4yLmRvbmUpIHJldHVybiAhMDtcbiAgICBpZiAocjIuZG9uZSB8fCBuMi5kb25lIHx8ICFPYmplY3QuaXMocjIudmFsdWUsIG4yLnZhbHVlKSkgcmV0dXJuICExO1xuICB9IHdoaWxlICghMCk7XG59XG5mdW5jdGlvbiBTJDIodDIpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0MikgIT09IFwiW29iamVjdCBPYmplY3RdXCIpIHJldHVybiAhMTtcbiAgbGV0IGUyID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHQyKTtcbiAgcmV0dXJuIGUyID09PSBudWxsIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlMikgPT09IG51bGw7XG59XG5mdW5jdGlvbiBnJDIodDIpIHtcbiAgbGV0IFtlMiwgcjJdID0gdDIoKSwgbjIgPSBvJDUoKTtcbiAgcmV0dXJuICguLi5iMikgPT4ge1xuICAgIGUyKC4uLmIyKSwgbjIuZGlzcG9zZSgpLCBuMi5taWNyb1Rhc2socjIpO1xuICB9O1xufVxuZnVuY3Rpb24gUyQxKGUyLCBuMiwgcjIgPSBoJDEpIHtcbiAgcmV0dXJuIHdpdGhTZWxlY3RvckV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IobyQ0KChpMikgPT4gZTIuc3Vic2NyaWJlKHMkMywgaTIpKSwgbyQ0KCgpID0+IGUyLnN0YXRlKSwgbyQ0KCgpID0+IGUyLnN0YXRlKSwgbyQ0KG4yKSwgcjIpO1xufVxuZnVuY3Rpb24gcyQzKGUyKSB7XG4gIHJldHVybiBlMjtcbn1cbmZ1bmN0aW9uIHUobDIpIHtcbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBvYmplY3Q6IFwiICsgbDIpO1xufVxudmFyIGMkMSA9ICgoaTIpID0+IChpMltpMi5GaXJzdCA9IDBdID0gXCJGaXJzdFwiLCBpMltpMi5QcmV2aW91cyA9IDFdID0gXCJQcmV2aW91c1wiLCBpMltpMi5OZXh0ID0gMl0gPSBcIk5leHRcIiwgaTJbaTIuTGFzdCA9IDNdID0gXCJMYXN0XCIsIGkyW2kyLlNwZWNpZmljID0gNF0gPSBcIlNwZWNpZmljXCIsIGkyW2kyLk5vdGhpbmcgPSA1XSA9IFwiTm90aGluZ1wiLCBpMikpKGMkMSB8fCB7fSk7XG5mdW5jdGlvbiBmKGwyLCBuMikge1xuICBsZXQgdDIgPSBuMi5yZXNvbHZlSXRlbXMoKTtcbiAgaWYgKHQyLmxlbmd0aCA8PSAwKSByZXR1cm4gbnVsbDtcbiAgbGV0IHIyID0gbjIucmVzb2x2ZUFjdGl2ZUluZGV4KCksIHMyID0gcjIgPz8gLTE7XG4gIHN3aXRjaCAobDIuZm9jdXMpIHtcbiAgICBjYXNlIDA6IHtcbiAgICAgIGZvciAobGV0IGUyID0gMDsgZTIgPCB0Mi5sZW5ndGg7ICsrZTIpIGlmICghbjIucmVzb2x2ZURpc2FibGVkKHQyW2UyXSwgZTIsIHQyKSkgcmV0dXJuIGUyO1xuICAgICAgcmV0dXJuIHIyO1xuICAgIH1cbiAgICBjYXNlIDE6IHtcbiAgICAgIHMyID09PSAtMSAmJiAoczIgPSB0Mi5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgZTIgPSBzMiAtIDE7IGUyID49IDA7IC0tZTIpIGlmICghbjIucmVzb2x2ZURpc2FibGVkKHQyW2UyXSwgZTIsIHQyKSkgcmV0dXJuIGUyO1xuICAgICAgcmV0dXJuIHIyO1xuICAgIH1cbiAgICBjYXNlIDI6IHtcbiAgICAgIGZvciAobGV0IGUyID0gczIgKyAxOyBlMiA8IHQyLmxlbmd0aDsgKytlMikgaWYgKCFuMi5yZXNvbHZlRGlzYWJsZWQodDJbZTJdLCBlMiwgdDIpKSByZXR1cm4gZTI7XG4gICAgICByZXR1cm4gcjI7XG4gICAgfVxuICAgIGNhc2UgMzoge1xuICAgICAgZm9yIChsZXQgZTIgPSB0Mi5sZW5ndGggLSAxOyBlMiA+PSAwOyAtLWUyKSBpZiAoIW4yLnJlc29sdmVEaXNhYmxlZCh0MltlMl0sIGUyLCB0MikpIHJldHVybiBlMjtcbiAgICAgIHJldHVybiByMjtcbiAgICB9XG4gICAgY2FzZSA0OiB7XG4gICAgICBmb3IgKGxldCBlMiA9IDA7IGUyIDwgdDIubGVuZ3RoOyArK2UyKSBpZiAobjIucmVzb2x2ZUlkKHQyW2UyXSwgZTIsIHQyKSA9PT0gbDIuaWQpIHJldHVybiBlMjtcbiAgICAgIHJldHVybiByMjtcbiAgICB9XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHUobDIpO1xuICB9XG59XG5mdW5jdGlvbiBjKHQyKSB7XG4gIGxldCByMiA9IG8kNCh0MiksIGUyID0gdXNlUmVmKCExKTtcbiAgdXNlRWZmZWN0KCgpID0+IChlMi5jdXJyZW50ID0gITEsICgpID0+IHtcbiAgICBlMi5jdXJyZW50ID0gITAsIHQkMygoKSA9PiB7XG4gICAgICBlMi5jdXJyZW50ICYmIHIyKCk7XG4gICAgfSk7XG4gIH0pLCBbcjJdKTtcbn1cbmZ1bmN0aW9uIHMkMigpIHtcbiAgbGV0IHIyID0gdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCI7XG4gIHJldHVybiBcInVzZVN5bmNFeHRlcm5hbFN0b3JlXCIgaW4gUmVhY3QgPyAoKG8zKSA9PiBvMy51c2VTeW5jRXh0ZXJuYWxTdG9yZSkoUmVhY3QpKCgpID0+ICgpID0+IHtcbiAgfSwgKCkgPT4gITEsICgpID0+ICFyMikgOiAhMTtcbn1cbmZ1bmN0aW9uIGwkMSgpIHtcbiAgbGV0IHIyID0gcyQyKCksIFtlMiwgbjJdID0gUmVhY3QudXNlU3RhdGUocyQ3LmlzSGFuZG9mZkNvbXBsZXRlKTtcbiAgcmV0dXJuIGUyICYmIHMkNy5pc0hhbmRvZmZDb21wbGV0ZSA9PT0gITEgJiYgbjIoITEpLCBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGUyICE9PSAhMCAmJiBuMighMCk7XG4gIH0sIFtlMl0pLCBSZWFjdC51c2VFZmZlY3QoKCkgPT4gcyQ3LmhhbmRvZmYoKSwgW10pLCByMiA/ICExIDogZTI7XG59XG5sZXQgZSA9IGNyZWF0ZUNvbnRleHQoITEpO1xuZnVuY3Rpb24gYSQyKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChlKTtcbn1cbmZ1bmN0aW9uIGooZTIpIHtcbiAgbGV0IGwyID0gYSQyKCksIG8zID0gdXNlQ29udGV4dChIJDEpLCBbcjIsIHUyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICB2YXIgaTI7XG4gICAgaWYgKCFsMiAmJiBvMyAhPT0gbnVsbCkgcmV0dXJuIChpMiA9IG8zLmN1cnJlbnQpICE9IG51bGwgPyBpMiA6IG51bGw7XG4gICAgaWYgKHMkNy5pc1NlcnZlcikgcmV0dXJuIG51bGw7XG4gICAgbGV0IHQyID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLmdldEVsZW1lbnRCeUlkKFwiaGVhZGxlc3N1aS1wb3J0YWwtcm9vdFwiKTtcbiAgICBpZiAodDIpIHJldHVybiB0MjtcbiAgICBpZiAoZTIgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGxldCBhMyA9IGUyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgcmV0dXJuIGEzLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiaGVhZGxlc3N1aS1wb3J0YWwtcm9vdFwiKSwgZTIuYm9keS5hcHBlbmRDaGlsZChhMyk7XG4gIH0pO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICByMiAhPT0gbnVsbCAmJiAoZTIgIT0gbnVsbCAmJiBlMi5ib2R5LmNvbnRhaW5zKHIyKSB8fCBlMiA9PSBudWxsIHx8IGUyLmJvZHkuYXBwZW5kQ2hpbGQocjIpKTtcbiAgfSwgW3IyLCBlMl0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGwyIHx8IG8zICE9PSBudWxsICYmIHUyKG8zLmN1cnJlbnQpO1xuICB9LCBbbzMsIHUyLCBsMl0pLCByMjtcbn1cbmxldCBNJDEgPSBGcmFnbWVudCwgSSA9IEskMShmdW5jdGlvbihsMiwgbzMpIHtcbiAgbGV0IHsgb3duZXJEb2N1bWVudDogcjIgPSBudWxsLCAuLi51MiB9ID0gbDIsIHQyID0gdXNlUmVmKG51bGwpLCBhMyA9IHkkNChUJDMoKHMyKSA9PiB7XG4gICAgdDIuY3VycmVudCA9IHMyO1xuICB9KSwgbzMpLCBpMiA9IG4kMSh0MiksIGYyID0gcjIgPz8gaTIsIHAyID0gaihmMiksIFtuMl0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgdmFyIHMyO1xuICAgIHJldHVybiBzJDcuaXNTZXJ2ZXIgPyBudWxsIDogKHMyID0gZjIgPT0gbnVsbCA/IHZvaWQgMCA6IGYyLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpICE9IG51bGwgPyBzMiA6IG51bGw7XG4gIH0pLCBQMiA9IHVzZUNvbnRleHQoZyQxKSwgYjIgPSBsJDEoKTtcbiAgbiQzKCgpID0+IHtcbiAgICAhcDIgfHwgIW4yIHx8IHAyLmNvbnRhaW5zKG4yKSB8fCAobjIuc2V0QXR0cmlidXRlKFwiZGF0YS1oZWFkbGVzc3VpLXBvcnRhbFwiLCBcIlwiKSwgcDIuYXBwZW5kQ2hpbGQobjIpKTtcbiAgfSwgW3AyLCBuMl0pLCBuJDMoKCkgPT4ge1xuICAgIGlmIChuMiAmJiBQMikgcmV0dXJuIFAyLnJlZ2lzdGVyKG4yKTtcbiAgfSwgW1AyLCBuMl0pLCBjKCgpID0+IHtcbiAgICB2YXIgczI7XG4gICAgIXAyIHx8ICFuMiB8fCAobjIgaW5zdGFuY2VvZiBOb2RlICYmIHAyLmNvbnRhaW5zKG4yKSAmJiBwMi5yZW1vdmVDaGlsZChuMiksIHAyLmNoaWxkTm9kZXMubGVuZ3RoIDw9IDAgJiYgKChzMiA9IHAyLnBhcmVudEVsZW1lbnQpID09IG51bGwgfHwgczIucmVtb3ZlQ2hpbGQocDIpKSk7XG4gIH0pO1xuICBsZXQgaDIgPSBMJDIoKTtcbiAgcmV0dXJuIGIyID8gIXAyIHx8ICFuMiA/IG51bGwgOiBjcmVhdGVQb3J0YWwoaDIoeyBvdXJQcm9wczogeyByZWY6IGEzIH0sIHRoZWlyUHJvcHM6IHUyLCBzbG90OiB7fSwgZGVmYXVsdFRhZzogTSQxLCBuYW1lOiBcIlBvcnRhbFwiIH0pLCBuMikgOiBudWxsO1xufSk7XG5mdW5jdGlvbiBKJDEoZTIsIGwyKSB7XG4gIGxldCBvMyA9IHkkNChsMiksIHsgZW5hYmxlZDogcjIgPSAhMCwgb3duZXJEb2N1bWVudDogdTIsIC4uLnQyIH0gPSBlMiwgYTMgPSBMJDIoKTtcbiAgcmV0dXJuIHIyID8gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChJLCB7IC4uLnQyLCBvd25lckRvY3VtZW50OiB1MiwgcmVmOiBvMyB9KSA6IGEzKHsgb3VyUHJvcHM6IHsgcmVmOiBvMyB9LCB0aGVpclByb3BzOiB0Miwgc2xvdDoge30sIGRlZmF1bHRUYWc6IE0kMSwgbmFtZTogXCJQb3J0YWxcIiB9KTtcbn1cbmxldCBYJDEgPSBGcmFnbWVudCwgSCQxID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIGsoZTIsIGwyKSB7XG4gIGxldCB7IHRhcmdldDogbzMsIC4uLnIyIH0gPSBlMiwgdDIgPSB7IHJlZjogeSQ0KGwyKSB9LCBhMyA9IEwkMigpO1xuICByZXR1cm4gUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChIJDEuUHJvdmlkZXIsIHsgdmFsdWU6IG8zIH0sIGEzKHsgb3VyUHJvcHM6IHQyLCB0aGVpclByb3BzOiByMiwgZGVmYXVsdFRhZzogWCQxLCBuYW1lOiBcIlBvcG92ZXIuR3JvdXBcIiB9KSk7XG59XG5sZXQgZyQxID0gY3JlYXRlQ29udGV4dChudWxsKSwgQiA9IEskMShKJDEpLCBEID0gSyQxKGspLCBvZSA9IE9iamVjdC5hc3NpZ24oQiwgeyBHcm91cDogRCB9KTtcbmZ1bmN0aW9uIHMkMShuMiwgdDIpIHtcbiAgbGV0IGUyID0gdXNlUmVmKHsgbGVmdDogMCwgdG9wOiAwIH0pO1xuICBpZiAobiQzKCgpID0+IHtcbiAgICBpZiAoIXQyKSByZXR1cm47XG4gICAgbGV0IHIyID0gdDIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcjIgJiYgKGUyLmN1cnJlbnQgPSByMik7XG4gIH0sIFtuMiwgdDJdKSwgdDIgPT0gbnVsbCB8fCAhbjIgfHwgdDIgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHJldHVybiAhMTtcbiAgbGV0IG8zID0gdDIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBvMy50b3AgIT09IGUyLmN1cnJlbnQudG9wIHx8IG8zLmxlZnQgIT09IGUyLmN1cnJlbnQubGVmdDtcbn1cbmxldCBhJDEgPSAvKFtcXFxcdTI3MDAtXFxcXHUyN0JGXXxbXFxcXHVFMDAwLVxcXFx1RjhGRl18XFxcXHVEODNDW1xcXFx1REMwMC1cXFxcdURGRkZdfFxcXFx1RDgzRFtcXFxcdURDMDAtXFxcXHVERkZGXXxbXFxcXHUyMDExLVxcXFx1MjZGRl18XFxcXHVEODNFW1xcXFx1REQxMC1cXFxcdURERkZdKS9nO1xuZnVuY3Rpb24gbzIoZTIpIHtcbiAgdmFyIHIyLCBpMjtcbiAgbGV0IG4yID0gKHIyID0gZTIuaW5uZXJUZXh0KSAhPSBudWxsID8gcjIgOiBcIlwiLCB0MiA9IGUyLmNsb25lTm9kZSghMCk7XG4gIGlmICghKHQyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSByZXR1cm4gbjI7XG4gIGxldCB1MiA9ICExO1xuICBmb3IgKGxldCBmMiBvZiB0Mi5xdWVyeVNlbGVjdG9yQWxsKCdbaGlkZGVuXSxbYXJpYS1oaWRkZW5dLFtyb2xlPVwiaW1nXCJdJykpIGYyLnJlbW92ZSgpLCB1MiA9ICEwO1xuICBsZXQgbDIgPSB1MiA/IChpMiA9IHQyLmlubmVyVGV4dCkgIT0gbnVsbCA/IGkyIDogXCJcIiA6IG4yO1xuICByZXR1cm4gYSQxLnRlc3QobDIpICYmIChsMiA9IGwyLnJlcGxhY2UoYSQxLCBcIlwiKSksIGwyO1xufVxuZnVuY3Rpb24gZyhlMikge1xuICBsZXQgbjIgPSBlMi5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICBpZiAodHlwZW9mIG4yID09IFwic3RyaW5nXCIpIHJldHVybiBuMi50cmltKCk7XG4gIGxldCB0MiA9IGUyLmdldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxsZWRieVwiKTtcbiAgaWYgKHQyKSB7XG4gICAgbGV0IHUyID0gdDIuc3BsaXQoXCIgXCIpLm1hcCgobDIpID0+IHtcbiAgICAgIGxldCByMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGwyKTtcbiAgICAgIGlmIChyMikge1xuICAgICAgICBsZXQgaTIgPSByMi5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGkyID09IFwic3RyaW5nXCIgPyBpMi50cmltKCkgOiBvMihyMikudHJpbSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmICh1Mi5sZW5ndGggPiAwKSByZXR1cm4gdTIuam9pbihcIiwgXCIpO1xuICB9XG4gIHJldHVybiBvMihlMikudHJpbSgpO1xufVxuZnVuY3Rpb24gcyhjMikge1xuICBsZXQgdDIgPSB1c2VSZWYoXCJcIiksIHIyID0gdXNlUmVmKFwiXCIpO1xuICByZXR1cm4gbyQ0KCgpID0+IHtcbiAgICBsZXQgZTIgPSBjMi5jdXJyZW50O1xuICAgIGlmICghZTIpIHJldHVybiBcIlwiO1xuICAgIGxldCB1MiA9IGUyLmlubmVyVGV4dDtcbiAgICBpZiAodDIuY3VycmVudCA9PT0gdTIpIHJldHVybiByMi5jdXJyZW50O1xuICAgIGxldCBuMiA9IGcoZTIpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB0Mi5jdXJyZW50ID0gdTIsIHIyLmN1cnJlbnQgPSBuMiwgbjI7XG4gIH0pO1xufVxudmFyIGggPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIHkgPSAoZTIsIG4yLCB0MikgPT4gbjIgaW4gZTIgPyBoKGUyLCBuMiwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdDIgfSkgOiBlMltuMl0gPSB0MiwgdiA9IChlMiwgbjIsIHQyKSA9PiAoeShlMiwgdHlwZW9mIG4yICE9IFwic3ltYm9sXCIgPyBuMiArIFwiXCIgOiBuMiwgdDIpLCB0MiksIE0gPSAoKHQyKSA9PiAodDJbdDIuT3BlbiA9IDBdID0gXCJPcGVuXCIsIHQyW3QyLkNsb3NlZCA9IDFdID0gXCJDbG9zZWRcIiwgdDIpKShNIHx8IHt9KSwgVCA9ICgodDIpID0+ICh0Mlt0Mi5Qb2ludGVyID0gMF0gPSBcIlBvaW50ZXJcIiwgdDJbdDIuT3RoZXIgPSAxXSA9IFwiT3RoZXJcIiwgdDIpKShUIHx8IHt9KSwgYiA9ICgoaTIpID0+IChpMltpMi5PcGVuTWVudSA9IDBdID0gXCJPcGVuTWVudVwiLCBpMltpMi5DbG9zZU1lbnUgPSAxXSA9IFwiQ2xvc2VNZW51XCIsIGkyW2kyLkdvVG9JdGVtID0gMl0gPSBcIkdvVG9JdGVtXCIsIGkyW2kyLlNlYXJjaCA9IDNdID0gXCJTZWFyY2hcIiwgaTJbaTIuQ2xlYXJTZWFyY2ggPSA0XSA9IFwiQ2xlYXJTZWFyY2hcIiwgaTJbaTIuUmVnaXN0ZXJJdGVtcyA9IDVdID0gXCJSZWdpc3Rlckl0ZW1zXCIsIGkyW2kyLlVucmVnaXN0ZXJJdGVtcyA9IDZdID0gXCJVbnJlZ2lzdGVySXRlbXNcIiwgaTJbaTIuU2V0QnV0dG9uRWxlbWVudCA9IDddID0gXCJTZXRCdXR0b25FbGVtZW50XCIsIGkyW2kyLlNldEl0ZW1zRWxlbWVudCA9IDhdID0gXCJTZXRJdGVtc0VsZW1lbnRcIiwgaTJbaTIuU29ydEl0ZW1zID0gOV0gPSBcIlNvcnRJdGVtc1wiLCBpMikpKGIgfHwge30pO1xuZnVuY3Rpb24gUyhlMiwgbjIgPSAodDIpID0+IHQyKSB7XG4gIGxldCB0MiA9IGUyLmFjdGl2ZUl0ZW1JbmRleCAhPT0gbnVsbCA/IGUyLml0ZW1zW2UyLmFjdGl2ZUl0ZW1JbmRleF0gOiBudWxsLCByMiA9IF8objIoZTIuaXRlbXMuc2xpY2UoKSksICh1MikgPT4gdTIuZGF0YVJlZi5jdXJyZW50LmRvbVJlZi5jdXJyZW50KSwgbDIgPSB0MiA/IHIyLmluZGV4T2YodDIpIDogbnVsbDtcbiAgcmV0dXJuIGwyID09PSAtMSAmJiAobDIgPSBudWxsKSwgeyBpdGVtczogcjIsIGFjdGl2ZUl0ZW1JbmRleDogbDIgfTtcbn1cbmxldCBGID0geyAxKGUyKSB7XG4gIHJldHVybiBlMi5tZW51U3RhdGUgPT09IDEgPyBlMiA6IHsgLi4uZTIsIGFjdGl2ZUl0ZW1JbmRleDogbnVsbCwgcGVuZGluZ0ZvY3VzOiB7IGZvY3VzOiBjJDEuTm90aGluZyB9LCBtZW51U3RhdGU6IDEgfTtcbn0sIDAoZTIsIG4yKSB7XG4gIHJldHVybiBlMi5tZW51U3RhdGUgPT09IDAgPyBlMiA6IHsgLi4uZTIsIF9fZGVtb01vZGU6ICExLCBwZW5kaW5nRm9jdXM6IG4yLmZvY3VzLCBtZW51U3RhdGU6IDAgfTtcbn0sIDI6IChlMiwgbjIpID0+IHtcbiAgdmFyIHUyLCBtMiwgZDIsIGEzLCBJMjtcbiAgaWYgKGUyLm1lbnVTdGF0ZSA9PT0gMSkgcmV0dXJuIGUyO1xuICBsZXQgdDIgPSB7IC4uLmUyLCBzZWFyY2hRdWVyeTogXCJcIiwgYWN0aXZhdGlvblRyaWdnZXI6ICh1MiA9IG4yLnRyaWdnZXIpICE9IG51bGwgPyB1MiA6IDEsIF9fZGVtb01vZGU6ICExIH07XG4gIGlmIChuMi5mb2N1cyA9PT0gYyQxLk5vdGhpbmcpIHJldHVybiB7IC4uLnQyLCBhY3RpdmVJdGVtSW5kZXg6IG51bGwgfTtcbiAgaWYgKG4yLmZvY3VzID09PSBjJDEuU3BlY2lmaWMpIHJldHVybiB7IC4uLnQyLCBhY3RpdmVJdGVtSW5kZXg6IGUyLml0ZW1zLmZpbmRJbmRleCgoaTIpID0+IGkyLmlkID09PSBuMi5pZCkgfTtcbiAgaWYgKG4yLmZvY3VzID09PSBjJDEuUHJldmlvdXMpIHtcbiAgICBsZXQgaTIgPSBlMi5hY3RpdmVJdGVtSW5kZXg7XG4gICAgaWYgKGkyICE9PSBudWxsKSB7XG4gICAgICBsZXQgZzIgPSBlMi5pdGVtc1tpMl0uZGF0YVJlZi5jdXJyZW50LmRvbVJlZiwgbzMgPSBmKG4yLCB7IHJlc29sdmVJdGVtczogKCkgPT4gZTIuaXRlbXMsIHJlc29sdmVBY3RpdmVJbmRleDogKCkgPT4gZTIuYWN0aXZlSXRlbUluZGV4LCByZXNvbHZlSWQ6IChzMikgPT4gczIuaWQsIHJlc29sdmVEaXNhYmxlZDogKHMyKSA9PiBzMi5kYXRhUmVmLmN1cnJlbnQuZGlzYWJsZWQgfSk7XG4gICAgICBpZiAobzMgIT09IG51bGwpIHtcbiAgICAgICAgbGV0IHMyID0gZTIuaXRlbXNbbzNdLmRhdGFSZWYuY3VycmVudC5kb21SZWY7XG4gICAgICAgIGlmICgoKG0yID0gZzIuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IG0yLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpID09PSBzMi5jdXJyZW50IHx8ICgoZDIgPSBzMi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogZDIucHJldmlvdXNFbGVtZW50U2libGluZykgPT09IG51bGwpIHJldHVybiB7IC4uLnQyLCBhY3RpdmVJdGVtSW5kZXg6IG8zIH07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG4yLmZvY3VzID09PSBjJDEuTmV4dCkge1xuICAgIGxldCBpMiA9IGUyLmFjdGl2ZUl0ZW1JbmRleDtcbiAgICBpZiAoaTIgIT09IG51bGwpIHtcbiAgICAgIGxldCBnMiA9IGUyLml0ZW1zW2kyXS5kYXRhUmVmLmN1cnJlbnQuZG9tUmVmLCBvMyA9IGYobjIsIHsgcmVzb2x2ZUl0ZW1zOiAoKSA9PiBlMi5pdGVtcywgcmVzb2x2ZUFjdGl2ZUluZGV4OiAoKSA9PiBlMi5hY3RpdmVJdGVtSW5kZXgsIHJlc29sdmVJZDogKHMyKSA9PiBzMi5pZCwgcmVzb2x2ZURpc2FibGVkOiAoczIpID0+IHMyLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZCB9KTtcbiAgICAgIGlmIChvMyAhPT0gbnVsbCkge1xuICAgICAgICBsZXQgczIgPSBlMi5pdGVtc1tvM10uZGF0YVJlZi5jdXJyZW50LmRvbVJlZjtcbiAgICAgICAgaWYgKCgoYTMgPSBnMi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogYTMubmV4dEVsZW1lbnRTaWJsaW5nKSA9PT0gczIuY3VycmVudCB8fCAoKEkyID0gczIuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IEkyLm5leHRFbGVtZW50U2libGluZykgPT09IG51bGwpIHJldHVybiB7IC4uLnQyLCBhY3RpdmVJdGVtSW5kZXg6IG8zIH07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByMiA9IFMoZTIpLCBsMiA9IGYobjIsIHsgcmVzb2x2ZUl0ZW1zOiAoKSA9PiByMi5pdGVtcywgcmVzb2x2ZUFjdGl2ZUluZGV4OiAoKSA9PiByMi5hY3RpdmVJdGVtSW5kZXgsIHJlc29sdmVJZDogKGkyKSA9PiBpMi5pZCwgcmVzb2x2ZURpc2FibGVkOiAoaTIpID0+IGkyLmRhdGFSZWYuY3VycmVudC5kaXNhYmxlZCB9KTtcbiAgcmV0dXJuIHsgLi4udDIsIC4uLnIyLCBhY3RpdmVJdGVtSW5kZXg6IGwyIH07XG59LCAzOiAoZTIsIG4yKSA9PiB7XG4gIGxldCByMiA9IGUyLnNlYXJjaFF1ZXJ5ICE9PSBcIlwiID8gMCA6IDEsIGwyID0gZTIuc2VhcmNoUXVlcnkgKyBuMi52YWx1ZS50b0xvd2VyQ2FzZSgpLCBtMiA9IChlMi5hY3RpdmVJdGVtSW5kZXggIT09IG51bGwgPyBlMi5pdGVtcy5zbGljZShlMi5hY3RpdmVJdGVtSW5kZXggKyByMikuY29uY2F0KGUyLml0ZW1zLnNsaWNlKDAsIGUyLmFjdGl2ZUl0ZW1JbmRleCArIHIyKSkgOiBlMi5pdGVtcykuZmluZCgoYTMpID0+IHtcbiAgICB2YXIgSTI7XG4gICAgcmV0dXJuICgoSTIgPSBhMy5kYXRhUmVmLmN1cnJlbnQudGV4dFZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogSTIuc3RhcnRzV2l0aChsMikpICYmICFhMy5kYXRhUmVmLmN1cnJlbnQuZGlzYWJsZWQ7XG4gIH0pLCBkMiA9IG0yID8gZTIuaXRlbXMuaW5kZXhPZihtMikgOiAtMTtcbiAgcmV0dXJuIGQyID09PSAtMSB8fCBkMiA9PT0gZTIuYWN0aXZlSXRlbUluZGV4ID8geyAuLi5lMiwgc2VhcmNoUXVlcnk6IGwyIH0gOiB7IC4uLmUyLCBzZWFyY2hRdWVyeTogbDIsIGFjdGl2ZUl0ZW1JbmRleDogZDIsIGFjdGl2YXRpb25UcmlnZ2VyOiAxIH07XG59LCA0KGUyKSB7XG4gIHJldHVybiBlMi5zZWFyY2hRdWVyeSA9PT0gXCJcIiA/IGUyIDogeyAuLi5lMiwgc2VhcmNoUXVlcnk6IFwiXCIsIHNlYXJjaEFjdGl2ZUl0ZW1JbmRleDogbnVsbCB9O1xufSwgNTogKGUyLCBuMikgPT4ge1xuICBsZXQgdDIgPSBlMi5pdGVtcy5jb25jYXQobjIuaXRlbXMubWFwKChsMikgPT4gbDIpKSwgcjIgPSBlMi5hY3RpdmVJdGVtSW5kZXg7XG4gIHJldHVybiBlMi5wZW5kaW5nRm9jdXMuZm9jdXMgIT09IGMkMS5Ob3RoaW5nICYmIChyMiA9IGYoZTIucGVuZGluZ0ZvY3VzLCB7IHJlc29sdmVJdGVtczogKCkgPT4gdDIsIHJlc29sdmVBY3RpdmVJbmRleDogKCkgPT4gZTIuYWN0aXZlSXRlbUluZGV4LCByZXNvbHZlSWQ6IChsMikgPT4gbDIuaWQsIHJlc29sdmVEaXNhYmxlZDogKGwyKSA9PiBsMi5kYXRhUmVmLmN1cnJlbnQuZGlzYWJsZWQgfSkpLCB7IC4uLmUyLCBpdGVtczogdDIsIGFjdGl2ZUl0ZW1JbmRleDogcjIsIHBlbmRpbmdGb2N1czogeyBmb2N1czogYyQxLk5vdGhpbmcgfSwgcGVuZGluZ1Nob3VsZFNvcnQ6ICEwIH07XG59LCA2OiAoZTIsIG4yKSA9PiB7XG4gIGxldCB0MiA9IGUyLml0ZW1zLCByMiA9IFtdLCBsMiA9IG5ldyBTZXQobjIuaXRlbXMpO1xuICBmb3IgKGxldCBbdTIsIG0yXSBvZiB0Mi5lbnRyaWVzKCkpIGlmIChsMi5oYXMobTIuaWQpICYmIChyMi5wdXNoKHUyKSwgbDIuZGVsZXRlKG0yLmlkKSwgbDIuc2l6ZSA9PT0gMCkpIGJyZWFrO1xuICBpZiAocjIubGVuZ3RoID4gMCkge1xuICAgIHQyID0gdDIuc2xpY2UoKTtcbiAgICBmb3IgKGxldCB1MiBvZiByMi5yZXZlcnNlKCkpIHQyLnNwbGljZSh1MiwgMSk7XG4gIH1cbiAgcmV0dXJuIHsgLi4uZTIsIGl0ZW1zOiB0MiwgYWN0aXZhdGlvblRyaWdnZXI6IDEgfTtcbn0sIDc6IChlMiwgbjIpID0+IGUyLmJ1dHRvbkVsZW1lbnQgPT09IG4yLmVsZW1lbnQgPyBlMiA6IHsgLi4uZTIsIGJ1dHRvbkVsZW1lbnQ6IG4yLmVsZW1lbnQgfSwgODogKGUyLCBuMikgPT4gZTIuaXRlbXNFbGVtZW50ID09PSBuMi5lbGVtZW50ID8gZTIgOiB7IC4uLmUyLCBpdGVtc0VsZW1lbnQ6IG4yLmVsZW1lbnQgfSwgOTogKGUyKSA9PiBlMi5wZW5kaW5nU2hvdWxkU29ydCA/IHsgLi4uZTIsIC4uLlMoZTIpLCBwZW5kaW5nU2hvdWxkU29ydDogITEgfSA6IGUyIH07XG5jbGFzcyB4IGV4dGVuZHMgbSB7XG4gIGNvbnN0cnVjdG9yKHQyKSB7XG4gICAgc3VwZXIodDIpLCB2KHRoaXMsIFwiYWN0aW9uc1wiLCB7IHJlZ2lzdGVySXRlbTogZyQyKCgpID0+IHtcbiAgICAgIGxldCB0MyA9IFtdLCByMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICByZXR1cm4gWyhsMiwgdTIpID0+IHtcbiAgICAgICAgcjIuaGFzKHUyKSB8fCAocjIuYWRkKHUyKSwgdDMucHVzaCh7IGlkOiBsMiwgZGF0YVJlZjogdTIgfSkpO1xuICAgICAgfSwgKCkgPT4gKHIyLmNsZWFyKCksIHRoaXMuc2VuZCh7IHR5cGU6IDUsIGl0ZW1zOiB0My5zcGxpY2UoMCkgfSkpXTtcbiAgICB9KSwgdW5yZWdpc3Rlckl0ZW06IGckMigoKSA9PiB7XG4gICAgICBsZXQgdDMgPSBbXTtcbiAgICAgIHJldHVybiBbKHIyKSA9PiB0My5wdXNoKHIyKSwgKCkgPT4gdGhpcy5zZW5kKHsgdHlwZTogNiwgaXRlbXM6IHQzLnNwbGljZSgwKSB9KV07XG4gICAgfSkgfSksIHYodGhpcywgXCJzZWxlY3RvcnNcIiwgeyBhY3RpdmVEZXNjZW5kYW50SWQodDMpIHtcbiAgICAgIHZhciB1MjtcbiAgICAgIGxldCByMiA9IHQzLmFjdGl2ZUl0ZW1JbmRleCwgbDIgPSB0My5pdGVtcztcbiAgICAgIHJldHVybiByMiA9PT0gbnVsbCB8fCAodTIgPSBsMltyMl0pID09IG51bGwgPyB2b2lkIDAgOiB1Mi5pZDtcbiAgICB9LCBpc0FjdGl2ZSh0MywgcjIpIHtcbiAgICAgIHZhciBtMjtcbiAgICAgIGxldCBsMiA9IHQzLmFjdGl2ZUl0ZW1JbmRleCwgdTIgPSB0My5pdGVtcztcbiAgICAgIHJldHVybiBsMiAhPT0gbnVsbCA/ICgobTIgPSB1MltsMl0pID09IG51bGwgPyB2b2lkIDAgOiBtMi5pZCkgPT09IHIyIDogITE7XG4gICAgfSwgc2hvdWxkU2Nyb2xsSW50b1ZpZXcodDMsIHIyKSB7XG4gICAgICByZXR1cm4gdDMuX19kZW1vTW9kZSB8fCB0My5tZW51U3RhdGUgIT09IDAgfHwgdDMuYWN0aXZhdGlvblRyaWdnZXIgPT09IDAgPyAhMSA6IHRoaXMuaXNBY3RpdmUodDMsIHIyKTtcbiAgICB9IH0pLCB0aGlzLm9uKDUsICgpID0+IHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2VuZCh7IHR5cGU6IDkgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgbmV3KHsgX19kZW1vTW9kZTogdDIgPSAhMSB9ID0ge30pIHtcbiAgICByZXR1cm4gbmV3IHgoeyBfX2RlbW9Nb2RlOiB0MiwgbWVudVN0YXRlOiB0MiA/IDAgOiAxLCBidXR0b25FbGVtZW50OiBudWxsLCBpdGVtc0VsZW1lbnQ6IG51bGwsIGl0ZW1zOiBbXSwgc2VhcmNoUXVlcnk6IFwiXCIsIGFjdGl2ZUl0ZW1JbmRleDogbnVsbCwgYWN0aXZhdGlvblRyaWdnZXI6IDEsIHBlbmRpbmdTaG91bGRTb3J0OiAhMSwgcGVuZGluZ0ZvY3VzOiB7IGZvY3VzOiBjJDEuTm90aGluZyB9IH0pO1xuICB9XG4gIHJlZHVjZSh0MiwgcjIpIHtcbiAgICByZXR1cm4gdSQ3KHIyLnR5cGUsIEYsIHQyLCByMik7XG4gIH1cbn1cbmNvbnN0IGEyID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmZ1bmN0aW9uIGwoZTIpIHtcbiAgbGV0IG4yID0gdXNlQ29udGV4dChhMik7XG4gIGlmIChuMiA9PT0gbnVsbCkge1xuICAgIGxldCB0MiA9IG5ldyBFcnJvcihcXGA8XFwke2UyfSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxNZW51IC8+IGNvbXBvbmVudC5cXGApO1xuICAgIHRocm93IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHQyLCBpKSwgdDI7XG4gIH1cbiAgcmV0dXJuIG4yO1xufVxuZnVuY3Rpb24gaSh7IF9fZGVtb01vZGU6IGUyID0gITEgfSA9IHt9KSB7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IHgubmV3KHsgX19kZW1vTW9kZTogZTIgfSksIFtdKTtcbn1cbmxldCB6ZSA9IEZyYWdtZW50O1xuZnVuY3Rpb24gUWUoVDIsIEUyKSB7XG4gIGxldCB7IF9fZGVtb01vZGU6IGkkMTIgPSAhMSwgLi4uYSQxMiB9ID0gVDIsIG4yID0gaSh7IF9fZGVtb01vZGU6IGkkMTIgfSksIFtzMiwgbzMsIFAyXSA9IFMkMShuMiwgKHAyKSA9PiBbcDIubWVudVN0YXRlLCBwMi5pdGVtc0VsZW1lbnQsIHAyLmJ1dHRvbkVsZW1lbnRdKSwgYzIgPSB5JDQoRTIpLCBfMiA9IHMyID09PSBNLk9wZW47XG4gIFIkMShfMiwgW1AyLCBvM10sIChwMiwgRjIpID0+IHtcbiAgICB2YXIgQSQxMjtcbiAgICBuMi5zZW5kKHsgdHlwZTogYi5DbG9zZU1lbnUgfSksIEEoRjIsIGgkMi5Mb29zZSkgfHwgKHAyLnByZXZlbnREZWZhdWx0KCksIChBJDEyID0gbjIuc3RhdGUuYnV0dG9uRWxlbWVudCkgPT0gbnVsbCB8fCBBJDEyLmZvY3VzKCkpO1xuICB9KTtcbiAgbGV0IHQyID0gbyQ0KCgpID0+IHtcbiAgICBuMi5zZW5kKHsgdHlwZTogYi5DbG9zZU1lbnUgfSk7XG4gIH0pLCBSMiA9IHVzZU1lbW8oKCkgPT4gKHsgb3BlbjogczIgPT09IE0uT3BlbiwgY2xvc2U6IHQyIH0pLCBbczIsIHQyXSksIEkyID0geyByZWY6IGMyIH0sIGcyID0gTCQyKCk7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lLCBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGEyLlByb3ZpZGVyLCB7IHZhbHVlOiBuMiB9LCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGMkMywgeyB2YWx1ZTogdSQ3KHMyLCB7IFtNLk9wZW5dOiBpJDIuT3BlbiwgW00uQ2xvc2VkXTogaSQyLkNsb3NlZCB9KSB9LCBnMih7IG91clByb3BzOiBJMiwgdGhlaXJQcm9wczogYSQxMiwgc2xvdDogUjIsIGRlZmF1bHRUYWc6IHplLCBuYW1lOiBcIk1lbnVcIiB9KSkpKTtcbn1cbmxldCBZZSA9IFwiYnV0dG9uXCI7XG5mdW5jdGlvbiBaZShUJDEyLCBFMikge1xuICBsZXQgaTIgPSBsKFwiTWVudS5CdXR0b25cIiksIGEzID0gdXNlSWQkMSgpLCB7IGlkOiBuMiA9IFxcYGhlYWRsZXNzdWktbWVudS1idXR0b24tXFwke2EzfVxcYCwgZGlzYWJsZWQ6IHMyID0gITEsIGF1dG9Gb2N1czogbzMgPSAhMSwgLi4uUDIgfSA9IFQkMTIsIGMyID0gdXNlUmVmKG51bGwpLCBfMiA9IEZlKCksIHQyID0geSQ0KEUyLCBjMiwgeWUoKSwgbyQ0KChsMikgPT4gaTIuc2VuZCh7IHR5cGU6IGIuU2V0QnV0dG9uRWxlbWVudCwgZWxlbWVudDogbDIgfSkpKSwgUjIgPSBvJDQoKGwyKSA9PiB7XG4gICAgc3dpdGNoIChsMi5rZXkpIHtcbiAgICAgIGNhc2UgbyQzLlNwYWNlOlxuICAgICAgY2FzZSBvJDMuRW50ZXI6XG4gICAgICBjYXNlIG8kMy5BcnJvd0Rvd246XG4gICAgICAgIGwyLnByZXZlbnREZWZhdWx0KCksIGwyLnN0b3BQcm9wYWdhdGlvbigpLCBpMi5zZW5kKHsgdHlwZTogYi5PcGVuTWVudSwgZm9jdXM6IHsgZm9jdXM6IGMkMS5GaXJzdCB9IH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbyQzLkFycm93VXA6XG4gICAgICAgIGwyLnByZXZlbnREZWZhdWx0KCksIGwyLnN0b3BQcm9wYWdhdGlvbigpLCBpMi5zZW5kKHsgdHlwZTogYi5PcGVuTWVudSwgZm9jdXM6IHsgZm9jdXM6IGMkMS5MYXN0IH0gfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSksIEkyID0gbyQ0KChsMikgPT4ge1xuICAgIHN3aXRjaCAobDIua2V5KSB7XG4gICAgICBjYXNlIG8kMy5TcGFjZTpcbiAgICAgICAgbDIucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KSwgW2cyLCBwMl0gPSBTJDEoaTIsIChsMikgPT4gW2wyLm1lbnVTdGF0ZSwgbDIuaXRlbXNFbGVtZW50XSksIEYyID0gbyQ0KChsMikgPT4ge1xuICAgIHZhciBIMjtcbiAgICBpZiAobDIuYnV0dG9uID09PSAwKSB7XG4gICAgICBpZiAociQxKGwyLmN1cnJlbnRUYXJnZXQpKSByZXR1cm4gbDIucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHMyIHx8IChnMiA9PT0gTS5PcGVuID8gKGZsdXNoU3luYygoKSA9PiBpMi5zZW5kKHsgdHlwZTogYi5DbG9zZU1lbnUgfSkpLCAoSDIgPSBjMi5jdXJyZW50KSA9PSBudWxsIHx8IEgyLmZvY3VzKHsgcHJldmVudFNjcm9sbDogITAgfSkpIDogKGwyLnByZXZlbnREZWZhdWx0KCksIGkyLnNlbmQoeyB0eXBlOiBiLk9wZW5NZW51LCBmb2N1czogeyBmb2N1czogYyQxLk5vdGhpbmcgfSwgdHJpZ2dlcjogVC5Qb2ludGVyIH0pKSk7XG4gICAgfVxuICB9KSwgeyBpc0ZvY3VzVmlzaWJsZTogQTIsIGZvY3VzUHJvcHM6IGYyIH0gPSAkZjdkY2VmZmM1YWQ3NzY4YiRleHBvcnQkNGUzMjhmNjFjNTM4Njg3Zih7IGF1dG9Gb2N1czogbzMgfSksIHsgaXNIb3ZlcmVkOiBNJDEyLCBob3ZlclByb3BzOiBMMiB9ID0gJDYxNzliOTM2NzA1ZTc2ZDMkZXhwb3J0JGFlNzgwZGFmMjllNmQ0NTYoeyBpc0Rpc2FibGVkOiBzMiB9KSwgeyBwcmVzc2VkOiBTMiwgcHJlc3NQcm9wczogTzIgfSA9IHckMih7IGRpc2FibGVkOiBzMiB9KSwgeDIgPSB1c2VNZW1vKCgpID0+ICh7IG9wZW46IGcyID09PSBNLk9wZW4sIGFjdGl2ZTogUzIgfHwgZzIgPT09IE0uT3BlbiwgZGlzYWJsZWQ6IHMyLCBob3ZlcjogTSQxMiwgZm9jdXM6IEEyLCBhdXRvZm9jdXM6IG8zIH0pLCBbZzIsIE0kMTIsIEEyLCBTMiwgczIsIG8zXSksIFUyID0gXyQyKF8yKCksIHsgcmVmOiB0MiwgaWQ6IG4yLCB0eXBlOiBlJDEoVCQxMiwgYzIuY3VycmVudCksIFwiYXJpYS1oYXNwb3B1cFwiOiBcIm1lbnVcIiwgXCJhcmlhLWNvbnRyb2xzXCI6IHAyID09IG51bGwgPyB2b2lkIDAgOiBwMi5pZCwgXCJhcmlhLWV4cGFuZGVkXCI6IGcyID09PSBNLk9wZW4sIGRpc2FibGVkOiBzMiB8fCB2b2lkIDAsIGF1dG9Gb2N1czogbzMsIG9uS2V5RG93bjogUjIsIG9uS2V5VXA6IEkyLCBvbk1vdXNlRG93bjogRjIgfSwgZjIsIEwyLCBPMik7XG4gIHJldHVybiBMJDIoKSh7IG91clByb3BzOiBVMiwgdGhlaXJQcm9wczogUDIsIHNsb3Q6IHgyLCBkZWZhdWx0VGFnOiBZZSwgbmFtZTogXCJNZW51LkJ1dHRvblwiIH0pO1xufVxubGV0IGV0ID0gXCJkaXZcIiwgdHQgPSBPJDEuUmVuZGVyU3RyYXRlZ3kgfCBPJDEuU3RhdGljO1xuZnVuY3Rpb24gb3QoVDIsIEUyKSB7XG4gIGxldCBpMiA9IHVzZUlkJDEoKSwgeyBpZDogYTMgPSBcXGBoZWFkbGVzc3VpLW1lbnUtaXRlbXMtXFwke2kyfVxcYCwgYW5jaG9yOiBuMiwgcG9ydGFsOiBzMiA9ICExLCBtb2RhbDogbzMgPSAhMCwgdHJhbnNpdGlvbjogUDIgPSAhMSwgLi4uYzIgfSA9IFQyLCBfMiA9IHhlKG4yKSwgdDIgPSBsKFwiTWVudS5JdGVtc1wiKSwgW1IkMTIsIEkyXSA9IFJlKF8yKSwgZzIgPSBiZSgpLCBbcDIsIEYyXSA9IHVzZVN0YXRlKG51bGwpLCBBMiA9IHkkNChFMiwgXzIgPyBSJDEyIDogbnVsbCwgbyQ0KChlMikgPT4gdDIuc2VuZCh7IHR5cGU6IGIuU2V0SXRlbXNFbGVtZW50LCBlbGVtZW50OiBlMiB9KSksIEYyKSwgW2YyLCBNJDEyXSA9IFMkMSh0MiwgKGUyKSA9PiBbZTIubWVudVN0YXRlLCBlMi5idXR0b25FbGVtZW50XSksIEwyID0gbiQxKE0kMTIpLCBTMiA9IG4kMShwMik7XG4gIF8yICYmIChzMiA9ICEwKTtcbiAgbGV0IE8yID0gdSQyKCksIFt4MiwgVTJdID0geCQxKFAyLCBwMiwgTzIgIT09IG51bGwgPyAoTzIgJiBpJDIuT3BlbikgPT09IGkkMi5PcGVuIDogZjIgPT09IE0uT3Blbik7XG4gIG0kMih4MiwgTSQxMiwgKCkgPT4ge1xuICAgIHQyLnNlbmQoeyB0eXBlOiBiLkNsb3NlTWVudSB9KTtcbiAgfSk7XG4gIGxldCBHJDEyID0gUyQxKHQyLCAoZTIpID0+IGUyLl9fZGVtb01vZGUpLCBsJDEyID0gRyQxMiA/ICExIDogbzMgJiYgZjIgPT09IE0uT3BlbjtcbiAgZiQyKGwkMTIsIFMyKTtcbiAgbGV0IEgyID0gRyQxMiA/ICExIDogbzMgJiYgZjIgPT09IE0uT3BlbjtcbiAgeSQzKEgyLCB7IGFsbG93ZWQ6IHVzZUNhbGxiYWNrKCgpID0+IFtNJDEyLCBwMl0sIFtNJDEyLCBwMl0pIH0pO1xuICBsZXQgdTIgPSBmMiAhPT0gTS5PcGVuLCBhZSA9IHMkMSh1MiwgTSQxMikgPyAhMSA6IHgyO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBlMiA9IHAyO1xuICAgIGUyICYmIGYyID09PSBNLk9wZW4gJiYgZTIgIT09IChTMiA9PSBudWxsID8gdm9pZCAwIDogUzIuYWN0aXZlRWxlbWVudCkgJiYgZTIuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhMCB9KTtcbiAgfSwgW2YyLCBwMiwgUzJdKSwgRiQxKGYyID09PSBNLk9wZW4sIHsgY29udGFpbmVyOiBwMiwgYWNjZXB0KGUyKSB7XG4gICAgcmV0dXJuIGUyLmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwibWVudWl0ZW1cIiA/IE5vZGVGaWx0ZXIuRklMVEVSX1JFSkVDVCA6IGUyLmhhc0F0dHJpYnV0ZShcInJvbGVcIikgPyBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQIDogTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUO1xuICB9LCB3YWxrKGUyKSB7XG4gICAgZTIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm5vbmVcIik7XG4gIH0gfSk7XG4gIGxldCBxMiA9IHAkMigpLCBzZSA9IG8kNCgoZTIpID0+IHtcbiAgICB2YXIgTjIsIHosIFE7XG4gICAgc3dpdGNoIChxMi5kaXNwb3NlKCksIGUyLmtleSkge1xuICAgICAgY2FzZSBvJDMuU3BhY2U6XG4gICAgICAgIGlmICh0Mi5zdGF0ZS5zZWFyY2hRdWVyeSAhPT0gXCJcIikgcmV0dXJuIGUyLnByZXZlbnREZWZhdWx0KCksIGUyLnN0b3BQcm9wYWdhdGlvbigpLCB0Mi5zZW5kKHsgdHlwZTogYi5TZWFyY2gsIHZhbHVlOiBlMi5rZXkgfSk7XG4gICAgICBjYXNlIG8kMy5FbnRlcjpcbiAgICAgICAgaWYgKGUyLnByZXZlbnREZWZhdWx0KCksIGUyLnN0b3BQcm9wYWdhdGlvbigpLCB0Mi5zdGF0ZS5hY3RpdmVJdGVtSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBsZXQgeyBkYXRhUmVmOiBkZSB9ID0gdDIuc3RhdGUuaXRlbXNbdDIuc3RhdGUuYWN0aXZlSXRlbUluZGV4XTtcbiAgICAgICAgICAoeiA9IChOMiA9IGRlLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBOMi5kb21SZWYuY3VycmVudCkgPT0gbnVsbCB8fCB6LmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdDIuc2VuZCh7IHR5cGU6IGIuQ2xvc2VNZW51IH0pLCBHKHQyLnN0YXRlLmJ1dHRvbkVsZW1lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbyQzLkFycm93RG93bjpcbiAgICAgICAgcmV0dXJuIGUyLnByZXZlbnREZWZhdWx0KCksIGUyLnN0b3BQcm9wYWdhdGlvbigpLCB0Mi5zZW5kKHsgdHlwZTogYi5Hb1RvSXRlbSwgZm9jdXM6IGMkMS5OZXh0IH0pO1xuICAgICAgY2FzZSBvJDMuQXJyb3dVcDpcbiAgICAgICAgcmV0dXJuIGUyLnByZXZlbnREZWZhdWx0KCksIGUyLnN0b3BQcm9wYWdhdGlvbigpLCB0Mi5zZW5kKHsgdHlwZTogYi5Hb1RvSXRlbSwgZm9jdXM6IGMkMS5QcmV2aW91cyB9KTtcbiAgICAgIGNhc2UgbyQzLkhvbWU6XG4gICAgICBjYXNlIG8kMy5QYWdlVXA6XG4gICAgICAgIHJldHVybiBlMi5wcmV2ZW50RGVmYXVsdCgpLCBlMi5zdG9wUHJvcGFnYXRpb24oKSwgdDIuc2VuZCh7IHR5cGU6IGIuR29Ub0l0ZW0sIGZvY3VzOiBjJDEuRmlyc3QgfSk7XG4gICAgICBjYXNlIG8kMy5FbmQ6XG4gICAgICBjYXNlIG8kMy5QYWdlRG93bjpcbiAgICAgICAgcmV0dXJuIGUyLnByZXZlbnREZWZhdWx0KCksIGUyLnN0b3BQcm9wYWdhdGlvbigpLCB0Mi5zZW5kKHsgdHlwZTogYi5Hb1RvSXRlbSwgZm9jdXM6IGMkMS5MYXN0IH0pO1xuICAgICAgY2FzZSBvJDMuRXNjYXBlOlxuICAgICAgICBlMi5wcmV2ZW50RGVmYXVsdCgpLCBlMi5zdG9wUHJvcGFnYXRpb24oKSwgZmx1c2hTeW5jKCgpID0+IHQyLnNlbmQoeyB0eXBlOiBiLkNsb3NlTWVudSB9KSksIChRID0gdDIuc3RhdGUuYnV0dG9uRWxlbWVudCkgPT0gbnVsbCB8fCBRLmZvY3VzKHsgcHJldmVudFNjcm9sbDogITAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBvJDMuVGFiOlxuICAgICAgICBlMi5wcmV2ZW50RGVmYXVsdCgpLCBlMi5zdG9wUHJvcGFnYXRpb24oKSwgZmx1c2hTeW5jKCgpID0+IHQyLnNlbmQoeyB0eXBlOiBiLkNsb3NlTWVudSB9KSksIGokMih0Mi5zdGF0ZS5idXR0b25FbGVtZW50LCBlMi5zaGlmdEtleSA/IEYkMi5QcmV2aW91cyA6IEYkMi5OZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlMi5rZXkubGVuZ3RoID09PSAxICYmICh0Mi5zZW5kKHsgdHlwZTogYi5TZWFyY2gsIHZhbHVlOiBlMi5rZXkgfSksIHEyLnNldFRpbWVvdXQoKCkgPT4gdDIuc2VuZCh7IHR5cGU6IGIuQ2xlYXJTZWFyY2ggfSksIDM1MCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pLCBsZSA9IG8kNCgoZTIpID0+IHtcbiAgICBzd2l0Y2ggKGUyLmtleSkge1xuICAgICAgY2FzZSBvJDMuU3BhY2U6XG4gICAgICAgIGUyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSksIHBlMiA9IHVzZU1lbW8oKCkgPT4gKHsgb3BlbjogZjIgPT09IE0uT3BlbiB9KSwgW2YyXSksIGllID0gXyQyKF8yID8gZzIoKSA6IHt9LCB7IFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IFMkMSh0MiwgdDIuc2VsZWN0b3JzLmFjdGl2ZURlc2NlbmRhbnRJZCksIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFMkMSh0MiwgKGUyKSA9PiB7XG4gICAgdmFyIE4yO1xuICAgIHJldHVybiAoTjIgPSBlMi5idXR0b25FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogTjIuaWQ7XG4gIH0pLCBpZDogYTMsIG9uS2V5RG93bjogc2UsIG9uS2V5VXA6IGxlLCByb2xlOiBcIm1lbnVcIiwgdGFiSW5kZXg6IGYyID09PSBNLk9wZW4gPyAwIDogdm9pZCAwLCByZWY6IEEyLCBzdHlsZTogeyAuLi5jMi5zdHlsZSwgLi4uSTIsIFwiLS1idXR0b24td2lkdGhcIjogZCQyKE0kMTIsICEwKS53aWR0aCB9LCAuLi5SKFUyKSB9KSwgdWUgPSBMJDIoKTtcbiAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQob2UsIHsgZW5hYmxlZDogczIgPyBUMi5zdGF0aWMgfHwgeDIgOiAhMSwgb3duZXJEb2N1bWVudDogTDIgfSwgdWUoeyBvdXJQcm9wczogaWUsIHRoZWlyUHJvcHM6IGMyLCBzbG90OiBwZTIsIGRlZmF1bHRUYWc6IGV0LCBmZWF0dXJlczogdHQsIHZpc2libGU6IGFlLCBuYW1lOiBcIk1lbnUuSXRlbXNcIiB9KSk7XG59XG5sZXQgbnQgPSBGcmFnbWVudDtcbmZ1bmN0aW9uIHJ0KFQkMTIsIEUyKSB7XG4gIGxldCBpMiA9IHVzZUlkJDEoKSwgeyBpZDogYTMgPSBcXGBoZWFkbGVzc3VpLW1lbnUtaXRlbS1cXCR7aTJ9XFxgLCBkaXNhYmxlZDogbjIgPSAhMSwgLi4ucyQxMiB9ID0gVCQxMiwgbzMgPSBsKFwiTWVudS5JdGVtXCIpLCBQMiA9IFMkMShvMywgKHUyKSA9PiBvMy5zZWxlY3RvcnMuaXNBY3RpdmUodTIsIGEzKSksIGMyID0gdXNlUmVmKG51bGwpLCBfMiA9IHkkNChFMiwgYzIpLCB0MiA9IFMkMShvMywgKHUyKSA9PiBvMy5zZWxlY3RvcnMuc2hvdWxkU2Nyb2xsSW50b1ZpZXcodTIsIGEzKSk7XG4gIG4kMygoKSA9PiB7XG4gICAgaWYgKHQyKSByZXR1cm4gbyQ1KCkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHZhciB1MiwgSjI7XG4gICAgICAoSjIgPSAodTIgPSBjMi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogdTIuc2Nyb2xsSW50b1ZpZXcpID09IG51bGwgfHwgSjIuY2FsbCh1MiwgeyBibG9jazogXCJuZWFyZXN0XCIgfSk7XG4gICAgfSk7XG4gIH0sIFt0MiwgYzJdKTtcbiAgbGV0IFIyID0gcyhjMiksIEkyID0gdXNlUmVmKHsgZGlzYWJsZWQ6IG4yLCBkb21SZWY6IGMyLCBnZXQgdGV4dFZhbHVlKCkge1xuICAgIHJldHVybiBSMigpO1xuICB9IH0pO1xuICBuJDMoKCkgPT4ge1xuICAgIEkyLmN1cnJlbnQuZGlzYWJsZWQgPSBuMjtcbiAgfSwgW0kyLCBuMl0pLCBuJDMoKCkgPT4gKG8zLmFjdGlvbnMucmVnaXN0ZXJJdGVtKGEzLCBJMiksICgpID0+IG8zLmFjdGlvbnMudW5yZWdpc3Rlckl0ZW0oYTMpKSwgW0kyLCBhM10pO1xuICBsZXQgZzIgPSBvJDQoKCkgPT4ge1xuICAgIG8zLnNlbmQoeyB0eXBlOiBiLkNsb3NlTWVudSB9KTtcbiAgfSksIHAyID0gbyQ0KCh1MikgPT4ge1xuICAgIGlmIChuMikgcmV0dXJuIHUyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgbzMuc2VuZCh7IHR5cGU6IGIuQ2xvc2VNZW51IH0pLCBHKG8zLnN0YXRlLmJ1dHRvbkVsZW1lbnQpO1xuICB9KSwgRjIgPSBvJDQoKCkgPT4ge1xuICAgIGlmIChuMikgcmV0dXJuIG8zLnNlbmQoeyB0eXBlOiBiLkdvVG9JdGVtLCBmb2N1czogYyQxLk5vdGhpbmcgfSk7XG4gICAgbzMuc2VuZCh7IHR5cGU6IGIuR29Ub0l0ZW0sIGZvY3VzOiBjJDEuU3BlY2lmaWMsIGlkOiBhMyB9KTtcbiAgfSksIEEyID0gdSQzKCksIGYyID0gbyQ0KCh1MikgPT4ge1xuICAgIEEyLnVwZGF0ZSh1MiksICFuMiAmJiAoUDIgfHwgbzMuc2VuZCh7IHR5cGU6IGIuR29Ub0l0ZW0sIGZvY3VzOiBjJDEuU3BlY2lmaWMsIGlkOiBhMywgdHJpZ2dlcjogVC5Qb2ludGVyIH0pKTtcbiAgfSksIE0yID0gbyQ0KCh1MikgPT4ge1xuICAgIEEyLndhc01vdmVkKHUyKSAmJiAobjIgfHwgUDIgfHwgbzMuc2VuZCh7IHR5cGU6IGIuR29Ub0l0ZW0sIGZvY3VzOiBjJDEuU3BlY2lmaWMsIGlkOiBhMywgdHJpZ2dlcjogVC5Qb2ludGVyIH0pKTtcbiAgfSksIEwyID0gbyQ0KCh1MikgPT4ge1xuICAgIEEyLndhc01vdmVkKHUyKSAmJiAobjIgfHwgUDIgJiYgbzMuc2VuZCh7IHR5cGU6IGIuR29Ub0l0ZW0sIGZvY3VzOiBjJDEuTm90aGluZyB9KSk7XG4gIH0pLCBbUzIsIE8yXSA9IEsoKSwgW3gyLCBVMl0gPSB3JDEoKSwgRyQxMiA9IHVzZU1lbW8oKCkgPT4gKHsgYWN0aXZlOiBQMiwgZm9jdXM6IFAyLCBkaXNhYmxlZDogbjIsIGNsb3NlOiBnMiB9KSwgW1AyLCBuMiwgZzJdKSwgbCQxMiA9IHsgaWQ6IGEzLCByZWY6IF8yLCByb2xlOiBcIm1lbnVpdGVtXCIsIHRhYkluZGV4OiBuMiA9PT0gITAgPyB2b2lkIDAgOiAtMSwgXCJhcmlhLWRpc2FibGVkXCI6IG4yID09PSAhMCA/ICEwIDogdm9pZCAwLCBcImFyaWEtbGFiZWxsZWRieVwiOiBTMiwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IHgyLCBkaXNhYmxlZDogdm9pZCAwLCBvbkNsaWNrOiBwMiwgb25Gb2N1czogRjIsIG9uUG9pbnRlckVudGVyOiBmMiwgb25Nb3VzZUVudGVyOiBmMiwgb25Qb2ludGVyTW92ZTogTTIsIG9uTW91c2VNb3ZlOiBNMiwgb25Qb2ludGVyTGVhdmU6IEwyLCBvbk1vdXNlTGVhdmU6IEwyIH0sIEgyID0gTCQyKCk7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE8yLCBudWxsLCBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFUyLCBudWxsLCBIMih7IG91clByb3BzOiBsJDEyLCB0aGVpclByb3BzOiBzJDEyLCBzbG90OiBHJDEyLCBkZWZhdWx0VGFnOiBudCwgbmFtZTogXCJNZW51Lkl0ZW1cIiB9KSkpO1xufVxubGV0IGF0ID0gXCJkaXZcIjtcbmZ1bmN0aW9uIHN0KFQyLCBFMikge1xuICBsZXQgW2kyLCBhM10gPSBLKCksIG4yID0gVDIsIHMyID0geyByZWY6IEUyLCBcImFyaWEtbGFiZWxsZWRieVwiOiBpMiwgcm9sZTogXCJncm91cFwiIH0sIG8zID0gTCQyKCk7XG4gIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGEzLCBudWxsLCBvMyh7IG91clByb3BzOiBzMiwgdGhlaXJQcm9wczogbjIsIHNsb3Q6IHt9LCBkZWZhdWx0VGFnOiBhdCwgbmFtZTogXCJNZW51LlNlY3Rpb25cIiB9KSk7XG59XG5sZXQgbHQgPSBcImhlYWRlclwiO1xuZnVuY3Rpb24gcHQoVDIsIEUyKSB7XG4gIGxldCBpMiA9IHVzZUlkJDEoKSwgeyBpZDogYTMgPSBcXGBoZWFkbGVzc3VpLW1lbnUtaGVhZGluZy1cXCR7aTJ9XFxgLCAuLi5uMiB9ID0gVDIsIHMyID0gUCQxKCk7XG4gIG4kMygoKSA9PiBzMi5yZWdpc3RlcihhMyksIFthMywgczIucmVnaXN0ZXJdKTtcbiAgbGV0IG8zID0geyBpZDogYTMsIHJlZjogRTIsIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIC4uLnMyLnByb3BzIH07XG4gIHJldHVybiBMJDIoKSh7IG91clByb3BzOiBvMywgdGhlaXJQcm9wczogbjIsIHNsb3Q6IHt9LCBkZWZhdWx0VGFnOiBsdCwgbmFtZTogXCJNZW51LkhlYWRpbmdcIiB9KTtcbn1cbmxldCBpdCA9IFwiZGl2XCI7XG5mdW5jdGlvbiB1dChUMiwgRTIpIHtcbiAgbGV0IGkyID0gVDIsIGEzID0geyByZWY6IEUyLCByb2xlOiBcInNlcGFyYXRvclwiIH07XG4gIHJldHVybiBMJDIoKSh7IG91clByb3BzOiBhMywgdGhlaXJQcm9wczogaTIsIHNsb3Q6IHt9LCBkZWZhdWx0VGFnOiBpdCwgbmFtZTogXCJNZW51LlNlcGFyYXRvclwiIH0pO1xufVxubGV0IGR0ID0gSyQxKFFlKSwgbXQgPSBLJDEoWmUpLCBUdCA9IEskMShvdCksIGZ0ID0gSyQxKHJ0KSwgY3QgPSBLJDEoc3QpLCB5dCA9IEskMShwdCksIEV0ID0gSyQxKHV0KSwgdG8gPSBPYmplY3QuYXNzaWduKGR0LCB7IEJ1dHRvbjogbXQsIEl0ZW1zOiBUdCwgSXRlbTogZnQsIFNlY3Rpb246IGN0LCBIZWFkaW5nOiB5dCwgU2VwYXJhdG9yOiBFdCB9KSwgTCA9IFwidGV4dGFyZWFcIjtcbmZ1bmN0aW9uIEgoczIsIGwyKSB7XG4gIGxldCBpMiA9IHVzZUlkJDEoKSwgZDIgPSB1JDYoKSwgbjIgPSBhJDkoKSwgeyBpZDogcDIgPSBkMiB8fCBcXGBoZWFkbGVzc3VpLXRleHRhcmVhLVxcJHtpMn1cXGAsIGRpc2FibGVkOiBlMiA9IG4yIHx8ICExLCBhdXRvRm9jdXM6IHIyID0gITEsIGludmFsaWQ6IGEzID0gITEsIC4uLlQyIH0gPSBzMiwgZjIgPSBJJDIoKSwgbTIgPSBVJDEoKSwgeyBpc0ZvY3VzZWQ6IG8zLCBmb2N1c1Byb3BzOiB1MiB9ID0gJGY3ZGNlZmZjNWFkNzc2OGIkZXhwb3J0JDRlMzI4ZjYxYzUzODY4N2YoeyBhdXRvRm9jdXM6IHIyIH0pLCB7IGlzSG92ZXJlZDogdDIsIGhvdmVyUHJvcHM6IGIyIH0gPSAkNjE3OWI5MzY3MDVlNzZkMyRleHBvcnQkYWU3ODBkYWYyOWU2ZDQ1Nih7IGlzRGlzYWJsZWQ6IGUyIH0pLCB5MiA9IF8kMih7IHJlZjogbDIsIGlkOiBwMiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogZjIsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBtMiwgXCJhcmlhLWludmFsaWRcIjogYTMgPyBcInRydWVcIiA6IHZvaWQgMCwgZGlzYWJsZWQ6IGUyIHx8IHZvaWQgMCwgYXV0b0ZvY3VzOiByMiB9LCB1MiwgYjIpLCB4MiA9IHVzZU1lbW8oKCkgPT4gKHsgZGlzYWJsZWQ6IGUyLCBpbnZhbGlkOiBhMywgaG92ZXI6IHQyLCBmb2N1czogbzMsIGF1dG9mb2N1czogcjIgfSksIFtlMiwgYTMsIHQyLCBvMywgcjJdKTtcbiAgcmV0dXJuIEwkMigpKHsgb3VyUHJvcHM6IHkyLCB0aGVpclByb3BzOiBUMiwgc2xvdDogeDIsIGRlZmF1bHRUYWc6IEwsIG5hbWU6IFwiVGV4dGFyZWFcIiB9KTtcbn1cbmxldCBKID0gSyQxKEgpO1xuZnVuY3Rpb24gVG9vbGJhckl0ZW0ocHJvcHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlbGF0aXZlIGZsZXggdy1mdWxsIHNocmluay0wIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLCBjaGlsZHJlbjogW1xuICAgIHByb3BzLmNoaWxkcmVuLFxuICAgIHByb3BzLmJhZGdlQ29udGVudCAmJiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJkaXZcIixcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgICBcImJnLWJsdWUtNjAwIHRleHQtd2hpdGVcIixcbiAgICAgICAgICBwcm9wcy5iYWRnZUNsYXNzTmFtZSxcbiAgICAgICAgICBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgcmlnaHQtMCBib3R0b20tMCBmbGV4IGgtMyB3LW1heCBtaW4tdy0zIG1heC13LTggc2VsZWN0LW5vbmUgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRydW5jYXRlIHJvdW5kZWQtZnVsbCBweC0wLjUgZm9udC1zZW1pYm9sZCB0ZXh0LVswLjVlbV1cIlxuICAgICAgICApLFxuICAgICAgICBjaGlsZHJlbjogcHJvcHMuYmFkZ2VDb250ZW50XG4gICAgICB9XG4gICAgKSxcbiAgICBwcm9wcy5zdGF0dXNEb3QgJiYgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgICAgXCJiZy1yb3NlLTYwMCB0ZXh0LXdoaXRlXCIsXG4gICAgICAgICAgcHJvcHMuc3RhdHVzRG90Q2xhc3NOYW1lLFxuICAgICAgICAgIFwicG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSB0b3AtMCByaWdodC0wIHNpemUtMS41IHJvdW5kZWQtZnVsbFwiXG4gICAgICAgIClcbiAgICAgIH1cbiAgICApXG4gIF0gfSk7XG59XG5jb25zdCBUb29sYmFyQnV0dG9uID0gZm9yd2FyZFJlZihcbiAgKHtcbiAgICBiYWRnZUNvbnRlbnQsXG4gICAgYmFkZ2VDbGFzc05hbWUsXG4gICAgc3RhdHVzRG90LFxuICAgIHN0YXR1c0RvdENsYXNzTmFtZSxcbiAgICB0b29sdGlwSGludCxcbiAgICB2YXJpYW50ID0gXCJkZWZhdWx0XCIsXG4gICAgYWN0aXZlLFxuICAgIC4uLnByb3BzXG4gIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBIJDQsXG4gICAgICB7XG4gICAgICAgIHJlZixcbiAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgICAgXCJmbGV4IGN1cnNvci1wb2ludGVyIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLWZ1bGwgYmctcmFkaWFsIGZyb20tdHJhbnNwYXJlbnQgdG8tdHJhbnNwYXJlbnQgcC0xIHRleHQtY3VycmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0xNTAgaG92ZXI6ZnJvbS0yMCUgaG92ZXI6ZnJvbS16aW5jLTEwMC80MCBob3Zlcjp0by03NSUgaG92ZXI6dG8temluYy0xMDAvMFwiLFxuICAgICAgICAgIHZhcmlhbnQgPT09IFwiZGVmYXVsdFwiID8gXCJzaXplLThcIiA6IFwiaC04IHJvdW5kZWQtZnVsbFwiLFxuICAgICAgICAgIGFjdGl2ZSAmJiBcImZyb20tMzAlIGZyb20temluYy0xMDAvNjAgdG8tNzUlIHRvLXppbmMtMTAwLzAgZmlsbC1bdmFyKC0tYWN0aXZlKV0gc3Ryb2tlLVt2YXIoLS1hY3RpdmUpXSB0ZXh0LVt2YXIoLS1hY3RpdmUpXVwiLFxuICAgICAgICAgIHByb3BzLmNsYXNzTmFtZVxuICAgICAgICApXG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFRvb2xiYXJJdGVtLFxuICAgICAge1xuICAgICAgICBiYWRnZUNvbnRlbnQsXG4gICAgICAgIGJhZGdlQ2xhc3NOYW1lLFxuICAgICAgICBzdGF0dXNEb3QsXG4gICAgICAgIHN0YXR1c0RvdENsYXNzTmFtZSxcbiAgICAgICAgY2hpbGRyZW46IGJ1dHRvblxuICAgICAgfVxuICAgICk7XG4gIH1cbik7XG5Ub29sYmFyQnV0dG9uLmRpc3BsYXlOYW1lID0gXCJUb29sYmFyQnV0dG9uXCI7XG5mdW5jdGlvbiBUb29sYmFyU2VjdGlvbih7IGNoaWxkcmVuIH0pIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmFkZS1pbiBzbGlkZS1pbi1mcm9tLXJpZ2h0LTIgZmxleCBtYXgtaC1zbSBtYXgtdy1mdWxsIGFuaW1hdGUtaW4gc25hcC1zdGFydCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIGdhcC0xIHB5LTAuNVwiLCBjaGlsZHJlbiB9KTtcbn1cbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgdG9LZWJhYkNhc2UgPSAoc3RyaW5nKSA9PiBzdHJpbmcucmVwbGFjZSgvKFthLXowLTldKShbQS1aXSkvZywgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpLCB0b0NhbWVsQ2FzZSA9IChzdHJpbmcpID0+IHN0cmluZy5yZXBsYWNlKFxuICAvXihbQS1aXSl8W1xcXFxzLV9dKyhcXFxcdykvZyxcbiAgKG1hdGNoLCBwMSwgcDIpID0+IHAyID8gcDIudG9VcHBlckNhc2UoKSA6IHAxLnRvTG93ZXJDYXNlKClcbiksIHRvUGFzY2FsQ2FzZSA9IChzdHJpbmcpID0+IHtcbiAgY29uc3QgY2FtZWxDYXNlID0gdG9DYW1lbENhc2Uoc3RyaW5nKTtcbiAgcmV0dXJuIGNhbWVsQ2FzZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGNhbWVsQ2FzZS5zbGljZSgxKTtcbn0sIG1lcmdlQ2xhc3NlcyA9ICguLi5jbGFzc2VzKSA9PiBjbGFzc2VzLmZpbHRlcigoY2xhc3NOYW1lLCBpbmRleDIsIGFycmF5KSA9PiAhIWNsYXNzTmFtZSAmJiBjbGFzc05hbWUudHJpbSgpICE9PSBcIlwiICYmIGFycmF5LmluZGV4T2YoY2xhc3NOYW1lKSA9PT0gaW5kZXgyKS5qb2luKFwiIFwiKS50cmltKCksIGhhc0ExMXlQcm9wID0gKHByb3BzKSA9PiB7XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcylcbiAgICBpZiAocHJvcC5zdGFydHNXaXRoKFwiYXJpYS1cIikgfHwgcHJvcCA9PT0gXCJyb2xlXCIgfHwgcHJvcCA9PT0gXCJ0aXRsZVwiKVxuICAgICAgcmV0dXJuICEwO1xufTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGRlZmF1bHRBdHRyaWJ1dGVzID0ge1xuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICB3aWR0aDogMjQsXG4gIGhlaWdodDogMjQsXG4gIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gIHN0cm9rZVdpZHRoOiAyLFxuICBzdHJva2VMaW5lY2FwOiBcInJvdW5kXCIsXG4gIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCJcbn07XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41MjMuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IEljb24gPSBmb3J3YXJkUmVmKFxuICAoe1xuICAgIGNvbG9yID0gXCJjdXJyZW50Q29sb3JcIixcbiAgICBzaXplOiBzaXplMiA9IDI0LFxuICAgIHN0cm9rZVdpZHRoID0gMixcbiAgICBhYnNvbHV0ZVN0cm9rZVdpZHRoLFxuICAgIGNsYXNzTmFtZSA9IFwiXCIsXG4gICAgY2hpbGRyZW4sXG4gICAgaWNvbk5vZGUsXG4gICAgLi4ucmVzdFxuICB9LCByZWYpID0+IGNyZWF0ZUVsZW1lbnQoXG4gICAgXCJzdmdcIixcbiAgICB7XG4gICAgICByZWYsXG4gICAgICAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgIHdpZHRoOiBzaXplMixcbiAgICAgIGhlaWdodDogc2l6ZTIsXG4gICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IGFic29sdXRlU3Ryb2tlV2lkdGggPyBOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQgLyBOdW1iZXIoc2l6ZTIpIDogc3Ryb2tlV2lkdGgsXG4gICAgICBjbGFzc05hbWU6IG1lcmdlQ2xhc3NlcyhcImx1Y2lkZVwiLCBjbGFzc05hbWUpLFxuICAgICAgLi4uIWNoaWxkcmVuICYmICFoYXNBMTF5UHJvcChyZXN0KSAmJiB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSxcbiAgICAgIC4uLnJlc3RcbiAgICB9LFxuICAgIFtcbiAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgIC4uLkFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dXG4gICAgXVxuICApXG4pO1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTIzLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBjcmVhdGVMdWNpZGVJY29uID0gKGljb25OYW1lLCBpY29uTm9kZSkgPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmKFxuICAgICh7IGNsYXNzTmFtZSwgLi4ucHJvcHMgfSwgcmVmKSA9PiBjcmVhdGVFbGVtZW50KEljb24sIHtcbiAgICAgIHJlZixcbiAgICAgIGljb25Ob2RlLFxuICAgICAgY2xhc3NOYW1lOiBtZXJnZUNsYXNzZXMoXG4gICAgICAgIFxcYGx1Y2lkZS1cXCR7dG9LZWJhYkNhc2UodG9QYXNjYWxDYXNlKGljb25OYW1lKSl9XFxgLFxuICAgICAgICBcXGBsdWNpZGUtXFwke2ljb25OYW1lfVxcYCxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICApLFxuICAgICAgLi4ucHJvcHNcbiAgICB9KVxuICApO1xuICByZXR1cm4gQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gdG9QYXNjYWxDYXNlKGljb25OYW1lKSwgQ29tcG9uZW50O1xufTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgX19pY29uTm9kZSRlID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJtNSAxMiA3LTcgNyA3XCIsIGtleTogXCJoYXYwdmdcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTEyIDE5VjVcIiwga2V5OiBcIngwbXE5clwiIH1dXG5dLCBBcnJvd1VwID0gY3JlYXRlTHVjaWRlSWNvbihcImFycm93LXVwXCIsIF9faWNvbk5vZGUkZSk7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41MjMuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IF9faWNvbk5vZGUkZCA9IFtbXCJwYXRoXCIsIHsgZDogXCJNMjAgNiA5IDE3bC01LTVcIiwga2V5OiBcIjFnbWYyY1wiIH1dXSwgQ2hlY2sgPSBjcmVhdGVMdWNpZGVJY29uKFwiY2hlY2tcIiwgX19pY29uTm9kZSRkKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgX19pY29uTm9kZSRjID0gW1tcInBhdGhcIiwgeyBkOiBcIm02IDkgNiA2IDYtNlwiLCBrZXk6IFwicXJ1bnNsXCIgfV1dLCBDaGV2cm9uRG93biA9IGNyZWF0ZUx1Y2lkZUljb24oXCJjaGV2cm9uLWRvd25cIiwgX19pY29uTm9kZSRjKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgX19pY29uTm9kZSRiID0gW1tcInBhdGhcIiwgeyBkOiBcIm0xOCAxNS02LTYtNiA2XCIsIGtleTogXCIxNTN1ZHpcIiB9XV0sIENoZXZyb25VcCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJjaGV2cm9uLXVwXCIsIF9faWNvbk5vZGUkYik7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41MjMuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IF9faWNvbk5vZGUkYSA9IFtcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTJcIiwgY3k6IFwiMTJcIiwgcjogXCIxMFwiLCBrZXk6IFwiMW1nbGF5XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0xNSA5LTYgNlwiLCBrZXk6IFwiMXV6aHZyXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm05IDkgNiA2XCIsIGtleTogXCJ6MGJpcWZcIiB9XVxuXSwgQ2lyY2xlWCA9IGNyZWF0ZUx1Y2lkZUljb24oXCJjaXJjbGUteFwiLCBfX2ljb25Ob2RlJGEpO1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTIzLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBfX2ljb25Ob2RlJDkgPSBbXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMiAyMGE4IDggMCAxIDAgMC0xNiA4IDggMCAwIDAgMCAxNlpcIiwga2V5OiBcInNvYnZ6NVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgMTRhMiAyIDAgMSAwIDAtNCAyIDIgMCAwIDAgMCA0WlwiLCBrZXk6IFwiMTFpNDk2XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMiAydjJcIiwga2V5OiBcInR1czAzbVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgMjJ2LTJcIiwga2V5OiBcIjFvc2RjcVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtMTcgMjAuNjYtMS0xLjczXCIsIGtleTogXCJlcTNvcmJcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTExIDEwLjI3IDcgMy4zNFwiLCBrZXk6IFwiMTZwZjloXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0yMC42NiAxNy0xLjczLTFcIiwga2V5OiBcInNnMHY2ZlwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtMy4zNCA3IDEuNzMgMVwiLCBrZXk6IFwiMXVsb25kXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xNCAxMmg4XCIsIGtleTogXCI0ZjQzaTlcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTIgMTJoMlwiLCBrZXk6IFwiMXQ4ZjhuXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0yMC42NiA3LTEuNzMgMVwiLCBrZXk6IFwiMW93MDVuXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0zLjM0IDE3IDEuNzMtMVwiLCBrZXk6IFwibnVrNzY0XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0xNyAzLjM0LTEgMS43M1wiLCBrZXk6IFwiMndlbDhzXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIm0xMSAxMy43My00IDYuOTNcIiwga2V5OiBcIjc5NHR0Z1wiIH1dXG5dLCBDb2cgPSBjcmVhdGVMdWNpZGVJY29uKFwiY29nXCIsIF9faWNvbk5vZGUkOSk7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41MjMuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IF9faWNvbk5vZGUkOCA9IFtbXCJwYXRoXCIsIHsgZDogXCJNMjEgMTJhOSA5IDAgMSAxLTYuMjE5LTguNTZcIiwga2V5OiBcIjEzemFsZFwiIH1dXSwgTG9hZGVyQ2lyY2xlID0gY3JlYXRlTHVjaWRlSWNvbihcImxvYWRlci1jaXJjbGVcIiwgX19pY29uTm9kZSQ4KTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgX19pY29uTm9kZSQ3ID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNNy45IDIwQTkgOSAwIDEgMCA0IDE2LjFMMiAyMlpcIiwga2V5OiBcInZ2MTFzZFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNOS4wOSA5YTMgMyAwIDAgMSA1LjgzIDFjMCAyLTMgMy0zIDNcIiwga2V5OiBcIjF1Nzczc1wiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMTIgMTdoLjAxXCIsIGtleTogXCJwMzJwMDVcIiB9XVxuXSwgTWVzc2FnZUNpcmNsZVF1ZXN0aW9uTWFyayA9IGNyZWF0ZUx1Y2lkZUljb24oXCJtZXNzYWdlLWNpcmNsZS1xdWVzdGlvbi1tYXJrXCIsIF9faWNvbk5vZGUkNyk7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41MjMuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IF9faWNvbk5vZGUkNiA9IFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTcuOSAyMEE5IDkgMCAxIDAgNCAxNi4xTDIgMjJaXCIsIGtleTogXCJ2djExc2RcIiB9XVxuXSwgTWVzc2FnZUNpcmNsZSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJtZXNzYWdlLWNpcmNsZVwiLCBfX2ljb25Ob2RlJDYpO1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTIzLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBfX2ljb25Ob2RlJDUgPSBbXG4gIFtcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0xNS4zOSA0LjM5YTEgMSAwIDAgMCAxLjY4LS40NzQgMi41IDIuNSAwIDEgMSAzLjAxNCAzLjAxNSAxIDEgMCAwIDAtLjQ3NCAxLjY4bDEuNjgzIDEuNjgyYTIuNDE0IDIuNDE0IDAgMCAxIDAgMy40MTRMMTkuNjEgMTUuMzlhMSAxIDAgMCAxLTEuNjgtLjQ3NCAyLjUgMi41IDAgMSAwLTMuMDE0IDMuMDE1IDEgMSAwIDAgMSAuNDc0IDEuNjhsLTEuNjgzIDEuNjgyYTIuNDE0IDIuNDE0IDAgMCAxLTMuNDE0IDBMOC42MSAxOS42MWExIDEgMCAwIDAtMS42OC40NzQgMi41IDIuNSAwIDEgMS0zLjAxNC0zLjAxNSAxIDEgMCAwIDAgLjQ3NC0xLjY4bC0xLjY4My0xLjY4MmEyLjQxNCAyLjQxNCAwIDAgMSAwLTMuNDE0TDQuMzkgOC42MWExIDEgMCAwIDEgMS42OC40NzQgMi41IDIuNSAwIDEgMCAzLjAxNC0zLjAxNSAxIDEgMCAwIDEtLjQ3NC0xLjY4bDEuNjgzLTEuNjgyYTIuNDE0IDIuNDE0IDAgMCAxIDMuNDE0IDB6XCIsXG4gICAgICBrZXk6IFwidzQ2ZHI1XCJcbiAgICB9XG4gIF1cbl0sIFB1enpsZSA9IGNyZWF0ZUx1Y2lkZUljb24oXCJwdXp6bGVcIiwgX19pY29uTm9kZSQ1KTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgX19pY29uTm9kZSQ0ID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMyAxMmE5IDkgMCAwIDEgOS05IDkuNzUgOS43NSAwIDAgMSA2Ljc0IDIuNzRMMjEgOFwiLCBrZXk6IFwidjloNXZjXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0yMSAzdjVoLTVcIiwga2V5OiBcIjFxN3RvMFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMjEgMTJhOSA5IDAgMCAxLTkgOSA5Ljc1IDkuNzUgMCAwIDEtNi43NC0yLjc0TDMgMTZcIiwga2V5OiBcIjN1aWZsM1wiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNOCAxNkgzdjVcIiwga2V5OiBcIjFjdjY3OFwiIH1dXG5dLCBSZWZyZXNoQ3cgPSBjcmVhdGVMdWNpZGVJY29uKFwicmVmcmVzaC1jd1wiLCBfX2ljb25Ob2RlJDQpO1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTIzLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBfX2ljb25Ob2RlJDMgPSBbXG4gIFtcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0xMi4yMiAyaC0uNDRhMiAyIDAgMCAwLTIgMnYuMThhMiAyIDAgMCAxLTEgMS43M2wtLjQzLjI1YTIgMiAwIDAgMS0yIDBsLS4xNS0uMDhhMiAyIDAgMCAwLTIuNzMuNzNsLS4yMi4zOGEyIDIgMCAwIDAgLjczIDIuNzNsLjE1LjFhMiAyIDAgMCAxIDEgMS43MnYuNTFhMiAyIDAgMCAxLTEgMS43NGwtLjE1LjA5YTIgMiAwIDAgMC0uNzMgMi43M2wuMjIuMzhhMiAyIDAgMCAwIDIuNzMuNzNsLjE1LS4wOGEyIDIgMCAwIDEgMiAwbC40My4yNWEyIDIgMCAwIDEgMSAxLjczVjIwYTIgMiAwIDAgMCAyIDJoLjQ0YTIgMiAwIDAgMCAyLTJ2LS4xOGEyIDIgMCAwIDEgMS0xLjczbC40My0uMjVhMiAyIDAgMCAxIDIgMGwuMTUuMDhhMiAyIDAgMCAwIDIuNzMtLjczbC4yMi0uMzlhMiAyIDAgMCAwLS43My0yLjczbC0uMTUtLjA4YTIgMiAwIDAgMS0xLTEuNzR2LS41YTIgMiAwIDAgMSAxLTEuNzRsLjE1LS4wOWEyIDIgMCAwIDAgLjczLTIuNzNsLS4yMi0uMzhhMiAyIDAgMCAwLTIuNzMtLjczbC0uMTUuMDhhMiAyIDAgMCAxLTIgMGwtLjQzLS4yNWEyIDIgMCAwIDEtMS0xLjczVjRhMiAyIDAgMCAwLTItMnpcIixcbiAgICAgIGtleTogXCIxcW1lMmZcIlxuICAgIH1cbiAgXSxcbiAgW1wiY2lyY2xlXCIsIHsgY3g6IFwiMTJcIiwgY3k6IFwiMTJcIiwgcjogXCIzXCIsIGtleTogXCIxdjd6cmRcIiB9XVxuXSwgU2V0dGluZ3MgPSBjcmVhdGVMdWNpZGVJY29uKFwic2V0dGluZ3NcIiwgX19pY29uTm9kZSQzKTtcbi8qKlxuICogQGxpY2Vuc2UgbHVjaWRlLXJlYWN0IHYwLjUyMy4wIC0gSVNDXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgSVNDIGxpY2Vuc2UuXG4gKiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuY29uc3QgX19pY29uTm9kZSQyID0gW1xuICBbXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJtMjEuNzMgMTgtOC0xNGEyIDIgMCAwIDAtMy40OCAwbC04IDE0QTIgMiAwIDAgMCA0IDIxaDE2YTIgMiAwIDAgMCAxLjczLTNcIixcbiAgICAgIGtleTogXCJ3bW9lbnFcIlxuICAgIH1cbiAgXSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTEyIDl2NFwiLCBrZXk6IFwianV6cHU3XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0xMiAxN2guMDFcIiwga2V5OiBcInAzMnAwNVwiIH1dXG5dLCBUcmlhbmdsZUFsZXJ0ID0gY3JlYXRlTHVjaWRlSWNvbihcInRyaWFuZ2xlLWFsZXJ0XCIsIF9faWNvbk5vZGUkMik7XG4vKipcbiAqIEBsaWNlbnNlIGx1Y2lkZS1yZWFjdCB2MC41MjMuMCAtIElTQ1xuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIElTQyBsaWNlbnNlLlxuICogU2VlIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmNvbnN0IF9faWNvbk5vZGUkMSA9IFtcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTEyIDIwaC4wMVwiLCBrZXk6IFwiemVrZWk5XCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk04LjUgMTYuNDI5YTUgNSAwIDAgMSA3IDBcIiwga2V5OiBcIjFieWNmZlwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNNSAxMi44NTlhMTAgMTAgMCAwIDEgNS4xNy0yLjY5XCIsIGtleTogXCIxZGwxd2ZcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwiTTE5IDEyLjg1OWExMCAxMCAwIDAgMC0yLjAwNy0xLjUyM1wiLCBrZXk6IFwiNGsyM2tuXCIgfV0sXG4gIFtcInBhdGhcIiwgeyBkOiBcIk0yIDguODJhMTUgMTUgMCAwIDEgNC4xNzctMi42NDNcIiwga2V5OiBcIjFncmhqcFwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJNMjIgOC44MmExNSAxNSAwIDAgMC0xMS4yODgtMy43NjRcIiwga2V5OiBcInozandieVwiIH1dLFxuICBbXCJwYXRoXCIsIHsgZDogXCJtMiAyIDIwIDIwXCIsIGtleTogXCIxb29ld3lcIiB9XVxuXSwgV2lmaU9mZiA9IGNyZWF0ZUx1Y2lkZUljb24oXCJ3aWZpLW9mZlwiLCBfX2ljb25Ob2RlJDEpO1xuLyoqXG4gKiBAbGljZW5zZSBsdWNpZGUtcmVhY3QgdjAuNTIzLjAgLSBJU0NcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBJU0MgbGljZW5zZS5cbiAqIFNlZSB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5jb25zdCBfX2ljb25Ob2RlID0gW1xuICBbXCJwYXRoXCIsIHsgZDogXCJNMTggNiA2IDE4XCIsIGtleTogXCIxYmw1ZjhcIiB9XSxcbiAgW1wicGF0aFwiLCB7IGQ6IFwibTYgNiAxMiAxMlwiLCBrZXk6IFwiZDhiazZ2XCIgfV1cbl0sIFggPSBjcmVhdGVMdWNpZGVJY29uKFwieFwiLCBfX2ljb25Ob2RlKTtcbmZ1bmN0aW9uIFJlZ3VsYXJDb250ZW50KCkge1xuICBjb25zdCB7XG4gICAgaXNTZXR0aW5nc09wZW4sXG4gICAgb3BlblNldHRpbmdzLFxuICAgIGNsb3NlU2V0dGluZ3MsXG4gICAgaXNDaGF0T3BlbixcbiAgICBvcGVuQ2hhdCxcbiAgICBjbG9zZUNoYXQsXG4gICAgb3BlblBsdWdpbk5hbWUsXG4gICAgY2xvc2VQbHVnaW4sXG4gICAgb3BlblBsdWdpblxuICB9ID0gdXNlUGFuZWxzKCksIHsgc3RhcnRQcm9tcHRDcmVhdGlvbiB9ID0gdXNlQ2hhdFN0YXRlKCksIHBsdWdpbnNXaXRoQWN0aW9ucyA9IHVzZVBsdWdpbnMoKS5wbHVnaW5zLmZpbHRlcihcbiAgICAocGx1Z2luKSA9PiBwbHVnaW4ub25BY3Rpb25DbGlja1xuICApO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclNlY3Rpb24sIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBUb29sYmFyQnV0dG9uLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiBpc1NldHRpbmdzT3BlbiA/IGNsb3NlU2V0dGluZ3MgOiBvcGVuU2V0dGluZ3MsXG4gICAgICAgIGFjdGl2ZTogaXNTZXR0aW5nc09wZW4sXG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFNldHRpbmdzLCB7IGNsYXNzTmFtZTogXCJzaXplLTRcIiB9KVxuICAgICAgfVxuICAgICkgfSksXG4gICAgcGx1Z2luc1dpdGhBY3Rpb25zLmxlbmd0aCA+IDAgJiYgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyU2VjdGlvbiwgeyBjaGlsZHJlbjogcGx1Z2luc1dpdGhBY3Rpb25zLm1hcCgocGx1Z2luKSA9PiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgVG9vbGJhckJ1dHRvbixcbiAgICAgIHtcbiAgICAgICAgb25DbGljazogb3BlblBsdWdpbk5hbWUgPT09IHBsdWdpbi5wbHVnaW5OYW1lID8gY2xvc2VQbHVnaW4gOiAoKSA9PiBvcGVuUGx1Z2luKHBsdWdpbi5wbHVnaW5OYW1lKSxcbiAgICAgICAgYWN0aXZlOiBvcGVuUGx1Z2luTmFtZSA9PT0gcGx1Z2luLnBsdWdpbk5hbWUsXG4gICAgICAgIGNoaWxkcmVuOiBwbHVnaW4uaWNvblN2ZyA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInNpemUtNCAqOnNpemUtZnVsbFwiLCBjaGlsZHJlbjogcGx1Z2luLmljb25TdmcgfSkgOiAvKiBAX19QVVJFX18gKi8ganN4KFB1enpsZSwgeyBjbGFzc05hbWU6IFwic2l6ZS00XCIgfSlcbiAgICAgIH0sXG4gICAgICBwbHVnaW4ucGx1Z2luTmFtZVxuICAgICkpIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclNlY3Rpb24sIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBUb29sYmFyQnV0dG9uLFxuICAgICAge1xuICAgICAgICBvbkNsaWNrOiBpc0NoYXRPcGVuID8gY2xvc2VDaGF0IDogKCkgPT4ge1xuICAgICAgICAgIG9wZW5DaGF0KCksIHN0YXJ0UHJvbXB0Q3JlYXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlOiBpc0NoYXRPcGVuLFxuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChNZXNzYWdlQ2lyY2xlLCB7IGNsYXNzTmFtZTogXCJzaXplLTRcIiB9KVxuICAgICAgfVxuICAgICkgfSlcbiAgXSB9KTtcbn1cbmZ1bmN0aW9uIERpc2Nvbm5lY3RlZENvbnRlbnQoKSB7XG4gIGNvbnN0IHsgcmVmcmVzaEFnZW50TGlzdCwgaXNSZWZyZXNoaW5nIH0gPSB1c2VBZ2VudHMoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhclNlY3Rpb24sIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgVG9vbGJhckJ1dHRvbixcbiAgICB7XG4gICAgICBvbkNsaWNrOiBpc1JlZnJlc2hpbmcgPyB2b2lkIDAgOiAoKSA9PiByZWZyZXNoQWdlbnRMaXN0KCksXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgUmVmcmVzaEN3LFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBjbihcInNpemUtNFwiLCBpc1JlZnJlc2hpbmcgJiYgXCJhbmltYXRlLXNwaW5cIilcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgKSB9KTtcbn1cbmNvbnN0IExvZ28gPSAoe1xuICBjb2xvciA9IFwiZGVmYXVsdFwiLFxuICBsb2FkaW5nID0gITEsXG4gIGxvYWRpbmdTcGVlZCA9IFwic2xvd1wiLFxuICAuLi5wcm9wc1xufSkgPT4ge1xuICBjb25zdCBjb2xvclN0eWxlID0ge1xuICAgIGRlZmF1bHQ6IFwiZmlsbC1zdGFnZXdpc2UtNzAwIHN0cm9rZS1ub25lXCIsXG4gICAgYmxhY2s6IFwiZmlsbC16aW5jLTk1MCBzdHJva2Utbm9uZVwiLFxuICAgIHdoaXRlOiBcImZpbGwtd2hpdGUgc3Ryb2tlLW5vbmVcIixcbiAgICB6aW5jOiBcImZpbGwtemluYy01MDAvNTAgc3Ryb2tlLW5vbmVcIixcbiAgICBjdXJyZW50OiBcImZpbGwtY3VycmVudCBzdHJva2Utbm9uZVwiLFxuICAgIGdyYWRpZW50OiBcImZpbGwtd2hpdGUgc3Ryb2tlLWJsYWNrLzMwIHN0cm9rZS0xXCJcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcXGByZWxhdGl2ZSBcXCR7Y29sb3IgPT09IFwiZ3JhZGllbnRcIiA/IFwicm91bmRlZC1mdWxsIGJnLVtpbWFnZTp2YXIoLS1ncmFkaWVudCldIGJnLWNvdmVyIGJnLW5vLXJlcGVhdFwiIDogXCJcIn0gXFwke3Byb3BzLmNsYXNzTmFtZSB8fCBcIlwifSBcXCR7bG9hZGluZyA/IFwiZHJvcC1zaGFkb3cteGxcIiA6IFwiXCJ9IGFzcGVjdC1zcXVhcmUgb3ZlcmZsb3ctdmlzaWJsZVxcYCxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICAgIFwic3ZnXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBcXGBhYnNvbHV0ZSBvdmVyZmxvdy12aXNpYmxlIFxcJHtjb2xvciA9PT0gXCJncmFkaWVudFwiID8gXCJ0b3AtWzI1JV0gbGVmdC1bMjUlXSBoLVs1MCVdIHctWzUwJV1cIiA6IFwidG9wLTAgbGVmdC0wIGgtZnVsbCB3LWZ1bGxcIn1cXGAsXG4gICAgICAgICAgICB2aWV3Qm94OiBcIjAgMCAyMDQ4IDIwNDhcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJ0aXRsZVwiLCB7IGNoaWxkcmVuOiBcInN0YWdld2lzZVwiIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICAgIFwiZWxsaXBzZVwiLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY29sb3JTdHlsZVtjb2xvcl0gKyAobG9hZGluZyA/IFwiIGFuaW1hdGUtcHVsc2VcIiA6IFwiXCIpLFxuICAgICAgICAgICAgICAgICAgaWQ6IFwicGF0aDNcIixcbiAgICAgICAgICAgICAgICAgIHJ5OiBcIjYyNFwiLFxuICAgICAgICAgICAgICAgICAgcng6IFwiNjI0XCIsXG4gICAgICAgICAgICAgICAgICBjeTogXCIxMDI0XCIsXG4gICAgICAgICAgICAgICAgICBjeDogXCIxMDI0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgXCJzdmdcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFxcYGFic29sdXRlIG92ZXJmbG93LXZpc2libGUgXFwke2NvbG9yID09PSBcImdyYWRpZW50XCIgPyBcInRvcC1bMjUlXSBsZWZ0LVsyNSVdIGgtWzUwJV0gdy1bNTAlXVwiIDogXCJ0b3AtMCBsZWZ0LTAgaC1mdWxsIHctZnVsbFwifVxcYCxcbiAgICAgICAgICAgIHZpZXdCb3g6IFwiMCAwIDIwNDggMjA0OFwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICAgIFwicGF0aFwiLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IFwicGF0aDRcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwib3JpZ2luLWNlbnRlciBcIiArIGNvbG9yU3R5bGVbY29sb3JdICsgKGxvYWRpbmcgPyBsb2FkaW5nU3BlZWQgPT09IFwiZmFzdFwiID8gXCIgYW5pbWF0ZS1zcGluLWZhc3RcIiA6IFwiIGFuaW1hdGUtc3Bpbi1zbG93XCIgOiBcIlwiKSxcbiAgICAgICAgICAgICAgICBkOiBcIk0gMTAyNCAwIEEgMTAyNCAxMDI0IDAgMCAwIDAgMTAyNCBBIDEwMjQgMTAyNCAwIDAgMCAxMDI0IDIwNDggTCAxNzM2IDIwNDggTCAxODQ4IDIwNDggQyAxOTU4Ljc5OTggMjA0OCAyMDQ4IDE5NTguNzk5OCAyMDQ4IDE4NDggTCAyMDQ4IDE3MzYgTCAyMDQ4IDEwMjQgQSAxMDI0IDEwMjQgMCAwIDAgMTAyNCAwIHogTSAxMDI0Ljk0MTQgMjAwIEEgODI0IDgyNCAwIDAgMSAxODQ4Ljk0MTQgMTAyNCBBIDgyNCA4MjQgMCAwIDEgMTAyNC45NDE0IDE4NDggQSA4MjQgODI0IDAgMCAxIDIwMC45NDE0MSAxMDI0IEEgODI0IDgyNCAwIDAgMSAxMDI0Ljk0MTQgMjAwIHogXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn0sIEFuaW1hdGVkR3JhZGllbnRCYWNrZ3JvdW5kID0gKHtcbiAgY2xhc3NOYW1lXG59KSA9PiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgXCJzdmdcIixcbiAge1xuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgODAwIDgwMFwiLFxuICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwieE1pZFlNaWQgc2xpY2VcIixcbiAgICBjbGFzc05hbWUsXG4gICAgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkZWZzXCIsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJmaWx0ZXJcIiwgeyBpZDogXCJibHVyXCIsIHg6IFwiLTUwJVwiLCB5OiBcIi01MCVcIiwgd2lkdGg6IFwiMjAwJVwiLCBoZWlnaHQ6IFwiMjAwJVwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImZlR2F1c3NpYW5CbHVyXCIsIHsgaW46IFwiU291cmNlR3JhcGhpY1wiLCBzdGREZXZpYXRpb246IFwiODBcIiB9KSB9KSB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJyZWN0XCIsIHsgd2lkdGg6IFwiODAwXCIsIGhlaWdodDogXCI4MDBcIiwgZmlsbDogXCIjMDAwZjY4XCIgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImdcIiwgeyBmaWx0ZXI6IFwidXJsKCNibHVyKVwiLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImNpcmNsZVwiLCB7IGN4OiBcIjEwMFwiLCBjeTogXCI0MDBcIiwgcjogXCIyNjBcIiwgZmlsbDogXCIjMWU5MGZmXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiBcImN4XCIsXG4gICAgICAgICAgICAgIGR1cjogXCIxNXNcIixcbiAgICAgICAgICAgICAgYmVnaW46IFwiMHNcIixcbiAgICAgICAgICAgICAgdmFsdWVzOiBcIjEwMDsgNzAwOyAxMDBcIixcbiAgICAgICAgICAgICAgcmVwZWF0Q291bnQ6IFwiaW5kZWZpbml0ZVwiLFxuICAgICAgICAgICAgICBjYWxjTW9kZTogXCJzcGxpbmVcIixcbiAgICAgICAgICAgICAga2V5VGltZXM6IFwiMDsgMC41OyAxXCIsXG4gICAgICAgICAgICAgIGtleVNwbGluZXM6IFwiMC40MiAwIDAuNTggMTsgMC40MiAwIDAuNTggMVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgXCJhbmltYXRlXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiY3lcIixcbiAgICAgICAgICAgICAgZHVyOiBcIjIwc1wiLFxuICAgICAgICAgICAgICBiZWdpbjogXCIwLjFzXCIsXG4gICAgICAgICAgICAgIHZhbHVlczogXCI0MDA7IDEwMDsgNDAwXCIsXG4gICAgICAgICAgICAgIHJlcGVhdENvdW50OiBcImluZGVmaW5pdGVcIixcbiAgICAgICAgICAgICAgY2FsY01vZGU6IFwic3BsaW5lXCIsXG4gICAgICAgICAgICAgIGtleVRpbWVzOiBcIjA7IDAuNTsgMVwiLFxuICAgICAgICAgICAgICBrZXlTcGxpbmVzOiBcIjAuNDIgMCAwLjU4IDE7IDAuNDIgMCAwLjU4IDFcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJjaXJjbGVcIiwgeyBjeDogXCI3MDBcIiwgY3k6IFwiMTAwXCIsIHI6IFwiMjIwXCIsIGZpbGw6IFwiI2MzMDBmZlwiLCBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICBcImFuaW1hdGVcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogXCJjeFwiLFxuICAgICAgICAgICAgICBkdXI6IFwiMTJzXCIsXG4gICAgICAgICAgICAgIGJlZ2luOiBcIjAuMnNcIixcbiAgICAgICAgICAgICAgdmFsdWVzOiBcIjcwMDsgMTAwOyA3MDBcIixcbiAgICAgICAgICAgICAgcmVwZWF0Q291bnQ6IFwiaW5kZWZpbml0ZVwiLFxuICAgICAgICAgICAgICBjYWxjTW9kZTogXCJzcGxpbmVcIixcbiAgICAgICAgICAgICAga2V5VGltZXM6IFwiMDsgMC41OyAxXCIsXG4gICAgICAgICAgICAgIGtleVNwbGluZXM6IFwiMC40MiAwIDAuNTggMTsgMC40MiAwIDAuNTggMVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgXCJhbmltYXRlXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiY3lcIixcbiAgICAgICAgICAgICAgZHVyOiBcIjEwc1wiLFxuICAgICAgICAgICAgICBiZWdpbjogXCIwLjNzXCIsXG4gICAgICAgICAgICAgIHZhbHVlczogXCIxMDA7IDcwMDsgMTAwXCIsXG4gICAgICAgICAgICAgIHJlcGVhdENvdW50OiBcImluZGVmaW5pdGVcIixcbiAgICAgICAgICAgICAgY2FsY01vZGU6IFwic3BsaW5lXCIsXG4gICAgICAgICAgICAgIGtleVRpbWVzOiBcIjA7IDAuNTsgMVwiLFxuICAgICAgICAgICAgICBrZXlTcGxpbmVzOiBcIjAuNDIgMCAwLjU4IDE7IDAuNDIgMCAwLjU4IDFcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJjaXJjbGVcIiwgeyBjeDogXCI0MDBcIiwgY3k6IFwiNzAwXCIsIHI6IFwiMjQwXCIsIGZpbGw6IFwiIzAwNTVmZlwiLCBjaGlsZHJlbjogW1xuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgICBcImFuaW1hdGVcIixcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogXCJjeFwiLFxuICAgICAgICAgICAgICBkdXI6IFwiMThzXCIsXG4gICAgICAgICAgICAgIGJlZ2luOiBcIjAuNHNcIixcbiAgICAgICAgICAgICAgdmFsdWVzOiBcIjQwMDsgNTAwOyAyMDA7IDQwMFwiLFxuICAgICAgICAgICAgICByZXBlYXRDb3VudDogXCJpbmRlZmluaXRlXCIsXG4gICAgICAgICAgICAgIGNhbGNNb2RlOiBcInNwbGluZVwiLFxuICAgICAgICAgICAgICBrZXlUaW1lczogXCIwOyAwLjMzOyAwLjY3OyAxXCIsXG4gICAgICAgICAgICAgIGtleVNwbGluZXM6IFwiMC40MiAwIDAuNTggMTsgMC40MiAwIDAuNTggMTsgMC40MiAwIDAuNTggMVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKSxcbiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgXCJhbmltYXRlXCIsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IFwiY3lcIixcbiAgICAgICAgICAgICAgZHVyOiBcIjIyc1wiLFxuICAgICAgICAgICAgICBiZWdpbjogXCIwLjVzXCIsXG4gICAgICAgICAgICAgIHZhbHVlczogXCI3MDA7IDQwMDsgNzAwXCIsXG4gICAgICAgICAgICAgIHJlcGVhdENvdW50OiBcImluZGVmaW5pdGVcIixcbiAgICAgICAgICAgICAgY2FsY01vZGU6IFwic3BsaW5lXCIsXG4gICAgICAgICAgICAgIGtleVRpbWVzOiBcIjA7IDAuNTsgMVwiLFxuICAgICAgICAgICAgICBrZXlTcGxpbmVzOiBcIjAuNDIgMCAwLjU4IDE7IDAuNDIgMCAwLjU4IDFcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgXSB9KVxuICAgICAgXSB9KVxuICAgIF1cbiAgfVxuKTtcbmZ1bmN0aW9uIFRvb2xiYXIoe1xuICBkcmFnZ2FibGVIYW5kbGVSZWYsXG4gIHBvc2l0aW9uLFxuICBpc0RyYWdnZWRcbn0pIHtcbiAgY29uc3QgeyBtaW5pbWl6ZWQsIG1pbmltaXplLCBleHBhbmQgfSA9IHVzZUFwcFN0YXRlKCksIHsgcmVxdWlyZXNVc2VyQXR0ZW50aW9uLCBpc0luaXRpYWxMb2FkIH0gPSB1c2VBZ2VudHMoKSwgeyBpc0F2YWlsYWJsZSB9ID0gdXNlQWdlbnRBdmFpbGFiaWxpdHkoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIEdsYXNzeSxcbiAgICB7XG4gICAgICBhczogXCJkaXZcIixcbiAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgIFwicG9pbnRlci1ldmVudHMtYXV0byBhYnNvbHV0ZSB6LTEwIG9yaWdpbi1jZW50ZXIgcm91bmRlZC1mdWxsIHAtMC41IHNoYWRvdy1tZCB0cmFuc2l0aW9uLXRyYW5zZm9ybSBkdXJhdGlvbi01MDAgZWFzZS1zcHJpbmdcIixcbiAgICAgICAgbWluaW1pemVkIHx8IGlzSW5pdGlhbExvYWQgPyBcInNpemUtMTAgYmctYmx1ZS05NTAvODBcIiA6IFwic2l6ZS1hdXRvXCIsXG4gICAgICAgIGlzRHJhZ2dlZCAmJiBcInNjYWxlLTExMCBiZy1za3ktMTAwLzYwIHNoYWRvdy1sZyBzaGFkb3ctc2t5LTUwMC8xMCBibHVyLVswLjJweF1cIixcbiAgICAgICAgIXJlcXVpcmVzVXNlckF0dGVudGlvbiAmJiBpc0F2YWlsYWJsZSA/IFwiWy0tYWN0aXZlLXNlY29uZGFyeTp2YXIoLS1jb2xvci1ibHVlLTEwMCldIFstLWFjdGl2ZTp2YXIoLS1jb2xvci1ibHVlLTYwMCldIFstLXByaW1hcnk6dmFyKC0tY29sb3ItemluYy05NTApXSBbLS1zZWNvbmRhcnk6dmFyKC0tY29sb3ItemluYy00MDApXVwiIDogXCJiZy1vcmFuZ2UtMjAwLzUwIFstLWFjdGl2ZS1zZWNvbmRhcnk6dmFyKC0tY29sb3Itb3JhbmdlLTEwMCldIFstLWFjdGl2ZTp2YXIoLS1jb2xvci1vcmFuZ2UtNjAwKV0gWy0tcHJpbWFyeTp2YXIoLS1jb2xvci1vcmFuZ2UtOTAwKV0gWy0tc2Vjb25kYXJ5OnZhcigtLWNvbG9yLW9yYW5nZS0xMDApXVwiLFxuICAgICAgICBcInN0cm9rZS1bdmFyKC0tcHJpbWFyeSldIHRleHQtW3ZhcigtLXByaW1hcnkpXVwiXG4gICAgICApLFxuICAgICAgcmVmOiBkcmFnZ2FibGVIYW5kbGVSZWYsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICBIJDQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgb25DbGljazogKCkgPT4gZXhwYW5kKCksXG4gICAgICAgICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICAgICAgICBcImFic29sdXRlIGxlZnQtMCB6LTUwIGZsZXggc2l6ZS0xMCBvcmlnaW4tY2VudGVyIGN1cnNvci1wb2ludGVyIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBvdmVyZmxvdy1oaWRkZW4gcm91bmRlZC1mdWxsIGJvcmRlciBib3JkZXItemluYy01MDAvMjAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tNTAwIGVhc2Utc3ByaW5nIGhvdmVyOm9wYWNpdHktOTBcIixcbiAgICAgICAgICAgICAgbWluaW1pemVkIHx8IGlzSW5pdGlhbExvYWQgPyBcInBvaW50ZXItZXZlbnRzLWF1dG8gc2NhbGUtMTAwIG9wYWNpdHktMTAwIGJsdXItbm9uZVwiIDogXCJwb2ludGVyLWV2ZW50cy1ub25lIHNjYWxlLTI1IG9wYWNpdHktMCBibHVyLW1kXCIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uLmlzVG9wSGFsZiA/IFwidG9wLTBcIiA6IFwiYm90dG9tLTBcIixcbiAgICAgICAgICAgICAgKHJlcXVpcmVzVXNlckF0dGVudGlvbiB8fCAhaXNBdmFpbGFibGUpICYmIFwiYmctb3JhbmdlLTUwMFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgIXJlcXVpcmVzVXNlckF0dGVudGlvbiAmJiBpc0F2YWlsYWJsZSAmJiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCQxLCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChBbmltYXRlZEdyYWRpZW50QmFja2dyb3VuZCwgeyBjbGFzc05hbWU6IFwiLXotMTAgYWJzb2x1dGUgaW5zZXQtMCBzaXplLWZ1bGxcIiB9KSxcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KExvZ28sIHsgY29sb3I6IFwid2hpdGVcIiwgY2xhc3NOYW1lOiBcIm1yLXB4IG1iLXB4IHNpemUtMS8yIHNoYWRvdy0yeHNcIiB9KVxuICAgICAgICAgICAgICBdIH0pLFxuICAgICAgICAgICAgICByZXF1aXJlc1VzZXJBdHRlbnRpb24gJiYgLyogQF9fUFVSRV9fICovIGpzeChXaWZpT2ZmLCB7IGNsYXNzTmFtZTogXCJzaXplLTUgc3Ryb2tlLXdoaXRlXCIgfSksXG4gICAgICAgICAgICAgICFyZXF1aXJlc1VzZXJBdHRlbnRpb24gJiYgIWlzQXZhaWxhYmxlICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goVHJpYW5nbGVBbGVydCwgeyBjbGFzc05hbWU6IFwic2l6ZS01IHN0cm9rZS13aGl0ZVwiIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgICAgICAgIFwiZmxleCBoLVtjYWxjLXNpemUoYXV0byxzaXplKV0gc2NhbGUtMTAwIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBkaXZpZGUteSBkaXZpZGUtYm9yZGVyLzIwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTUwMCBlYXNlLXNwcmluZ1wiLFxuICAgICAgICAgICAgICBwb3NpdGlvbi5pc1RvcEhhbGYgPyBcIm9yaWdpbi10b3AgZmxleC1jb2wtcmV2ZXJzZSBkaXZpZGUteS1yZXZlcnNlXCIgOiBcIm9yaWdpbi1ib3R0b20gZmxleC1jb2xcIixcbiAgICAgICAgICAgICAgbWluaW1pemVkICYmIFwicG9pbnRlci1ldmVudHMtbm9uZSBoLTAgc2NhbGUtNTAgb3BhY2l0eS0wIGJsdXItbWRcIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICFyZXF1aXJlc1VzZXJBdHRlbnRpb24gJiYgaXNBdmFpbGFibGUgPyAvKiBAX19QVVJFX18gKi8ganN4KFJlZ3VsYXJDb250ZW50LCB7fSkgOiAvKiBAX19QVVJFX18gKi8ganN4KERpc2Nvbm5lY3RlZENvbnRlbnQsIHt9KSxcbiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChUb29sYmFyU2VjdGlvbiwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgICBUb29sYmFyQnV0dG9uLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG1pbmltaXplLFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgICAgICAgICAgICAgXCJoLTVcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24uaXNUb3BIYWxmID8gXCJyb3VuZGVkLXQtM3hsIHJvdW5kZWQtYi1sZ1wiIDogXCJyb3VuZGVkLXQtbGcgcm91bmRlZC1iLTN4bFwiXG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IHBvc2l0aW9uLmlzVG9wSGFsZiA/IC8qIEBfX1BVUkVfXyAqLyBqc3goQ2hldnJvblVwLCB7IGNsYXNzTmFtZTogXCJzaXplLTRcIiB9KSA6IC8qIEBfX1BVUkVfXyAqLyBqc3goQ2hldnJvbkRvd24sIHsgY2xhc3NOYW1lOiBcInNpemUtNFwiIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gQWdlbnRTZWxlY3Rpb24oe1xuICBzaG93Q29ubmVjdGVkRGV0YWlscyA9ICExXG59KSB7XG4gIGNvbnN0IHtcbiAgICBjb25uZWN0ZWQsXG4gICAgcmVmcmVzaEFnZW50TGlzdCxcbiAgICBpc1JlZnJlc2hpbmcsXG4gICAgYXZhaWxhYmxlQWdlbnRzLFxuICAgIGNvbm5lY3RBZ2VudFxuICB9ID0gdXNlQWdlbnRzKCksIGhhbmRsZUFnZW50Q2hhbmdlID0gKGUyKSA9PiB7XG4gICAgY29uc3QgcG9ydCA9IE51bWJlci5wYXJzZUludChlMi50YXJnZXQudmFsdWUpO1xuICAgIHBvcnQgJiYgY29ubmVjdEFnZW50KHBvcnQpO1xuICB9LCBwbGFjZWhvbGRlclRleHQgPSBhdmFpbGFibGVBZ2VudHMubGVuZ3RoID4gMCA/IFwiU2VsZWN0IGFuIGFnZW50Li4uXCIgOiBcIk5vIGFnZW50cyBhdmFpbGFibGVcIjtcbiAgcmV0dXJuIGlzUmVmcmVzaGluZyA/IGF2YWlsYWJsZUFnZW50cy5sZW5ndGggPiAwID8gXCJTY2FubmluZyBmb3IgYWRkaXRpb25hbCBhZ2VudHMuLi5cIiA6IFwiU2Nhbm5pbmcgZm9yIGF2YWlsYWJsZSBhZ2VudHMuLi5cIiA6IGF2YWlsYWJsZUFnZW50cy5sZW5ndGggPT09IDAgPyBcIk5vIGFnZW50cyBmb3VuZC4gTWFrZSBzdXJlIHRoZSBzdGFnZXdpc2UgZXh0ZW5zaW9uIGlzIGluc3RhbGxlZCBhbmQgcnVubmluZy5cIiA6IG51bGwsIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNwYWNlLXktM1wiLCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICBcImxhYmVsXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBodG1sRm9yOiBcImFnZW50LXNlbGVjdFwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJtYi0yIGJsb2NrIGZvbnQtbWVkaXVtIHRleHQtZm9yZWdyb3VuZCB0ZXh0LXNtXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIFwiQWdlbnRcIixcbiAgICAgICAgICAgIGlzUmVmcmVzaGluZyAmJiAvKiBAX19QVVJFX18gKi8ganN4KFJlZnJlc2hDdywgeyBjbGFzc05hbWU6IFwibWwtMiBpbmxpbmUgc2l6ZS0zIGFuaW1hdGUtc3BpbiB0ZXh0LW11dGVkLWZvcmVncm91bmRcIiB9KVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmxleCB3LWZ1bGwgaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogXCJhZ2VudC1zZWxlY3RcIixcbiAgICAgICAgICB2YWx1ZTogKGNvbm5lY3RlZCA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGVkLnBvcnQpIHx8IFwiXCIsXG4gICAgICAgICAgb25DaGFuZ2U6IGhhbmRsZUFnZW50Q2hhbmdlLFxuICAgICAgICAgIGNsYXNzTmFtZTogXCJoLTggbWluLXctMCBmbGV4LTEgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLXppbmMtOTUwLzEwIGJnLXppbmMtNTAwLzEwIHB4LTMgdGV4dC1zbSByaW5nLTEgcmluZy13aGl0ZS8yMCBmb2N1czpib3JkZXItemluYy01MDAgZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJvcHRpb25cIiwgeyB2YWx1ZTogXCJcIiwgZGlzYWJsZWQ6ICEwLCBjaGlsZHJlbjogcGxhY2Vob2xkZXJUZXh0IH0pLFxuICAgICAgICAgICAgYXZhaWxhYmxlQWdlbnRzLm1hcCgoYWdlbnQpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwib3B0aW9uXCIsIHsgdmFsdWU6IGFnZW50LnBvcnQsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIGFnZW50Lm5hbWUsXG4gICAgICAgICAgICAgIFwiIC0gXCIsXG4gICAgICAgICAgICAgIGFnZW50LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICBcIiAtIFBvcnQgXCIsXG4gICAgICAgICAgICAgIGFnZW50LnBvcnRcbiAgICAgICAgICAgIF0gfSwgYWdlbnQucG9ydCkpXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICApIH0pXG4gICAgXSB9KSxcbiAgICBjb25uZWN0ZWQgJiYgc2hvd0Nvbm5lY3RlZERldGFpbHMgJiYgLyogQF9fUFVSRV9fICovIGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicm91bmRlZC1sZyBiZy16aW5jLTk1MC81IHAtM1wiLCBjaGlsZHJlbjogW1xuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcInBcIiwgeyBjbGFzc05hbWU6IFwiZm9udC1tZWRpdW0gdGV4dC1mb3JlZ3JvdW5kIHRleHQtc21cIiwgY2hpbGRyZW46IFwiQWN0aXZlIEFnZW50XCIgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJtdC0yIGZvbnQtc2VtaWJvbGQgdGV4dC1iYXNlIHRleHQtZm9yZWdyb3VuZFwiLCBjaGlsZHJlbjogY29ubmVjdGVkLm5hbWUgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LW11dGVkLWZvcmVncm91bmQgdGV4dC14c1wiLCBjaGlsZHJlbjogY29ubmVjdGVkLmRlc2NyaXB0aW9uIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoXCJwXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtbXV0ZWQtZm9yZWdyb3VuZCB0ZXh0LXhzXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgIFwiUG9ydCBcIixcbiAgICAgICAgY29ubmVjdGVkLnBvcnRcbiAgICAgIF0gfSlcbiAgICBdIH0pXG4gIF0gfSk7XG59XG5jb25zdCBEcm9wZG93bk1lbnUgPSB0bywgRHJvcGRvd25NZW51QnV0dG9uID0gZm9yd2FyZFJlZihcbiAgKHByb3BzLCByZWYpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3gobXQsIHsgYXM6IEZyYWdtZW50LCByZWYsIC4uLnByb3BzIH0pXG4pLCBEcm9wZG93bk1lbnVDb250ZW50ID0gZm9yd2FyZFJlZihcbiAgKHByb3BzLCByZWYpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgVHQsXG4gICAge1xuICAgICAgcmVmLFxuICAgICAgYW5jaG9yOiBcImJvdHRvbVwiLFxuICAgICAgdHJhbnNpdGlvbjogITAsXG4gICAgICBwb3J0YWw6ICEwLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBnbGFzc3lCb3hDbGFzc05hbWUsXG4gICAgICAgIFwiei01MCBmbGV4IHctZml0IG1pbi13LTI0IG1heC13LTkwIGZsZXgtY29sIGl0ZW1zLXN0cmV0Y2gganVzdGlmeS1zdGFydCBnYXAtMSByb3VuZGVkLXhsIHAtMSBzaGFkb3ctYmxhY2svNTAgc2hhZG93LWxnIG91dGxpbmUtbm9uZSBkYXRhLWZvY3VzOm91dGxpbmUtbm9uZVwiLFxuICAgICAgICBwcm9wcy5jbGFzc05hbWVcbiAgICAgIClcbiAgICB9XG4gIClcbiksIERyb3Bkb3duTWVudUl0ZW1TdHlsZXMgPSBcInctZnVsbCBmbGV4IGZsZXgtcm93IHNlbGVjdC1ub25lIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LXN0YXJ0IGdhcC0yIHB5LTEuNSBwbC0yIHByLTYgdHJ1bmNhdGUgb3ZlcmZsb3ctaGlkZGVuIHJvdW5kZWQtbGcgaG92ZXI6YmctemluYy05NTAvMTAgZm9jdXM6dGV4dC16aW5jLTkwMCBjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uLWNvbG9yIGR1cmF0aW9uLTE1MCB0ZXh0LXNtIGZvbnQtbm9ybWFsIHRleHQtZm9yZWdyb3VuZFwiO1xuZm9yd2FyZFJlZihcbiAgKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IGNsYXNzTmFtZSwgLi4uYnV0dG9uUHJvcHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KGZ0LCB7IHJlZiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBIJDQsXG4gICAgICB7XG4gICAgICAgIGFzOiBcImJ1dHRvblwiLFxuICAgICAgICAuLi5idXR0b25Qcm9wcyxcbiAgICAgICAgY2xhc3NOYW1lOiBjbihEcm9wZG93bk1lbnVJdGVtU3R5bGVzLCBjbGFzc05hbWUpXG4gICAgICB9XG4gICAgKSB9KTtcbiAgfVxuKTtcbmNvbnN0IERyb3Bkb3duTWVudUxpbmtJdGVtID0gZm9yd2FyZFJlZihcbiAgKHByb3BzLCByZWYpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goZnQsIHsgcmVmLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcImFcIiwgeyAuLi5wcm9wcywgY2xhc3NOYW1lOiBjbihEcm9wZG93bk1lbnVJdGVtU3R5bGVzLCBwcm9wcy5jbGFzc05hbWUpIH0pIH0pXG4pO1xuZnVuY3Rpb24gU2V0dGluZ3NQYW5lbCgpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFBhbmVsLCB7IGNoaWxkcmVuOiBbXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChQYW5lbEhlYWRlciwgeyB0aXRsZTogXCJTZXR0aW5nc1wiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goUGFuZWxDb250ZW50LCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEFnZW50U2VsZWN0aW9uLCB7IHNob3dDb25uZWN0ZWREZXRhaWxzOiAhMCB9KSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KFBhbmVsRm9vdGVyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhEcm9wZG93bk1lbnUsIHsgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRHJvcGRvd25NZW51QnV0dG9uLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhCdXR0b24sIHsgZ2xhc3N5OiAhMCwgc2l6ZTogXCJzbVwiLCB2YXJpYW50OiBcInNlY29uZGFyeVwiLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KE1lc3NhZ2VDaXJjbGVRdWVzdGlvbk1hcmssIHsgY2xhc3NOYW1lOiBcIm1yLTIgc2l6ZS00XCIgfSksXG4gICAgICAgIFwiTmVlZCBoZWxwP1wiXG4gICAgICBdIH0pIH0pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoRHJvcGRvd25NZW51Q29udGVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIERyb3Bkb3duTWVudUxpbmtJdGVtLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9zdGFnZXdpc2UuaW8vZG9jc1wiLFxuICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFwiUmVhZCB0aGUgZG9jc1wiXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIERyb3Bkb3duTWVudUxpbmtJdGVtLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9kaXNjb3JkLmdnL3k4Z2ROYjREXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJKb2luIHRoZSBjb21tdW5pdHlcIlxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXSB9KVxuICAgIF0gfSkgfSlcbiAgXSB9KTtcbn1cbmZ1bmN0aW9uIENvbnRleHRFbGVtZW50c0NoaXBzKCkge1xuICBjb25zdCB7IGRvbUNvbnRleHRFbGVtZW50cywgcmVtb3ZlQ2hhdERvbUNvbnRleHQgfSA9IHVzZUNoYXRTdGF0ZSgpLCB7IHNldEhvdmVyZWRFbGVtZW50IH0gPSB1c2VDb250ZXh0Q2hpcEhvdmVyKCk7XG4gIHJldHVybiBkb21Db250ZXh0RWxlbWVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwibWItMS41XCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInNjcm9sbGJhci10aGluIGZsZXggZ2FwLTIgb3ZlcmZsb3cteC1hdXRvIHBiLTFcIiwgY2hpbGRyZW46IGRvbUNvbnRleHRFbGVtZW50cy5tYXAoKGNvbnRleHRFbGVtZW50LCBpbmRleDIpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgQ29udGV4dEVsZW1lbnRDaGlwLFxuICAgIHtcbiAgICAgIGVsZW1lbnQ6IGNvbnRleHRFbGVtZW50LmVsZW1lbnQsXG4gICAgICBwbHVnaW5Db250ZXh0OiBjb250ZXh0RWxlbWVudC5wbHVnaW5Db250ZXh0LFxuICAgICAgb25EZWxldGU6ICgpID0+IHJlbW92ZUNoYXREb21Db250ZXh0KGNvbnRleHRFbGVtZW50LmVsZW1lbnQpLFxuICAgICAgb25Ib3Zlcjogc2V0SG92ZXJlZEVsZW1lbnQsXG4gICAgICBvblVuaG92ZXI6ICgpID0+IHNldEhvdmVyZWRFbGVtZW50KG51bGwpXG4gICAgfSxcbiAgICBcXGBcXCR7Y29udGV4dEVsZW1lbnQuZWxlbWVudC50YWdOYW1lfS1cXCR7aW5kZXgyfVxcYFxuICApKSB9KSB9KTtcbn1cbmZ1bmN0aW9uIENvbnRleHRFbGVtZW50Q2hpcCh7XG4gIGVsZW1lbnQsXG4gIHBsdWdpbkNvbnRleHQsXG4gIG9uRGVsZXRlLFxuICBvbkhvdmVyLFxuICBvblVuaG92ZXJcbn0pIHtcbiAgY29uc3QgY2hpcExhYmVsID0gdXNlTWVtbygoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBmaXJzdEFubm90YXRpb24gPSAoX2IgPSAoX2EgPSBwbHVnaW5Db250ZXh0LmZpbmQoXG4gICAgICAocGx1Z2luKSA9PiB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiAoX2EyID0gcGx1Z2luLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuYW5ub3RhdGlvbjtcbiAgICAgIH1cbiAgICApKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmFubm90YXRpb247XG4gICAgaWYgKGZpcnN0QW5ub3RhdGlvbilcbiAgICAgIHJldHVybiBmaXJzdEFubm90YXRpb247XG4gICAgY29uc3QgdGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBpZCA9IGVsZW1lbnQuaWQgPyBcXGAjXFwke2VsZW1lbnQuaWR9XFxgIDogXCJcIjtcbiAgICByZXR1cm4gXFxgXFwke3RhZ05hbWV9XFwke2lkfVxcYDtcbiAgfSwgW2VsZW1lbnQsIHBsdWdpbkNvbnRleHRdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgXCJmbGV4IG1pbi13LWZpdCBzaHJpbmstMCBpdGVtcy1jZW50ZXIgZ2FwLTEgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLWJvcmRlci8yMCBiZy13aGl0ZS8xMCBweC0yIHB5LTEgdGV4dC14cyB0cmFuc2l0aW9uLWFsbCBob3Zlcjpib3JkZXItYm9yZGVyLzQwIGhvdmVyOmJnLXdoaXRlLzIwXCJcbiAgICAgICksXG4gICAgICBvbk1vdXNlRW50ZXI6ICgpID0+IG9uSG92ZXIoZWxlbWVudCksXG4gICAgICBvbk1vdXNlTGVhdmU6ICgpID0+IG9uVW5ob3ZlcigpLFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwibWF4LXctMjQgdHJ1bmNhdGUgZm9udC1tZWRpdW0gdGV4dC1mb3JlZ3JvdW5kLzgwXCIsIGNoaWxkcmVuOiBjaGlwTGFiZWwgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogKGUyKSA9PiB7XG4gICAgICAgICAgICAgIGUyLnN0b3BQcm9wYWdhdGlvbigpLCBvbkRlbGV0ZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJ0ZXh0LW11dGVkLWZvcmVncm91bmQgdHJhbnNpdGlvbi1jb2xvcnMgaG92ZXI6dGV4dC1yZWQtNTAwXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChYLCB7IGNsYXNzTmFtZTogXCJzaXplLTNcIiB9KVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgXVxuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIEFnZW50TWVzc2FnZURpc3BsYXkoKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gIGNvbnN0IG1lc3NhZ2luZyA9IHVzZUFnZW50TWVzc2FnaW5nKCksIGFnZW50U3RhdGUgPSB1c2VBZ2VudFN0YXRlKCksIHNjcm9sbENvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKSwgd2FzQXRCb3R0b21SZWYgPSB1c2VSZWYoITApLCBzY3JvbGxUb0JvdHRvbSA9ICgpID0+IHtcbiAgICBjb25zdCBjb250YWluZXIgPSBzY3JvbGxDb250YWluZXJSZWYuY3VycmVudDtcbiAgICBjb250YWluZXIgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb250YWluZXIuc2Nyb2xsVG9wID0gY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICB9LCAwKTtcbiAgfSwgY2hlY2tJZkF0Qm90dG9tID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIHJldHVybiBjb250YWluZXIgPyBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLmNsaWVudEhlaWdodCA+PSBjb250YWluZXIuc2Nyb2xsSGVpZ2h0IC0gMTAgOiAhMDtcbiAgfSwgaGFuZGxlU2Nyb2xsID0gKCkgPT4ge1xuICAgIGNvbnN0IGlzQXRCb3R0b20gPSBjaGVja0lmQXRCb3R0b20oKTtcbiAgICB3YXNBdEJvdHRvbVJlZi5jdXJyZW50ID0gaXNBdEJvdHRvbTtcbiAgfTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2Nyb2xsQ29udGFpbmVyUmVmLmN1cnJlbnQgJiYgd2FzQXRCb3R0b21SZWYuY3VycmVudCAmJiBzY3JvbGxUb0JvdHRvbSgpO1xuICB9LCBbKF9hID0gbWVzc2FnaW5nLmFnZW50TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRlbnRJdGVtcywgYWdlbnRTdGF0ZS5zdGF0ZV0pLCB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgIGlmIChjb250YWluZXIpXG4gICAgICByZXR1cm4gY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlU2Nyb2xsKSwgc2Nyb2xsVG9Cb3R0b20oKSwgd2FzQXRCb3R0b21SZWYuY3VycmVudCA9ICEwLCAoKSA9PiB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XG4gICAgICB9O1xuICB9LCBbXSksICgoX2MgPSAoX2IgPSBtZXNzYWdpbmcuYWdlbnRNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudEl0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2MubGVuZ3RoKSA+IDAgfHwgYWdlbnRTdGF0ZS5zdGF0ZSA9PT0gQWdlbnRTdGF0ZVR5cGUuSURMRSA/IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICByZWY6IHNjcm9sbENvbnRhaW5lclJlZixcbiAgICAgIGNsYXNzTmFtZTogXCJzY3JvbGxiYXItdGhpbiBwb2ludGVyLWV2ZW50cy1hdXRvIHNwYWNlLXktMiBvdmVyZmxvdy15LXNjcm9sbCBvdmVyc2Nyb2xsLWNvbnRhaW4gcHgtMyBweS00IHRleHQtZm9yZWdyb3VuZCB0ZXh0LXNtIGZvY3VzLXdpdGhpbjpvdXRsaW5lLW5vbmUgaG92ZXI6Ymctd2hpdGUvMCBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgICAgIG9uU2Nyb2xsOiBoYW5kbGVTY3JvbGwsXG4gICAgICBvbk1vdXNlRW50ZXI6ICgpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgKF9hMiA9IHNjcm9sbENvbnRhaW5lclJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9hMi5mb2N1cygpO1xuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiAoX2UgPSAoX2QgPSBtZXNzYWdpbmcuYWdlbnRNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuY29udGVudEl0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogX2UubWFwKChpdGVtLCBpbmRleDIpID0+IGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgPyAvKiBAX19QVVJFX18gKi8ganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJ3aGl0ZXNwYWNlLXByZS13cmFwXCIsIGNoaWxkcmVuOiBpdGVtLnRleHQgfSwgXFxgaXRlbV9cXCR7aW5kZXgyICsgMX1cXGApIDogaXRlbS50eXBlID09PSBcImltYWdlXCIgPyAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInRleHQtc21cIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICAgIFwiaW1nXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzcmM6IGl0ZW0uZGF0YSxcbiAgICAgICAgICBhbHQ6IFwiQWdlbnQgbWVzc2FnZSBhdHRhY2htZW50XCIsXG4gICAgICAgICAgY2xhc3NOYW1lOiBcIm1heC13LWZ1bGwgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLWJsYWNrLzE1IHJpbmctMSByaW5nLXdoaXRlLzIwXCJcbiAgICAgICAgfVxuICAgICAgKSB9LCBcXGBpdGVtX1xcJHtpbmRleDIgKyAxfVxcYCkgOiBudWxsKVxuICAgIH1cbiAgKSA6IG51bGw7XG59XG5jb25zdCBERUZBVUxUX1ZBUklBTlRTID0ge1xuICBibHVlOiB7XG4gICAgYWN0aXZlU3BlZWQ6IFwic2xvd1wiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMGQyNTNmXCIsXG4gICAgY29sb3JzOiBbXCIjMWU0MGFmXCIsIFwiIzI1NjNlYlwiLCBcIiMzYjgyZjZcIiwgXCIjNjBhNWZhXCJdXG4gIH0sXG4gIGdyZWVuOiB7XG4gICAgYWN0aXZlU3BlZWQ6IFwiZmFzdFwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMDYyYTIyXCIsXG4gICAgY29sb3JzOiBbXCIjMDU5NjY5XCIsIFwiIzEwYjk4MVwiLCBcIiMzNGQzOTlcIiwgXCIjNmVlN2I3XCJdXG4gIH0sXG4gIHRyYW5zcGFyZW50OiB7XG4gICAgYWN0aXZlU3BlZWQ6IFwic2xvd1wiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgIGNvbG9yczogW1widHJhbnNwYXJlbnRcIiwgXCJ0cmFuc3BhcmVudFwiLCBcInRyYW5zcGFyZW50XCIsIFwidHJhbnNwYXJlbnRcIl1cbiAgfVxufSwgU0hBUEVfREVGQVVMVFMgPSBbXG4gIC8vIFRoaXMgaXMgbm93IGp1c3QgYSB0ZW1wbGF0ZSBmb3IgZ2VuZXJhdGluZyBzaGFwZXMgZm9yIGVhY2ggc3BlZWQgZ3JvdXBcbiAgeyB0eXBlOiBcImNpcmNsZVwiLCBjeDogXCIxNSVcIiwgY3k6IFwiMjAlXCIsIHI6IFwiMzAlXCIsIGNvbG9yOiAxIH0sXG4gIHtcbiAgICB0eXBlOiBcInJlY3RcIixcbiAgICB4OiBcIjUwJVwiLFxuICAgIHk6IFwiMCVcIixcbiAgICB3aWR0aDogXCI0MCVcIixcbiAgICBoZWlnaHQ6IFwiNDAlXCIsXG4gICAgY29sb3I6IDJcbiAgfSxcbiAgeyB0eXBlOiBcImNpcmNsZVwiLCBjeDogXCI3NSVcIiwgY3k6IFwiNjAlXCIsIHI6IFwiMjUlXCIsIGNvbG9yOiAzIH0sXG4gIHtcbiAgICB0eXBlOiBcInJlY3RcIixcbiAgICB4OiBcIjEwJVwiLFxuICAgIHk6IFwiNTUlXCIsXG4gICAgd2lkdGg6IFwiMzUlXCIsXG4gICAgaGVpZ2h0OiBcIjM1JVwiLFxuICAgIGNvbG9yOiA0XG4gIH0sXG4gIHsgdHlwZTogXCJjaXJjbGVcIiwgY3g6IFwiNDAlXCIsIGN5OiBcIjgwJVwiLCByOiBcIjIwJVwiLCBjb2xvcjogMSB9XG5dLCByYW5kb20gPSAobWluMiwgbWF4MikgPT4gTWF0aC5yYW5kb20oKSAqIChtYXgyIC0gbWluMikgKyBtaW4yLCBTaGFwZUdyb3VwID0gKHtcbiAgc2hhcGVzLFxuICBzcGVlZCxcbiAgc3BlZWRDbGFzc1xufSkgPT4ge1xuICBjb25zdCBhbmltYXRpb25NdWx0aXBsaWVycyA9IHVzZU1lbW8oKCkgPT4gc2hhcGVzLm1hcCgoXzIsIGkyKSA9PiAoe1xuICAgIGR1cmF0aW9uOiByYW5kb20oMC44LCAxLjIpLFxuICAgIGRlbGF5OiByYW5kb20oMCwgLTEpLFxuICAgIGRpcmVjdGlvbjogaTIgJSAyID09PSAwID8gXCJhbHRlcm5hdGVcIiA6IFwiYWx0ZXJuYXRlLXJldmVyc2VcIlxuICB9KSksIFtzaGFwZXNdKSwgc2hhcGVzV2l0aENvbG9yVmFyID0gc2hhcGVzLm1hcCgoc2hhcGUsIGkyKSA9PiAoe1xuICAgIC4uLnNoYXBlLFxuICAgIGNvbG9yVmFyOiBcXGAtLWNoYXQtZ3JhZC1iZy1jXFwke3NoYXBlLmNvbG9yfVxcYCxcbiAgICBpZDogXFxgXFwke3NoYXBlLnR5cGV9LVxcJHtzaGFwZS5jb2xvcn0tXFwke2kyfVxcYCxcbiAgICAvLyBCZXR0ZXIga2V5IGZvciBSZWFjdFxuICAgIGFuaW1hdGlvbk11bHRpcGxpZXJzOiBhbmltYXRpb25NdWx0aXBsaWVyc1tpMl1cbiAgfSkpO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcImdcIiwgeyBjbGFzc05hbWU6IHNwZWVkQ2xhc3MsIGNoaWxkcmVuOiBzaGFwZXNXaXRoQ29sb3JWYXIubWFwKChzaGFwZSkgPT4ge1xuICAgIGNvbnN0IG11bHRpcGxpZXJzID0gc2hhcGUuYW5pbWF0aW9uTXVsdGlwbGllcnMsIGFuaW1hdGlvblByb3BzID0ge1xuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IFxcYGNhbGMoXFwke3NwZWVkfXMgKiBcXCR7bXVsdGlwbGllcnMuZHVyYXRpb259KVxcYCxcbiAgICAgIGFuaW1hdGlvbkRlbGF5OiBcXGBjYWxjKFxcJHtzcGVlZH1zICogXFwke211bHRpcGxpZXJzLmRlbGF5fSlcXGAsXG4gICAgICBhbmltYXRpb25EaXJlY3Rpb246IG11bHRpcGxpZXJzLmRpcmVjdGlvblxuICAgIH07XG4gICAgcmV0dXJuIHNoYXBlLnR5cGUgPT09IFwiY2lyY2xlXCIgPyAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgXCJjaXJjbGVcIixcbiAgICAgIHtcbiAgICAgICAgY3g6IHNoYXBlLmN4LFxuICAgICAgICBjeTogc2hhcGUuY3ksXG4gICAgICAgIHI6IHNoYXBlLnIsXG4gICAgICAgIGZpbGw6IFxcYHZhcihcXCR7c2hhcGUuY29sb3JWYXJ9KVxcYCxcbiAgICAgICAgY2xhc3NOYW1lOiBcInNoYXBlLWFuaW1cIixcbiAgICAgICAgc3R5bGU6IGFuaW1hdGlvblByb3BzXG4gICAgICB9LFxuICAgICAgc2hhcGUuaWRcbiAgICApIDogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgIFwicmVjdFwiLFxuICAgICAge1xuICAgICAgICB4OiBzaGFwZS54LFxuICAgICAgICB5OiBzaGFwZS55LFxuICAgICAgICB3aWR0aDogc2hhcGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2hhcGUuaGVpZ2h0LFxuICAgICAgICBmaWxsOiBcXGB2YXIoXFwke3NoYXBlLmNvbG9yVmFyfSlcXGAsXG4gICAgICAgIGNsYXNzTmFtZTogXCJzaGFwZS1hbmltXCIsXG4gICAgICAgIHN0eWxlOiBhbmltYXRpb25Qcm9wc1xuICAgICAgfSxcbiAgICAgIHNoYXBlLmlkXG4gICAgKTtcbiAgfSkgfSk7XG59LCBHcmFkaWVudEJhY2tncm91bmRDaGF0ID0gKHtcbiAgY3VycmVudFZhcmlhbnQsXG4gIHZhcmlhbnRzID0gREVGQVVMVF9WQVJJQU5UUyxcbiAgY2xhc3NOYW1lLFxuICBibHVyQW1vdW50ID0gODAsXG4gIHNoYXBlcyA9IFNIQVBFX0RFRkFVTFRTLFxuICB0cmFuc3BhcmVudCA9ICExXG59KSA9PiB7XG4gIGNvbnN0IFtzdHlsZSwgc2V0U3R5bGVdID0gdXNlU3RhdGUoe30pO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVWYXJpYW50ID0gdmFyaWFudHNbY3VycmVudFZhcmlhbnRdO1xuICAgIGlmICghYWN0aXZlVmFyaWFudCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcXGBWYXJpYW50IFwiXFwke2N1cnJlbnRWYXJpYW50fVwiIG5vdCBmb3VuZCwgZmFsbGluZyBiYWNrIHRvIGRlZmF1bHRcXGBcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZEJlVHJhbnNwYXJlbnQgPSB0cmFuc3BhcmVudCB8fCBjdXJyZW50VmFyaWFudCA9PT0gXCJ0cmFuc3BhcmVudFwiO1xuICAgIHNldFN0eWxlKHtcbiAgICAgIFwiLS1jaGF0LWdyYWQtYmctYmctY29sb3JcIjogYWN0aXZlVmFyaWFudC5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidmFyKC0tY2hhdC1ncmFkLWJnLWJnLWNvbG9yKVwiLFxuICAgICAgXCItLWNoYXQtZ3JhZC1iZy1jMVwiOiBhY3RpdmVWYXJpYW50LmNvbG9yc1swXSxcbiAgICAgIFwiLS1jaGF0LWdyYWQtYmctYzJcIjogYWN0aXZlVmFyaWFudC5jb2xvcnNbMV0sXG4gICAgICBcIi0tY2hhdC1ncmFkLWJnLWMzXCI6IGFjdGl2ZVZhcmlhbnQuY29sb3JzWzJdLFxuICAgICAgXCItLWNoYXQtZ3JhZC1iZy1jNFwiOiBhY3RpdmVWYXJpYW50LmNvbG9yc1szXSxcbiAgICAgIFwiLS1jaGF0LWdyYWQtYmctb3BhY2l0eS1zbG93XCI6IGFjdGl2ZVZhcmlhbnQuYWN0aXZlU3BlZWQgPT09IFwic2xvd1wiID8gMSA6IDAsXG4gICAgICBcIi0tY2hhdC1ncmFkLWJnLW9wYWNpdHktbWVkaXVtXCI6IGFjdGl2ZVZhcmlhbnQuYWN0aXZlU3BlZWQgPT09IFwibWVkaXVtXCIgPyAxIDogMCxcbiAgICAgIFwiLS1jaGF0LWdyYWQtYmctb3BhY2l0eS1mYXN0XCI6IGFjdGl2ZVZhcmlhbnQuYWN0aXZlU3BlZWQgPT09IFwiZmFzdFwiID8gMSA6IDAsXG4gICAgICBcIi0tY2hhdC1ncmFkLWJnLW92ZXJhbGwtb3BhY2l0eVwiOiBzaG91bGRCZVRyYW5zcGFyZW50ID8gMCA6IDEsXG4gICAgICBvcGFjaXR5OiBcInZhcigtLWNoYXQtZ3JhZC1iZy1vdmVyYWxsLW9wYWNpdHkpXCJcbiAgICB9KTtcbiAgfSwgW2N1cnJlbnRWYXJpYW50LCB2YXJpYW50cywgdHJhbnNwYXJlbnRdKSwgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogXFxgYWJzb2x1dGUgaW5zZXQtMCBvdmVyZmxvdy1oaWRkZW4gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMTAwMCBcXCR7Y2xhc3NOYW1lfVxcYCxcbiAgICAgIHN0eWxlLFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgICAgICBcInN2Z1wiLFxuICAgICAgICB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcIi1pbnNldC1bMjUlXSBhYnNvbHV0ZSBoLVsxNTAlXSB3LVsxNTAlXVwiLFxuICAgICAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICAgICAgICByb2xlOiBcInByZXNlbnRhdGlvblwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiZGVmc1wiLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZmlsdGVyXCIsIHsgaWQ6IFwiYmx1ci1maWx0ZXJcIiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJmZUdhdXNzaWFuQmx1clwiLCB7IHN0ZERldmlhdGlvbjogYmx1ckFtb3VudCB9KSB9KSB9KSxcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZ1wiLCB7IGZpbHRlcjogXCJ1cmwoI2JsdXItZmlsdGVyKVwiLCBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFNoYXBlR3JvdXAsIHsgc2hhcGVzLCBzcGVlZDogNDAsIHNwZWVkQ2xhc3M6IFwiZy1zbG93XCIgfSksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goU2hhcGVHcm91cCwgeyBzaGFwZXMsIHNwZWVkOiAyMCwgc3BlZWRDbGFzczogXCJnLW1lZGl1bVwiIH0pLFxuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFNoYXBlR3JvdXAsIHsgc2hhcGVzLCBzcGVlZDogNSwgc3BlZWRDbGFzczogXCJnLWZhc3RcIiB9KVxuICAgICAgICAgICAgXSB9KVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgKTtcbn0sIHRleHRTbGlkZXNob3dWYXJpYW50cyA9IGN2YShcbiAgXCJyZWxhdGl2ZSBibG9jayBoLVsxLjJlbV0gaC1mdWxsIG92ZXJmbG93LWhpZGRlblwiXG4pO1xuZnVuY3Rpb24gVGV4dFNsaWRlc2hvdyh7XG4gIGNsYXNzTmFtZSxcbiAgdGV4dHMsXG4gIGNoYW5nZUV2ZXJ5TXMgPSAzZTMsXG4gIC4uLnByb3BzXG59KSB7XG4gIGNvbnN0IFtjdXJyZW50SW5kZXgsIHNldEN1cnJlbnRJbmRleF0gPSBSZWFjdC51c2VTdGF0ZSgwKSwgW2lzQW5pbWF0aW5nLCBzZXRJc0FuaW1hdGluZ10gPSBSZWFjdC51c2VTdGF0ZSghMSk7XG4gIHJldHVybiBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0ZXh0cy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2V0SXNBbmltYXRpbmcoITApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0Q3VycmVudEluZGV4KChwcmV2SW5kZXgpID0+IChwcmV2SW5kZXggKyAxKSAlIHRleHRzLmxlbmd0aCksIHNldElzQW5pbWF0aW5nKCExKTtcbiAgICAgIH0sIDMwMCk7XG4gICAgfSwgY2hhbmdlRXZlcnlNcyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9LCBbdGV4dHMubGVuZ3RoLCBjaGFuZ2VFdmVyeU1zXSksIHRleHRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICBcInNwYW5cIixcbiAgICB7XG4gICAgICBcImRhdGEtc2xvdFwiOiBcInRleHQtc2xpZGVzaG93XCIsXG4gICAgICBjbGFzc05hbWU6IGNuKHRleHRTbGlkZXNob3dWYXJpYW50cygpLCBjbGFzc05hbWUpLFxuICAgICAgLi4ucHJvcHMsXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgICAgICAgIFwiYWJzb2x1dGUgaW5zZXQtMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXRcIixcbiAgICAgICAgICAgICAgaXNBbmltYXRpbmcgPyBcIi10cmFuc2xhdGUteS0yIHRyYW5zZm9ybSBvcGFjaXR5LTAgYmx1ci1zbVwiIDogXCJ0cmFuc2xhdGUteS0wIHRyYW5zZm9ybSBvcGFjaXR5LTEwMFwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRleHRzW2N1cnJlbnRJbmRleF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFxcYGN1cnJlbnQtXFwke2N1cnJlbnRJbmRleH1cXGBcbiAgICAgICAgKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICAgICAgICBcImFic29sdXRlIGluc2V0LTAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCIsXG4gICAgICAgICAgICAgIGlzQW5pbWF0aW5nID8gXCJ0cmFuc2xhdGUteS0wIG9wYWNpdHktMTAwXCIgOiBcInRyYW5zbGF0ZS15LTIgb3BhY2l0eS0wIGJsdXItc21cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0ZXh0c1soY3VycmVudEluZGV4ICsgMSkgJSB0ZXh0cy5sZW5ndGhdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcXGBuZXh0LVxcJHsoY3VycmVudEluZGV4ICsgMSkgJSB0ZXh0cy5sZW5ndGh9XFxgXG4gICAgICAgIClcbiAgICAgIF1cbiAgICB9XG4gICk7XG59XG5jb25zdCBhZ2VudFN0YXRlVG9UZXh0ID0ge1xuICBbQWdlbnRTdGF0ZVR5cGUuV0FJVElOR19GT1JfVVNFUl9SRVNQT05TRV06IFwiV2FpdGluZyBmb3IgdXNlciByZXNwb25zZVwiLFxuICBbQWdlbnRTdGF0ZVR5cGUuSURMRV06IFwiXCIsXG4gIFtBZ2VudFN0YXRlVHlwZS5USElOS0lOR106IFwiVGhpbmtpbmdcIixcbiAgW0FnZW50U3RhdGVUeXBlLkZBSUxFRF06IFwiRmFpbGVkXCIsXG4gIFtBZ2VudFN0YXRlVHlwZS5DT01QTEVURURdOiBcIkNvbXBsZXRlZFwiLFxuICBbQWdlbnRTdGF0ZVR5cGUuV09SS0lOR106IFwiV29ya2luZ1wiLFxuICBbQWdlbnRTdGF0ZVR5cGUuQ0FMTElOR19UT09MXTogXCJDYWxsaW5nIHRvb2xcIlxufSwgYWdlbnRTdGF0ZVRvSWNvbiA9IHtcbiAgW0FnZW50U3RhdGVUeXBlLldBSVRJTkdfRk9SX1VTRVJfUkVTUE9OU0VdOiAvKiBAX19QVVJFX18gKi8ganN4KE1lc3NhZ2VDaXJjbGVRdWVzdGlvbk1hcmssIHsgY2xhc3NOYW1lOiBcInNpemUtNlwiIH0pLFxuICBbQWdlbnRTdGF0ZVR5cGUuSURMRV06IC8qIEBfX1BVUkVfXyAqLyBqc3goRnJhZ21lbnQkMSwge30pLFxuICBbQWdlbnRTdGF0ZVR5cGUuVEhJTktJTkddOiAvKiBAX19QVVJFX18gKi8ganN4KExvYWRlckNpcmNsZSwgeyBjbGFzc05hbWU6IFwic2l6ZS02IGFuaW1hdGUtc3BpbiBzdHJva2UtdmlvbGV0LTYwMFwiIH0pLFxuICBbQWdlbnRTdGF0ZVR5cGUuRkFJTEVEXTogLyogQF9fUFVSRV9fICovIGpzeChDaXJjbGVYLCB7IGNsYXNzTmFtZTogXCJzaXplLTYgc3Ryb2tlLXJvc2UtNjAwXCIgfSksXG4gIFtBZ2VudFN0YXRlVHlwZS5DT01QTEVURURdOiAvKiBAX19QVVJFX18gKi8ganN4KENoZWNrLCB7IGNsYXNzTmFtZTogXCJzaXplLTYgc3Ryb2tlLWdyZWVuLTYwMFwiIH0pLFxuICBbQWdlbnRTdGF0ZVR5cGUuV09SS0lOR106IC8qIEBfX1BVUkVfXyAqLyBqc3goTG9hZGVyQ2lyY2xlLCB7IGNsYXNzTmFtZTogXCJzaXplLTYgYW5pbWF0ZS1zcGluIHN0cm9rZS1ibHVlLTYwMFwiIH0pLFxuICBbQWdlbnRTdGF0ZVR5cGUuQ0FMTElOR19UT09MXTogLyogQF9fUFVSRV9fICovIGpzeChDb2csIHsgY2xhc3NOYW1lOiBcInNpemUtNiBhbmltYXRlLXNwaW4gc3Ryb2tlLWZ1Y2hzaWEtNzAwXCIgfSlcbn07XG5mdW5jdGlvbiBDaGF0UGFuZWwoKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgYWdlbnRTdGF0ZSA9IHVzZUFnZW50U3RhdGUoKSwgY2hhdFN0YXRlID0gdXNlQ2hhdFN0YXRlKCksIGNoYXRNZXNzYWdpbmcgPSB1c2VBZ2VudE1lc3NhZ2luZygpLCBbaXNDb21wb3NpbmcsIHNldElzQ29tcG9zaW5nXSA9IHVzZVN0YXRlKCExKSwgZW5hYmxlSW5wdXRGaWVsZCA9IHVzZU1lbW8oKCkgPT4gYWdlbnRTdGF0ZS5zdGF0ZSA9PT0gQWdlbnRTdGF0ZVR5cGUuV0FJVElOR19GT1JfVVNFUl9SRVNQT05TRSB8fCBhZ2VudFN0YXRlLnN0YXRlID09PSBBZ2VudFN0YXRlVHlwZS5JRExFLCBbYWdlbnRTdGF0ZS5zdGF0ZV0pLCBjYW5TZW5kTWVzc2FnZSA9IHVzZU1lbW8oKCkgPT4gZW5hYmxlSW5wdXRGaWVsZCAmJiBjaGF0U3RhdGUuY2hhdElucHV0LnRyaW0oKS5sZW5ndGggPiAyICYmIGNoYXRTdGF0ZS5pc1Byb21wdENyZWF0aW9uQWN0aXZlLCBbZW5hYmxlSW5wdXRGaWVsZCwgY2hhdFN0YXRlXSksIGFueU1lc3NhZ2VJbkNoYXQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgX2EyLCBfYjtcbiAgICByZXR1cm4gKChfYiA9IChfYTIgPSBjaGF0TWVzc2FnaW5nLmFnZW50TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5jb250ZW50SXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID4gMDtcbiAgfSwgWyhfYSA9IGNoYXRNZXNzYWdpbmcuYWdlbnRNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY29udGVudEl0ZW1zXSksIGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjaGF0U3RhdGUuc2VuZE1lc3NhZ2UoKSwgY2hhdFN0YXRlLnN0b3BQcm9tcHRDcmVhdGlvbigpO1xuICB9LCBbY2hhdFN0YXRlXSksIGhhbmRsZUtleURvd24gPSB1c2VDYWxsYmFjayhcbiAgICAoZTIpID0+IHtcbiAgICAgIGUyLmtleSA9PT0gXCJFbnRlclwiICYmICFlMi5zaGlmdEtleSAmJiAhaXNDb21wb3NpbmcgJiYgKGUyLnByZXZlbnREZWZhdWx0KCksIGhhbmRsZVN1Ym1pdCgpKTtcbiAgICB9LFxuICAgIFtoYW5kbGVTdWJtaXQsIGlzQ29tcG9zaW5nXVxuICApLCBoYW5kbGVDb21wb3NpdGlvblN0YXJ0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldElzQ29tcG9zaW5nKCEwKTtcbiAgfSwgW10pLCBoYW5kbGVDb21wb3NpdGlvbkVuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRJc0NvbXBvc2luZyghMSk7XG4gIH0sIFtdKSwgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCksIGlzSW50ZW50aW9uYWxseVN0b3BwaW5nUmVmID0gdXNlUmVmKCExKTtcbiAgcmV0dXJuIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIGNvbnN0IGJsdXJIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdmFyIF9hMztcbiAgICAgIGlmIChpc0ludGVudGlvbmFsbHlTdG9wcGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGlzSW50ZW50aW9uYWxseVN0b3BwaW5nUmVmLmN1cnJlbnQgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgKF9hMyA9IGlucHV0UmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2EzLmZvY3VzKCk7XG4gICAgfTtcbiAgICByZXR1cm4gY2hhdFN0YXRlLmlzUHJvbXB0Q3JlYXRpb25BY3RpdmUgJiYgZW5hYmxlSW5wdXRGaWVsZCA/ICgoX2EyID0gaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYTIuZm9jdXMoKSwgKF9iID0gaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVySGFuZGxlciksIGlzSW50ZW50aW9uYWxseVN0b3BwaW5nUmVmLmN1cnJlbnQgPSAhMSkgOiAoaW5wdXRSZWYuY3VycmVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoaXNJbnRlbnRpb25hbGx5U3RvcHBpbmdSZWYuY3VycmVudCA9ICEwKSwgKF9jID0gaW5wdXRSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfYy5ibHVyKCkpLCAoKSA9PiB7XG4gICAgICB2YXIgX2EzO1xuICAgICAgKF9hMyA9IGlucHV0UmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2EzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJIYW5kbGVyKTtcbiAgICB9O1xuICB9LCBbY2hhdFN0YXRlLmlzUHJvbXB0Q3JlYXRpb25BY3RpdmUsIGVuYWJsZUlucHV0RmllbGRdKSwgLyogQF9fUFVSRV9fICovIGpzeHMoXG4gICAgUGFuZWwsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgYW55TWVzc2FnZUluQ2hhdCA/IFwiaC1bMzV2aF0gbWF4LWgtWzUwdmhdIG1pbi1oLVsyMHZoXVwiIDogXCIhaC1bY2FsYy1zaXplKGF1dG8sc2l6ZSldIGgtYXV0byBtaW4taC0wXCJcbiAgICAgICksXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIFBhbmVsSGVhZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgICAgICAgIFwibWItMCBvcmlnaW4tYm90dG9tIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLW91dFwiLFxuICAgICAgICAgICAgICBhZ2VudFN0YXRlLnN0YXRlICE9PSBBZ2VudFN0YXRlVHlwZS5JRExFID8gXCIhaC1bY2FsYy1zaXplKGF1dG8sc2l6ZSldIGgtYXV0b1wiIDogXCJoLTAgc2NhbGUteC03NSBzY2FsZS15LTAgcC0wIG9wYWNpdHktMCBibHVyLW1kXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aXRsZTogLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwidGV4dC1iYXNlXCIsIGNoaWxkcmVuOiBhZ2VudFN0YXRlVG9UZXh0W2FnZW50U3RhdGUuc3RhdGVdIH0pLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGFnZW50U3RhdGUuZGVzY3JpcHRpb24gJiYgLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwidGV4dC1zbVwiLCBjaGlsZHJlbjogYWdlbnRTdGF0ZS5kZXNjcmlwdGlvbiB9KSxcbiAgICAgICAgICAgIGljb25BcmVhOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZsZXggc2l6ZS04IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiLCBjaGlsZHJlbjogT2JqZWN0LnZhbHVlcyhBZ2VudFN0YXRlVHlwZSkubWFwKChzdGF0ZSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChTdGF0ZUljb24sIHsgc2hvdWxkUmVuZGVyOiBhZ2VudFN0YXRlLnN0YXRlID09PSBzdGF0ZSwgY2hpbGRyZW46IGFnZW50U3RhdGVUb0ljb25bc3RhdGVdIH0sIHN0YXRlKSkgfSksXG4gICAgICAgICAgICBhY3Rpb25BcmVhOiAvKiBAX19QVVJFX18gKi8ganN4KEZyYWdtZW50JDEsIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiLXotMTAgcG9pbnRlci1ldmVudHMtbm9uZSBhYnNvbHV0ZSBpbnNldC0wIG92ZXJmbG93LWhpZGRlbiByb3VuZGVkLVtpbmhlcml0XSBvcGFjaXR5LTUwXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICBHcmFkaWVudEJhY2tncm91bmRDaGF0LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNpemUtZnVsbFwiLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYXJpYW50OiBhZ2VudFN0YXRlLnN0YXRlLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBHcmFkaWVudEJhY2tncm91bmRWYXJpYW50cyxcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogYWdlbnRTdGF0ZS5zdGF0ZSA9PT0gQWdlbnRTdGF0ZVR5cGUuSURMRVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApIH0pIH0pXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIFBhbmVsQ29udGVudCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICAgICAgICBcImZsZXggYmFzaXMtW2luaXRpYWxdIGZsZXgtY29sIGdhcC0wIHB4LTEgcHktMFwiLFxuICAgICAgICAgICAgICBhbnlNZXNzYWdlSW5DaGF0ID8gXCIhaC1bY2FsYy1zaXplKGF1dG8sc2l6ZSldIGgtYXV0byBmbGV4LTFcIiA6IFwiaC0wXCIsXG4gICAgICAgICAgICAgIGFnZW50U3RhdGUuc3RhdGUgPT09IEFnZW50U3RhdGVUeXBlLklETEUgPyBcInJvdW5kZWQtdC1baW5oZXJpdF1cIiA6IFwicm91bmRlZC10LW5vbmVcIixcbiAgICAgICAgICAgICAgXCJtYXNrLWFscGhhIG1hc2stW2xpbmVhci1ncmFkaWVudCh0b19ib3R0b20sdHJhbnNwYXJlbnRfMCUsYmxhY2tfNSUsYmxhY2tfOTUlLHRyYW5zcGFyZW50XzEwMCUpXVwiLFxuICAgICAgICAgICAgICBcIm92ZXJmbG93LWhpZGRlblwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQWdlbnRNZXNzYWdlRGlzcGxheSwge30pXG4gICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICAgICAgICBQYW5lbEZvb3RlcixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICAgICAgICBcIm10LTAgZmxleCBvcmlnaW4tdG9wIGZsZXgtY29sIGl0ZW1zLXN0cmV0Y2ggZ2FwLTAgcHgtMiBwdC0xIHBiLTIgZHVyYXRpb24tMTUwIGVhc2Utb3V0XCIsXG4gICAgICAgICAgICAgICFlbmFibGVJbnB1dEZpZWxkICYmIFwicG9pbnRlci1ldmVudHMtbm9uZSBvcGFjaXR5LTgwIGJyaWdodG5lc3MtNzVcIixcbiAgICAgICAgICAgICAgY2hhdFN0YXRlLmlzUHJvbXB0Q3JlYXRpb25BY3RpdmUgJiYgXCJiZy1ibHVlLTQwMC8xMFwiLFxuICAgICAgICAgICAgICBhbnlNZXNzYWdlSW5DaGF0ID8gXCJoLTI0XCIgOiBcImgtMzZcIixcbiAgICAgICAgICAgICAgIWFueU1lc3NhZ2VJbkNoYXQgJiYgYWdlbnRTdGF0ZS5zdGF0ZSA9PT0gQWdlbnRTdGF0ZVR5cGUuSURMRSAmJiBcInJvdW5kZWQtdC1baW5oZXJpdF0gYm9yZGVyLXRyYW5zcGFyZW50IGJvcmRlci10LW5vbmUgcHQtMyBwbC0zXCJcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KENvbnRleHRFbGVtZW50c0NoaXBzLCB7fSksXG4gICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZsZXggZmxleC0xIGZsZXgtcm93IGl0ZW1zLWVuZCBqdXN0aWZ5LWJldHdlZW4gZ2FwLTJcIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJoLWZ1bGwgZmxleC0xXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICAgICAgICBKLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVmOiBpbnB1dFJlZixcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2hhdFN0YXRlLmNoYXRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGUyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGF0U3RhdGUuc2V0Q2hhdElucHV0KGUyLnRhcmdldC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBvbkZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGF0U3RhdGUuc3RhcnRQcm9tcHRDcmVhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgb25LZXlEb3duOiBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcG9zaXRpb25TdGFydDogaGFuZGxlQ29tcG9zaXRpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBvc2l0aW9uRW5kOiBoYW5kbGVDb21wb3NpdGlvbkVuZCxcbiAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZDogIWVuYWJsZUlucHV0RmllbGQsXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIm0tMSBoLWZ1bGwgdy1mdWxsIHJlc2l6ZS1ub25lIGZvY3VzOm91dGxpbmUtbm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYWJzb2x1dGUgaW5zZXQtMCB6LTEwIHAtMVwiLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgICAgICAgVGV4dFNsaWRlc2hvdyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgICAgICAgICAgICAgICAgICBcInRleHQtZm9yZWdyb3VuZC80MCB0ZXh0LXNtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGF0U3RhdGUuY2hhdElucHV0Lmxlbmd0aCAhPT0gMCAmJiBcIm9wYWNpdHktMFwiXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICB0ZXh0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJUcnk6IEFkZCBhIG5ldyBidXR0b24gaW50byB0aGUgdG9wIHJpZ2h0IGNvcm5lclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJUcnk6IENvbnZlcnQgdGhlc2UgY2FyZHMgaW50byBhY2NvcmRpb25zXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlRyeTogQWRkIGEgZ3JhZGllbnQgdG8gdGhlIGJhY2tncm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgKSB9KVxuICAgICAgICAgICAgICAgIF0gfSksXG4gICAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgICAgIEJ1dHRvbixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ6ICFjYW5TZW5kTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb25DbGljazogaGFuZGxlU3VibWl0LFxuICAgICAgICAgICAgICAgICAgICBnbGFzc3k6ICEwLFxuICAgICAgICAgICAgICAgICAgICB2YXJpYW50OiBcInByaW1hcnlcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcInNpemUtOCBjdXJzb3ItcG9pbnRlciByb3VuZGVkLWZ1bGwgcC0xXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KEFycm93VXAsIHsgY2xhc3NOYW1lOiBcInNpemUtNCBzdHJva2UtM1wiIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICBdXG4gICAgfVxuICApO1xufVxuY29uc3QgU3RhdGVJY29uID0gKHtcbiAgY2hpbGRyZW4sXG4gIHNob3VsZFJlbmRlclxufSkgPT4gLyogQF9fUFVSRV9fICovIGpzeChcbiAgXCJkaXZcIixcbiAge1xuICAgIGNsYXNzTmFtZTogY24oXG4gICAgICBcImFic29sdXRlIG9yaWdpbi1jZW50ZXIgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tNTAwIGVhc2Utc3ByaW5nLXNvZnRcIixcbiAgICAgIHNob3VsZFJlbmRlciA/IFwic2NhbGUtMTAwXCIgOiBcInNjYWxlLTAgb3BhY2l0eS0wIGJsdXItbWRcIlxuICAgICksXG4gICAgY2hpbGRyZW5cbiAgfVxuKSwgR3JhZGllbnRCYWNrZ3JvdW5kVmFyaWFudHMgPSB7XG4gIFtBZ2VudFN0YXRlVHlwZS5XQUlUSU5HX0ZPUl9VU0VSX1JFU1BPTlNFXToge1xuICAgIGFjdGl2ZVNwZWVkOiBcInNsb3dcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidmFyKC0tY29sb3ItYmx1ZS0yMDApXCIsXG4gICAgY29sb3JzOiBbXG4gICAgICBcInZhcigtLWNvbG9yLWJsdWUtMjAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci1pbmRpZ28tNDAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci1za3ktMTAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci1jeWFuLTIwMClcIlxuICAgIF1cbiAgfSxcbiAgW0FnZW50U3RhdGVUeXBlLklETEVdOiB7XG4gICAgYWN0aXZlU3BlZWQ6IFwic2xvd1wiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCJ2YXIoLS1jb2xvci13aGl0ZS8wKVwiLFxuICAgIGNvbG9yczogW1xuICAgICAgXCJ2YXIoLS1jb2xvci13aGl0ZS8wKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci13aGl0ZS8wKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci13aGl0ZS8wKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci13aGl0ZS8wKVwiXG4gICAgXVxuICB9LFxuICBbQWdlbnRTdGF0ZVR5cGUuVEhJTktJTkddOiB7XG4gICAgYWN0aXZlU3BlZWQ6IFwibWVkaXVtXCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInZhcigtLWNvbG9yLWJsdWUtNDAwKVwiLFxuICAgIGNvbG9yczogW1xuICAgICAgXCJ2YXIoLS1jb2xvci1vcmFuZ2UtMzAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci10ZWFsLTMwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItZnVjaHNpYS00MDApXCIsXG4gICAgICBcInZhcigtLWNvbG9yLWluZGlnby0yMDApXCJcbiAgICBdXG4gIH0sXG4gIFtBZ2VudFN0YXRlVHlwZS5XT1JLSU5HXToge1xuICAgIGFjdGl2ZVNwZWVkOiBcIm1lZGl1bVwiLFxuICAgIGJhY2tncm91bmRDb2xvcjogXCJ2YXIoLS1jb2xvci1pbmRpZ28tNDAwKVwiLFxuICAgIGNvbG9yczogW1xuICAgICAgXCJ2YXIoLS1jb2xvci1za3ktMzAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci10ZWFsLTUwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItdmlvbGV0LTQwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItaW5kaWdvLTIwMClcIlxuICAgIF1cbiAgfSxcbiAgW0FnZW50U3RhdGVUeXBlLkNBTExJTkdfVE9PTF06IHtcbiAgICBhY3RpdmVTcGVlZDogXCJmYXN0XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInZhcigtLWNvbG9yLWZ1Y2hzaWEtNDAwKVwiLFxuICAgIGNvbG9yczogW1xuICAgICAgXCJ2YXIoLS1jb2xvci1mdWNoc2lhLTQwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItdmlvbGV0LTQwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItaW5kaWdvLTUwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItcHVycGxlLTIwMClcIlxuICAgIF1cbiAgfSxcbiAgW0FnZW50U3RhdGVUeXBlLkZBSUxFRF06IHtcbiAgICBhY3RpdmVTcGVlZDogXCJzbG93XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInZhcigtLWNvbG9yLXJlZC0yMDApXCIsXG4gICAgY29sb3JzOiBbXG4gICAgICBcInZhcigtLWNvbG9yLXJlZC0xMDApXCIsXG4gICAgICBcInZhcigtLWNvbG9yLXJvc2UtMzAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci1mdWNoc2lhLTQwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItaW5kaWdvLTMwMClcIlxuICAgIF1cbiAgfSxcbiAgW0FnZW50U3RhdGVUeXBlLkNPTVBMRVRFRF06IHtcbiAgICBhY3RpdmVTcGVlZDogXCJzbG93XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcInZhcigtLWNvbG9yLWdyZWVuLTQwMClcIixcbiAgICBjb2xvcnM6IFtcbiAgICAgIFwidmFyKC0tY29sb3ItZ3JlZW4tMzAwKVwiLFxuICAgICAgXCJ2YXIoLS1jb2xvci10ZWFsLTQwMClcIixcbiAgICAgIFwidmFyKC0tY29sb3ItZW1lcmFsZC01MDApXCIsXG4gICAgICBcInZhcigtLWNvbG9yLWxpbWUtMjAwKVwiXG4gICAgXVxuICB9XG59O1xuZnVuY3Rpb24gU2VsZWN0QWdlbnQoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KEFnZW50U2VsZWN0aW9uLCB7fSk7XG59XG5mdW5jdGlvbiBOb0FnZW50Rm91bmQoKSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzcGFjZS15LTIgdGV4dC1mb3JlZ3JvdW5kIHRleHQtc21cIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KFwicFwiLCB7IGNsYXNzTmFtZTogXCJmb250LW1lZGl1bVwiLCBjaGlsZHJlbjogXCJUbyBjb25uZWN0OlwiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwib2xcIiwgeyBjbGFzc05hbWU6IFwibGlzdC1pbnNpZGUgbGlzdC1kZWNpbWFsIHNwYWNlLXktMSBwbC0yIHRleHQtc21cIiwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJsaVwiLCB7IGNoaWxkcmVuOiBcIk9wZW4geW91ciBJREUgKEN1cnNvciwgV2luZHN1cmYsIGV0Yy4pXCIgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwibGlcIiwgeyBjaGlsZHJlbjogXCJJbnN0YWxsIHRoZSBzdGFnZXdpc2UgZXh0ZW5zaW9uXCIgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwibGlcIiwgeyBjaGlsZHJlbjogXCJNYWtlIHN1cmUgdGhlIGV4dGVuc2lvbiBpcyBhY3RpdmVcIiB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJsaVwiLCB7IGNoaWxkcmVuOiBcIkNsaWNrIHJlZnJlc2ggaW4gdGhlIHRvb2xiYXJcIiB9KVxuICAgIF0gfSlcbiAgXSB9KTtcbn1cbmZ1bmN0aW9uIEFnZW50RGlzY29ubmVjdGVkKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJ0ZXh0LWZvcmVncm91bmQgdGV4dC1zbVwiLCBjaGlsZHJlbjogW1xuICAgICAgXCJUaGUgcHJldmlvdXNseSBjb25uZWN0ZWQgYWdlbnQgaXMgbm90IGF2YWlsYWJsZSBhbnltb3JlLlwiLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcImJyXCIsIHt9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJiclwiLCB7fSksXG4gICAgICBcIlRyeSB0byB3YWl0IGEgc2Vjb25kIG9yIHJlc3RhcnQgdGhlIGFnZW50LlwiXG4gICAgXSB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KEFnZW50U2VsZWN0aW9uLCB7fSlcbiAgXSB9KTtcbn1cbmNvbnN0IGF2YWlsYWJpbGl0eUVycm9yTWVzc2FnZXMgPSB7XG4gIFtBZ2VudEF2YWlsYWJpbGl0eUVycm9yLk5PX0NPTk5FQ1RJT05dOiBcIlRoZSBhZ2VudCBoYXMgbm8gY29ubmVjdGlvbiB0byBpdCdzIHNlcnZpY2UuXCIsXG4gIFtBZ2VudEF2YWlsYWJpbGl0eUVycm9yLklOQ09NUEFUSUJMRV9WRVJTSU9OXTogXCJUaGUgYWdlbnQgaXMgcnVubmluZyBhbiBpbmNvbXBhdGlibGUgdmVyc2lvbi5cIixcbiAgW0FnZW50QXZhaWxhYmlsaXR5RXJyb3IuTk9fQVVUSEVOVElDQVRJT05dOiBcIllvdSdyZSBub3QgYXV0aGVudGljYXRlZCB0byB0aGUgYWdlbnQuXCIsXG4gIFtBZ2VudEF2YWlsYWJpbGl0eUVycm9yLk9USEVSXTogXCJcIlxufTtcbmZ1bmN0aW9uIEJhZEFnZW50QXZhaWxhYmlsaXR5KCkge1xuICBjb25zdCBhdmFpbGFiaWxpdHlTdGF0dXMgPSB1c2VBZ2VudEF2YWlsYWJpbGl0eSgpO1xuICByZXR1cm4gYXZhaWxhYmlsaXR5U3RhdHVzLmlzQXZhaWxhYmxlID8gbnVsbCA6IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEZyYWdtZW50JDEsIHsgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4cyhcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwidGV4dC1mb3JlZ3JvdW5kIHRleHQtc21cIiwgY2hpbGRyZW46IFtcbiAgICAgIFwiVGhlIGFnZW50IGlzIGNvbm5lY3RlZCB0byB0aGUgdG9vbGJhciwgYnV0IG5vdCByZWFkeSB0byB1c2UuXCIsXG4gICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwiYnJcIiwge30pLFxuICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcImJyXCIsIHt9KSxcbiAgICAgIFwiZXJyb3JcIiBpbiBhdmFpbGFiaWxpdHlTdGF0dXMgJiYgYXZhaWxhYmlsaXR5RXJyb3JNZXNzYWdlc1thdmFpbGFiaWxpdHlTdGF0dXMuZXJyb3JdLmxlbmd0aCA+IDAgJiYgLyogQF9fUFVSRV9fICovIGpzeHMoRnJhZ21lbnQkMSwgeyBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmb250LW1lZGl1bSB0ZXh0LWZvcmVncm91bmRcIiwgY2hpbGRyZW46IFwiUmVhc29uXCIgfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJiclwiLCB7fSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInRleHQtZm9yZWdyb3VuZC84MFwiLCBjaGlsZHJlbjogYXZhaWxhYmlsaXR5U3RhdHVzLmVycm9yTWVzc2FnZSB8fCBhdmFpbGFiaWxpdHlFcnJvck1lc3NhZ2VzW2F2YWlsYWJpbGl0eVN0YXR1cy5lcnJvcl0gfSksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXCJiclwiLCB7fSlcbiAgICAgIF0gfSlcbiAgICBdIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goQWdlbnRTZWxlY3Rpb24sIHt9KVxuICBdIH0pO1xufVxuZnVuY3Rpb24gQWdlbnRDb25uZWN0aXZpdHlQYW5lbCgpIHtcbiAgY29uc3QgeyBhdmFpbGFibGVBZ2VudHMsIGNvbm5lY3RlZFVuYXZhaWxhYmxlLCBjb25uZWN0ZWQgfSA9IHVzZUFnZW50cygpLCBhdmFpbGFiaWxpdHlTdGF0dXMgPSB1c2VBZ2VudEF2YWlsYWJpbGl0eSgpLCBzaG91bGRSZW5kZXJBc1dhcm5pbmcgPSB1c2VNZW1vKCgpID0+IGF2YWlsYWJsZUFnZW50cy5sZW5ndGggPT09IDAgfHwgY29ubmVjdGVkVW5hdmFpbGFibGUgfHwgIWF2YWlsYWJpbGl0eVN0YXR1cy5pc0F2YWlsYWJsZSwgW2F2YWlsYWJsZUFnZW50cywgY29ubmVjdGVkVW5hdmFpbGFibGUsIGF2YWlsYWJpbGl0eVN0YXR1c10pLCB0aXRsZSA9IHVzZU1lbW8oKCkgPT4gYXZhaWxhYmxlQWdlbnRzLmxlbmd0aCA9PT0gMCA/IFwiTm8gYWdlbnRzIGF2YWlsYWJsZVwiIDogY29ubmVjdGVkVW5hdmFpbGFibGUgPyBcIkFnZW50IGRpc2Nvbm5lY3RlZFwiIDogY29ubmVjdGVkICYmICFhdmFpbGFiaWxpdHlTdGF0dXMuaXNBdmFpbGFibGUgPyBcIkFnZW50IG5vdCByZWFkeSB0byB1c2VcIiA6IFwiU2VsZWN0IGFuIGFnZW50IHRvIGNvbm5lY3QgdG9cIiwgW2F2YWlsYWJsZUFnZW50cywgY29ubmVjdGVkVW5hdmFpbGFibGUsIGF2YWlsYWJpbGl0eVN0YXR1c10pLCByZW5kZXJlZEljb24gPSB1c2VNZW1vKCgpID0+IHNob3VsZFJlbmRlckFzV2FybmluZyA/IGNvbm5lY3RlZFVuYXZhaWxhYmxlIHx8IGNvbm5lY3RlZCAmJiBcImVycm9yXCIgaW4gYXZhaWxhYmlsaXR5U3RhdHVzICYmIGF2YWlsYWJpbGl0eVN0YXR1cy5lcnJvciA9PT0gQWdlbnRBdmFpbGFiaWxpdHlFcnJvci5OT19DT05ORUNUSU9OID8gLyogQF9fUFVSRV9fICovIGpzeChXaWZpT2ZmLCB7IGNsYXNzTmFtZTogXCJzaXplLTZcIiB9KSA6IC8qIEBfX1BVUkVfXyAqLyBqc3goVHJpYW5nbGVBbGVydCwgeyBjbGFzc05hbWU6IFwic2l6ZS02XCIgfSkgOiBudWxsLCBbY29ubmVjdGVkVW5hdmFpbGFibGUsIGNvbm5lY3RlZCwgYXZhaWxhYmlsaXR5U3RhdHVzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhcbiAgICBQYW5lbCxcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBzaG91bGRSZW5kZXJBc1dhcm5pbmcgJiYgXCJbLS1jb2xvci1mb3JlZ3JvdW5kOnZhcigtLWNvbG9yLW9yYW5nZS03MDApXSBbLS1jb2xvci1tdXRlZC1mb3JlZ3JvdW5kOnZhcigtLWNvbG9yLW9yYW5nZS02MDApXSBiZWZvcmU6Ymctb3JhbmdlLTUwLzgwXCJcbiAgICAgICksXG4gICAgICBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgIFBhbmVsSGVhZGVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpdGxlLFxuICAgICAgICAgICAgYWN0aW9uQXJlYTogc2hvdWxkUmVuZGVyQXNXYXJuaW5nICYmIHJlbmRlcmVkSWNvblxuICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoUGFuZWxDb250ZW50LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgYXZhaWxhYmxlQWdlbnRzLmxlbmd0aCA+IDAgJiYgIWNvbm5lY3RlZFVuYXZhaWxhYmxlICYmICFjb25uZWN0ZWQgJiYgLyogQF9fUFVSRV9fICovIGpzeChTZWxlY3RBZ2VudCwge30pLFxuICAgICAgICAgIGNvbm5lY3RlZFVuYXZhaWxhYmxlICYmIC8qIEBfX1BVUkVfXyAqLyBqc3goQWdlbnREaXNjb25uZWN0ZWQsIHt9KSxcbiAgICAgICAgICBhdmFpbGFibGVBZ2VudHMubGVuZ3RoID09PSAwICYmICFjb25uZWN0ZWRVbmF2YWlsYWJsZSAmJiAvKiBAX19QVVJFX18gKi8ganN4KE5vQWdlbnRGb3VuZCwge30pLFxuICAgICAgICAgICFjb25uZWN0ZWRVbmF2YWlsYWJsZSAmJiBjb25uZWN0ZWQgJiYgIWF2YWlsYWJpbGl0eVN0YXR1cy5pc0F2YWlsYWJsZSAmJiAvKiBAX19QVVJFX18gKi8ganN4KEJhZEFnZW50QXZhaWxhYmlsaXR5LCB7fSlcbiAgICAgICAgXSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChQYW5lbEZvb3RlciwgeyBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeHMoRHJvcGRvd25NZW51LCB7IGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChEcm9wZG93bk1lbnVCdXR0b24sIHsgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hzKEJ1dHRvbiwgeyBnbGFzc3k6ICEwLCBzaXplOiBcInNtXCIsIHZhcmlhbnQ6IFwic2Vjb25kYXJ5XCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KE1lc3NhZ2VDaXJjbGVRdWVzdGlvbk1hcmssIHsgY2xhc3NOYW1lOiBcIm1yLTIgc2l6ZS00XCIgfSksXG4gICAgICAgICAgICBcIk5lZWQgaGVscD9cIlxuICAgICAgICAgIF0gfSkgfSksXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeHMoRHJvcGRvd25NZW51Q29udGVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICAgICAgICAgICAgRHJvcGRvd25NZW51TGlua0l0ZW0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vc3RhZ2V3aXNlLmlvL2RvY3NcIixcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUmVhZCB0aGUgZG9jc1wiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgICAgICAgICBEcm9wZG93bk1lbnVMaW5rSXRlbSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9kaXNjb3JkLmdnL3k4Z2ROYjREXCIsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkpvaW4gdGhlIGNvbW11bml0eVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdIH0pXG4gICAgICAgIF0gfSkgfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59XG5jb25zdCBUT09MQkFSX1BPU0lUSU9OX0tFWSA9IFwic3RhZ2V3aXNlX3Rvb2xiYXJfdG9vbGJhcl9wb3NpdGlvblwiO1xuZnVuY3Rpb24gZ2V0U3RvcmVkVG9vbGJhclBvc2l0aW9uKCkge1xuICB0cnkge1xuICAgIGNvbnN0IHN0b3JlZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFRPT0xCQVJfUE9TSVRJT05fS0VZKTtcbiAgICBpZiAoc3RvcmVkKVxuICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGxvYWQgdG9vbGJhciBwb3NpdGlvbiBmcm9tIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNhdmVUb29sYmFyUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgdHJ5IHtcbiAgICBwb3NpdGlvbiAmJiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShUT09MQkFSX1BPU0lUSU9OX0tFWSwgcG9zaXRpb24pO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gc2F2ZSB0b29sYmFyIHBvc2l0aW9uIHRvIGxvY2FsU3RvcmFnZTpcIiwgZXJyb3IyKTtcbiAgfVxufVxuZnVuY3Rpb24gRGVmYXVsdExheW91dCgpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goQ29udGV4dENoaXBIb3ZlclByb3ZpZGVyLCB7IGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogY24oXCJmaXhlZCBpbnNldC0wIGgtc2NyZWVuIHctc2NyZWVuXCIpLCBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRE9NQ29udGV4dFNlbGVjdG9yLCB7fSksXG4gICAgLyogQF9fUFVSRV9fICovIGpzeChEcmFnZ2luZ0FyZWEsIHt9KVxuICBdIH0pIH0pO1xufVxuZnVuY3Rpb24gRHJhZ2dpbmdBcmVhKCkge1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIHotNTAgc2l6ZS1mdWxsXCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIGluc2V0LTRcIiwgcmVmOiBjb250YWluZXJSZWYsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIERyYWdnYWJsZVByb3ZpZGVyLFxuICAgIHtcbiAgICAgIGNvbnRhaW5lclJlZixcbiAgICAgIHNuYXBBcmVhczoge1xuICAgICAgICB0b3BMZWZ0OiAhMCxcbiAgICAgICAgdG9wUmlnaHQ6ICEwLFxuICAgICAgICBib3R0b21MZWZ0OiAhMCxcbiAgICAgICAgYm90dG9tUmlnaHQ6ICEwLFxuICAgICAgICB0b3BDZW50ZXI6ICExLFxuICAgICAgICBib3R0b21DZW50ZXI6ICExXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goVG9vbGJhckFuZFBhbmVsQXJlYSwge30pXG4gICAgfVxuICApIH0pIH0pO1xufVxuZnVuY3Rpb24gVG9vbGJhckFuZFBhbmVsQXJlYSgpIHtcbiAgY29uc3Qgb25OZXdTbmFwQXJlYSA9IHVzZUNhbGxiYWNrKFxuICAgIChzbmFwQXJlYSkgPT4ge1xuICAgICAgc2F2ZVRvb2xiYXJQb3NpdGlvbihzbmFwQXJlYSk7XG4gICAgfSxcbiAgICBbXVxuICApLCBpbml0aWFsU25hcEFyZWEgPSB1c2VNZW1vKCgpID0+IGdldFN0b3JlZFRvb2xiYXJQb3NpdGlvbigpIHx8IFwiYm90dG9tUmlnaHRcIiwgW10pLCBkcmFnZ2FibGUgPSB1c2VEcmFnZ2FibGUoe1xuICAgIHN0YXJ0VGhyZXNob2xkOiA1LFxuICAgIGluaXRpYWxTbmFwQXJlYSxcbiAgICBvbkRyYWdFbmQ6IG9uTmV3U25hcEFyZWFcbiAgfSksIGNsaWNrSGFuZGxlUmVmID0gdXNlUmVmKG51bGwpO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsaXN0ZW5lciA9IChlMikgPT4ge1xuICAgICAgaWYgKGRyYWdnYWJsZS53YXNEcmFnZ2VkKSB7XG4gICAgICAgIGUyLnByZXZlbnREZWZhdWx0KCksIGUyLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBsaXN0ZW5lciwgeyBjYXB0dXJlOiAhMCB9KSwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBsaXN0ZW5lciwgeyBjYXB0dXJlOiAhMCB9KTtcbiAgICB9O1xuICB9LCBbZHJhZ2dhYmxlXSksIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImFic29sdXRlIGluc2V0LTAgei01MCBzaXplLWZ1bGxcIiwgY2hpbGRyZW46IFtcbiAgICAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgICAgVG9vbGJhcixcbiAgICAgIHtcbiAgICAgICAgZHJhZ2dhYmxlSGFuZGxlUmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgZHJhZ2dhYmxlLmhhbmRsZVJlZihyZWYpLCBkcmFnZ2FibGUuZHJhZ2dhYmxlUmVmKHJlZiksIGNsaWNrSGFuZGxlUmVmLmN1cnJlbnQgPSByZWY7XG4gICAgICAgIH0sXG4gICAgICAgIGlzRHJhZ2dlZDogZHJhZ2dhYmxlLmlzRHJhZ2dpbmcsXG4gICAgICAgIHBvc2l0aW9uOiBkcmFnZ2FibGUucG9zaXRpb25cbiAgICAgIH1cbiAgICApLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgICBQYW5lbHNBcmVhLFxuICAgICAge1xuICAgICAgICBwb3NpdGlvbjogZHJhZ2dhYmxlLnBvc2l0aW9uLFxuICAgICAgICBpc1Rvb2xiYXJEcmFnZ2VkOiBkcmFnZ2FibGUuaXNEcmFnZ2luZ1xuICAgICAgfVxuICAgIClcbiAgXSB9KTtcbn1cbmZ1bmN0aW9uIFBhbmVsc0FyZWEoe1xuICBwb3NpdGlvbixcbiAgaXNUb29sYmFyRHJhZ2dlZFxufSkge1xuICBjb25zdCB7XG4gICAgaXNDaGF0T3BlbixcbiAgICBpc1NldHRpbmdzT3BlbixcbiAgICBpc0FnZW50Q29ubmVjdGl2aXR5T3BlbixcbiAgICBvcGVuUGx1Z2luTmFtZVxuICB9ID0gdXNlUGFuZWxzKCksIHBsdWdpbnMgPSB1c2VQbHVnaW5zKCksIHBsdWdpblBhbmVsID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFvcGVuUGx1Z2luTmFtZSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHBsdWdpbiA9IHBsdWdpbnMucGx1Z2lucy5maW5kKFxuICAgICAgKHBsdWdpbjIpID0+IHBsdWdpbjIucGx1Z2luTmFtZSA9PT0gb3BlblBsdWdpbk5hbWVcbiAgICApO1xuICAgIGlmICghcGx1Z2luKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcGFuZWxSZXN1bHQgPSBwbHVnaW4ub25BY3Rpb25DbGljaygpO1xuICAgIHJldHVybiBwYW5lbFJlc3VsdCB8fCBudWxsO1xuICB9LCBbb3BlblBsdWdpbk5hbWUsIHBsdWdpbnNdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hzKFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBjbihcbiAgICAgICAgXCJhYnNvbHV0ZSB6LTAgZmxleCBoLWZ1bGwgdy05NiBtYXgtdy1bY2FsYygxMDAlLTQ4cHgpXSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi01MDAgZWFzZS1zcHJpbmdcIixcbiAgICAgICAgcG9zaXRpb24uaXNMZWZ0SGFsZiA/IFwibGVmdC0xMlwiIDogXCJyaWdodC0xMlwiLFxuICAgICAgICBwb3NpdGlvbi5pc1RvcEhhbGYgPyBcInRvcC0wIGZsZXgtY29sXCIgOiBcImJvdHRvbS0wIGZsZXgtY29sLXJldmVyc2VcIixcbiAgICAgICAgaXNUb29sYmFyRHJhZ2dlZCA/IFwic2NhbGUtOTUgb3BhY2l0eS01MCBibHVyLW1kIGJyaWdodG5lc3MtOTBcIiA6IFwib3BhY2l0eS0xMDBcIlxuICAgICAgKSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goUGFuZWxXcmFwcGVyLCB7IHBvc2l0aW9uLCBpc09wZW46IGlzQ2hhdE9wZW4sIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4KENoYXRQYW5lbCwge30pIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFBhbmVsV3JhcHBlciwgeyBwb3NpdGlvbiwgaXNPcGVuOiBpc1NldHRpbmdzT3BlbiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goU2V0dGluZ3NQYW5lbCwge30pIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFBhbmVsV3JhcHBlciwgeyBwb3NpdGlvbiwgaXNPcGVuOiBpc0FnZW50Q29ubmVjdGl2aXR5T3BlbiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goQWdlbnRDb25uZWN0aXZpdHlQYW5lbCwge30pIH0pLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFBhbmVsV3JhcHBlciwgeyBwb3NpdGlvbiwgaXNPcGVuOiAhIXBsdWdpblBhbmVsLCBjaGlsZHJlbjogcGx1Z2luUGFuZWwgfSlcbiAgICAgIF1cbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBQYW5lbFdyYXBwZXIoe1xuICBjaGlsZHJlbixcbiAgcG9zaXRpb24sXG4gIGlzT3BlblxufSkge1xuICBjb25zdCBbc2hvdWxkUmVuZGVyLCBzZXRTaG91bGRSZW5kZXJdID0gdXNlU3RhdGUoaXNPcGVuKSwgc3RvcFJlbmRlclRpbWVvdXRSZWYgPSB1c2VSZWYobnVsbCksIGlzQWdlbnRQYW5lbCA9IGNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZHJlbiA9PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZHJlbi50eXBlID09IFwiZnVuY3Rpb25cIiAmJiBjaGlsZHJlbi50eXBlLm5hbWUgPT09IFwiQWdlbnRDb25uZWN0aXZpdHlQYW5lbFwiO1xuICByZXR1cm4gdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0FnZW50UGFuZWwgJiYgY29uc29sZS5kZWJ1ZyhcIltQYW5lbFdyYXBwZXJdIEFnZW50Q29ubmVjdGl2aXR5UGFuZWwgaXNPcGVuIGNoYW5nZWQ6XCIsIHtcbiAgICAgIGlzT3BlbixcbiAgICAgIHNob3VsZFJlbmRlcixcbiAgICAgIGhhc1RpbWVvdXQ6ICEhc3RvcFJlbmRlclRpbWVvdXRSZWYuY3VycmVudFxuICAgIH0pLCBpc09wZW4gPyAoaXNBZ2VudFBhbmVsICYmIGNvbnNvbGUuZGVidWcoXG4gICAgICBcIltQYW5lbFdyYXBwZXJdIEFnZW50Q29ubmVjdGl2aXR5UGFuZWwgc2V0dGluZyBzaG91bGRSZW5kZXIgdG8gdHJ1ZSBpbW1lZGlhdGVseVwiXG4gICAgKSwgc2V0U2hvdWxkUmVuZGVyKCEwKSwgc3RvcFJlbmRlclRpbWVvdXRSZWYuY3VycmVudCAmJiAoY2xlYXJUaW1lb3V0KHN0b3BSZW5kZXJUaW1lb3V0UmVmLmN1cnJlbnQpLCBzdG9wUmVuZGVyVGltZW91dFJlZi5jdXJyZW50ID0gbnVsbCkpIDogc3RvcFJlbmRlclRpbWVvdXRSZWYuY3VycmVudCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaXNBZ2VudFBhbmVsICYmIGNvbnNvbGUuZGVidWcoXG4gICAgICAgIFwiW1BhbmVsV3JhcHBlcl0gQWdlbnRDb25uZWN0aXZpdHlQYW5lbCBzZXR0aW5nIHNob3VsZFJlbmRlciB0byBmYWxzZSBhZnRlciB0aW1lb3V0XCJcbiAgICAgICksIHNldFNob3VsZFJlbmRlcighMSk7XG4gICAgfSwgNTAwKTtcbiAgfSwgW2lzT3BlbiwgaXNBZ2VudFBhbmVsXSksIHVzZUVmZmVjdCgoKSA9PiAoKSA9PiB7XG4gICAgc3RvcFJlbmRlclRpbWVvdXRSZWYuY3VycmVudCAmJiBjbGVhclRpbWVvdXQoc3RvcFJlbmRlclRpbWVvdXRSZWYuY3VycmVudCk7XG4gIH0sIFtdKSwgLyogQF9fUFVSRV9fICovIGpzeChcbiAgICBcImRpdlwiLFxuICAgIHtcbiAgICAgIGNsYXNzTmFtZTogY24oXG4gICAgICAgIFwiaC1bY2FsYy1zaXplKGF1dG8sc2l6ZSldIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTE1MCBlYXNlLW91dFwiLFxuICAgICAgICBwb3NpdGlvbi5pc1RvcEhhbGYgPyBcIm1iLTNcIiA6IFwibXQtM1wiLFxuICAgICAgICBwb3NpdGlvbi5pc0xlZnRIYWxmID8gXCJvcmlnaW4tbGVmdFwiIDogXCJvcmlnaW4tcmlnaHRcIixcbiAgICAgICAgaXNPcGVuID8gXCJcIiA6IFwibXQtMCBtYi0wIGgtMCBzY2FsZS0wIG9wYWNpdHktMCBibHVyLW1kXCJcbiAgICAgICksXG4gICAgICBjaGlsZHJlbjogc2hvdWxkUmVuZGVyICYmIGNoaWxkcmVuXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gTWFpbkFwcEJsb2NrZXIoKSB7XG4gIGNvbnN0IHsgaXNNYWluQXBwQmxvY2tlZCB9ID0gdXNlQXBwU3RhdGUoKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICBjbGFzc05hbWU6IGNuKFxuICAgICAgICBcImZpeGVkIGluc2V0LTAgaC1zY3JlZW4gdy1zY3JlZW5cIixcbiAgICAgICAgaXNNYWluQXBwQmxvY2tlZCA/IFwicG9pbnRlci1ldmVudHMtYXV0b1wiIDogXCJwb2ludGVyLWV2ZW50cy1ub25lXCJcbiAgICAgICksXG4gICAgICByb2xlOiBcImJ1dHRvblwiLFxuICAgICAgdGFiSW5kZXg6IDBcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBBcHAoY29uZmlnMikge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeHMoQXBwU3RhdGVQcm92aWRlciwgeyBjaGlsZHJlbjogW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goTWFpbkFwcEJsb2NrZXIsIHt9KSxcbiAgICAvKiBAX19QVVJFX18gKi8ganN4cyhDb250ZXh0UHJvdmlkZXJzLCB7IGNvbmZpZzogY29uZmlnMiwgY2hpbGRyZW46IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goSG90a2V5TGlzdGVuZXIsIHt9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3goRGVmYXVsdExheW91dCwge30pXG4gICAgXSB9KVxuICBdIH0pO1xufVxuY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuc3R5bGVOb2RlLnRleHRDb250ZW50ID0gYXBwU3R5bGU7XG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlTm9kZSk7XG5jcmVhdGVSb290KGRvY3VtZW50LmJvZHkpLnJlbmRlcihcbiAgY3JlYXRlRWxlbWVudChTdHJpY3RNb2RlLCBudWxsLCBjcmVhdGVFbGVtZW50KEFwcCwgY29uZmlnKSlcbik7XG5gLCBcInBsdWdpbi11aS5qc1wiOiBgaW1wb3J0IHsgbSBhcyBjbiwgdyBhcyBjdmEsIGIgYXMgdXNlUGx1Z2lucyB9IGZyb20gXCJpbmRleC1Ec0M1enBlcy5qc1wiO1xuaW1wb3J0IHsgQiwgciwgdCwgdiwgcyB9IGZyb20gXCJpbmRleC1Ec0M1enBlcy5qc1wiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBiYWRnZVZhcmlhbnRzID0gY3ZhKFwicm91bmRlZC1tZCBwLTJcIiwge1xuICB2YXJpYW50czoge1xuICAgIGNvbG9yOiB7XG4gICAgICBibHVlOiBcIlwiLFxuICAgICAgZ3JlZW46IFwiXCIsXG4gICAgICByZWQ6IFwiXCIsXG4gICAgICB5ZWxsb3c6IFwiXCIsXG4gICAgICBwdXJwbGU6IFwiXCIsXG4gICAgICBvcmFuZ2U6IFwiXCIsXG4gICAgICBwaW5rOiBcIlwiXG4gICAgfSxcbiAgICBzdHlsZToge1xuICAgICAgZGVmYXVsdDogXCJ0ZXh0LXdoaXRlXCIsXG4gICAgICBvdXRsaW5lOiBcImJvcmRlciB0ZXh0LXppbmMtOTUwXCJcbiAgICB9XG4gIH0sXG4gIGNvbXBvdW5kVmFyaWFudHM6IFtcbiAgICB7XG4gICAgICBzdHlsZTogXCJkZWZhdWx0XCIsXG4gICAgICBjb2xvcjogXCJibHVlXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmctYmx1ZS01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwiZGVmYXVsdFwiLFxuICAgICAgY29sb3I6IFwiZ3JlZW5cIixcbiAgICAgIGNsYXNzTmFtZTogXCJiZy1ncmVlbi01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwiZGVmYXVsdFwiLFxuICAgICAgY29sb3I6IFwicmVkXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmctcmVkLTUwMFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBzdHlsZTogXCJkZWZhdWx0XCIsXG4gICAgICBjb2xvcjogXCJ5ZWxsb3dcIixcbiAgICAgIGNsYXNzTmFtZTogXCJiZy15ZWxsb3ctNTAwXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHN0eWxlOiBcImRlZmF1bHRcIixcbiAgICAgIGNvbG9yOiBcInB1cnBsZVwiLFxuICAgICAgY2xhc3NOYW1lOiBcImJnLXB1cnBsZS01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwiZGVmYXVsdFwiLFxuICAgICAgY29sb3I6IFwib3JhbmdlXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmctb3JhbmdlLTUwMFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBzdHlsZTogXCJkZWZhdWx0XCIsXG4gICAgICBjb2xvcjogXCJwaW5rXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYmctcGluay01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwib3V0bGluZVwiLFxuICAgICAgY29sb3I6IFwiYmx1ZVwiLFxuICAgICAgY2xhc3NOYW1lOiBcImJvcmRlci1ibHVlLTUwMFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBzdHlsZTogXCJvdXRsaW5lXCIsXG4gICAgICBjb2xvcjogXCJncmVlblwiLFxuICAgICAgY2xhc3NOYW1lOiBcImJvcmRlci1ncmVlbi01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwib3V0bGluZVwiLFxuICAgICAgY29sb3I6IFwicmVkXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYm9yZGVyLXJlZC01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwib3V0bGluZVwiLFxuICAgICAgY29sb3I6IFwieWVsbG93XCIsXG4gICAgICBjbGFzc05hbWU6IFwiYm9yZGVyLXllbGxvdy01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwib3V0bGluZVwiLFxuICAgICAgY29sb3I6IFwicHVycGxlXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYm9yZGVyLXB1cnBsZS01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwib3V0bGluZVwiLFxuICAgICAgY29sb3I6IFwib3JhbmdlXCIsXG4gICAgICBjbGFzc05hbWU6IFwiYm9yZGVyLW9yYW5nZS01MDBcIlxuICAgIH0sXG4gICAge1xuICAgICAgc3R5bGU6IFwib3V0bGluZVwiLFxuICAgICAgY29sb3I6IFwicGlua1wiLFxuICAgICAgY2xhc3NOYW1lOiBcImJvcmRlci1waW5rLTUwMFwiXG4gICAgfVxuICBdLFxuICBkZWZhdWx0VmFyaWFudHM6IHtcbiAgICBjb2xvcjogXCJibHVlXCIsXG4gICAgc3R5bGU6IFwiZGVmYXVsdFwiXG4gIH1cbn0pO1xuZnVuY3Rpb24gQmFkZ2UoeyBjaGlsZHJlbiwgY29sb3IsIHN0eWxlLCBjbGFzc05hbWUgfSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNuKGJhZGdlVmFyaWFudHMoeyBjb2xvciwgc3R5bGUgfSksIGNsYXNzTmFtZSksIGNoaWxkcmVuIH0pO1xufVxuY29uc3QgdXNlVG9vbGJhciA9ICgpID0+IHVzZVBsdWdpbnMoKS50b29sYmFyQ29udGV4dDtcbmV4cG9ydCB7XG4gIEJhZGdlLFxuICBCIGFzIEJ1dHRvbixcbiAgciBhcyBQYW5lbCxcbiAgdCBhcyBQYW5lbENvbnRlbnQsXG4gIHYgYXMgUGFuZWxGb290ZXIsXG4gIHMgYXMgUGFuZWxIZWFkZXIsXG4gIHVzZVRvb2xiYXJcbn07XG5gIH07XG5mdW5jdGlvbiBpbml0VG9vbGJhcihjb25maWcgPSB7fSkge1xuICBpZiAoISh0eXBlb2Ygd2luZG93IDwgXCJ1XCIpKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJTdGFnZXdpc2UgVG9vbGJhciBpcyBub3Qgc3VwcG9ydGVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cIlxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic3RhZ2V3aXNlLXRvb2xiYXJcIikpIHtcbiAgICBjb25zb2xlLndhcm4oXCJTdGFnZXdpc2UgVG9vbGJhciBpcyBhbHJlYWR5IGxvYWRlZCAtIGFib3J0aW5nIGluaXQuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0YWdld2lzZS10b29sYmFyXCIpO1xuICB3cmFwcGVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHdyYXBwZXIuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCIsIHdyYXBwZXIuc3R5bGUudG9wID0gXCIwXCIsIHdyYXBwZXIuc3R5bGUubGVmdCA9IFwiMFwiLCB3cmFwcGVyLnN0eWxlLnJpZ2h0ID0gXCIwXCIsIHdyYXBwZXIuc3R5bGUuYm90dG9tID0gXCIwXCIsIHdyYXBwZXIuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCIsIHdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gXCIxMDB2aFwiLCB3cmFwcGVyLnN0eWxlLnpJbmRleCA9IFwiMjE0NzQ4MzY0N1wiLCB3cmFwcGVyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgY29uc3QgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSBcIm5vbmVcIiwgaWZyYW1lLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIiwgaWZyYW1lLnN0eWxlLm1hcmdpbiA9IFwiMFwiLCBpZnJhbWUuc3R5bGUucGFkZGluZyA9IFwiMFwiLCBpZnJhbWUuc3R5bGUud2lkdGggPSBcIjEwMHZ3XCIsIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSBcIjEwMHZoXCIsIGlmcmFtZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInRyYW5zcGFyZW50XCIsIGlmcmFtZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIsIGlmcmFtZS5zdHlsZS5jb2xvclNjaGVtZSA9IFwibm9ybWFsXCIsIGlmcmFtZS5zYW5kYm94LmFkZChcImFsbG93LXNhbWUtb3JpZ2luXCIpLCBpZnJhbWUuc2FuZGJveC5hZGQoXCJhbGxvdy1zY3JpcHRzXCIpLCBpZnJhbWUuc2FuZGJveC5hZGQoXCJhbGxvdy1wcmVzZW50YXRpb25cIiksIGlmcmFtZS5zYW5kYm94LmFkZChcImFsbG93LXBvaW50ZXItbG9ja1wiKSwgaWZyYW1lLnNhbmRib3guYWRkKFwiYWxsb3ctcG9wdXBzXCIpLCBpZnJhbWUuc2V0QXR0cmlidXRlKFwiYWxsb3d0cmFuc3BhcmVuY3lcIiwgXCJ0cnVlXCIpLCBpZnJhbWUuc3JjZG9jID0gJzwhRE9DVFlQRSBodG1sPjxodG1sPjxoZWFkPjxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPjxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXCI+PGxpbmsgcmVsPVwicHJlY29ubmVjdFwiIGhyZWY9XCJodHRwczovL3JzbXMubWUvXCI+PGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCJodHRwczovL3JzbXMubWUvaW50ZXIvaW50ZXIuY3NzXCI+PC9oZWFkPjxib2R5IHN0eWxlPVwicG9pbnRlci1ldmVudHM6IG5vbmU7XCI+PC9ib2R5PjwvaHRtbD4nLCBpZnJhbWUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xuICAgIGxldCBsYXN0TW91c2VPdmVySW50ZXJhY3RpdmVBcmVhU3RhdGUgPSAhMTtcbiAgICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSAoZSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudEF0UG9pbnQgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoXG4gICAgICAgIGUuY2xpZW50WCxcbiAgICAgICAgZS5jbGllbnRZXG4gICAgICApLCBpc0ludGVyYWN0aXZlID0gZWxlbWVudEF0UG9pbnQgJiYgZWxlbWVudEF0UG9pbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZWxlbWVudEF0UG9pbnQudGFnTmFtZSAhPT0gXCJIVE1MXCI7XG4gICAgICBpc0ludGVyYWN0aXZlICE9PSBsYXN0TW91c2VPdmVySW50ZXJhY3RpdmVBcmVhU3RhdGUgJiYgKGlmcmFtZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gaXNJbnRlcmFjdGl2ZSA/IFwiYXV0b1wiIDogXCJub25lXCIsIGxhc3RNb3VzZU92ZXJJbnRlcmFjdGl2ZUFyZWFTdGF0ZSA9IGlzSW50ZXJhY3RpdmUpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgaGFuZGxlTW91c2VNb3ZlLCB7IGNhcHR1cmU6ICEwIH0pLCBpZnJhbWUuY29udGVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGhhbmRsZU1vdXNlTW92ZSwge1xuICAgICAgY2FwdHVyZTogITBcbiAgICB9KTtcbiAgICBjb25zdCBkZXZTdWZmaXggPSBcIlwiLCBtYWluX21vZHVsZXMgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhkZWZpbmVfTUFJTl9NT0RVTEVTX2RlZmF1bHQpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBbXG4gICAgICAgIGtleSxcbiAgICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbdmFsdWVdLCB7IHR5cGU6IFwidGV4dC9qYXZhc2NyaXB0XCIgfSkpXG4gICAgICBdKVxuICAgICk7XG4gICAgaWYgKG1haW5fbW9kdWxlc1tcIkBzdGFnZXdpc2UvdG9vbGJhci9wbHVnaW4tdWlcIl0gPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoW1wiZXhwb3J0ICogZnJvbSAncGx1Z2luLXVpLmpzJ1wiXSwgeyB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiIH0pXG4gICAgKSwgY29uZmlnLnBsdWdpbnMpXG4gICAgICBmb3IgKGNvbnN0IFtpbmRleCwgcGx1Z2luXSBvZiBjb25maWcucGx1Z2lucy5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luX21vZHVsZSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgICAgbmV3IEJsb2IoW3BsdWdpbi5tYWluUGx1Z2luXSwgeyB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiIH0pXG4gICAgICAgICk7XG4gICAgICAgIG1haW5fbW9kdWxlc1tgcGx1Z2luLWVudHJ5LSR7aW5kZXh9YF0gPSBwbHVnaW5fbW9kdWxlO1xuICAgICAgfVxuICAgIGNvbnN0IGNvbmZpZ19tb2R1bGUgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoW2dldENvbmZpZ01vZHVsZUNvbnRlbnQoY29uZmlnKV0sIHsgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHRcIiB9KVxuICAgICk7XG4gICAgbWFpbl9tb2R1bGVzW1wiQHN0YWdld2lzZS90b29sYmFyL2NvbmZpZ1wiXSA9IGNvbmZpZ19tb2R1bGU7XG4gICAgY29uc3QgaW1wb3J0cyA9IHtcbiAgICAgIHJlYWN0OiBgaHR0cHM6Ly9lc20uc2gvcmVhY3RAMTkuMS4wJHtkZXZTdWZmaXh9YCxcbiAgICAgIFwicmVhY3QtZG9tXCI6IGBodHRwczovL2VzbS5zaC9yZWFjdC1kb21AMTkuMS4wJHtkZXZTdWZmaXh9YCxcbiAgICAgIFwicmVhY3QtZG9tL2NsaWVudFwiOiBgaHR0cHM6Ly9lc20uc2gvcmVhY3QtZG9tQDE5LjEuMC9jbGllbnQke2RldlN1ZmZpeH1gLFxuICAgICAgXCJyZWFjdC9qc3gtcnVudGltZVwiOiBgaHR0cHM6Ly9lc20uc2gvcmVhY3RAMTkuMS4wL2pzeC1ydW50aW1lJHtkZXZTdWZmaXh9YCxcbiAgICAgIC4uLm1haW5fbW9kdWxlc1xuICAgIH0sIGltcG9ydG1hcFNjcmlwdCA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICBpbXBvcnRtYXBTY3JpcHQudHlwZSA9IFwiaW1wb3J0bWFwXCIsIGltcG9ydG1hcFNjcmlwdC50ZXh0Q29udGVudCA9IGB7XCJpbXBvcnRzXCI6JHtKU09OLnN0cmluZ2lmeShpbXBvcnRzKX19YCwgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGltcG9ydG1hcFNjcmlwdCk7XG4gICAgY29uc3Qgc2NyaXB0ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC50eXBlID0gXCJtb2R1bGVcIiwgc2NyaXB0LnRleHRDb250ZW50ID0gXCJpbXBvcnQoJ2luZGV4LmpzJyk7XCIsIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICB9KSwgd3JhcHBlci5hcHBlbmRDaGlsZChpZnJhbWUpLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdyYXBwZXIpO1xufVxuZnVuY3Rpb24gZ2V0Q29uZmlnTW9kdWxlQ29udGVudChjb25maWcpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcGx1Z2luSW1wb3J0cyA9ICgoX2EgPSBjb25maWcucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm1hcCgoXywgaW5kZXgpID0+IGBpbXBvcnQgcGx1Z2luJHtpbmRleH0gZnJvbSAncGx1Z2luLWVudHJ5LSR7aW5kZXh9J2ApLmpvaW4oYFxuYCkpID8/IFwiXCIsIGNvbnZlcnRlZFBsdWdpbkFycmF5ID0gYFskeygoX2IgPSBjb25maWcucGx1Z2lucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm1hcCgoXywgaW5kZXgpID0+IGBwbHVnaW4ke2luZGV4fWApLmpvaW4oXCIsXCIpKSA/PyBcIlwifV1gLCBjb252ZXJ0ZWRDb25maWcgPSB7XG4gICAgLi4uY29uZmlnLFxuICAgIHBsdWdpbnM6IFwiX19QTFVHSU5fUExBQ0VIT0xERVJfX1wiXG4gIH07XG4gIGxldCBjb25maWdTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShjb252ZXJ0ZWRDb25maWcpO1xuICByZXR1cm4gY29uZmlnU3RyaW5nID0gY29uZmlnU3RyaW5nLnJlcGxhY2UoXG4gICAgJ1wiX19QTFVHSU5fUExBQ0VIT0xERVJfX1wiJyxcbiAgICBjb252ZXJ0ZWRQbHVnaW5BcnJheVxuICApLCBgJHtwbHVnaW5JbXBvcnRzfVxuXG5jb25zdCBjb25maWcgPSAke2NvbmZpZ1N0cmluZ307XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZztcbmA7XG59XG5leHBvcnQge1xuICBpbml0VG9vbGJhclxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@stagewise/toolbar/dist/index.es.js\n"));

/***/ })

}]);